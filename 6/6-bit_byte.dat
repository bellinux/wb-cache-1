2|1|Public
5000|$|In a 2010 {{interview}} by Kevin Kelly for {{an article in}} Wired Magazine, Brooks was asked [...] "What do you consider your greatest technological achievement?" [...] Brooks responded [...] "The most important single decision I ever made was to change the IBM 360 series from a <b>6-bit</b> <b>byte</b> to an 8-bit byte, thereby enabling the use of lowercase letters. That change propagated everywhere." ...|$|E
50|$|Memory was {{addressed}} by words, which were 48 bits long. Each word {{was divided into}} eight 6-bit bytes. A <b>6-bit</b> <b>byte,</b> {{as opposed to the}} 8-bit byte in common use today, was common in IBM and other scientific computers of the time. The address space provided a maximum of 256K words. The prototype was equipped with 128k words (48 bits plus two parity bits) of memory that was oil and water cooled. Also considered as part of the memory subsystem in that they were addressed via fixed reserved memory addresses, were 4 48 position switch banks, in which a short program could be inserted, and a plug panel, similar to the one used in IBM Unit-Record equipment, that had the capacity of 32 words, so longer bootstrap or diagnostic programs could be installed in plug panels which could then be inserted into the receptacle and used as a primitive ROM. The memory had a cycle time of 2.5 microseconds, and the lack of memory management was a limitation in the computer.|$|E
50|$|The 600 series used 36-bit {{words and}} 18-bit addresses. They had two 36-bit accumulators, eight 18-bit index registers, and one 8-bit {{exponent}} register. It supported floating point in both 36-bit single-precision and 2 x 36-bit double precision, the exponent being stored separately, allowing up to 71 bits of precision (one bit {{being used for}} the sign). It had an elaborate set of addressing modes, many of which used indirect words, {{some of which were}} auto-incrementing or auto-decrementing. It supported <b>6-bit</b> and 9-bit <b>bytes</b> through addressing modes; these supported extracting specific bytes, and incrementing the byte pointer, but not random access to bytes.|$|R

