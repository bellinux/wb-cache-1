117|84|Public
50|$|One {{difference}} with JML, is that ACSL aims at static verification and deductive verification whereas JML aims both at runtime <b>assertion</b> <b>checking</b> and static verification using for instance the ESC/Java tool.|$|E
5000|$|A {{variety of}} tools provide {{functionality}} based on JML annotations. The Iowa State JML tools provide an <b>assertion</b> <b>checking</b> compiler [...] which converts JML annotations into runtime assertions, a documentation generator [...] which produces Javadoc documentation augmented with extra information from JML annotations, and a unit test generator [...] which generates JUnit test code from JML annotations.|$|E
50|$|Most {{languages}} allow assertions to be enabled {{or disabled}} globally, and sometimes independently. Assertions are often enabled during development and disabled during final testing and on release to the customer. Not checking assertions avoids {{the cost of}} evaluating the assertions while (assuming the assertions are free of side effects) still producing the same result under normal conditions. Under abnormal conditions, disabling <b>assertion</b> <b>checking</b> can mean that a program that would have aborted will continue to run. This is sometimes preferable.|$|E
40|$|This paper {{presents}} the verification of control systems implemented in Simulink. The {{goal is to}} ensure that high-level requirements on control performance, like stability, are satisfied by the Simulink diagram. A two stage process is proposed. First, the high-level requirements are decomposed into specific parametrized sub-requirements and implemented as assertions in Simulink. Second, the verification takes place. On one hand, the sub-requirements are verified through <b>assertion</b> <b>checks</b> in simulation. On the other hand, according to their scope, some of the sub-requirements are verified through <b>assertion</b> <b>checks</b> in simulation, and others via automatic theorem proving over an ideal mathematical model of the diagram. We compare performing only <b>assertion</b> <b>checks</b> against the use of theorem proving, to highlight the advantages of the latter. Theorem proving performs verification by computing a mathematical proof symbolically, covering the entire state space of the variables. An automatic translation tool from Simulink to the language of the theorem proving tool Why 3 is also presented. The paper demonstrates our approach by verifying the stability of a simple discrete linear system. Comment: Accepted, waiting for publication. European Control Conference, July 2015, Linz, Austri...|$|R
40|$|The paper {{proposes a}} novel method for PSL {{language}} <b>assertions</b> simulation-based <b>checking.</b> The method uses a system representation model called High-Level Decision Diagrams (HLDD). Previous works {{have shown that}} HLDDs are {{an efficient model for}} simulation and convenient for diagnosis and debug. The presented approach proposes a temporal extension for the existing HLDD model aimed at supporting temporal properties expressed in PSL. Other contributions of the paper are methodology for direct conversion of PSL properties to HLDD and HLDD-based simulator modification for <b>assertions</b> <b>checking</b> support. Experimental results show the feasibility and efficiency of the proposed approach...|$|R
30|$|Mutual key authentication: the AS is {{authenticated}} to M by {{proving the}} possession of the random value R 1 and the authentication key (AK). We got Casper to check this using the Secret (M, AK, [AS]) and Secret (AS, AK, [M]) <b>assertion</b> <b>checks.</b> Since no attack was found against the key secrecy, this property is met.|$|R
40|$|This paper {{establishes}} {{an interesting}} connection between <b>assertion</b> <b>checking</b> in programs and unification {{in the theory}} underlying the program expressions. Using this connection, we describe how unification algorithms from theorem proving {{can be used to}} perform backward analysis over programs for <b>assertion</b> <b>checking.</b> Interestingly enough, this connection also helps prove hardness results for <b>assertion</b> <b>checking</b> for classes of program abstractions. In particular, we show (a) <b>Assertion</b> <b>checking</b> is PTIME for programs with nondeterministic conditionals that use expressions from a strict unitary theory. (b) <b>Assertion</b> <b>checking</b> is coNP-hard for programs with nondeterministic conditionals that use expressions from a bitary theory. (c) <b>Assertion</b> <b>checking</b> is decidable for programs with disequality guards that use expressions from a convex finitary theory. (d) Summary computation for interprocedural analysis can be performed using backward analysis, enabled with unification, on generic assertions. This helps generalize result (a) to interprocedural analysis. These results generalize several recently published results using a uniform framework. They also provide several new results, and partially solve the long standing open problem of interprocedural global value numbering. In essence, they provide new techniques for backward analysis of programs based on novel integration of theorem proving technology in program analysis...|$|E
40|$|Abstract. <b>Assertion</b> <b>checking</b> is the {{restriction}} of program verification to validity of program assertions. It encompasses safety checking, which is program verification of safety properties, like memory safety {{or absence of}} overflows. In this paper, we consider <b>assertion</b> <b>checking</b> of program parts instead of whole programs, which we call modular <b>assertion</b> <b>checking.</b> Classically, modular <b>assertion</b> <b>checking</b> is possible only if {{the context in which}} a program part is executed is known. By default, the worst-case context must be assumed, which may impair the verification task. It usually takes user effort to detail enough the execution context for the verification task to succeed, by providing strong enough preconditions. We propose a method to automatically infer sufficient preconditions in the context of interpretation, weakest precondition calculus and quantifier elimination. We instantiate this method to prove memory safety for C and Java programs, under some memory separation conditions. ...|$|E
40|$|Abstract. We {{revisit the}} {{connection}} between equality <b>assertion</b> <b>checking</b> in programs and unification that was recently described in [8]. Using a general formalization of this connection, we establish interesting connections between the complexity of <b>assertion</b> <b>checking</b> in programs and unification theory of the underlying program expressions. In particular, we show that <b>assertion</b> <b>checking</b> is: (a) PTIME for programs with nondeterministic conditionals that use expressions from a strict unitary theory, (b) coNP-hard for programs with nondeterministic conditionals that use expressions from a bitary theory, and (c) decidable for programs with disequality guards that use expressions from a convex finitary theory. These results generalize several recently published results and also establish several new results. In essence, they provide new techniques for backward analysis of programs based on novel integration of theorem proving technology in program analysis. ...|$|E
50|$|In {{theoretical}} terms, this {{establishes a}} measure of sanity, whereby one can reason about a program's state without simultaneously modifying that state. In practical terms, CQS allows all <b>assertion</b> <b>checks</b> to be bypassed in a working system to improve its performance without inadvertently modifying its behaviour. CQS may also prevent the occurrence of certain kinds of heisenbugs.|$|R
40|$|Abstruct- Correctness of the {{execution}} of sorting programs can be checked by two assertions: the order assertion and the permutation assertion. The order <b>assertion</b> <b>checks</b> if the sorted data is in ascending or descending order. The permutation <b>assertion</b> <b>checks</b> if the output data produced by sorting is a permutation of the original input data. Permutation and order assertions are sufficient {{for the detection of}} errors in {{the execution}} of sorting programs; however, in terms of execution time these assertions cost the same as sorting programs. An assertion, called the order-sum assertion, that has lower execution cost than sorting programs is derived from permutation and order assertions. The reduction in cost is achieved at the expense of incomplete checking. Some metrics are derived to quantify the effectiveness of order-sum assertion under various error models. A natural connection between the effectiveness of the order-sum assertion and the partition theory of numbers is shown. Asymptotic formulae for partition functions are derived...|$|R
40|$|In the {{development}} of large-scale software systems, analysts, designers, and programmers identify properties of data objects in the system. The ability to <b>check</b> those <b>assertions</b> during runtime is desirable {{as a means of}} verifying the integrity of the program. Typically, programmers ensure the satisfaction of such properties through the use of some form of manually embedded <b>assertion</b> <b>check.</b> The disadvantage to this approach is that these assertions become entangled within the program code. The goal of the research is to develop an integrity constraint monitoring mechanism whereby a repository of software system properties (called integrity constraints) are automatically inserted into the program by the mechanism to check for incorrect program behaviors. Such a mechanism would overcome many of the deficiencies of manually embedded <b>assertion</b> <b>checks.</b> This paper gives an overview of the preliminary work performed toward this goal. The manual instrumentation of constraint checking on a series of test programs is discussed, This review then is used as the basis for a discussion of issues to be considered in developing an automated integrity constraint monitor...|$|R
40|$|This report {{presents}} initial {{results in}} the area of software testing and analysis produced as part of the Software Engineering Impact Project. The report describes the historical development of runtime <b>assertion</b> <b>checking,</b> including a description of the origins of and significant features associated with <b>assertion</b> <b>checking</b> mechanisms, and initial findings about current industrial use. A future report will provide a more comprehensive assessment of development practice, for which we invite readers of this report to contribute information...|$|E
40|$|Abstract. This paper {{presents}} {{results on}} the problem of checking equality assertions in programs whose expressions have been abstracted using combination of linear arithmetic and uninterpreted functions, and whose conditionals are treated as non-deterministic. We first show that the problem of <b>assertion</b> <b>checking</b> for this combined abstraction is coNP-hard, even for loop-free programs. This result is quite surprising since <b>assertion</b> <b>checking</b> for the individual abstractions of linear arithmetic and uninterpreted functions can be performed efficiently in polynomial time. Next, we give an <b>assertion</b> <b>checking</b> algorithm for this combined abstraction, thereby proving decidability of this problem despite the underlying lattice having infinite height. Our algorithm is based on an important connection between unification theory and program analysis. Specifically, we show that weakest preconditions can be strengthened by replacing equalities by their unifiers, without losing any precision, during backward analysis of programs. ...|$|E
40|$|This paper {{describes}} {{the development of}} a monitoring and <b>assertion</b> <b>checking</b> tool, MAC, which supports monitoring of symbolic execution traces generated by the Modechart Toolset, permitting testing of specifications early in the design phase and providing a mechanism for evaluating properties of the system on a particular execution trace. This approach avoids the many of the difficulties of run-time monitoring and testing such as interference and the probe affect. Monitoring and <b>assertion</b> <b>checking</b> capabilities are provided by the automatic translation of assertions in a declarative language (such as Real Time Logic) into monitoring fragments, written in Modechart, which augment the original specification to perform monitoring and <b>assertion</b> <b>checking</b> during simulation. 1 Introduction Ensuring that embedded real-time systems meet their prescribed specifications is a growing challenge that faces the industry in the coming decade. The distributed nature of these systems introduces additiona [...] ...|$|E
30|$|Mutual key {{authentication}}: {{the mutual}} authentication between the MT and the DesDA 3 C {{is based on}} the secrecy of the freshly derived DesAK. We got Casper to check this using the Secret (MT, DesAK, [DesDA 3 C]) and Secret (DesDA 3 C, DesAK, [MT]) <b>assertion</b> <b>checks.</b> Since Casper/FDR found no attacks against the secrecy of the DesAK, this implies that, only other party apart form the intended ones could possess this key.|$|R
5000|$|<b>Assertions</b> - <b>checks</b> {{that can}} be {{disabled}} - are the preferred way to check things that should be unnecessary to check, such as design contracts between software components.|$|R
40|$|Two {{kinds of}} {{interface}} contract violations {{can occur in}} component-based software: A client component can fail to satisfy a requirement of a component it is using, or a component implementation can fail to fulfill its obligations to the client. The traditional approach to detecting and reporting such violations is to embed <b>assertion</b> <b>checks</b> into component source code, with compile-time control over whether they are enabled. This works well for the original component developers, but it fails {{to meet the needs}} of component clients who do not have access to source code for such components. A wrapper-based approach, in which contract checking is not hard-coded into the underlying component but is “layered ” on top of it, offers several relative advantages. It is practical and effective for C++ classes. Checking code can be distributed in binary form along with the underlying component, it can be installed or removed without requiring recompilation of either the underlying component or the client code, it can be selectively enabled or disabled by the component client on a per-component basis, and it does not require the client to have access to any special tools (which might have been used by the component developer) to support wrapper installation and control. Experimental evidence indicates that wrappers in C++ impose modest additional overhead compared to inlining <b>assertion</b> <b>checks...</b>|$|R
40|$|<b>Assertion</b> <b>checking</b> is a {{technique}} widely used to discover inconsistencies between specified behavior and actual implementation behavior. In general, the inconsistencies can be detected statically or dynamically. This paper explains a class of interface-related and internal design-time errors that arise in a component-based setting, when one implementation is substituted for another to provide the same behavior. These errors go undetected if only runtime <b>assertion</b> <b>checking</b> is employed. To overcome this problem, we present two variations of static analysis for use in conjunction with runtime checking...|$|E
40|$|A test oracle in {{software}} testing is {{a mechanism for}} checking whether the program under test behaves correctly for any execution. In some practical situations, oracles can be unavailable or too expensive to apply. Metamorphic testing (MT) was proposed to alleviate this problem so that software can be delivered under the time-to-market pressure. However, the effectiveness of MT has not been studied adequately. This paper conducts a controlled experiment to investigate the cost effectiveness of using MT. The fault detection capability and time cost of MT are compared with the standard <b>assertion</b> <b>checking</b> method. Our results show that MT has potentials to detect more faults than the <b>assertion</b> <b>checking</b> method. The experiment results also show a trade-off between the two testing methods: MT can be less efficient but more effective, and can be defined at a coarser level of granularity than the <b>assertion</b> <b>checking</b> method...|$|E
40|$|This paper {{presents}} a practical methodology {{for the application}} of formal verification to the industrial design environment "Protocol Compiler". Our verification flow is to first create a testbench and simulate the design. Then we modify the testbench and perform a formal verification technique called <b>assertion</b> <b>checking.</b> The examples are taken from the networking arena. The first is a simplified RS 232 transceiver, the second a pipelined FIFO-like buffer written in Verilog. We show that <b>assertion</b> <b>checking</b> fits well into the design flow and is easy to use within Protocol Compiler. 1...|$|E
30|$|To <b>check</b> <b>assertion</b> 1, we {{will use}} Lemma  1 from [13].|$|R
50|$|<b>Assertions</b> {{that are}} <b>checked</b> at compile time are called static assertions.|$|R
5000|$|Coq - Which {{allows the}} {{expression}} of mathematical <b>assertions,</b> mechanically <b>checks</b> proofs of these assertions, helps to find formal proofs, and extracts a certified program from the constructive proof of its formal specification.|$|R
40|$|Assertions are a {{powerful}} bug detection technique. Traditional <b>assertion</b> <b>checking,</b> however, is performed synchronously, imposing its full cost on the runtime of the program. As a result, many useful kinds of checks are impractical because they lead to extreme slowdowns. We present {{a solution that}} decouples assertion evaluation from program execution: assertions are evaluated asynchronously while the program continues to execute. Our technique ensures that the <b>assertion</b> <b>checking</b> thread operates on a consistent view of the global state, and that an assertion always produces the same result as it would in a serial execution. We implemented our technique in a system called STROBE, a snapshot-based system for asynchronous <b>assertion</b> <b>checking</b> in both single-and multi-threaded Java applications. STROBE runs inside the Java virtual machine and uses copy-on-write to build snapshots incrementally. We find that asynchronous checking scales almost perfectly over synchronous checking in many cases, indicating that the snapshot overhead is quite low. STROBE provides tolerable overheads (under 2 X) even for heavy-weight assertions that would otherwise result in crushing slowdowns. 1...|$|E
40|$|A mobile {{concurrent}} {{system can}} be checked for correctness at run-time by placing assertions in the code in a method called <b>assertion</b> <b>checking.</b> We propose using this method on a model problem, the Automated Highway System (AHS), to ensure that temporal specifications of the system are fulfilled at run-time. The process of <b>assertion</b> <b>checking</b> used involves collection of event histories and using assertions to scan through these histories to evaluate them for correctness. Implementation results using Java Aglets (Mobile Agents) on a network of workstations are {{used to measure the}} effectiveness of the error detection through fault coverage and error detection latency for various induced failures...|$|E
40|$|An oracle in {{software}} testing is {{a mechanism for}} checking whether the system under test has behaved correctly for any executions. In some situations, oracles are unavailable or too expensive to apply. This {{is known as the}} oracle problem. It is crucial to develop techniques to address it, and metamorphic testing (MT) was one of such proposals. This paper conducts a controlled experiment to investigate the cost effectiveness of using MT by 38 testers on three open-source programs. The fault detection capability and time cost of MT are compared with the popular <b>assertion</b> <b>checking</b> method. Our results show that MT is cost-efficient and has potentials for detecting more faults than the <b>assertion</b> <b>checking</b> method. ...|$|E
50|$|Besides calling methods via interfaces, Go allows {{converting}} interface {{values to}} other types with a run-time type check. The language constructs {{to do so}} are the type <b>assertion,</b> which <b>checks</b> against a single potential type, and the type switch, which checks against multiple types.|$|R
50|$|In {{computer}} science, a {{loop invariant}} is a property {{of a program}} loop that is true before (and after) each iteration. It is a logical <b>assertion,</b> sometimes <b>checked</b> within the code by an assertion call. Knowing its invariant(s) is essential in understanding {{the effect of a}} loop.|$|R
5000|$|When the {{constant}} expression is [...] the compiler produces an error message. The first example {{is similar to}} the preprocessor directive , although the preprocessor does only support integral types. In contrast, in the second example the <b>assertion</b> is <b>checked</b> at every instantiation of the template class [...]|$|R
40|$|Run-time {{verification}} {{is one of}} {{the most}} useful techniques for detecting faults, and can be applied during any program execution context, including debugging, testing, and production. But in general it is limited to either state-based properties of the data-flow (run-time <b>assertion</b> <b>checking)</b> or protocol-oriented properties of the control flow (monitoring). We introduce SAGA, a general framework that combines monitoring and run-time <b>assertion</b> <b>checking.</b> SAGA integrates both data-flow and control flow properties of Java classes and interfaces in a single formalism. Furthermore we compare the expressiveness and the usability of SAGA to other current state of the art tools for run-time verification by conducting an industrial case study from the eCommerce software company Fredhopper...|$|E
40|$|This paper {{describes}} MTSim, an extensible, cus-tomizable {{simulation platform}} for the Modechart toolset (MT) [3]. MTSim provides suppori for ‘$lug-ging in ” user-defined viewers useful in simulating sys-tem behavior in diflerent ways, including application-specific ways. MTSim also supports full user participa-lion in the generation of simulations b y allowing users to inject events into the execution trace. Moreover, MTSim provides monitoring and <b>assertion</b> <b>checking</b> of execution traces and the invocation of user-specified handlers upon assertion violation. This paper also in-troduces a MTSim component called WebSim, a suite of simulation tools for MT, and an an application-specific component of MTSim, which displays the cock-pit of an F- 18 aircraft and models its bomb release function. Index terms: simulation, specification, symbolic ex-ecution, monitoring and <b>assertion</b> <b>checking,</b> formal methods. ...|$|E
40|$|Runtime <b>assertion</b> <b>checking</b> (RAC) is a {{well-established}} technique for runtime verification of object-oriented (OO) programs. Contemporary RACs use specifications from the receiver’s dynamic type when checking method calls. This implies that in presence of subtyping and dynamic dispatch features of object-oriented programming, these specifications {{differ from the}} ones used by static verification tools, which rely on the specifications associated with the static type of the receiver. Besides the heterogeneity problem, this also hinders the benefits of modular reasoning achieved by the notion of supertype abstraction. In this context, we propose a more precise runtime <b>assertion</b> <b>checking</b> for OO programs that better matches the semantics used in static verification tools. While we describe our approach, we discuss {{how it can be}} used to avoid the heterogenous semantics problem and among others...|$|E
40|$|Abstract. We {{present a}} tool, called Cascade, to <b>check</b> <b>assertions</b> in C {{programs}} {{as part of}} a multi-stage verification strategy. Cascade takes as input a C program and a control file (the output of an earlier stage) that specifies one or more <b>assertions</b> to be <b>checked</b> together with (option-ally) some restrictions on program behaviors. For each assertion, Cascade produces either a concrete trace violating the assertion or a deduction (proof) that the assertion cannot be violated. ...|$|R
5000|$|Computations of weakest-preconditions {{are largely}} used to statically <b>check</b> <b>assertions</b> in {{programs}} using a theorem-prover (like SMT-solvers or proof assistants): see Frama-C or ESC/Java2.|$|R
40|$|Assertions (SVA), a {{synchronous}} assertion package {{based on}} the temporal-logic semantics of PSL. Traditionally <b>assertions</b> are <b>checked</b> in software simulation. We introduce a method for synthesizing SVA directly into hardware modules in Bluespec SystemVerilog. This opens up new possibilities for FPGA-accelerated testbenches, hardware/software co-emulation, dynamic verification and fault-tolerance. We describe adding synthesizable assertions to a cache controller, and investigate their hardware cost. ...|$|R
