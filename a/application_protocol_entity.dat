0|3493|Public
50|$|Simple Gateway Monitoring Protocol (SGMP) {{defined in}} RFC 1028, allows {{commands}} {{to be issued}} to <b>application</b> <b>protocol</b> <b>entities</b> to set or retrieve values (integer or octet string types) for use in monitoring the gateways on which the <b>application</b> <b>protocol</b> <b>entities</b> reside. Messages are exchanged using UDP and utilize unreliable transport methods. Authentication takes place on UDP port 153. Some examples of {{things that can be}} monitored are listed below.|$|R
40|$|The {{complexity}} and efficiency {{aspects of a}} distributed <b>application</b> <b>protocol</b> (e. g., replicated data access, decentralized commit) are often intertwined with the application-specific communication requirements between <b>protocol</b> <b>entities</b> and the underlying support for communication. For example, the choice between recovery by application from a mis-ordered message delivery versus providing message ordering property in the communication layer (CL) is based on tradeoffs between protocol {{complexity and}} efficiency. The paper systematically analyzes these tradeoffs in a quantitative manner. The analysis is based on message ordering and atomicity, which refer to consistent event ordering at <b>protocol</b> <b>entities.</b> Enforcing these properties in the CL leads to uniform communication structure of applications. However, the CL incurs message and execution time overhead due {{to the need to}} maintain extensive communication state (e. g., message sequencing). When these properties are not supported by CL but a [...] ...|$|R
40|$|This thesis {{summarizes}} {{the work of}} the author as a master/doctor student of Osaka University on the implementation of service specifications on distributed computing systems. In a distributed computing system, multiple computers, called <b>protocol</b> <b>entities,</b> communicate with each other, exchanging messages for synchronization and data transfer. On the implementation phase of such a distributed system, the behavior of all the <b>protocol</b> <b>entities</b> must be specified. The specification of each <b>protocol</b> <b>entity</b> is called a <b>protocol</b> <b>entity</b> specification and the set of all the <b>protocol</b> <b>entity</b> specifications is called a protocol specification. In general, the control flow of each <b>protocol</b> <b>entity</b> specification may become complicated, since it contains communications among other <b>protocol</b> <b>entities</b> for cooperative computing. Therefore, it is hard for designers to describe a protocol specification directly without mistake. In the recent years, for designing reliable distributed computing systems, many approaches [...] ...|$|R
40|$|In general, the {{services}} of a distributed system are provided by some cooperative <b>protocol</b> <b>entities.</b> The <b>protocol</b> <b>entities</b> must exchange some data values and synchronization messages in order to ensure the temporal ordering of the events which are described in a service specification of the distributed system. It is desirable that a correct <b>protocol</b> <b>entity</b> specification for each node can be derived automatically from a given service specification. In this pape...|$|R
40|$|In general, the {{services}} of a distributed system are provided by some cooperative <b>protocol</b> <b>entities.</b> The <b>protocol</b> <b>entities</b> must exchange some data values and synchronization messages in order to ensure the temporal ordering of the events which are described in a service specification of the distributed system. It is desirable that a correct <b>protocol</b> <b>entity</b> specification for each node can be derived automatically from a given service specification. In this paper, we propose an algorithm which synthesizes a correct <b>protocol</b> <b>entity</b> specification automatically from a service specification in a Petri Net model with Registers called PNR model. In our model, parallel events and selective operations can be described naturally. The control flow of a service specification must be described as a free-choice net in order to simplify the derivation algorithm, however, many practical systems can be described in this class. In our approach, since each <b>protocol</b> <b>entity</b> specification is also described i [...] ...|$|R
40|$|A way {{to create}} well-functioning {{computer}} systems is to automate error detection in the systems. Automated techniques for finding errors, such as testing and formal verification, requires {{a model of the}} system. The technique for constructing deterministic finite automata (DFA) models, without access to the source code, is called regular inference. The technique provides sequences of input, so called membership queries, to a system, observes the responses, and infers a model from the input and responses. This thesis presents work to adapt regular inference to a certain kind of systems: communication <b>protocol</b> <b>entities.</b> Such entities interact by sending and receiving messages consisting of a message type and a number of parameters, each of which potentially can take on a large number of values. This may cause a model of a communication <b>protocol</b> <b>entity</b> inferred by regular inference, to be very large and {{take a long time to}} infer. Since regular inference creates a model from the observed behavior of a communication <b>protocol</b> <b>entity,</b> the model may be very different from a designer's model of the system's source code. This thesis presents adaptations of regular inference to infer more compact models and use less membership queries. The first contribution is a survey over three algorithms for regular inference. We present their similarities and their differences in terms of the required number of membership queries. The second contribution is an investigation on how many membership queries a common regular inference algorithm, the L* algorithm by Angluin, requires for randomly generated DFAs and randomly generated DFAs with a structure common for communication <b>protocol</b> <b>entities.</b> In comparison, the DFAs with a structure common for communication <b>protocol</b> <b>entities</b> require more membership queries. The third contribution is an adaptation of regular inference to communication <b>protocol</b> <b>entities</b> which behavior foremost are affected by the message types. The adapted algorithm avoids asking membership queries containing messages with parameter values that results in already observed responses. The fourth contribution is an approach for regular inference of communication <b>protocol</b> <b>entities</b> which communicate with messages containing parameter values from very large ranges. The approach infers compact models, and uses parameter values taken from a small portion of their ranges in membership queries. The fifth contribution is an approach to infer compact models of communication <b>protocol</b> <b>entities</b> which have a similar partitioning of an entity's behavior into control states as in a designer's model of the protocol...|$|R
40|$|Typically {{a real-life}} {{protocol}} specification {{is composed of}} two or more <b>protocol</b> <b>entities</b> communicating with each other by exchanging messages through service access points (SAPs). These <b>protocol</b> <b>entities</b> can be created and released dynamically, and their connections can change over time. These dynamic behaviours {{have been one of the}} serious problems for protocol designers to model and analyze. Petri nets and high-level Petri nets have been used commonly and widely in protocol specification and verification. Traditionally protocol designers use a place in Petri nets to represent a state of a protocol. By following this tradition, it is impossible to model the dynamic configuration of communication protocols. To overcome this problem, tokens in Numerical Petri Nets (NPNs) are used to model states and also to model <b>protocol</b> <b>entities</b> and their connections. A sliding-window protocol is used to illustrate this approach...|$|R
3000|$|... local components, {{which are}} the <b>protocol</b> <b>entities</b> within the network node. Each such node may be a base station, a mobile station, or even a data server.|$|R
40|$|A {{prototype}} <b>application</b> <b>protocol</b> for ready-to-wear {{pattern making}} {{was developed for}} the communication of pattern pieces and related information between various CAD systems. The basic methodology for the <b>application</b> <b>protocol</b> isthe Standard for the Exchange ofProduct Model Data (STEP). STEP is an emerging international standard, {{the result of an}} effort to develop a mechanism for digitally representing the physical and functional characteristics of a product throughout the product’s life cycle. The STEP <b>application</b> <b>protocol</b> addresses a specific application area and contains an information model written in the conceptual modeling language EXPRESS. The experience gained through the implementation of the prototype <b>application</b> <b>protocol</b> and recommendations received from apparel researchers provided us useful input to improve the prototype <b>application</b> <b>protocol.</b> This report presents a revised version of the information model usingboth the EXPRESS language and the EXPRESS-G graphical notation. An application activity model that defines the scope and information requirements of the prototype <b>application</b> <b>protocol</b> is also presented in this report. Neither the EXPRESS-Gdiagrams nor the application activity model was shown in the original prototype <b>application</b> <b>protocol</b> report...|$|R
40|$|COMSCRIPT {{is a new}} {{programming}} language based on POSTSCRIPT, designed {{for the implementation of}} protocol stacks. COMSCRIPT is a concurrent language providing synchronousand asynchronousinter-process communications based on a hierarchical model. The language allows the implementation of both low level and high level <b>protocol</b> <b>entities.</b> COMSCRIPT also allows a process to configure dynamically its communication needs. Thus COMSCRIPT is a configuration language. This paper describes the first implementation of a COMSCRIPT interpreter with its interfaces provoding access to raw Ethernet, IP datagrams, TCP/IP sockets and ordinary files. Finally we report on the coding of a low level <b>protocol</b> <b>entity</b> (ARP) and an application level FTP-server with COMSCRIPT...|$|R
40|$|This chapter proposes an {{alternative}} reference architecture for <b>application</b> <b>protocols.</b> The proposed reference architecture {{consists of the}} set of possible architectures for <b>application</b> <b>protocols.</b> This set is implicitly defined by defining {{the different types of}} <b>application</b> <b>protocol</b> components and their relationships. The component types and their relationships are derived by application of the design trajectory, design methods and structuring techniques presented in the previous chapters. This chapter also identifies and characterizes some generic <b>application</b> <b>protocol</b> building blocks that can be used as components in many different <b>application</b> <b>protocol</b> architectures. The main purpose of a reference architecture is to help the designer in choosing a suitable architecture for his specific design, and to incorporate pre-defined, generic building blocks. A reference architecture should therefore either define a single architecture that is generally applicable in the design domain at hand, or a set of architectures, each appropriate in a specific sub-domain. Because of the diversity of interaction requirements of different classes of distributed applications, {{we do not believe that}} it is possible to define a single useful architecture for <b>application</b> <b>protocols.</b> Such a reference architectur...|$|R
40|$|The Wireless Transaction Protocol (WTP) {{is part of}} the Wireless <b>Application</b> <b>Protocol</b> (WAP) {{architecture}} and provides a reliable request-response service. The state space method of Coloured Petri Nets has been used to analyse a revised version of WTP, to gain a high level of confidence in the correctness of the design. Full state space analysis allows us to prove properties of the protocol for maximum values of the retransmission counters used in GSM networks (values are 4). However, the size of the state space grows rapidly as the maximum counter values are increased. We apply the sweep-line method {{to take advantage of the}} progress present in the protocol, notably the progression through major states of the <b>protocol</b> <b>entities,</b> and the increasing nature of the retransmission counters. The sweep-line method allows us to prove properties of the protocol for larger counter values, including those used in Internet Protocol (IP) networks (where the maximum values are 8). As a result, verification of WTP can be performed for the two most important networks (GSM and IP), the ones for which the WAP standard gives recommended maximum values for the retransmission counters...|$|R
40|$|Master {{thesis is}} focused on {{classification}} of <b>application</b> <b>protocols</b> based on <b>application</b> data taken from layer L 7 of ISO/OSI model. The aim of the thesis is to suggest a classifier for SDM system (Software defined monitoring) {{so it could be}} used for links with throughput up to 100 Gb/s. At the same time it should classify with the fewest possible errors. Designed classifier consists of two parts. First part depicts encoders for encoding selected attributes. Second part deals with evaluating circuit which detects series characteristic for particular <b>application</b> <b>protocols</b> on the output from the first part. Considered attributes and series are taken from statistic analyzes of <b>application</b> <b>protocol</b> data. The classifier itself is designed so it can be implemented in FPGA and enables modification set of <b>application</b> <b>protocols</b> who intended for classification. The quality of  designed classifier is tested on real network data. The results of classification are compared with current methods used for classification of <b>application</b> <b>protocols...</b>|$|R
5000|$|MIL-STD-3011, Joint Range Extension <b>Application</b> <b>Protocol</b> (JREAP) ...|$|R
40|$|In {{the last}} decades, much {{effort has been}} spent on the design and {{provision}} of sophisticated communication infrastructures. The development of end-user oriented distributed system applications, leaning on top of these communication infrastructures, so far has attracted little attention. This is regrettable, since communication infrastructures can only become useful and profitable {{if they can be}} deployed {{in the context of a}} sufficient number of distributed applications. Two important factors determine the success of distributed applications: (1) the provision of high quality <b>application</b> services and <b>protocols</b> at short time scales; and (2) the availability of standards for these services and protocols that can be used for the construction of ‘open’ distributed systems. The achievement of both (1) and (2) can be supported by a suitable design methodology. A design methodology entails a systematic approach to carry out complex designs, and therefore should incorporate proper concepts that enable the effective structuring of such designs. Concepts currently used for the design and structuring of <b>application</b> <b>protocols</b> appear to be inadequate for this purpose. Also a step-wise design approach that would help to master complexity and shorten development times is currently lacking. Standards are necessary since individual users of distributed system applications prefer to be independent on any particular manufacturer or vendor when procuring products, while manufacturers prefer to have maximum implementation freedom when developing such products. An ‘open’ protocol standard defines necessary and sufficient conditions for system parts to interact, such that the system parts can be implemented independently of each other. ISO and ITU-TSS base the development and definition of protocol standards on a ‘reference model’, called the Reference Model for Open Systems Interconnection (OSIRM). This model comprises a rudimentary form of a design approach and a reference architecture that can be derived with this approach. According to the OSI-RM, the overall <b>application</b> <b>protocol</b> functionality is distributed over three hierarchical protocol layers. Each layer has been assigned a specific functionality, except the highest layer, the Application Layer, which is made responsible for all remaining protocol functions. Because the functionality of the Application Layer is not delimited it cannot, as opposed to the other layers, be covered by a single protocol standard or a fixed set of protocol standards. Several identified sets of <b>Application</b> Layer <b>protocol</b> functions are defined by separate Application Service Elements (ASEs). The appropriateness of the OSI-RM for the development and definition of <b>application</b> <b>protocol</b> standards can be criticized on a number of points: - the reference architecture defined by the OSI-RM is not flexible enough to adequately cope with the diversity of interaction requirements of distributed applications. - some design concepts are not clearly defined, thus prohibiting their effective application to structuring problems; - the relationship between high level application requirements and proposed <b>application</b> <b>protocol</b> solutions is unclear; - the development of <b>application</b> <b>protocol</b> standards generally takes a long time. This thesis aims at the development of a methodology for the design of <b>application</b> <b>protocols,</b> including <b>application</b> <b>protocol</b> standards, and so addresses the problems mentioned above. The following contributions are made to achieve this aim: - design quality criteria are proposed that can be used to guide design decisions and to evaluate designs; - OSI design decisions and design concepts with respect to <b>application</b> <b>protocols</b> are evaluated; - general-purpose, elementary design concepts are proposed; - milestones in the <b>application</b> <b>protocol</b> design process are presented; - behaviour composition and structuring techniques are developed that can be used to represent design results corresponding to the identified milestones; - design methods are proposed to support the correct performance of design steps between milestones; - a flexible reference architecture is proposed. A (potential) result of the design methodology is that layered <b>application</b> <b>protocol</b> hierarchies can be avoided if they are not required by the class of distributed applications that must be supported. This thesis is structured as follows: - Chapter 1 (Introduction) presents a global problem description for this thesis, the scope and objectives of this thesis, and the approach followed in this thesis. It further introduces some general concepts related to the design of distributed systems. - Chapter 2 (Design Quality Criteria) discusses quality criteria that can be used to guide the design of <b>application</b> <b>protocols</b> and to evaluate the quality of already designed <b>application</b> <b>protocols.</b> - Chapter 3 (OSI Upper Layer Architecture and Model: State of the Art) presents the architecture and concepts defined by the OSI-RM with respect to <b>application</b> <b>protocol</b> standards. It also contains a brief description of the most important <b>application</b> <b>protocol</b> standards that were developed in the context of the OSI-RM. - Chapter 4 (OSI Upper Layer Architecture and Model: Evaluation) evaluates the architecture and concepts defined by the OSI-RM with respect to <b>application</b> <b>protocol</b> standards. It also discusses the relation between the quality of <b>application</b> <b>protocol</b> standards and the nature of standardization, and the implementation freedom supported by protocol standards. - Chapter 5 (Design Framework) presents a general framework for the design of <b>application</b> <b>protocols.</b> It identifies elementary concepts for distributed systems design, and abstraction levels at which distributed systems and system parts can be represented. The abstraction levels are used to define an <b>application</b> <b>protocol</b> design trajectory consisting of a sequence of design steps between different milestones in the <b>application</b> <b>protocol</b> design process. - Chapter 6 (Design Model) discusses a model for the representation and manipulation of behaviours, such that it can be used in the <b>application</b> <b>protocol</b> design trajectory. The model is based on the elementary design concepts, identified in Chapter 5, and defines additional concepts and rules in order to allow the composition of behaviours. It also includes techniques for the composition of structured behaviours and requirements for behaviour decomposition and refinement. - Chapter 7 (<b>Application</b> <b>Protocol</b> Reference Architecture) proposes a flexible reference architecture for <b>application</b> <b>protocols.</b> The reference architecture is based on the design quality criteria, the design framework and the design model, and presents specific design methods for structuring <b>application</b> <b>protocols.</b> Furthermore, some generic <b>application</b> <b>protocol</b> structures are discussed, and some <b>application</b> <b>protocol</b> functions that can be used as building blocks for the support of many classes of distributed system applications are characterized. - Chapter 8 (Suggestions for Further Work) presents some suggestions for further work. - Chapter 9 (Summary of Conclusions) presents a summary of the conclusions drawn in the previous chapters...|$|R
5000|$|ISO 15118-4: Network and <b>application</b> <b>protocol</b> {{conformance}} test ...|$|R
5000|$|IFSF is {{more complex}} but more {{comprehensive}} than most proprietary protocols. The IFSF protocol has two independent layers; a device <b>application</b> <b>protocol</b> layer and a communications <b>protocol</b> layer. The <b>application</b> <b>protocol</b> is independent of the underlying communications layer. The communications protocol specification makes the link to the transport layer.|$|R
40|$|A {{synergistic}} relationship {{exists between}} Concurrent Engineering (CE) frameworks and the PDES initiative of promulgating STEP. This paper emphasizes and punctuates {{the importance of}} the STEP-CE linkage and defines further cooperative bindings. One focus of the presentation is the use of STEP <b>application</b> <b>protocols</b> to create the shared information models necessary for Concurrent Engineering(CE). After a discussion of the natural fusion of CE and PDES/STEP <b>application</b> <b>protocols,</b> the need for the extension of STEP resource models and <b>application</b> <b>protocols</b> to include information sharing capabilities for process and organization data is presented...|$|R
40|$|This chapter {{presents}} {{some suggestions}} for further work: section 1 suggests an approach for testing the proposed <b>application</b> <b>protocol</b> reference architecture in practice; section 2 discusses the notion of application service engineering and presents some items for further work in this area; section 3 presents an alternative graphical notation which should be further investigated; section 4 indicates areas where the <b>application</b> <b>protocol</b> design methodology may be useful; section 5 mentions the need to investigate the combined use of object-oriented approaches and the <b>application</b> <b>protocol</b> design methods; section 6 presents possibilities for generalized constraint-oriented composition; and section 7 mentions {{the need for further}} work in the area of specification language support. 8. 1 Elaboration and application of the reference architecture The <b>application</b> <b>protocol</b> reference architecture proposed in Chapter 7 (<b>Application</b> <b>Protocol</b> Reference Architecture) should be tested by applying it to realistic examples. One {{way to do this is}} the following: • define the building blocks characterized in Chapter 7 with the design model presented in Chapter 6 (Design Model); possibly, characterize further useful building blocks an...|$|R
30|$|Upon {{reception}} {{from the}} upper layer, a <b>protocol</b> <b>entity</b> adds its signaling information {{in front of the}} first byte of the received SDU, increases the pduBytes member by an amount equal {{to the size of the}} added signaling header, and transfers it to the lower layer. Upon reception from the lower layer, a <b>protocol</b> <b>entity</b> reads the header inserted by its homologous entity on the source, decreases the pduBytes member by an amount equal to the size of this signaling header, and transfers it to the upper layer. In this scheme, there is no longer one specific class derived of cMessage for each protocol layer, but only one generic BytesMsg class. The information usually contained in the data members of the classes derived from cMessage is contained in the properly encoded protocol headers.|$|R
5000|$|Application-Layer Host: traffic {{statistics}} by <b>application</b> <b>protocol,</b> per host ...|$|R
5000|$|... #Subtitle level 2: Coverage of STEP <b>Application</b> <b>Protocols</b> (AP) ...|$|R
5000|$|... #Subtitle level 4: CAN <b>application</b> <b>protocol</b> over EtherCAT (CoE) ...|$|R
5000|$|WAP1, Wireless <b>Application</b> <b>Protocol</b> 1, 5-layer {{stack of}} {{protocols}} ...|$|R
5000|$|Alternative {{protocols}} {{include the}} [...] Advanced Message Queuing Protocol (AMQP), [...] Streaming Text Oriented Messaging Protocol (STOMP) the IETF Constrained <b>Application</b> <b>Protocol,</b> [...] XMPP and Web <b>Application</b> Messaging <b>Protocol</b> (WAMP).|$|R
5000|$|Internet {{applications}} for smart devices through wireless <b>application</b> <b>protocol</b> (WAP) ...|$|R
5000|$|ISO/CD 15118-7: Network and <b>application</b> <b>protocol</b> {{requirements}} for wireless communication ...|$|R
40|$|REX is a {{protocol}} supporting a client/server style {{of interaction between}} a number of entities in a distributed system. Within this interaction paradigm, client entities may request services supplied by server entities, by interacting with intermediate <b>protocol</b> <b>entities.</b> This paper presents a Z specification of part of the REX protocol...|$|R
40|$|Abstract. Existing {{algorithms}} {{for regular}} inference (aka automata learning) allows to infer a {{finite state machine}} model of a system under test (SUT) by observing the output that the SUT produces in response to selected sequences of input. In this paper we present an approach using regular inference to construct models of communication <b>protocol</b> <b>entities.</b> <b>Entities</b> of communication <b>protocols</b> typically take input messages in the format of a protocol data unit (PDU) type together {{with a number of}} parameters and produce output of the same format. We assume that parameters from input can be stored in state variables of communication protocols for later use. A model of a communication protocol is usually structured into control states. Our goal is to infer symbolic extended finite state machine models of communication <b>protocol</b> <b>entities</b> with control states in the model that are similar to the control states in the communication protocol. In our approach, we first apply an existing regular inference algorithm to a communication <b>protocol</b> <b>entity</b> to generate a finite state machine model of the entity. Thereafter we fold the generated model into a symbolic extended finite state machine model with locations and state variables. We have applied parts of our approach to an executable specification of the Mobile Arts Advanced Mobile Location Center (A-MLC) protocol and evaluated the results. ...|$|R
40|$|This thesis {{focuses on}} methods for fast {{recognition}} of <b>application</b> <b>protocols.</b> Fast recognition is recognition with minimal delay {{from the time}} of capturing the first data packet sent  from the source node. This thesis describes possible techniques and methods for recognition of <b>application</b> <b>protocols</b> and basic information and description of reference system for lawful interception in computer networks. Furthermore, the thesis describes analysis, design and implementation phase of a tool for fast recognition of <b>application</b> <b>protocols.</b> The conclusion of this thesis describes the results of tests performed by the tool and shows its limitations and possible extensions...|$|R
50|$|WMLC is {{apparently}} synonymous with Wireless <b>Application</b> <b>Protocol</b> Binary XML (WBXML).|$|R
5000|$|IEC 61334-4-42:1996 Data {{communication}} <b>protocols</b> - <b>Application</b> <b>protocols</b> - <b>Application</b> layer ...|$|R
5000|$|IEEE 1278.1-1995 - Standard for Distributed Interactive Simulation - <b>Application</b> <b>protocols</b> ...|$|R
40|$|This paper {{describes}} the Ad Hoc Access <b>Application</b> <b>Protocol</b> (AHAAP) used for authentication, authorization and accounting services in ad hoc networks. This protocol assumes that device layer ad hoc networking capability {{is available in}} mobile devices. Being an <b>application</b> level <b>protocol,</b> {{it is designed to}} work {{in the same way as}} AAA protocols such as diameter base <b>protocol</b> and associated <b>application</b> <b>protocols.</b> The work presented in this paper is an extension of a previous work done by the author...|$|R
40|$|Previous papers {{describe}} an algorithm for deriving a specification of <b>protocol</b> <b>entities</b> from a given service specification. A service specification defines a particular ordering for {{the execution of}} service primitives at the different service access points using operators for sequential, parallel and alternative executions. The derived <b>protocol</b> <b>entities</b> ensure the correct ordering by exchanging appropriate synchronization messages, between one another through the underlying communication medium. This paper presents several new results which represent important improvements to the above protocol derivation approach. First the language restriction to finite behaviors is removed by allowing for the definition of procedures which can be called recursively. Secondly, a new derivation algorithm has been developed which is much simpler than the previous one. Third, the resulting protocol specifications are much more optimized than those obtained previously. * Christian Kant is with the UniversitC de Moncton, 1...|$|R
5000|$|Application-Layer Matrix: traffic {{statistics}} by <b>application</b> <b>protocol,</b> per source/destination pairs of hosts ...|$|R
