43|752|Public
25|$|By design, the 286 {{could not}} revert from {{protected}} mode {{to the basic}} 8086-compatible real <b>address</b> <b>mode</b> ("real mode") without a hardware-initiated reset. In the PC/AT introduced in 1984, IBM added external circuitry, as well as specialized code in the ROM BIOS and the 8042 peripheral microcontroller to enable software to cause the reset, allowing real-mode reentry while retaining active memory and returning control to the program that initiated the reset. (The BIOS is necessarily involved because it obtains control directly whenever the CPU resets.) Though it worked correctly, the method imposed a huge performance penalty.|$|E
50|$|A Change <b>Address</b> <b>Mode</b> (CAM) {{instruction}} switched between 2-, 3- and 4-character address modes.The <b>address</b> <b>mode</b> specified {{the number}} of characters needed for each operand address in instructions.|$|E
5000|$|<b>Address</b> <b>mode</b> {{operations}} - Use address modes {{to simplify}} code.|$|E
50|$|When {{there are}} only a few <b>addressing</b> <b>modes,</b> the {{particular}} <b>addressing</b> <b>mode</b> required is usually encoded within the instruction code(e.g. IBM System/360 and successors, most RISC). But when there are lots of <b>addressing</b> <b>modes,</b> a specific field is often set aside in the instruction to specify the <b>addressing</b> <b>mode.</b> The DEC VAX allowed multiple memory operands for almost all instructions, and so reserved the first few bits of each operand specifier to indicate the <b>addressing</b> <b>mode</b> for that particular operand.Keeping the <b>addressing</b> <b>mode</b> specifier bits separate from the opcode operation bits produces an orthogonal instruction set.|$|R
5000|$|Unlike the octal-oriented PDP-11, the VAX-11 was a hexadecimal-oriented machine (4-bit sub-byte). This {{resulted}} in 16 logical <b>addressing</b> <b>modes</b> (0-15), however, <b>addressing</b> <b>modes</b> 0-3 were [...] "short immediate" [...] for immediate data of 6 bits or less (the 2 low-order {{bits of the}} <b>addressing</b> <b>mode</b> being the 2 high-order bits of the immediate data, when prepended to the remaining 4 bits in that data-addressing byte). Since <b>addressing</b> <b>modes</b> 0-3 were identical, this made 13 (electronic) <b>addressing</b> <b>modes,</b> but as in the PDP-11, {{the use of the}} Stack Pointer (R14) and Program Counter (R15) created a total of over 15 conceptual <b>addressing</b> <b>modes</b> (with the assembler program translating the source code into the actual stack-pointer or program-counter based <b>addressing</b> <b>mode</b> needed).|$|R
50|$|This <b>addressing</b> <b>mode</b> {{is closely}} related to the indexed {{absolute}} <b>addressing</b> <b>mode.</b>|$|R
5000|$|Support {{of several}} {{addressing}} modes. In {{addition to the}} 6-byte MAC address (including multicast and unicast), it supports a MAC address-less mode, and an optional 3-byte <b>address</b> <b>mode.</b>|$|E
50|$|The latest {{graphing}} calculator in the Ti-84 line by Texas Instruments, the TI-84 Plus CE, {{uses the}} eZ80 in the 24-bit <b>address</b> <b>mode</b> at a clock rate of 48 MHz.|$|E
5000|$|With four <b>address</b> <b>mode</b> {{selection}} bits (P, R, I and N - indexed, relative, indirect and immediate), NAR 2 instructions can specify 16 different {{addressing modes}} {{but not all}} make sense in all instructions. In the following table: ...|$|E
5000|$|Different {{computer}} architectures vary greatly {{as to the}} number of <b>addressing</b> <b>modes</b> they provide in hardware. There are some benefits to eliminating complex <b>addressing</b> <b>modes</b> and using only one or a few simpler <b>addressing</b> <b>modes,</b> even though it requires a few extra instructions, and perhaps an extra register. [...] It has proven much easier to design pipelined CPUs if the only <b>addressing</b> <b>modes</b> available are simple ones.|$|R
50|$|Since the PDP-11 was an octal-oriented (3-bit sub-byte) machine (<b>addressing</b> <b>modes</b> 0-7, {{registers}} R0-R7), {{there were}} (electronically) 8 <b>addressing</b> <b>modes.</b> Through {{the use of}} the Stack Pointer (R6) and Program Counter (R7) as referenceable registers, there were 10 conceptual <b>addressing</b> <b>modes</b> available.|$|R
25|$|The {{designers}} {{attempted to}} make the assembly language orthogonal. That is, instructions are divided into operations and <b>address</b> <b>modes,</b> and almost all <b>address</b> <b>modes</b> are available for almost all instructions. There are 56 instructions and a minimum instruction size of 16 bits. Many instructions and <b>addressing</b> <b>modes</b> are longer to include additional <b>address</b> or <b>mode</b> bits.|$|R
50|$|In computing, {{protected}} mode, {{also called}} protected virtual <b>address</b> <b>mode,</b> is an operational mode of x86-compatible {{central processing units}} (CPUs). It allows system software to use features such as virtual memory, paging and safe multi-tasking designed to increase an operating system's control over application software.|$|E
50|$|All {{practical}} stack machines have {{variants of}} the load/store opcodes for accessing local variables and formal parameters without explicit address calculations. This can be by offsets {{from the current}} top-of-stack address, or by offsets from a stable frame-base register. Register machines handle this with a register+offset <b>address</b> <b>mode,</b> but use a wider offset field.|$|E
5000|$|Real mode, {{also called}} real <b>address</b> <b>mode,</b> is an {{operating}} mode of all x86-compatible CPUs. Real mode {{is characterized by}} a 20-bit segmented memory address space (giving exactly 1 MiB of addressable memory) and unlimited direct software access to all addressable memory, I/O addresses and peripheral hardware. Real mode provides no support for memory protection, multitasking, or code privilege levels.|$|E
5000|$|Note {{that there}} is no {{generally}} accepted way of naming the various <b>addressing</b> <b>modes.</b> In particular, different authors and computer manufacturers may give different names to the same <b>addressing</b> <b>mode,</b> or the same names to different <b>addressing</b> <b>modes.</b> Furthermore, an <b>addressing</b> <b>mode</b> which, in one given architecture, is treated as a single <b>addressing</b> <b>mode</b> may represent functionality that, in another architecture, is covered by two or more <b>addressing</b> <b>modes.</b> For example, some complex instruction set computer (CISC) architectures, such as the Digital Equipment Corporation (DEC) VAX, treat registers and literal or immediate constants as just another <b>addressing</b> <b>mode.</b> Others, such as the IBM System/360 and its successors, and most reduced instruction set computer (RISC) designs, encode this information within the instruction. Thus, the latter machines have three distinct instruction codes for copying one register to another, copying a literal constant into a register, and copying the contents of a memory location into a register, while the VAX has only a single [...] "MOV" [...] instruction.|$|R
50|$|Even on a {{computer}} with many <b>addressing</b> <b>modes,</b> measurements of actual programs indicate that the simple <b>addressing</b> <b>modes</b> listed below account for some 90% or more of all <b>addressing</b> <b>modes</b> used. Since most such measurements are based on code generated from high-level languages by compilers, this reflects to some extent {{the limitations of the}} compilers being used.|$|R
40|$|GCC has {{no formal}} <b>addressing</b> <b>mode</b> {{selection}} mechanism. It uses target hooks to generate valid <b>addressing</b> <b>modes</b> for a target. However, {{a significant amount}} of high level information is destroyed while doing this, especially for targets lacking a rich set of <b>addressing</b> <b>modes.</b> This leads to poor aliasing, and subsequently poorer CSE, GCSE, and scheduling. Hence, an unoptimal object code. This paper proposes an abstraction over RTL to generate machine independent <b>addressing</b> <b>modes</b> to achieve better aliasing. The actual <b>addressing</b> <b>modes</b> of the target are exposed after the first scheduling pass, where they are selected based on current execution scenario. Inter block address inheritance is also done at this point. The idea can be extended to specify a general “mid-level ” RTL for GCC...|$|R
50|$|The Pep/7's {{instruction}} set is simplistic, with only 32 possible opcodes. The instruction specifier {{consists of the}} opcode of 5 bits, a register selector (A or X) of 1 bit, and a memory access mode of 2 bits, with the opcode occupying the top 5 bits of a byte, the register selector in bit 2 and the <b>address</b> <b>mode</b> in bits 1 and 0.|$|E
5000|$|The zero page <b>address</b> <b>mode</b> was {{enhanced}} {{in several}} late model 8-bit processors, including the WDC 65816, the CSG 65CE02, and the Motorola 6809. The new mode, known as [...] "direct page" [...] addressing, added {{the ability to}} move the 256-byte zero page memory window from the start of memory (offset address $0000) to a new location within the first 64 KB of memory.|$|E
5000|$|The 286 was {{the first}} of the x86 CPU family to support Protected virtual <b>address</b> <b>mode,</b> {{commonly}} called [...] "protected mode". In addition, it {{was the first}} commercially available microprocessor with on-chip MMU capabilities. (Systems using the contemporaneous Motorola 68010 and NS320xx could be equipped with an optional MMU controller.) This would allow IBM compatibles to have advanced multitasking OSes for the first time and compete in the Unix-dominated server/workstation market.|$|E
40|$|In this paper, two new <b>addressing</b> <b>modes</b> are {{introduced}} to the 16 -bit Thumb instruction set architecture to improve performance of the ARM/Thumb processors. Contrary to previous approaches, the proposed approach focuses on the <b>addressing</b> <b>mode</b> of the instruction set architecture. It adopts scaled register offset <b>addressing</b> <b>mode</b> and post-indexed <b>addressing</b> <b>mode</b> from the 32 -bit ARM architecture, which is the superset of the 16 -bit Thumb architecture. To provide the encoding space for the new <b>addressing</b> <b>modes,</b> the register fields in the LDM and STM instructions are reduced, which are not frequently executed. Experiments show the proposed extension achieves an average of 7. 0 % performance improvement for the seven benchmark programs {{when compared to the}} 16 -bit Thumb instruction set architecture...|$|R
50|$|As a result, {{a greater}} number of {{programs}} were able to utilize the enhanced direct page <b>addressing</b> <b>mode</b> versus legacy processors that only included the zero page <b>addressing</b> <b>mode.</b>|$|R
50|$|Additionally, a third index {{register}} (Z) was included, the stack pointer was widened to 16 bits, and the zero page <b>addressing</b> <b>mode</b> was superseded {{by the more}} flexible direct page <b>addressing</b> <b>mode.</b>|$|R
50|$|By design, the 286 {{could not}} revert from {{protected}} mode {{to the basic}} 8086-compatible Real <b>address</b> <b>mode</b> ("real mode") without a hardware-initiated reset. In the PC/AT introduced in 1984, IBM added external circuitry as well as specialized code in the ROM BIOS and the 8042 peripheral microcontroller to enable software to cause the reset, allowing real-mode reentry while retaining active memory and returning control to the program that initiated the reset. (The BIOS is necessarily involved because it obtains control directly whenever the CPU resets.) Though it worked correctly, the method imposed a huge performance penalty.|$|E
50|$|The eZ80 (like the Z380) is binary {{compatible}} with the Z80 and Z180, but almost three {{times as fast as}} the original Z80 chip at the same clock frequency. The eZ80 has a three-stage pipeline. Available at up to 50 MHz (2004), the performance is comparable to a Z80 clocked at 150 MHz if fast memory is used (i.e. no wait states for opcode fetches, for data, or for I/O) or even higher in some applications (a 16-bit addition is 11 times as fast as in the original). The eZ80 also supports direct continuous addressing of 16 MB of memory without a memory management unit, by extending most registers (HL, BC, DE, IX, IY, SP, and PC) from 16 to 24 bits. In order to do so, the CPU works in a Z80-compatible mode or a full 24-bit <b>address</b> <b>mode.</b>|$|E
5000|$|Real <b>Address</b> <b>mode,</b> {{commonly}} called Real mode, is an operating mode of 8086 and later x86-compatible CPUs. Real mode {{is characterized by}} a 20-bit segmented memory address space (meaning that only 1 MiB of memory can be addressed - actually, slightly more), direct software access to peripheral hardware, and no concept of memory protection or multitasking at the hardware level. All x86 CPUs in the 80286 series and later start up in real mode at power-on; 80186 CPUs and earlier had only one operational mode, which is equivalent to real mode in later chips. (On the IBM PC platform, direct software access to the IBM BIOS routines is available only in real mode, since BIOS is written for real mode. However, this is not a characteristic of the x86 CPU but of the IBM BIOS design.) ...|$|E
50|$|A {{cylinder}} is {{a division}} of data in a disk drive, as used in the CHS <b>addressing</b> <b>mode</b> of a Fixed Block Architecture disk or the cylinder-head-record (CCHHR) <b>addressing</b> <b>mode</b> of a CKD disk.|$|R
50|$|<b>Addressing</b> <b>modes</b> are {{an aspect}} of the {{instruction}} set architecture in most central processing unit (CPU) designs. The various <b>addressing</b> <b>modes</b> that are defined in a given instruction set architecture define how machine language instructions in that architecture identify the operand(s) of each instruction. An <b>addressing</b> <b>mode</b> specifies how to calculate the effective memory address of an operand by using information held in registers and/or constants contained within a machine instruction or elsewhere.|$|R
50|$|Besides instructions, the ISA defines {{items in}} the {{computer}} {{that are available to}} a program - e.g. data types, registers, <b>addressing</b> <b>modes,</b> and memory. Instructions locate these available items with register indexes (or names) and memory <b>addressing</b> <b>modes.</b>|$|R
50|$|BIOS {{interrupt}} {{calls are}} {{a facility that}} operating systems and application programs use to invoke the facilities of the Basic Input/Output System on IBM PC compatible computers. Traditionally, BIOS calls are mainly used by MS-DOS programs and some other software such as boot loaders (including, mostly historically, relatively simple application software that boots directly and runs without an operating system - especially game software.) BIOS only runs in the real <b>address</b> <b>mode</b> (Real Mode) of the x86 CPU, so programs that call BIOS either must also run in real mode or must switch from protected mode to real mode before calling BIOS and then switch back again. For this reason, modern operating systems that use the CPU in Protected Mode generally do not use the BIOS to support system functions, although some of them use the BIOS to probe and initialize hardware resources during their early stages of booting.|$|E
50|$|Another common hybrid is {{to start}} with a {{register}} machine architecture, and add another memory <b>address</b> <b>mode</b> which emulates the push or pop operations of stack machines: 'memaddress = reg; reg += instr.displ'. This was first used in DEC's PDP-11 minicomputer. This feature was carried forward in VAX computers and in Motorola 6800 and M68000 microprocessors. This allowed the use of simpler stack methods in early compilers. It also efficiently supported virtual machines using stack interpreters or threaded code. However, this feature did not help the register machine's own code to become as compact as pure stack machine code. Also, the execution speed was less than when compiling well to the register architecture. It is faster to change the top-of-stack pointer only occasionally (once per call or return) rather than constantly stepping it up and down throughout each program statement, and it is even faster to avoid memory references entirely.|$|E
5000|$|The pound sign or hash symbol {{is often}} used in {{information}} technology to highlight a special meaning. (It {{should be noted that}} the words [...] "Pound Sign" [...] in the UK refer specifically to currency [...] "£"—extended ASCII character 156—and not weight.) In 1970 for example, the number sign was used to denote immediate <b>address</b> <b>mode</b> in the assembly language of the PDP-11 when placed next to a symbol or a number. In 1978, Brian Kernighan and Dennis Ritchie used # in the C programming language for special keywords that had to be processed first by the C preprocessor. In the 1986 SGML standard, ISO 8879:1986 (q.v.), # is a reserved name indicator (rni) which precedes keyword syntactic literals,--e.g., the primitive content token #PCDATA, used for parsed character data. In usage predating the current meaning of hashtag, the pound sign was called the [...] "hash symbol" [...] in some countries outside of North America so as to avoid confusion with the UK currency symbol.|$|E
50|$|Within a loop, this <b>addressing</b> <b>mode</b> {{can be used}} to step {{backwards}} {{through all}} the elements of an array or vector. A stack can be implemented by using this mode in conjunction with the previous <b>addressing</b> <b>mode</b> (autoincrement).|$|R
50|$|The <b>{{addressing}}</b> <b>modes</b> {{listed below}} {{are divided into}} code addressing and data addressing. Most computer architectures maintain this distinction, but there are, or have been, some architectures which allow (almost) all <b>addressing</b> <b>modes</b> {{to be used in}} any context.|$|R
5000|$|The x86-64 {{architecture}} and the 64-bit ARMv8-A architecture have PC-relative <b>addressing</b> <b>modes,</b> called [...] "RIP-relative" [...] in x86-64 and [...] "literal" [...] in ARMv8-A. The Motorola 6809, a very advanced 8-bits CPU designed in 1978, also supports a PC-relative <b>addressing</b> <b>mode.</b>|$|R
