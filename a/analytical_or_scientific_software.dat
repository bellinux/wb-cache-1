0|9926|Public
40|$|Distributed {{applications}} {{in general and}} distributed hypermedia systems in particular require sophisticated language and run-time support {{in order to be}} able to construct efficient, reliable and extensible distributed software systems. Two language extensions of existing programming languages and their seamless integration for object-oriented multiparadigm distributed programming are described as well as their run-time system. The presented language symbiosis is intended for convenient and flexible software construction for distributed object computing in the context of hypermedia systems. Index terms: distributed multiparadigm programming, interoperable active objects, distributed object computing. 1 Introduction One of the important decisions with respect to the implementation of complex distributed software systems is the choice of the implementation language and additional tools. For large nondistributed industrial <b>or</b> <b>scientific</b> <b>software</b> systems there are a reasonable number of mor [...] ...|$|R
40|$|UnrestrictedScientists today {{increasingly}} rely {{on computers}} to perform simulations {{of the physical}} world that are impractical (in the case of drug discovery), impossible (nano-scale fracture dynamics) or unsafe (nuclear physics). This type of in silico experimentation has taken its place with in vitro and in vivo scientific experiments in helping scientists to understand the world around us.; <b>Scientific</b> <b>software</b> systems, the code that has replaced the test-bench in the scientist's lab, is complex and quite costly to produce. As such, it represents a significant investment on the part of computational scientists. In order to improve upon {{the state of the art}} in <b>scientific</b> <b>software</b> development methodologies, we must move from large, monolithic software systems to more modularized systems capable of being evolved and redeployed rapidly at a pace dictated by the evolution of the experiment rather than the rate of code development.; The state of the art methodology today for developing <b>scientific</b> <b>software</b> systems is to produce monolithic systems that, while performant, are difficult to understand, modify, and reconfigure, all necessary activities as the scientist evolves the scientific experiment that the code implements.; This dissertation asks and answers the question of how software engineering can be leveraged to provide improved development support to scientists conducting in silico experimentation.; A modular software system, decomposed into software components with explicit communications through software connectors, is the heart of the software architectural approach, and the first, necessary step toward an architected <b>scientific</b> <b>software</b> system that supports evolution, replication, scaling and third-party validation.; This dissertation presents two thrusts of research developed to support the scientist performing in silico research. The first thrust is to analyze existing scientific code in order to identify snippets that can be encapsulated and modularized. A domain-specific software architectural recovery technique, trained specifically for <b>scientific</b> <b>software,</b> called KADRE, implements this approach.; The second thrust of research presented in this dissertation is the implementation of a domain-specific <b>software</b> architecture for <b>scientific</b> <b>software</b> that orchestrates these identified modules into a software system with explicit software architecture that aids scientists to manipulate the software system at the level of the scientific experiment being conducted while at the same time providing support to the software engineer making decisions to improve the performance of the software system in term of its components and connectors. This architecture is called SWSA, <b>or</b> <b>Scientific</b> Workflow <b>Software</b> Architecture...|$|R
50|$|The Gruber Foundation Cosmology Prize honors {{a leading}} cosmologist, astronomer, {{astrophysicist}} <b>or</b> <b>scientific</b> philosopher for theoretical, <b>analytical</b> <b>or</b> conceptual discoveries {{leading to a}} fundamental advances in the field.|$|R
40|$|The speech {{will present}} bibliographical and full-text databases, created {{with the support}} of ICM UW as part of the Virtual Library of Science project, in the current of ongoing {{transformation}} of science towards greater openness. First part of the speech concerns a global transformation of the process of scientific communication, occurring due to the digital revolution. As a result, we observe growing openness of all forms of scientific content: publications, educational materials, data <b>or</b> <b>scientific</b> <b>software.</b> This leads to a redefinition of the rules of conducting science towards greater openness and transparency, and a concurrent transformation of institutions and mechanisms responsible for scientific communication. On one hand, new tools are created – technical, such as software for creating databases and repositories, and legal solutions, such as open licenses that allow free availability of content. Secondly, international organizations, grant-giving institutions, universities and research institutes ever more often adopt institutional mandates that recommend or require openness of scientific content. In particular, open mandates of this sort require results of research conducted with the help of public funds to be publicly available. Second part concerns the development of the open science models in Poland. This model allows digital exclusion to be eliminated, increases visibility and reuse of research results, and changes mechanisms for evaluation of publications and research results. Until today, open models of scientific communication remain relatively little known and not sufficiently developed or supported, in particular by state regulation. Nevertheless they are being developed today by a range of different institutions. One of them is the Interdisciplinary Center for Mathematical and Computational Modeling at the University of Warsaw, which has been developing in the last dozen years the Virtual Library of Science project. The goal of this project is the creation in Poland of an infrastructure for open science, {{in the shape of a}} unified system of content with a hybrid structure. Bibliographical and full-text databases based on the Yadda platform: BazTech, BazHum and Agro, are an important part of this infrastructure. The third part of the speech will present the current state of development of the Virtual Library of Science, as well as possible future actions, tied to the development and promotion of open science in Poland...|$|R
40|$|ABSTRACT A {{portable}} microcomputer-based {{data collection}} and analysis system was configured utilizing commercial software and hardware. The system consists of a portable microcomputer, an optional minicomputer, an electronic digital balance, a line printer, a communications <b>software</b> package, <b>or</b> <b>scientific</b> data management <b>software</b> package. In the application described, chick and feed weights were electronically collected and subsequently analyzed with programs on the microcomputer or electronically transmitted via a modem to a minicomputer for analysis. The microcomputer could be interfaced with a variety of instruments via its RS- 232 C serial input/ output port for data acquisition. The portability and adaptability of this data acquisition and analysis system makes it a very useful laboratory computer system. This system contributed to a 60 to 65 % savings in the time necessary for {{data collection and}} analysis compared to manual methods. (Key words: computerized data acquisition, portable microcomputer, electronic scales...|$|R
40|$|Given recent {{increases}} {{in the size of}} main memory in modern machines, it is now common to to store large data sets in RAM for faster processing. Multidimensional access methods aim to provide efficient access to large data sets when queries apply predicates to some of the data dimensions. We examine multidimensional access methods {{in the context of an}} in-memory column store tuned for on-line <b>analytical</b> processing <b>or</b> <b>scientific</b> data analysis. We propose a multidimensional data structure that contains a novel combination of a grid array and several bitmaps. The base data is clustered in an order matching that of the index structure. The bitmaps contain one bit per block of data, motivating the term "blockmap. " The proposed data structures are compact, typically taking less than one bit of space per row of data. Partition boundaries can be chosen in a way that reflects both the query workload and the data distribution, and boundaries are not required to evenly divide the data if there is a bias in the query distribution. We examine the theoretical performance of the data structure and experimentally measure its performance on three modern CPUs and one GPU processor. We demonstrate that efficient multidimensional access can be achieved with minimal space overhead...|$|R
40|$|Software Engineering for Science {{provides}} an in-depth collection of peer-reviewed chapters that describe experiences with applying software engineering practices {{to the development}} of <b>scientific</b> <b>software.</b> It provides {{a better understanding of how}} software engineering is and should be practiced, and which software engineering practices are effective for <b>scientific</b> <b>software.</b> The book starts with a detailed overview of the <b>Scientific</b> <b>Software</b> Lifecycle, and a general overview of the <b>scientific</b> <b>software</b> development process. It highlights key issues commonly arising during <b>scientific</b> <b>software</b> development, as well as solutions to these problems. The second part of the book provides examples of the use of testing in <b>scientific</b> <b>software</b> development, including key issues and challenges. The chapters then describe solutions and case studies aimed at applying testing to <b>scientific</b> <b>software</b> development efforts. The final part of the book provides examples of applying software engineering techniques to <b>scientific</b> <b>software,</b> including not only computational modeling, but also software for data management and analysis. The authors describe their experiences and lessons learned from developing complex <b>scientific</b> <b>software</b> in different domains...|$|R
40|$|The {{sustainability}} of <b>scientific</b> <b>software</b> {{is critical for}} the future of science. Recent efforts by funding agencies to recognize software as a contribution to science demonstrate the importance of <b>software</b> for science. <b>Scientific</b> <b>software</b> should be prepared and maintained for subsequent use in the future. Developers of <b>scientific</b> <b>software</b> should consider potential users and the future usability of the software...|$|R
40|$|Though <b>{{scientific}}</b> <b>software</b> is {{an engine}} for scientific progress and provides data for critical decisions, {{the testing of}} <b>scientific</b> <b>software</b> is often anything but scientific. Our research examines the factors that complicate the testing of <b>scientific</b> <b>software,</b> including {{the complexity of the}} subject matter, inadequate validation criteria, a high demand for correctness, and the lack of testing expertise among scientists...|$|R
40|$|Context: <b>Scientific</b> <b>software</b> {{plays an}} {{important}} role in critical decision making, for example making weather predictions based on climate models, and computation of evidence for research publications. Recently, scientists have had to retract publications due to errors caused by software faults. Systematic testing can identify such faults in code. Objective: This study aims to identify specific challenges, proposed solutions, and unsolved problems faced when testing <b>scientific</b> <b>software.</b> Method: We conducted a systematic literature survey to identify and analyze relevant literature. We identified 62 studies that provided relevant information about testing <b>scientific</b> <b>software.</b> Results: We found that challenges faced when testing <b>scientific</b> <b>software</b> fall into two main categories: (1) testing challenges that occur due to characteristics of <b>scientific</b> <b>software</b> such as oracle problems and (2) testing challenges that occur due to cultural differences between scientists and the software engineering community such as viewing the code and the model that it implements as inseparable entities. In addition, we identified methods to potentially overcome these challenges and their limitations. Finally we describe unsolved challenges and how software engineering researches and practitioners can help to overcome them. Conclusions: <b>Scientific</b> <b>software</b> presents special challenges for testing. Specifically, cultural differences between scientist developers and software engineers, along with the characteristics of the <b>scientific</b> <b>software</b> make testing more difficult. Existing techniques such as code clone detection can help to improve the testing process. Software engineers should consider special challenges posed by <b>scientific</b> <b>software</b> such as oracle problems when developing testing techniques...|$|R
40|$|We {{argue that}} delayed-evaluation, self-optimising <b>scientific</b> <b>software</b> components, which {{dynamically}} change their behaviour {{according to their}} calling context at runtime offer a possible way of bridging the apparent conflict between the quality of <b>scientific</b> <b>software</b> and its performance. Rather than equipping <b>scientific</b> <b>software</b> components with a performance interface which allows the caller to supply the context information that is lost when building abstract software components, we propose to recapture this lost context information at runtime...|$|R
40|$|Citation of <b>scientific</b> <b>software</b> {{contributes}} to the reproducibility, attribution, documentation, and provenance of science. Considerations for the citation of <b>scientific</b> <b>software</b> are described and recommendations for practice are offered for software developers, software users, data centers, and publishers...|$|R
50|$|Neuro Laboratory is a {{shareware}} <b>scientific</b> computing <b>software</b> for Windows and Linux platforms {{developed by}} <b>Scientific</b> <b>Software.</b> The current version is 1.1.|$|R
40|$|<b>Scientific</b> <b>software</b> {{development}} projects that integrate usability and user-centered design methods {{can have an}} impact that goes beyond a limited set of users. W hether <b>scientific</b> <b>software</b> tools exist primarily to improve workflow effi-ciency or to open doors to new scientific discovery, they must be useful to and usable by scientists. 1 Commercial software design’s usability and user-centered design (UCD) concepts have matured greatly over the years. However, although those working in academic <b>scientific</b> <b>software</b> development environ...|$|R
40|$|The {{development}} of <b>scientific</b> <b>software</b> {{is often a}} partnership between domain scientists and <b>scientific</b> <b>software</b> engineers. It is especially important to embrace these collaborations when developing advanced <b>scientific</b> <b>software,</b> where sustainability, reproducibility, and extensibility are important. In the ideal case, as discussed in this manuscript, this brings together teams composed of the world's foremost scientific experts in a given field with seasoned software developers experienced in forming highly collaborative teams working on <b>software</b> to further <b>scientific</b> research. Comment: 4 pages, submission for WSSSPE...|$|R
40|$|Abstract We are {{developing}} <b>scientific</b> <b>software</b> component technology {{to manage the}} complexity of modern, parallel simulation software and increase the interop-erability and re-use of <b>scientific</b> <b>software</b> packages. In this paper, we describe a language interoperability tool named Babel that enables the creation and dis-tribution of language-independent software libraries using interface definition language (IDL) techniques. We have created a scientific IDL {{that focuses on the}} unique interface description needs of <b>scientific</b> <b>software,</b> such as complex numbers, dense multidimensional arrays, and parallel distributed objects. Pre-liminary results indicate that in addition to language interoperability, this ap-proach provides useful tools for the design of modern object-oriented <b>scientific</b> <b>software</b> libraries. We also describe a web-based component repository called Alexandria that facilitates the distribution, documentation, and re-use of scien-tific components and libraries...|$|R
40|$|Complex problems, whether <b>scientific</b> <b>or</b> engineering, {{are most}} often solved today by {{utilizing}} public domain or commercial libraries or some form of problem solving environment. The task of "selecting" the best software for a targeted application or computation is often difficult and sometimes even intractable. We have proposed an approach for dealing with this issue by "mining" performance data of <b>scientific</b> <b>software</b> to generate knowledge {{that can be used}} to select software for a particular scientific problem, assuming some computational objectives. In this paper we describe a framework together with its software implementation for mining performance data of <b>scientific</b> <b>software</b> and using the results to generate knowledge necessary to solve the software selection problem...|$|R
40|$|The {{nature of}} {{scientific}} research {{and the development of}} <b>scientific</b> <b>software</b> have similarities with processes that follow the agile manifesto: responsiveness to change and collaboration are of the utmost importance. But how well do current <b>scientific</b> <b>software</b> development processes match the practices found in agile development methods, and what are the effects of using agile practices in such processes? In order to investigate this, we conduct a literature review, focusing on evaluating the agility present in a selection of <b>scientific</b> <b>software</b> projects. Both projects with intentionally agile practices and projects with a certain degree of agile elements are taken into consideration. In the agility assessment, we define and utilize an agile mapping chart. The elements of the mapping chart are based on Scrum and XP, thus covering two of the most prominent agile reference models. We compared the findings of the literature review to results of a previously conducted survey. The comparison indicates that <b>scientific</b> <b>software</b> development projects adopting agile practices perceive their testing to be better than average. No difference to average projects was perceived regarding requirements-related activities. Future work includes an in-depth case study to further investigate the existence and impact of agility in three large <b>scientific</b> <b>software</b> projects, ultimately aiming at {{a better understanding of the}} particularities involved in developing <b>scientific</b> <b>software...</b>|$|R
5000|$|Mathematical Aspects of <b>Scientific</b> <b>Software</b> (Springer-Verlag, 1988) ...|$|R
40|$|Our work in {{software}} quality for digital humanities was borne {{of an effort}} to address sustainable practices in <b>scientific</b> <b>software</b> development, where the speaker (Thiruvathukal) co-authored a position paper on the case for <b>software</b> engineering in <b>scientific</b> <b>software</b> development as part of an all-encompassing strategy to create more sustainable <b>scientific</b> <b>software</b> (an example of a well-known <b>scientific</b> <b>software</b> package is LINPACK). In this position paper, we addressed how “progress in scientific research is dependent on the quality and accessibility of software at all levels 2 ̆ 2. This progress depends on embracing the best traditional [...] and emergent [...] practices {{in software}} engineering, especially agile practices that intersect with the more formal tradition of software engineering. Although this paper was about <b>scientific</b> <b>software</b> development, it {{could just as easily have}} been about any interdisciplinary software development community. Our interest in applying what we’ve learned to DH, however, comes from work Thiruvathukal and Hayward have done and/or supervised in DH, especially WoolfOnline and a Richmond Times Dispatch viewer, where more software engineering could have been helpful...|$|R
40|$|Abstract. We {{argue that}} delayed-evaluation, self-optimising <b>scientific</b> <b>software</b> components, which {{dynamically}} change their behaviour {{according to their}} calling context at runtime offer a possible way of bridging the apparent conflict between the quality of <b>scientific</b> <b>software</b> and its performance. Rather than equipping <b>scientific</b> <b>software</b> components with a performance interface which allows the caller to supply the context information that is lost when building abstract software components, we propose to recapture this lost context information at runtime. This paper {{is accompanied by a}} public release of a parallel linear algebra library with both C and C++ language interfaces which implements this proposal. We demonstrate the usability of this library by showing that {{it can be used to}} supply linear algebra component functionality to an existing external software package. We give preliminary performance figures and discuss avenues for future work. 1 Component-based Application Construction There is often an apparent conflict between the quality of <b>scientific</b> <b>software</b> and its performance. High quality <b>scientific</b> <b>software</b> has to be easy to re-use, easy to re-engineer...|$|R
5000|$|... #Subtitle level 2: <b>Scientific</b> <b>software</b> for {{analysis}} of hydroacoustic data ...|$|R
40|$|<b>Scientific</b> <b>software</b> {{has become}} an {{indispensable}} commodity for the production, processing and analysis of empirical data but also for modelling and simulation of complex processes. Software has a significant influence {{on the quality of}} research results. For strengthening the recognition of the academic performance of <b>scientific</b> <b>software</b> development, for increasing its visibility and for promoting the reproducibility of research results, concepts for the publication of <b>scientific</b> <b>software</b> have to be developed, tested, evaluated, and then transferred into operations. For this, the publication and citability of <b>scientific</b> <b>software</b> have to fulfil scientific criteria by means of defined processes and the use of persistent identifiers, similar to data publications. The SciForge project is addressing these challenges. Based on interviews a blueprint for a <b>scientific</b> <b>software</b> publishing platform and a systematic implementation plan has been designed. In addition, the potential of journals, software repositories and persistent identifiers have been evaluated to improve the publication and dissemination of reusable software solutions. It is important that procedures for publishing software as well as methods and tools for software engineering are reflected in the architecture of the platform, in order {{to improve the quality of}} the software and the results of research. In addition, it is necessary to work continuously on improving specific conditions that promote the adoption and sustainable utilization of <b>scientific</b> <b>software</b> publications. Among others, this would include policies for the development and publication of <b>scientific</b> <b>software</b> in the institutions but also policies for establishing the necessary competencies and skills of scientists and IT personnel. To implement the concepts developed in SciForge a combined bottom-up / top-down approach is considered that will be implemented in parallel in different scientific domains, e. g. in earth sciences, climate research and the life sciences. Based on the developed blueprints a <b>scientific</b> <b>software</b> publishing platform will be iteratively implemented, tested, and evaluated. Thus the platform should be developed continuously on the basis of gained experiences and results. The platform services will be extended one by one corresponding to the requirements of the communities. Thus the implemented platform for the publication of <b>scientific</b> <b>software</b> can be improved and stabilized incrementally as a tool with software, science, publishing, and user oriented features...|$|R
40|$|In {{this paper}} are {{analyzed}} two cultures, {{the scientists who}} develop their own software and software engineers who develop <b>scientific</b> <b>software,</b> It describes {{some of the problems}} that arise when both cultures come together to develop <b>scientific</b> <b>software,</b> and discusses the impact that arises when their representatives intend to carry out joint projects...|$|R
5000|$|June 1998: Dakota <b>Scientific</b> <b>Software,</b> Inc. - {{development}} tools for high-performance computing ...|$|R
40|$|The goal is {{to survey}} the impact of <b>scientific</b> <b>software</b> on mathematics. Three types of impacts are {{identified}} and several topics from each are discussed in some depth. First is {{the impact on the}} structure of mathematics through its Tole as the scientific tool for problem solving. <b>Scientific</b> <b>software</b> leads to new assessments of what algorithms are, how well they work, and what a solution really is. Second is the initiation of new mathematical endeavors. Numerical computation is already very widely known, we dis-cuss the important future roles of symbolic and geometric computation. Finally, there are particular mathematical problems that arise from <b>scientific</b> <b>software.</b> Examples dis-cussed include round-off errors and the validation of computations, mapping problems and algorithms into machines, and adaptive methods. There is considerable discussion of the shortcommings of mathematics in providing an adequate model for the scientific analysis of <b>scientific</b> <b>software...</b>|$|R
40|$|Highly {{accurate}} <b>scientific</b> <b>software</b> requires valid <b>scientific</b> models, accurate numerical methods, {{and highly}} correct code. Software engineers specialize in testing code, {{but the lack}} of test oracles and the existence of “silent faults” makes it very difficult to test the correctness of scientific code. We suggest that code mutation can be used to study code faults in <b>scientific</b> <b>software</b> in the hope that software engineers can use the derived knowledge to make valuable contributions to the quality of <b>scientific</b> <b>software</b> and the as-sociated research. This poster highlights challenges of sci-entific software testing before briefly describing the muta-tion testing process and providing sample results from mu-tation sensitivity tests. 1...|$|R
5000|$|GraphPad Software Inc. is {{a privately}} held California corporation. They publish <b>scientific</b> <b>software,</b> including: ...|$|R
3000|$|Computation-dominant software—i.e. {{operations}} research, {{information management}} and manipulation, artistic creativity, <b>scientific</b> <b>software</b> and artificial intelligence [...]...|$|R
50|$|OpenEye <b>Scientific</b> <b>Software</b> is an American {{software}} company which develops large-scale molecular modelling applications and toolkits.|$|R
5000|$|SICONOS is an Open Source <b>scientific</b> <b>software</b> {{primarily}} targeted atmodeling and simulating non-smooth dynamical systems (NSDS): ...|$|R
50|$|BioDiscovery is a <b>scientific</b> <b>software</b> {{company based}} in El Segundo, California, focused on genetic {{research}} and genomic analysis.|$|R
40|$|Design {{patterns}} in software engineering {{have been proven}} to offer great benefits, and <b>scientific</b> <b>software</b> is no exception. Especially as <b>scientific</b> <b>software</b> becomes more object-oriented, the importance of design patterns cannot be underestimated. We present a set of design patterns for scientific computing implemented in C++, apply them to two example object-oriented frameworks, and demonstrate their application benefits in terms of speed, memory consumption, flexibility, and software maintenance...|$|R
5000|$|... 2007: {{first prize}} in the <b>scientific</b> <b>software</b> {{division}} of Les Trophées du Libre, an international competition for free software.|$|R
50|$|In 2007, GetFEM++ {{received}} the second prize {{in the category}} of <b>scientific</b> <b>software</b> in the Les Trophées du Libre contest.|$|R
50|$|Scicos is {{developed}} in and distributed with the <b>scientific</b> <b>software</b> package ScicosLab. Scicos 4.4.1 {{has been released}} in April 2011.|$|R
