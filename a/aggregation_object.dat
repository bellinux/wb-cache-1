5|108|Public
5000|$|GigaSpaces eXtreme Application Platform (XAP), is a {{distributed}} in-memory data-grid {{suited for}} high performance and low-latency transaction processing {{as well as}} real-time analytics use cases. XAP performance is achieved by maximizing the utilization of RAM and SSD as the main data store. It is commonly used to speed up existing database performance and scalability and include built-in synchronization with RDBS such as MySQL {{as well as new}} databases such as MongoDB, Cassandra etc. XAP was designed to serve as the system of record for the data that it maintains. Therefore, it supports all the features of databases such as complex queries, transaction support etc. Among its main features is support {{for a wide range of}} data models starting from a simple key,value API to advance <b>aggregation,</b> <b>Object</b> Graph and SQL support.|$|E
40|$|Workflows {{provide a}} popular means for {{preserving}} scientific methods by explicitly encoding their process. However, {{some of them}} are subject to a decay in their ability to be re-executed or reproduce the same results over time, largely due to the volatility of the resources required for workflow executions. This paper provides an analysis of the root causes of workflow decay based on an empirical study of a collection of Taverna workflows from the myExperiment repository. Although our analysis was based on a specific type of workflow, the outcomes and methodology should be applicable to workflows from other systems, at least those whose executions also rely largely on accessing third-party resources. Based on our understanding about decay we recommend a minimal set of auxiliary resources to be preserved together with the workflows as an <b>aggregation</b> <b>object</b> and provide a software tool for end-users to create such aggregations and to assess their completeness. © 2012 IEEE...|$|E
40|$|Abstract-semantic domain for {{object-oriented}} {{languages and}} systems outlined {{in this paper}} is an amalgamation of two approaches: the objects-as-sheaves approach of the second author published nearly two decades ago, and the more recent ideas {{of the first and}} third authors on objects as processes endowed with observation. The basic insight is that objects in the latter sense correspond to object morphisms in the former sense. After an informal introduction into both approaches, we first elaborate on the sheaf model, using the term "behaviour" for objects in this sense, and avoiding concepts from topology. Behaviours and behaviour morphisms are shown to form a complete category where parallel composition is reflected by limits. Objects are defined to be behaviour morphisms, giving rise to a cocompletc category of objects where colimits reflect object <b>aggregation.</b> <b>Object</b> morphisms reflect different forms of inheritance, and also object reifieation (implementing objects over objects) is conveniently expressed in this framework. Key words-object-oriented system; object; object morphism; process; behaviour; object aggregation: parallel composition; object inheritance; object reification. 204 I...|$|E
5000|$|Objects {{can view}} {{resources}} (via <b>object</b> <b>aggregation,</b> a weak [...] "has a" [...] relationship).|$|R
40|$|Every day, I {{write letters}} to prisoners. I have done this for years now, and have written {{literally}} thousands of letters. Somewhere along the way the correspondence gave birth to an art vision—an <b>aggregation</b> of <b>objects</b> and content that has provided the source material for work that I have been creating since 2013...|$|R
40|$|A logic for specifying and {{reasoning}} about object classes and their instances (aspects) is presented and illustrated. This logic {{is an extension}} of a rather standard linear temporal, many-sorted, first-order predicate logic with equality. The extensions where designed to be as simple as possible while supporting the envisaged locality of arguments, object specialization and <b>object</b> <b>aggregation.</b> <b>Objects</b> are specified through their aspects. Each aspect establishes a local vocabulary (signature). The logic works at two levels: first, we can specify and prove assertions about a given object aspect in isolation (local reasoning), eg persons, or patients, or cars; second, we can specify interaction constraints and make inferences between aspects within the same community of objects (global reasoning), eg carry the theorems of persons onto patients (specialization inheritance), or carry the theorems of persons onto the aggregations of persons and cars (incorporation inheritance). Some reflecti [...] ...|$|R
40|$|AbstractObject-Z is an {{extension}} of the Z notation which facilitates specification of large, complex software by defining a system as a collection of independent classes. A number of contributions have been made so far to map Object-Z to various object-oriented languages. However, the given mapping approaches do not cover several Object-Z specification constructs, such as class union, object <b>aggregation,</b> <b>object</b> containment and some of the operation operators. Also, in much of the existing work, mapping rules are given in a very abstract form. In other words, they do not consider all cases in a detailed way needed to automate the mapping procedure. In our previous work, we partially tackled these issues; however, in this paper, we present a much more comprehensive way to animate Object-Z specifications using C++. The given method covers some constructs that have not been addressed in our previous work. Also, mapping rules are described with enough details facilitating automation. Finally, we consider some level of user interaction in our new method which increases the flexibility and efficiency of final codes from the user point of view...|$|E
50|$|The {{performance}} of VBS3 is an improvement on VBS2. With VBS3, the developers implemented new <b>object</b> <b>aggregation</b> technology and smarter object fading {{to enhance the}} software's fast air performance capabilities.|$|R
40|$|TROLL is a {{language}} to specify information systems with dynamic behavior. Here, we {{elaborate on the}} specification of <b>object</b> <b>aggregation</b> in TROLL. We distinguish between two kinds of aggregation, static and dynamic aggregation. Static aggregation means that the composition of objects is described using predicates over constant properties. Dynamic aggregation means that we may alter the composition of objects by invoking special operations (events) that are implicitly defined for each dynamic complex object. Additionally, we describe the specification of disjoint complex {{as a means for}} structuring a specification. We introduce language features to describe <b>object</b> <b>aggregation</b> and give some hints towards their semantics...|$|R
5000|$|... column <b>aggregation</b> {{inheritance}} (similar <b>objects</b> can {{be stored}} in one database table, with one type-column specifying the subtype of the particular object - the correct subclass is always returned when a query is done); ...|$|R
40|$|To {{reduce the}} data volume, various {{algorithms}} {{have been proposed}} for data compression and data <b>aggregation.</b> In <b>object</b> tracking applications, natural phenomena show that many creatures form large social groups and move in regular patterns. However, the previous works do not address application level semantics, such as the group relationships and movement patterns, in the location data. In this paper, we first introduce an efficient distributed mining algorithm to approach the moving object clustering problem and discover group movement patterns. Afterward, we propose a novel compression algorithm, based on the discovered group movement patterns to overcome the group data compression problem. Our experimental {{results show that the}} proposed compression algorithm effectively and efficiently reduces the amount of delivered data and reduces energy consumption expense for data transmission in WSNs. Keywords [...] - Data compression, data <b>aggregation,</b> distributed mining, <b>object</b> tracking,energy consumption. I...|$|R
5000|$|A {{resource}} map (ReM) is {{a concept}} of the ORE Model for associating an identity with compound digital <b>objects</b> (<b>aggregations</b> of digital resources) and making assertions about their structure and semantics. Compound objects combine distributed resources, including multiple media types.|$|R
50|$|LiteSQL creates tables, indexes and {{sequences}} to {{database and}} upgrades schema when needed. In addition to object persistence, LiteSQL provides object relations {{which can be}} used to model basic OO building blocks (<b>aggregation,</b> composition, association). <b>Objects</b> can be selected, filtered and ordered using template- and class-based API with type checking at compile time.|$|R
40|$|This text {{provides}} a background {{view of the}} object approach, related geometric aspects, the different level of data modelling {{and the role of}} geo-information theory. The rest of the book builds upon these concepts describing the applicability of broader aspects such as topology, thematic object classes and class hierarchies, <b>object</b> <b>aggregation</b> and generalization and uncertainty...|$|R
40|$|Many current {{programming}} languages offer insufficient {{support for}} the aggregation relationship. They do not offer a language support for composite structures (object hierarchies, whole/part hierarchies) on the object-level. Instead they rely on techniques, like embedding or referencing through pointers, which do not fully incorporate the semantics of aggregation. As a superior technique we present the language construct dynamic <b>object</b> <b>aggregations...</b>|$|R
40|$|Best merge {{region growing}} {{normally}} produces segmentations with closed connected region objects. Recognizing that spectrally similar objects often appear in spatially separate locations, we present an approach for tightly integrating best merge region growing with non-adjacent region <b>object</b> <b>aggregation,</b> {{which we call}} Hierarchical Segmentation or HSeg. However, the original implementation of non-adjacent region <b>object</b> <b>aggregation</b> in HSeg required excessive computing time even for moderately sized images because of the required intercomparison of each region with all other regions. This problem was previously addressed by a recursive approximation of HSeg, called RHSeg. In this paper we introduce a refined implementation of non-adjacent region <b>object</b> <b>aggregation</b> in HSeg that reduces the computational requirements of HSeg without resorting to the recursive approximation. In this refinement, HSeg s region inter-comparisons among non-adjacent regions are limited to regions of a dynamically determined minimum size. We show that this refined version of HSeg can process moderately sized images in {{about the same amount}} of time as RHSeg incorporating the original HSeg. Nonetheless, RHSeg is still required for processing very large images due to its lower computer memory requirements and amenability to parallel processing. We then note a limitation of RHSeg with the original HSeg for high spatial resolution images, and show how incorporating the refined HSeg into RHSeg overcomes this limitation. The quality of the image segmentations produced by the refined HSeg is then compared with other available best merge segmentation approaches. Finally, we comment on the unique nature of the hierarchical segmentations produced by HSeg...|$|R
40|$|International audienceBest merge {{region growing}} {{normally}} produces seg- mentations with closed connected region objects. Recognizing that spectrally similar objects often appear in spatially separate loca- tions, we present an approach for tightly integrating best merge region growing with nonadjacent region <b>object</b> <b>aggregation,</b> {{which we call}} hierarchical segmentation or HSeg. However, the original implementation of nonadjacent region <b>object</b> <b>aggregation</b> in HSeg required excessive computing time even for moderately sized im- ages because of the required intercomparison of each region with all other regions. This problem was previously addressed by a recursive approximation of HSeg, called RHSeg. In this paper, we introduce a refined implementation of nonadjacent region <b>object</b> <b>aggregation</b> in HSeg that reduces the computational requirements of HSeg without resorting to the recursive approximation. In this refinement, HSeg's region intercomparisons among nonadjacent regions are limited to regions of a dynamically determined mini- mum size. We show that this refined version of HSeg can process moderately sized images in {{about the same amount}} of time as RHSeg incorporating the original HSeg. Nonetheless, RHSeg is still required for processing very large images due to its lower computer memory requirements and amenability to parallel pro- cessing. We then note a limitation of RHSeg with the original HSeg for high spatial resolution images and show how incorpo- rating the refined HSeg into RHSeg overcomes this limitation. The quality of the image segmentations produced by the refined HSeg is then compared with other available best merge segmentation approaches. Finally, we comment on the unique nature of the hierarchical segmentations produced by HSeg...|$|R
40|$|AbstractA {{method for}} <b>object</b> <b>aggregation</b> and cluster {{identification}} {{has been proposed}} for knowledge discovery in databases. By integrating conceptual clustering and machine learning (especially learning-from-examples) paradigms, the method classifies the data into different clusters, extracts the characteristics of each cluster, and discoversknowledge rules based on the relationships among different clusters. Different kinds of knowledge rules, including hierarchical, equivalence and inheritance rules can be discovered efficiently...|$|R
50|$|Zonnon uses a {{compositional}} inheritance model {{based on}} <b>aggregation.</b> Typically, an <b>object</b> (or module) {{is composed of}} a number of functional components, each of them presenting itself to clients {{in the form of an}} abstract definition. The set of definitions plus the object’s intrinsic interface (that is the set of all public elements of the object) constitutes the interface between the object and its clients.|$|R
40|$|Abstrac/- Time {{synchronization}} {{is essential}} for several ad-hoc network protocols and applications, such as TDMA scheduling, dolo <b>aggregation,</b> caching, <b>object</b> tracking, and security checking. Prior work on synchronization in wire-less networks has not adequately addressed rapid conver· gence and scalability requirements in dense networks serv-ing time-sensitive applications, such as sensor networks. In this paper, we propose a distributed clustering-based high-level time synchronization framework for multi-hop od-hoc networks that builds a two-tired. synchronized network. We do not make any assumptions about node capabilities (e. g.) being GPS-enabled), or the presence of reference nodes in the network. Thus, global consensus on one time value is not our goal. Rather, we assume Lhat relative node synchronization is sufficient. We study both classe...|$|R
40|$|It {{is a vital}} {{research}} {{direction for}} spatial clustering to recognize polygon cluster, but due to the dual-constrains by geometric information of polygons and obstacles, the position similarity of polygon is difficult to calculate accurately and quickly. A polygon clustering algorithm under dual-constrains is proposed by extending the algorithm of multi-scale spatial clustering, and constructing an intensity function to express position <b>aggregation</b> between <b>object</b> and its adjacent object. For further discuss, it takes the same thresholds of intensity function in adjacent scales as convergence condition. Simulated polygons and real data are chosen to perform clustering in experiments to verify the validity of our algorithm. Results show that without predefined parameters, this algorithm can identify variety polygon clusters with different densities, arbitrary shape, bridge and obstacle...|$|R
40|$|Abstract. In {{the field}} of the multifeature {{querying}} {{it is possible to}} use many heuristics to retrieve top k objects to became low number of accesses to the sources. When the sources have many equal values, it is often hard to choose which source should be accessed next. In this paper we compare previous random approach with the parallel approach to the set of actual candidate sources. Key words: multifeature querying, top-k <b>objects,</b> <b>aggregation...</b>|$|R
40|$|This {{document}} describes {{changes and}} enhancements {{to the existing}} aggregation process in the DRIVER Testbed in order to widen the import to other metadata formats beside Dublin Core (DC), to ensure their quality and to prepare affected services for the <b>aggregation</b> of compound <b>objects.</b> This specification sets the functional context, the detailed technical specification for the development process is maintained and dynamically developed in the virtual collaboration tools of the project (e. g. WIKI) ...|$|R
50|$|Bohemia Interactive Simulations {{released}} VBS3 v3.0 to the U.S. Army in March 2014. Within a few weeks, {{thousands of}} soldiers had downloaded VBS3 from the Army's MilGaming portal. The company also announced performance improvements for fast-air simulation, including real-time <b>object</b> <b>aggregation</b> and sub-pixel rendering. In May 2014, Army Times {{reported on a}} special plug-in developed in VBS3 for the U.S. Army that allows soldiers to assign physical training scores and weapons qualifications to their avatars in the simulation.|$|R
40|$|Moving objects {{databases}} (MOD) {{have been}} receiving increasing {{attention from the}} database community in recent years, mainly due to {{the wide variety of}} applications that technology allows nowadays. Trajectories of moving objects like cars or pedestrians, can be reconstructed by means of samples describing the locations of these objects at certain points in time. Although there are many proposals for modeling and querying moving objects, {{only a small part of}} them address the problem of <b>aggregation</b> of moving <b>objects</b> data in a GIS (Geographic Information Systems) scenario. In previous work we presented a formal model where the geometric components of the thematic layers in a GIS are represented as an OLAP (On Line Analytical Processing) dimension hierarchy, and introduced the notion of spatial aggregation. In this paper we extend this proposal in order to address moving <b>object</b> <b>aggregation</b> over a GIS. In this way, complex aggregate queries can be expressed in an elegant fashion. We present the data model, characterize the kinds of queries that may appear in this scenario, and show how these queries can be expressed as an aggregation over the result given by a first order formula expressing constraints over the geometries of the layers. ...|$|R
30|$|Aggregation {{indicates}} {{the formation of}} a particular object as a result of one object built as a collection. In <b>aggregation,</b> the contained <b>objects</b> are not strongly dependent on the life cycle of the container. There are 2 aggregation links between a Drug object and an ATC object, and between a Gene object and a SNP object. A Drug object is made up of none or more ATC codes. And a Gene object is made up of one or more SNPs.|$|R
40|$|Spatial layout is {{frequently}} used for managing loosely organized information, such as desktop icons and digital ink. To help users organize {{this type of}} information efficiently, we propose an interface for manipulating spatial <b>aggregations</b> of <b>objects.</b> The aggregated objects are automatically recognized as a group, and the group structure is visualized as a two-dimensional bubble surface that surrounds the objects. Users can drag, copy, or delete a group by operating on the bubble. Furthermore, to help pick out individual objects in a dense aggregation, the system spreads the objects to avoid overlapping when requested. This paper describes the design of this interface and its implementation. We tested our technique in icon grouping and ink relocation tasks and observed improvements in user performance. ACM Classification: H 5. 2 [Information interfaces and presentation]: User Interfaces – Graphical user interfaces...|$|R
5000|$|Implementation-wise, in object composition, {{if using}} the dispose pattern, the owning object thus {{will also have}} a [...] method, which in turn calls the [...] methods of owned objects that must be disposed; in RAII this is handled {{automatically}} (so long as owned objects are themselves automatically destroyed: in C++ if they are a value or a , but not a raw pointer: see pointer ownership). In <b>object</b> <b>aggregation,</b> nothing {{needs to be done}} by the viewing object, as it is not responsible for the resource.|$|R
40|$|Query {{language}} and querying facilities are critical factors for wide acceptance of Object-Oriented Database Management Systems (OODBMS) in the market. In this paper, {{we focus on}} query model on an aggregation hierarchy. We call this query "Aggregation Query". Query on an aggregation hierarchy is unique and differs from general query on association relationships. The latter is often known as path expression query. The difference {{is analogous to the}} distinction between association and <b>aggregation</b> in <b>object</b> modelling. In our proposal, we present three important elements of aggregation query, particularly (i) aggregation query hierarchy, (ii) shorthand path expression for aggregation query utility, and (iii) retrieving aggregation tree. Whilst the first element above is adopted from path expression queries, the second element is an extension to general path expression query, and the third element is unique to aggregation, as aggregation resembles a Part-Of relationship, which is more specialized than association relationships...|$|R
40|$|The {{motivation}} {{for this research}} work {{is the lack of}} a complete declarative way for representative spatiotemporal composition of objects in the current multimedia document standards and authoring tools. In this paper we define such a model which is based on a set of spatial and temporal relationships between actors in multimedia applications. Our work exploits existing approaches for spatial and temporal relationships. We extend these relationships in order to cover the specific requirements of multimedia applications and we integrate the results in a uniform framework for spatiotemporal composition representation. 1. Introduction Multimedia Applications can be very complex concerning the number of involved objects (there fore "actors"), transformations of the objects in the scope of an application and relationships among them. We regard a multimedia application as a container that includes scenes (<b>aggregations</b> of <b>objects</b> in a thematic domain) which, in turn, include objects that are [...] ...|$|R
30|$|Light {{scattering}} is also {{classified into}} two components; single and multiple scattering, according to researches in computer vision [42, 50] and physics [51, 52]. Single scattering {{is caused by}} one-bounce collision with a particle, or particle <b>aggregation,</b> inside an <b>object,</b> which is often seen in optically thin media (Fig.  1 c). A well-known nature of single scattering is that an intensity of single scattering exponentially decays along its light path. On the other hand, multiple scattering is a phenomenon of multi-bounce collisions, which is often seen in optically thick media (Fig.  1 c).|$|R
40|$|A {{scalable}} object location {{service can}} enable users {{to search for}} various objects {{in an environment where}} many small, networked devices are attached to objects. We investigate two hierarchical, self-configuring or unattended approaches for an efficient object location service. Each approach has its advantages and disadvantages based on the anticipated load. The first approach, SCOUT-AGG, is based on <b>aggregation</b> of <b>object</b> names. The second approach, SCOUT-MAP, is based on indirection, where information about an object is stored at the locator sensor for the object. The relative efficiency of SCOUT-AGG and SCOUT-MAP can be characterized by the query to mobility update rate of the system. SCOUT-AGG performs better for low query to update rate but its performance deteriorates in general relative to SCOUT-MAP as the query to update rate increases. The rate of performance deterioration depends on query specificity (i. e., queries for a specific object or for any object of a particular type). [...] ...|$|R
40|$|In {{this paper}} {{we present a}} model for the {{representation}} of multimedia applications based on the scenario concept. The scenario is described in terms of events and actions. The proposed model represents all the events that may occur in a multimedia application (originated from the system, the application or the user). As regards actions we propose a rich scheme for spatial an temporal composition representation based on operators that cover all the spatial and temporal relationships among multimedia objects. Finally the scenario of the application is represented as a set of scenario tuples that correspond to fundamental sets of actions originated by the same event (or events). 1. Introduction Multimedia applications can be very complex as regards the number of involved objects, transformations of the objects in the scope of an application and relationships among them. We regard a multimedia application as a container that includes scenes (<b>aggregations</b> of <b>objects</b> in a thematic domain) w [...] ...|$|R
40|$|In {{this paper}} we present how to extend object {{specification}} logic by defaults. Thus overridable rules {{may be used}} in specifications which deal not only with object states, but also with dynamic object behaviour like enabling / occurrence of actions and temporal evolution. Defaults are particularly useful to formalize implicit negation, the "minimal change" semantics of actions, inheritance between <b>object</b> classes and <b>aggregation</b> of <b>objects.</b> We demonstrate this by means of examples, and study which default patterns should be used for typical problems of behaviour specification. 1 Introduction In this paper, we consider the different uses defaults may have in specifications of system behaviour. Systems are viewed as societies of interacting objects. To this end, we define a first version of OSD, an object specification logic with defaults, and study typical examples. OSD is based on a temporal logic which allows to refer to the occurrence and enabling of actions in the style of OSL [SSC 9 [...] ...|$|R
40|$|We {{have used}} magnetic-field-induced {{birefringence}} {{as a new}} sensitive technique to probe the aggregation kinetics of macrocyclic molecules in solution. We have found three consecutive <b>aggregation</b> stages: disordered <b>objects,</b> ordered fibers, and a network. The transition from disordered objects to ordered fibers {{is found to be}} slow, taking days or weeks to complete. We attribute this to the molecular tails of the macrocycles, which hamper fiber formation. We anticipate that Linking aggregation kinetics to molecular properties wilt lead {{to a better understanding of}} the mechanisms by which molecules self-assemble, allowing for a more rational design of the molecular building blocks. status: publishe...|$|R
40|$|Abstract. Nowadays {{the natural}} {{requirement}} of users is {{to retrieve the}} best answers for the criteria they have. To explain, what kind of objects user prefers, we need to know, which values of properties are suitable for the user. We assume that each property is possibly provided by an external source. Current algorithms can effectively solve this requirement, when the sources have the same ordering as the user preferences. Commonly, two users prefer different values of a given property. In this paper we describe how we can consider this feature. Key words: multifeature querying, top-k <b>objects,</b> <b>aggregation,</b> fuzzy function...|$|R
