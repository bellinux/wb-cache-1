35|86|Public
5000|$|Once {{capabilities}} are exchanged and master/slave determination steps have completed, devices may then open [...] "logical channels" [...] or media flows. This {{is done by}} simply sending an Open Logical Channel (OLC) message and receiving an <b>acknowledgement</b> <b>message.</b> Upon receipt of the <b>acknowledgement</b> <b>message,</b> an endpoint may then transmit audio or video to the remote endpoint.|$|E
50|$|On request, the Message Service {{provides}} different delivery guarantees (e.g. <b>acknowledgement,</b> <b>message</b> persistency, etc.) {{on message}} queues and on unicast message queue groups.|$|E
5000|$|With the IMSI {{contained}} in the MAP PRN message, the VLR assigns a temporary number known as the mobile station roaming number (MSRN) to the roaming cell phone. This MSRN number is {{sent back to the}} HLR in a MAP RIA (Routing Information <b>Acknowledgement)</b> <b>message.</b>|$|E
5000|$|In this setup, the {{synchronize}} messages act {{as service}} requests from one server to the other, while the <b>acknowledgement</b> <b>messages</b> {{return to the}} requesting server to let it know the message was received.|$|R
30|$|As {{shown in}} {{previous}} sections, each node processes sequentially each received message. Some {{of them will}} be treated as <b>acknowledgement</b> <b>messages</b> and others as m-DKLS messages. Furthermore, these last packets can belong to the initialization step of the algorithm, to the training step or can be result messages.|$|R
3000|$|We {{found that}} {{unsuccessful}} query dissemination in most segments occur {{because of the}} NP <b>message</b> <b>acknowledgement</b> timeout. Because nodes are evenly placed to guarantee the connectivity, the NP <b>message</b> <b>acknowledgement</b> timeout is only caused by NP message collisions among query sessions. The number of NP <b>message</b> <b>acknowledgement</b> timeouts in Fig. 5 [...]...|$|R
50|$|AIMD {{requires}} a binary signal of congestion. Most frequently, packet loss {{serves as the}} signal; the multiplicative decrease is triggered when a timeout or <b>acknowledgement</b> <b>message</b> indicates a packet was lost. It is also possible for in-network mechanisms to mark congestion (without discarding packets) as in Explicit Congestion Notification (ECN).|$|E
50|$|The HLR {{performs}} a database lookup {{to retrieve the}} B-Party's current location, and returns it in an <b>acknowledgement</b> <b>message</b> to the SMSC's GMSC entity. The current location may be the MSC address the subscriber is currently roaming on, the SGSN address, or both. The HLR may also return a failure, if it considers the destination to be unavailable for short messaging; see the Failed Short Message delivery section below.|$|E
50|$|Release 3.0 was {{published}} in April 2009, and the first minor revision (labelled 3.0.1) was issued in January 2012. A second minor revision (3.0.2) {{was published}} in January 2014. The latest version is 3.0.3, released in May 2016. This release has not yet completely replaced 2.1, though implementation of 3.0 is becoming more widespread (particularly outside the English-language publishing markets). There is also an <b>Acknowledgement</b> <b>message</b> format (published 2015) which recipients of ONIX data files may send to confirm receipt of ONIX messages.|$|E
40|$|The {{contribution}} {{of this paper}} is twofold. First a distributed garbage collector (DGC) is presented that is optimized for remote method invocation in reliable networks, such as current clusters of workstations. Since the algorithm does not require extra <b>acknowledgement</b> <b>messages,</b> even while collecting, it does not increase the latency of a remote call...|$|R
50|$|QSL - Coded {{request for}} <b>acknowledgement</b> of <b>message</b> sent - usually teleprinter.|$|R
3000|$|Two {{messages}} in the protocol can initiate resource allocations within an InP: EMBED, and LINK. Thus, corresponding roll-back messages must {{exist in the}} protocol: EMBED_REJECT and LINK_REJECT. In order to simplify {{the implementation of a}} controller’s PolyViNE message handling system and avoid race conditions, associated <b>acknowledgement</b> <b>messages</b> EMBED_REJECT_ACK and LINK_REJECT_ACK act as barriers to ensure that roll-back occurs in the opposite order to allocation. Note that link allocations corresponding to the set [...]...|$|R
50|$|Synchronous {{communication}} can be {{built on}} top of asynchronous communication by using a Synchronizer.For example, the α-Synchronizer works by ensuring that the sender always waits for an <b>acknowledgement</b> <b>message</b> from the receiver.The sender only sends the next message after the acknowledgement has been received. On the other hand, asynchronous communication can also be built on top of synchronous communication. For example, modern microkernels generally only provide a synchronous messaging primitive and asynchronous messaging can be implemented on top by using helper threads.|$|E
50|$|TCP is a {{reliable}} stream delivery service which guarantees that all bytes received will be identical with bytes sent {{and in the}} correct order. Since packet transfer by many networks is not reliable, a technique known as 'positive acknowledgement with re-transmission' is used to guarantee reliability. This fundamental technique requires the receiver to respond with an <b>acknowledgement</b> <b>message</b> as it receives the data. The sender keeps a record of each packet it sends and maintains a timer from when the packet was sent. The sender re-transmits a packet if the timer expires before receiving the message acknowledgement. The timer is needed in case a packet gets lost or corrupted.|$|E
5000|$|On {{the receive}} side, the {{received}} TLP's LCRC and sequence number are both validated in the link layer. If either the LCRC check fails (indicating a data error), or the sequence-number {{is out of}} range (non-consecutive from the last valid received TLP), then the bad TLP, {{as well as any}} TLPs received after the bad TLP, are considered invalid and discarded. The receiver sends a negative <b>acknowledgement</b> <b>message</b> (NAK) with the sequence-number of the invalid TLP, requesting re-transmission of all TLPs forward of that sequence-number. If the received TLP passes the LCRC check and has the correct sequence number, it is treated as valid. The link receiver increments the sequence-number (which tracks the last received good TLP), and forwards the valid TLP to the receiver's transaction layer. An ACK message is sent to remote transmitter, indicating the TLP was successfully received (and by extension, all TLPs with past sequence-numbers.) ...|$|E
40|$|A {{snapshot}} protocol {{derived from}} the Lay-Yang colouring algorithm [2] is presented. The special feature of this protocol {{is the use of}} system <b>acknowledgement</b> <b>messages,</b> already generated by most communication libraries, to detect snapshot termination. Formal definitions, demonstrations, message complexity (which is O(n) where n is the number of processes) a swell as comparisons with other communication protocols are discussed in [1]. In the following we provide a short description of an implementation based on the PVM library...|$|R
3000|$|... ’s cache, {{which leads}} to the traffic {{offloading}} at MCS. Moreover, from CCN’s inherent security characteristics, the processing for location update can be done without additional security mechanisms. That is, in MIPv 6, binding update and binding <b>acknowledgement</b> <b>messages</b> must be protected by IP security using Encapsulating Security Payload (ESP) protection with a non-NULL payload authentication algorithm [14, 15] while the proposed scheme can do the validity check of the “PREG” message through the embedded signature.|$|R
30|$|After {{receiving}} the PBU message, the LMA updates the routing states and maintains binding caches and then replies with a proxy binding <b>acknowledgement</b> (PBA) <b>message</b> to the MAG.|$|R
30|$|In [9], {{the authors}} {{introduce}} a per-hop hybrid implicit/explicit acknowledgement scheme for stop and wait ARQ in a multi-hop acoustic channel. In this scheme, when a relay node receives a packet, it sends an <b>acknowledgement</b> <b>message</b> only when its previous data transmission has been already acknowledged. The acknowledgement can be implicit {{with the data}} packet itself or explicit with an <b>acknowledgement</b> <b>message.</b> Unfortunately, both mechanisms have a high time-out. They demonstrate that their protocol has a better latency and energy efficiency than the traditional schemes. However, the latency remains high and when the explicit acknowledgement is used, it increases the energy expenditure.|$|E
30|$|The server agent then {{broadcasts}} {{the route}} request message using destination ID, the registered adjacent nodes that are nearer to the destination node which {{are ready to}} provide the service replies with the <b>acknowledgement</b> <b>message</b> to the server agent.|$|E
30|$|If {{the message}} is not an acknowledgement, it must be saved into the {{circular}} buffer. Once saved, an <b>acknowledgement</b> <b>message</b> must be sent immediately to the sender of the message, so QueuedReceiverC puts an ACK message into the QSend interface.|$|E
5000|$|Automatic Repeat reQuest (ARQ), {{also known}} as Automatic Repeat Query, is an error-control method for data {{transmission}} that uses <b>acknowledgements</b> (<b>messages</b> sent by the receiver indicating that it has correctly received a data frame or packet) and timeouts (specified periods of time allowed to elapse before an acknowledgment is to be received) to achieve reliable data transmission over an unreliable service. If the sender does not receive an acknowledgment before the timeout, it usually re-transmits the frame/packet until the sender receives an acknowledgment or exceeds a predefined number of re-transmissions [...]|$|R
50|$|It {{may be used}} as a {{protocol}} for the delivery and <b>acknowledgement</b> of <b>message</b> units, or it {{may be used as}} {{a protocol}} for the delivery of subdivided message sub-units.|$|R
40|$|Abstract—In many {{wireless}} data systems, automatic repeat re-quest (ARQ) and hybrid automatic repeat request (HARQ) work independently. In this paper, we {{introduce a}} new ARQ feedback scheme called Cross-Layer ARQ (CL-ARQ), where ARQ closely interoperates with HARQ by making use of the acknowledgement of HARQ internally. By doing so, CL-ARQ not only removes the overhead for ARQ <b>acknowledgement</b> <b>messages,</b> but also improves the average delivery delay and TCP throughput. Especially, when the entities in charge of HARQ and ARQ are located far apart geographically, CL-ARQ remarkably outperforms the legacy scheme. Index Terms—Automatic repeat request (ARQ), Hybrid ARQ (HARQ), Cross-layer approach I...|$|R
30|$|In our protocol, each station selects {{the flow}} with the maximum backlog to serve. To {{calculate}} the backlog, each station maintains a matrix {{that includes the}} approximate queue length of its neighbors. When the station receives a packet or an <b>acknowledgement</b> <b>message,</b> the corresponding queue length value in the matrix is synchronized to the value included in the header.|$|E
3000|$|... max is {{the maximum}} delay {{time or the}} {{neighbor}} response timeout, d is distance to the current forwarding node, and R is the transmission range. Because a more distant neighbor has a shorter waiting time, it should return the <b>acknowledgement</b> <b>message</b> earlier and be selected as the next forwarding node. It will then receive the TC message from the current forwarding node.|$|E
30|$|Redundancy-based {{retransmission}} mechanism. According to {{the reliability}} theory, {{the number of}} transmissions for the sender transmitting a data packet can be calculated. It {{does not need to}} receive the <b>acknowledgement</b> <b>message</b> from the receiver any more. The advantage of this mechanism is that the delay is short, but the energy consumption is large and this affects the application of this mechanism in real life [1, 10, 12 – 14].|$|E
40|$|The {{contribution}} {{of this paper}} is twofold. First a distributed garbage collector (DGC) is presented that is optimized for remote method invocation in reliable networks, such as current clusters of workstations. Since the algorithm does not require extra <b>acknowledgement</b> <b>messages,</b> even while collecting, it does not increase the latency of a remote call. Then it is discussed how several DGCs can cooperate in networks that consist of different areas with respect to communication, i. e., of areas with different reliability properties. Proper placement and use of bridge objects allow to select an optimized DGC for every area...|$|R
50|$|A client thread {{sending a}} message is BLOCKED (the process thread {{execution}} is temporarily suspended) until the server thread sends a received <b>message</b> <b>acknowledgement,</b> processes the <b>message,</b> and executes a reply. When the server thread replies the client thread becomes READY (unblocked). The server thread typically loops, waiting to receive a message from a client thread.|$|R
30|$|If {{a packet}} {{transmission}} fails for some reason, retransmission of the packet will be attempted until successful transmission takes place, i.e. packets {{will not be}} discarded in any case. For the analysis, we divide the operation into multiple discrete time slots and assume fixed packet sizes along with perfect time synchronization among the nodes. The length of a time slot τ is defined to correspond to the maximum propagation delay of resource request and <b>acknowledgement</b> <b>messages.</b> Channel sensing time {{is equal to the}} maximum propagation delay as well and we neglect channel switching penalty for the sake of simplicity. We only consider slotted systems with an infinite number of users.|$|R
30|$|If the {{required}} resources are available, which is checked by the admission control procedure {{in the target}} eNB, a handover request <b>acknowledgement</b> <b>message</b> {{is sent to the}} source eNB. The source eNB then sends a handover command to the RN (RRC connection reconfiguration including mobility control information), and from then on, the data destined to the RN is forwarded to the target eNB until the handover process is finalized.|$|E
3000|$|... -locators. As {{soon as the}} locator {{receives}} the Loc_req message from the sensor, it replies with an <b>acknowledgement</b> <b>message</b> Loc_ack similar to the beacon message, which includes the ID and location information of the locator. The Loc_ack message also includes above two status bits. When the sensor {{receives the}} Loc_ack message, it can measure {{the distance from the}} sending locator to itself using the RSSI. The sensor also calculates the response time of each [...]...|$|E
30|$|The {{steps for}} the next {{forwarding}} node selection are given in Algorithm 2 below. The current forwarding node includes the set of target road segments E_T and the set of corresponding flag variable F to indicate segments with traffic information already collected. The number of retries before giving up is set to 6. Only the first NP <b>acknowledgement</b> <b>message</b> from each different segment will trigger the TC message transmission, so does acknowledgements coming from nodes to which TC messages have already been sent.|$|E
5000|$|In December 2011, {{researcher}} Stefan Viehböck {{reported a}} {{design and implementation}} flaw that makes brute-force attacks against PIN-based WPS feasible to be performed on WPS-enabled Wi-Fi networks. A successful attack on WPS allows unauthorized parties {{to gain access to}} the network, and the only effective workaround is to disable WPS. [...] The vulnerability centers around the <b>acknowledgement</b> <b>messages</b> sent between the registrar and enrollee when attempting to validate a PIN, which is an eight-digit number used to add new WPA enrollees to the network. Since the last digit is a checksum of the previous digits, there are seven unknown digits in each PIN, yielding 107 = 10,000,000 possible combinations.|$|R
30|$|When the {{backoff period}} is passed, the station pops a packet from the flow queue and {{immediately}} starts transmitting. The {{distance between the}} current station and the destination station and the current queue length of the flow are both stored in the header. Then, the station waits for <b>acknowledgement</b> <b>messages</b> from its neighbors. Different from the default 802.11 MAC algorithm, we reserve multiple time slots for ACK exchanges in our protocol. In the ith slot, the recipient with the ith smallest queue length sends the ACK. This order can be calculated from the queue length matrix stored at each station. In the case where multiple stations have the same queue length, the stations send their ACKs {{in the order of}} their station IDs.|$|R
30|$|Upon {{receiving}} the PBA by the HMAG 1, a binding update list (BUL) table is created {{in order to}} register the MN 1. Afterwards, the HMAG 1 sends a local proxy binding <b>acknowledgement</b> (LPBA) <b>message</b> to the MAG 1 which provides the prefix address of the MN 1.|$|R
