7|33|Public
50|$|In Windows, an <b>asynchronous</b> <b>procedure</b> call (abbreviated APC) is a {{function}} that executes asynchronously {{in the context of}} a specific thread. APCs can be generated by the system (kernel-mode APCs) or by an application (user mode APCs).|$|E
50|$|A common way {{for dealing}} with {{asynchrony}} in a programming interface is to provide subroutines (methods, functions) that return to their caller an object, sometimes called a future or promise, that represents the ongoing events. Such an object will then typically come with a synchronizing operation that blocks until the operation is completed. Some programming languages, such as Cilk, have special syntax for expressing an <b>asynchronous</b> <b>procedure</b> call.|$|E
40|$|Asynchronous {{programming}} {{has become}} ubiquitous in smartphone and web application development, {{as well as}} in the development of server-side and system applications. Many of the uses of asynchrony can be modeled by extending programming languages with <b>asynchronous</b> <b>procedure</b> calls - procedures not executed immediately, but stored and selected for execution at a later point by a non-deterministic scheduler. Asynchronous calls induce a flow of control that is difficult to reason about, which in turn makes formal verification of asynchronous programs challenging. In response, we take a rely/guarantee approach: Each <b>asynchronous</b> <b>procedure</b> is verified separately with respect to its rely and guarantee predicates; the correctness of the whole program then follows from the natural conditions the rely/guarantee predicates have to satisfy. In this way, the verification of asynchronous programs is modularly decomposed into the more usual verification of sequential programs with synchronous calls. For the sequential program verification we use Hoare-style deductive reasoning, which we demonstrate on several simplified examples. These examples were inspired from programs written in C using the popular Libevent library; they are manually annotated and verified within the state-of-the-art Frama-C platform...|$|E
50|$|GWT {{emphasizes}} reusable {{approaches to}} common web development tasks, namely <b>asynchronous</b> remote <b>procedure</b> calls, history management, bookmarking, UI abstraction, internationalization, and cross-browser portability.|$|R
40|$|Numerical {{simulations}} of unsteady flows past a flexible structure require the simultaneous solution of structural dynamics and of fluid dynamics on deformable dynamic meshes. We present here an evaluation method of staggered partitioned procedures for time-integrating these focus coupled problems. This method {{is based on}} an estimation of the energy that is numerically created at the fluid/structure interface because of staggering. Simplifying assumptions make this estimation easy for a wide family of mixed explicit/implicit or implicit/implicit, synchronous or <b>asynchronous</b> <b>procedures.</b> Insights gained from this evaluation method are confirmed with the analysis of numerical results for the flutter of a flat panel in supersonic airstreams in two and three dimensions and for the transient aeroelastic response of an AGARD 445. 6 wing in the transonic regime...|$|R
40|$|In {{the last}} years, the AI {{community}} has shown an increasing interest in distributed problem solving. In {{the scope of}} distributed constraint reasoning, several <b>asynchronous</b> backtracking <b>procedures</b> have been proposed for finding solutions in a constraint network distributed among several computers. They differ {{in the way they}} store failing combinations of values (nogoods), and in the way they check the possible obsolescence of these nogoods. In this paper...|$|R
40|$|In {{this paper}} a novel {{computation}} model based on fine-grained objects and <b>asynchronous</b> <b>procedure</b> invocation is presented. Based {{on a set}} of only a few basic definitions {{it can be used to}} write well structured programs as well as exploit a large degree of potential parallelism. Yet the model is strong enough to express complicated subjects such as active objects and coordination patterns. By incorporating controlflow as one of its basic mechanisms it offers an abstraction well-known in sequential programming and is best suited to express iterative algorithmic primitives. The uniform semantics of object interaction by asynchronous reference-returning procedure calls leads to a dataflow-oriented programming style even outside the field of functional programming...|$|E
40|$|We {{describe}} pipes, a new linguistic {{mechanism for}} sequences of ordered <b>asynchronous</b> <b>procedure</b> calls in multiprocessor systems. Pipes allow {{a sequence of}} remote invocations to be performed in order, but asynchronously {{with respect to the}} calling thread. Using pipes results in programs that are easier to understand and debug than those with explicit synchronization between asynchronous invocations. The semantics of pipes make no assumptions about the underlying architecture, which enhances code portability. However, the implementation of pipes by the language compiler can be optimized so as to take advantage of any underlying message ordering a particular architecture may provide. Pipes also provide application-transparent flow control for asynchronous invocations and are able to throttle invocations from multiple calling threads. We present four implementations of pipes and show that the performance and space overheads associated with pipes are low. Keywords: linguistic mechanism, ord [...] ...|$|E
40|$|The present work {{deals with}} an {{optimization}} procedure {{developed in the}} full-f global GYrokinetic SEmi-LAgrangian code (GYSELA). Optimizing {{the writing of the}} restart files is necessary to reduce the computing impact of crashes. These files require a very large memory space, and particularly so for very large mesh sizes. The limited bandwidth of the data pipe between the comput- ing nodes and the storage system induces a non-scalable part in the GYSELA code, which increases with the mesh size. Indeed the transfer time of RAM to data depends linearly on the files size. The necessity of non synchronized writing-in-file procedure is therefore crucial. A new GYSELA module has been developed. This <b>asynchronous</b> <b>procedure</b> allows the frequent writ- ing of the restart files, whilst preventing a severe slowing down due to the limited writing bandwidth. This method has been improved to generate a checksum control of the restart files, and automatically rerun the code in case of a crash for any cause...|$|E
40|$|Abstract Motivated by an {{important}} problem of load balancing in parallel computing, this paper examines a modified algorithm to enhance Q-learning methods, especially in <b>asynchronous</b> recursive <b>procedures</b> for self-adaptive load distribution at runtime. Unlike the existing projection method that utilizes a fixed region, our algorithm employs {{a sequence of}} growing truncation bounds to ensure the boundedness of the iterates. Convergence and rates of convergence of the proposed algorithm are established. This class of algorithms has broad applications in signal processing, learning, financial engineering, and other related fields...|$|R
50|$|The Google Web Toolkit (GWT) is an {{open source}} toolkit {{allowing}} developers to create Ajax applications in the Java programming language. GWT supports rapid client-server development and debugging in any Java IDE. In a subsequent deployment step, the GWT compiler translates a working Java application into equivalent JavaScript that programmatically manipulates a web browser's HTML DOM using DHTML techniques. GWT emphasizes reusable, efficient solutions to recurring Ajax challenges, namely <b>asynchronous</b> remote <b>procedure</b> calls, history management, bookmarking, and cross-browser portability. It is released under the Apache License version 2.0.|$|R
40|$|The most {{important}} goal in hard real-time systems is {{to guarantee that}} all timing constraints are satisfied. Even though object-based techniques (which contain reusable software components) are used to manage the complexity in the software development process of such systems, execution efficiency {{may have to be}} sacrificed, due to the large number of procedure calls and contention for accessing software components. These issues are addressed by the following parallelizing techniques: (a) converting potentially inefficient procedure calls to a source of concurrency via <b>asynchronous</b> remote <b>procedure</b> calls (ARPC) (b) replicating (or cloning) software components to reduce the contention...|$|R
40|$|With the {{availability}} of multiple unlicensed spectral bands, and potential cost-based limitations on the capabilities of individual nodes, it is increasingly relevant to study the performance of multichannel wireless networks with channel switching constraints. To this effect, some constraint models have been recently proposed, and connectivity and capacity results have been formulated for networks of randomly deployed single-interface nodes subject to these constraints. One of these constraint models is termed random (c, f) assignment, wherein each node is pre-assigned a random subset of f channels out of c (each having bandwidth W c), and may only switch on these. Previous results for this model established bounds on network capacity, and proved that when c = O(logn), the per-prnd f flow capacity is O(W nlogn) and Ω(W cnlogn) (where prnd = 1 −(1 − f f f f 2 c) (1 − c− 1) [...] . (1 − c − f+ 1) ≥ 1 − e − c). In this paper we present a lower bound construction that matches the previous upper prnd bound. This establishes the capacity as Θ(W nlogn). The surprising implication of this result is that when f = Ω (√ c), random (c, f) assignment yields capacity of the same order as attainable via unconstrained switching. The routing/scheduling procedure used by us to achieve capacity requires synchronized route-construction for all flows in the network, leading to the open {{question of whether it}} is possible to achieve capacity using <b>asynchronous</b> <b>procedures...</b>|$|R
40|$|Mathematical {{modelling}} fluvial flow, {{sediment transport}} and morphological evolution started {{half a century}} ago and, to date, a variety of mathematical models have been developed and are in widespread use. However, the quality of mathematical river modelling remains uncertain because of: (a) poor assumptions in model formulations; (b) simplified numerical solution procedure; (c) the implementation of sediment relationships of questionable validity; and (d) the problematic use of model calibration and verification as assertions of model veracity. An overview of mathematical models for alluvial rivers is provided in this and the companion paper ‘Part 2 : Special issues’. This paper is the first part, providing a general review of mathematical river models. The issues addressed comprise what have been obvious since the very beginning of mathematical river modelling and are still open, and also the pertinent components that pose challenges to model developers and end-users pursuing refined modelling practice. In particular the simplified mass conservation equations, <b>asynchronous</b> solution <b>procedures,</b> sediment transport functions, movable-bed resistance, numerical difficulty for strong hyperbolic equations, and representation of movable and complex geometry are discussed. A test example is provided to demonstrate the impacts of simplified mass conservation equations and an <b>asynchronous</b> solution <b>procedure</b> in comparison with those of largely tuned friction factors. It is concluded that mathematical models for fluvial flow–sediment–morphology systems are far from being mature, and that considerable expertise, physical insight and experience are vital for meaningful solutions to be acquired and for the limitations of modelling outputs to be properly identified, interpreted and assessed...|$|R
40|$|This paper {{illustrates}} {{that several of}} the new features specified in the revised Ada standard facilitate programming real-time distributed/parallel applications. In particular; the Ada Distributed Systems Annex supports both statically bound and the more object-oriented dynamically bound remote procedure calls. These features are used to implement a paradigm for composing <b>asynchronous</b> remote <b>procedure</b> calls when both input and output parameters are required. The paradigm is based upon the notion of a distributed object through which the output parameters may be returned without blocking the execution of the callel: Such paradigms, when combined with the enhanced features for concurrency and data synchronization, suggest that Ada will contribute towards understanding some of the issues relevant to developing efficient implementations of distributed objects to support the next generation of real-time systems...|$|R
40|$|Two {{types of}} invincible {{clusters}} of cooperators are {{defined in the}} one-dimensional evolutionary Prisoner's Dilemma game. These invincible clusters can either be peaceful or aggressive. The survival of these invincible clusters is discussed {{in the context of}} the repeated Prisoner's Dilemma game with imitation and <b>asynchronous</b> updating <b>procedure.</b> The decay rates for these two types of clusters are analyzed numerically, for all enumeration of the configuration for small chain size. We find characteristic difference in the decay patterns of these two types of invincible clusters. The peaceful invincible clusters experience monotonic exponential decay, while the aggressive ones shows an interesting minimum in the density of cooperators before going through a slow exponential decay at long time. A heuristic argument for the existence of the minima is provided. © Springer-Verlag Berlin Heidelberg 2009...|$|R
40|$|In {{this paper}} we study a simple {{deterministic}} tree structure: an initial individual generates {{a finite number}} of offspring, each of which has given integer valued lifetime, iterating the same procedure when dying. Three asymptotic distributions of this <b>asynchronous</b> deterministic branching <b>procedure</b> are considered: the generation distribution, the ability of individuals to generate offspring and the age distribution. Thermodynamic formalism is then developped to reveal the multifractal nature of the mass splitting associated to our process...|$|R
40|$|Marionette is {{a system}} for {{distributed}} parallel programming {{in an environment of}} networked heterogeneous computer systems. It is based on a master/slave model. The master process can invoke worker operations (<b>asynchronous</b> remote <b>procedure</b> calls to single slaves) and context operations (updates to the state of all slaves). The master and slaves also interact through shared data structures that can be modified only by the master. The master and slave processes are pro-grammed in a sequential language. The Marionette runtime system manages slave process creation, propagates shared data structures to slaves as needed, queues and dispatches worker and context operations, and manages recovery from slave processor failures. The Marionette system also includes tools for automated compila-tion of program binaries for multiple architectures, and for distributing binaries to remote file sys-tems. A UNIX-based implementation of Marionette is described...|$|R
40|$|In {{this paper}} {{we present a}} {{distributed}} environment {{that allows us to}} integrate volume reduction techniques using irregular meshes and implicit adaptive rendering methods. Different parts of the system are distributed on up to five workstations. A flexible tool for explorative and adaptive visualization of three dimensional scalar fields is provided. The system combines grid generators and visualization components. The grid generators create an adaptively refined tetrahedral mesh and the visualization components make use of the implicit adaptivity information given by the size of each tetrahedron. The parallelization has been done using <b>asynchronous</b> remote <b>procedure</b> calls. A client process, that handles the graphical interface is communicating the tasks to the four clients, which do the main computation. The client program itself just contains the Motif /Inventor user interface and some routines for storing and retrieving data. 1 Introduction Volume visualization techniques such as is [...] ...|$|R
40|$|We {{show that}} asymptotically, {{completely}} <b>asynchronous</b> stochastic gradient <b>procedures</b> achieve optimal (even to constant factors) convergence {{rates for the}} solution of convex optimization problems under nearly the same conditions required for asymptotic optimality of standard stochastic gradient procedures. Roughly, the noise inherent to the stochastic approximation scheme dominates any noise from asynchrony. We also give empirical evidence demonstrating the strong performance of asynchronous, parallel stochastic optimization schemes, demonstrating that the robustness inherent to stochastic approximation problems allows substantially faster parallel and asynchronous solution methods. Comment: 38 pages, 8 figure...|$|R
40|$|We {{present a}} {{programming}} model which offers ease of parallel application programming for both shared variables and distributed programming. The model is more abstract than distributed models such as PVM, MPI and Split C and shared models such as thread packages or the ANL Parmacs. It improves {{on the property}} of memory-modelindependence of other models such as CC++ and Nexus and offers a remarkable amount of ease of use. ffl The process model - a work pool - is akin to CORBA {{in that it is}} defined in terms of abstract work pieces (services, tasks) rather than processes or threads. Semantically, this corresponds to <b>asynchronous</b> remote <b>procedure</b> calls. ffl The data model features global data which allows memory-model-independence as well. The coordination of accesses to global data is possible by so-called coordinators. Coordinators enable the declarative specification of access patterns to global data thus allowing automatic coordination. The overall model allows considering [...] ...|$|R
40|$|This paper {{investigates the}} {{possible}} role of neuroanatomical features in Pavlovian conditioning, via computer simulations with layered, feedforward artificial neural networks. The networks' structure and functioning are {{described by a}} strongly bottom-up model {{that takes into account}} the roles of hippocampal and dopaminergic systems in conditioning. Neuroanatomical features were simulated as generic structural or architectural features of neural networks. We focused on the number of units per hidden layer and connectivity. The effect of the number of units per hidden layer was investigated through simulations of resistance to extinction in fully connected networks. Large networks were more resistant to extinction than small networks, a stochastic effect of the <b>asynchronous</b> random <b>procedure</b> used in the simulator to update activations and weights. These networks did not simulate second-order conditioning because weight competition prevented conditioning to a stimulus after conditioning to another. Partially connected networks simulated second-order conditioning and devaluation of the second-order stimulus after extinction of a similar first-order stimulus. Similar stimuli were simulated as nonorthogonal input-vectors...|$|R
40|$|Direct {{memory access}} (DMA) is {{commonly}} used to perform data movement between peripheral devices and main memory independently of the processor. This thesis describes {{how to use a}} system-wide DMA engine, such as the one found in the OMAP system-on-chip platform, to perform memoryto-memory transfers. A driver for this DMA engine is implemented for the Barrelfish operating system, a research operating system developed at ETH Zurich. The driver relies on Barrelfish’s asynchronous message passing system for inter-process communication, as well as the capability system Barrelfish uses for memory management. The capability system allows user space applications to refer to physical memory regions in a secure and sound way, while the <b>asynchronous</b> remote <b>procedure</b> call interface of the driver allows applications to perform computations in parallel with the memory transfer which was offloaded to the device. As part of the evaluation, the raw performance of the hardware device is measured, as well as the overhead introduced by the software driver managing the device. The DMA engine is used in...|$|R
40|$|Asynchronously {{communicating}} pushdown systems (ACPS) that {{satisfy the}} empty-stack constraint (a pushdown process may receive only when its stack is empty) are a popular decidable model for recursive programs with <b>asynchronous</b> atomic <b>procedure</b> calls. We study a relaxation of the empty-stack constraint for ACPS that permits concurrency and communication actions at any stack height, called the shaped stack constraint, thus enabling a larger class of concurrent programs to be modelled. We establish a close connection between ACPS with shaped stacks and a novel extension of Petri nets: Nets with Nested Coloured Tokens (NNCTs). Tokens in NNCTs are of two types: simple and complex. Complex tokens carry an arbitrary number of coloured tokens. The rules of NNCT can synchronise complex and simple tokens, inject coloured tokens into a complex token, and eject all tokens of a specified set of colours to predefined places. We {{show that the}} coverability problem for NNCTs is Tower-complete. To our knowledge, NNCT is the first extension of Petri nets, {{in the class of}} nets with an infinite set of token types, that has primitive recursive coverability. This result implies Tower-completeness of coverability for ACPS with shaped stacks...|$|R
40|$|The {{issue of}} {{transport}} {{capacity of a}} randomly deployed wireless network under random (c, f) channel assignment was considered by us in [1]. We showed in [1] that {{when the number of}} available channels � is c = O(logn), and each f prnd node has a single interface assigned a random f subset of channels, the capacity is Ω(W cnlogn) and O(W nlogn), prnd and conjectured that capacity is Θ(W nlogn). We now present a lower bound construction that yields capacity prnd nlogn Ω(W) for all c = O(logn) and 2 ≤ f ≤ c. This establishes the capacity under random (c, f) assignment as prnd Θ(W nlogn). The surprising implication of this result is that when f = Ω(√c), random (c, f) assignment yields capacity of the same order as attainable via unconstrained switching. Also of interest is the routing/scheduling procedure we utilize to achieve capacity, which � marks a significant point of departure from the construction used to f obtain the previous lower bound of Ω(W cnlogn). This procedure requires synchronized route-construction for all flows in the network, leading to the open question of whether it is possible to achieve capacity using <b>asynchronous</b> routing/scheduling <b>procedures.</b> I...|$|R
40|$|Abstract — The SmartCam project investigates new {{opportunities}} {{provided by the}} integration of sensing and processing in a single surveillance-camera sized device. More specifically, it will provide tooling to find an applicationdependent mixture of single-instruction multiple-data (SIMD) and instruction-level parallel (ILP) processors using design space exploration. This will allow developers in fields such as robotics, surveillance, and industrial inspection to adapt the hardware to their application, instead of the other way around. Since {{a wide variety of}} hardware configurations are possible, and since it is undesirable to rewrite the program for every one, we have proposed the use of algorithmic skeletons [4] to express data parallelism. An efficient heterogeneous system requires the exploitation of task parallelism as well, though, and we have opted for a more conventional presentation to make the transition to our system easier. This paper describes our <b>asynchronous</b> remote <b>procedure</b> call (RPC) system, optimized for low-memory and sparsely connected systems such as smart cameras. It uses a futures[13]-like model to present a normal imperative C-interface to the user in which the skeleton calls are implicitly parallelized and pipelined. Simulation provides the dependency graph and performance numbers for the mapping, which can be done at run time to facilitate dependent branching...|$|R
40|$|Abstract- We {{show that}} {{existing}} synthesis techniques may produce asynchronous circuits {{that are not}} initializable by gate-level analysis tools even when the design is functionally initial-izable. Due {{to the absence of}} any initialization sequence, a fault simulator or test generator that assumes an unknown starting state will be completely ineffective for these circuits. In this paper, we show that proper consideration of initializability during the <b>asynchronous</b> circuit synthesis <b>procedure</b> can guarantee initial-izable implementations. We show that the assignment of don’t cares during the synthesis procedure affects the initializability of the final implementation. We present a novel implicit enumer-ation procedure that selectively assigns don’t cares to obtain an initializable implementation. Initialization sequences are obtained as a by-product of our synthesis procedure. Zndex Terms-Asynchronous synthesis, signal transition graph, initialization, don’t care assignment. I...|$|R
40|$|So far, {{the problem}} of unmixing large or multitemporal hyperspectral dataset has been {{specifically}} addressed in the remote sensing literature only by a few dedicated strategies. Among them, some {{attempts have been made}} within a distributed estimation framework, in particular relying on the alternating direction method of multipliers (ADMM). In this paper, we propose to study the interest of a partially <b>asynchronous</b> distributed unmixing <b>procedure</b> based on a recently proposed asynchronous algorithm. Under standard assumptions, the proposed algorithm inherits its convergence properties from recent contributions in non-convex optimization, while allowing {{the problem of}} interest to be efficiently addressed. Comparisons with a distributed synchronous counterpart of the proposed unmixing procedure allow its interest to be assessed on synthetic and real data. Besides, thanks to its genericity and flexibility, the procedure investigated in this work can be implemented to address various matrix factorization problems...|$|R
40|$|In {{this paper}} I present a data-intensive econometric {{smoothing}} method capable of fully exploiting the information content of intra-day option quotes. This {{is shown to}} be useful for both traditional option pricing applications as well as risk management. My method yields full sets of smoothed option prices with corresponding deltas and gammas for any "target time" of the day, while successfully addressing many common data problems, such as discontinuities in trading, the discreteness of option quotes and <b>asynchronous</b> trading. The <b>procedures</b> I outline here can be applied either in a real time setting or {{at the end of}} a trading day, so as to identify pricing errors or to estimate deltas and gammas for hedging purposes. In the process of smoothing the data, I also obtain reliable data-intensive estimates of the risk neutral density of the underlying asset at expiration. For the case of S&P 500 index options, these risk neutral density estimates are demonstrated to be superior to estimate [...] ...|$|R
40|$|The most {{important}} goal in hard real-time systems is {{to guarantee that}} all timing constraints are satisfied. Even though object-based techniques (which contain reusable software components) are used to manage the complexity in the software development process of such systems, execution efficiency {{may have to be}} sacrificed, due to the large number of procedure calls and contention for accessing software components. These issues are addressed by the following parallelizing techniques: (a) converting potentially inefficient procedure calls to a source of concurrency via <b>asynchronous</b> remote <b>procedure</b> calls (ARPC) (b) replicating (or cloning) software components to reduce the contention. The existing object-based scheduling algorithms construct an initial schedule and apply incremental parallelization techniques to modify the initial schedule till a feasible schedule is generated. But these algorithms are applicable for scheduling only multiple independent tasks. This paper describes a pre-run-time scheduling algorithm for a set of periodic object-based tasks having precedence constraints among them. The algorithm employs parallelism exploitation techniques to guarantee timeliness in almost fully predictable environments such as factory automation, aerospace, and avionics. It allocates the components of object-based periodic tasks to the sites of a distributed system based on a clustering heuristic which takes into account the ARPC parallelism and load balancing, and schedules them on respective sites. The algorithm also finds a schedule for communication channel(s) and clones the components of object-based periodic tasks, if contention occurs in accessing them. In addition to the above (periodicity and precedence) constraints, the tasks handled by our algorithm can have res [...] ...|$|R
40|$|Object-oriented {{programming}} {{is a widely}} adopted paradigm for desktop software development. This paradigm partitions software into separate entities, objects, which consist of data and related procedures used to modify and inspect it. The paradigm has evolved {{during the last few}} decades to emphasize decoupling between object implementations, via means such as explicit interface inheritance and event-based implicit invocation. Inter-process communication (IPC) technologies allow applications to interact with each other. This enables making software distributed across multiple processes, resulting in a modular architecture with benefits in resource sharing, robustness, code reuse and security. The support for object-oriented programming concepts varies between IPC systems. This thesis is focused on the D-Bus system, which has recently gained a lot of users, but is still scantily researched. D-Bus has support for <b>asynchronous</b> remote <b>procedure</b> calls with return values and a content-based publish/subscribe event delivery mechanism. In this thesis, several patterns for method invocation in D-Bus and similar systems are compared. The patterns that simulate synchronous local calls are shown to be dangerous. Later, we present a state-caching proxy construct, which avoids the complexity of properly asynchronous calls for object inspection. The proxy and certain supplementary constructs are presented conceptually as generic object-oriented design patterns. The e ect of these patterns on non-functional qualities of software, such as complexity, performance and power consumption, is reasoned about based on the properties of the D-Bus system. The use of the patterns reduces complexity, but maintains the other qualities at a good level. Finally, we present currently existing means of specifying D-Bus object interfaces for the purposes of code and documentation generation. The interface description language used by the Telepathy modular IM/VoIP framework is found to be an useful extension of the basic D-Bus introspection format...|$|R
40|$|In Wireless Sensor Networks (WSN), {{sensor node}} {{deployment}} {{is essential for}} maximizing the coverage and detection probabilities. But the existing optimization solution suffers from limited energy storage, node death, increased network traffic etc. To solve these issues, we propose a fuzzy based optimization model for power management in wireless sensor networks. The objectives considered in the paper include maximizing network coverage, connectivity, network lifetime and minimizing traffic load. A fuzzy rules table is constructed with the input parameters such as node degree, link quality, residual energy and traffic rate. Depending upon {{the outcome of the}} fuzzy logic, the nodes are categorized into good, normal and bad. After the initial deployment of good nodes, the SLEEP and WAKEUP Procedure is applied to maximize the lifetime of wireless sensor networks. By putting nodes to sleep when there are no events, the energy consumption of the sensor nodes can be significantly reduced. In SLEEP and WAKEUP <b>Procedure,</b> <b>asynchronous</b> type is used; it allows each node in the wireless sensor network to set its own SLEEP and WAKEUP schedule independently in order to save energy. Simulation result shows that the proposed Procedure provides maximization of the lifetime of Wireless Sensor Network (WSN). 1...|$|R
40|$|The {{success of}} the World Wide Web (W 3) {{in recent years has}} contributed {{significantly}} {{to the role of the}} Internet as a platform for developing CSCW systems. Today, a large number of applications are available for supporting cooperative tasks across an organization. Most of these systems have a centralized architecture, by virtue of which the entire application becomes unavailable when the central system crashes. Accessing the central system via remote networks can also lead to long response times. This study presents a new <b>asynchronous</b> replication <b>procedure</b> designed specially for use in the Internet, which goes a long way towards eliminating these problems. This procedure enables the replication mechanism to include computer systems located behind a firewall and nodes that are sometimes inaccessible due to network unavailability. The procedure is thus particularly useful in linking mobile systems (laptops, PDAs). A high level of autonomy is retained for the individual nodes without the use of strict locking procedures. The replication algorithm is based on a vector time model used to retain the causal sequence of transmission and reception events in a distributed system. The specification is effected formally using Colored Petri Nets. Based on a case study, the dissertation examines the extent to which it is advisable to avoid strict locking procedures in a W 3 -based cooperation application. This involves evaluating the database of a cooperation application which was used from the Internet by over 5000 users over a survey period of approximately 2 years. The result of the observation was that concurrent write accesses to the shared documents was not common, so that it seems advisable to use replication procedures that do not use strict locking procedures. The study also demonstrates that the use of object-oriented or structured document architectures can reduce the probability of incidental access to shared documents. In conclusion, the dissertation moves away from the case study to discuss the use of the replication procedure described in other fields (electronic commerce, distributed web site management) ...|$|R
40|$|A {{new method}} of {{designing}} collaborative multimedia environments for computer assisted problem solving is described. These environments support computer mediated interaction between multiple physically separated users {{joined by a}} communication network. Users interact using application specific models and objects, text, audio, video and graphics. Computer mediation enables both synchronous and asynchronous interaction, empowering users to transcend barriers of space and time. ^ Proliferation of high performance multimedia workstations and high speed and capacity networks provides us with the mechansim to realize real-time multi-user tools for computer-supported cooperative work. However, development and deployment of groupware, and consequent popular adoption, has been impeded {{by the absence of}} general models and enabling infrastructures. This thesis is a step towards developing formalisms for designing and implementing collaborative systems and groupware. ^ Requirements for the infrastructure from the developer 2 ̆ 7 s and the user 2 ̆ 7 s perspectives are identified and previous work is surveyed to highlight lessons learned, and to isolate desired features that are lacking. Application models that are amenable to distributed and collaborative operation on heterogeneous platforms are then developed. In these models, software tools consist of contexts that are characterized by a state that is modified by events and {{can be thought of as}} event driven distributed data flow machines. These models are used to build an enabling infrastructure for rapid prototyping of real-time groupware. Mechanisms for routing events to different states and contexts are provided, as are mechanisms for distribution functionality like synchronous and <b>asynchronous</b> remote <b>procedure</b> calling, and collaboration functionality like session control, interaction control, and high level access regulation. Identified shortcomings of extant work are overcome and mechanisms to implement policies derived from related research efforts are provided. The solution is justified from the technical and human factors viewpoints. ^ In this dissertation, the models and the infrastructure are described. Details of an implemented collaborative multimedia environment are presented, demonstrating the viability of the infrastructure. Possible applications of this technology are identified, and the facilitation of groupware prototyping by the model and infrastructure is described. Open issues and possible research directions are identified. ...|$|R
40|$|Many {{datasets}} can {{be thought}} of as expressing a collection of underlying traits with unknown cardinality. Moreover, these datasets are often persistently growing, and we expect the number of expressed traits to likewise increase over time. Priors from Bayesian nonparametrics are well-suited to this modeling challenge: they generate a countably infinite number of underlying traits, which allows the number of expressed traits to both be random and to grow with the dataset size. We also require corresponding streaming, distributed inference algorithms that handle persistently growing datasets without slowing down over time. However, a key ingredient in streaming, distributed inference-an explicit representation of the latent variables used to statistically decouple the data-is not available for nonparametric priors, as we cannot simulate or store infinitely many random variables in practice. One approach is to approximate the nonparametric prior by developing a sequential representation-such that the traits are generated by a sequence of finite-dimensional distributions-and subsequently truncating it at some finite level, thus allowing explicit representation. However, truncated sequential representations have been developed only for a small number of priors in Bayesian nonparametrics, and the order they impose on the traits creates identifiability issues in the streaming, distributed setting. This thesis provides a comprehensive theoretical treatment of sequential representations and truncation in Bayesian nonparametrics. It details three sequential representations of a large class of nonparametric priors, and analyzes their truncation error and computational complexity. The results generalize and improve upon those existing in the literature. Next, the truncated explicit representations are used to develop the first streaming, distributed, <b>asynchronous</b> inference <b>procedures</b> for models from Bayesian nonparametrics. The combinatorial issues associated with trait identifiability in such models are resolved via a novel matching optimization. The resulting algorithms are fast, learning rate-free, and truncation-free. Taken together, these contributions provide the practitioner with the means to (1) develop multiple finite approximations for a given nonparametric prior; (2) determine which is the best for their application; and (3) use that approximation in the development of efficient streaming, distributed, asynchronous inference algorithms. by Trevor David Jan Campbell. Thesis: Ph. D., Massachusetts Institute of Technology, Department of Aeronautics and Astronautics, 2016. Cataloged from PDF version of thesis. Includes bibliographical references (pages 167 - 175) ...|$|R
40|$|This paper {{focuses on}} the further {{development}} of the asynchronous method to simulate timetable compilation and railway operation. The newly developed simulation strategy {{and the use of}} appropriate basic components introduced in the field of timetable compilation lead to a train priorities respecting simulation procedure {{that can be used for}} various stages of the railway planning process. The use of existing basic components enables the procedure to employ infrastructure and timetable data from all over the German network already available. The new <b>asynchronous</b> simulation <b>procedure</b> provides improved solutions for classic questions of railway operation science, such as the calculation of infrastructure capacity or the validation of new timetables and operational concepts. It delivers better results because conflicts between train movements are resolved in a more sophisticated way, particularly on single track lines and in complex networks. This is achieved through automatic choice of alternative train-paths, section-wise resolution of conflicts, and the adaptive calculation of different conflict resolution alternatives where the choice is made with the help of target functions. The paper contains an overview on existing railway operation science models and on timetable compilation methods. The algorithmic complexity of automatic timetable compilation is discussed and corresponding mathematical approaches are analysed. It is demonstrated that, due to the combinatorial variety of possible train sequences and train-path alternatives, mathematical approaches require simplified mathematical modelling structures. However, these simplified modelling structures do not contrib-ute to solve the everyday problems of timetable compilation. Whereas the new procedure is based on concepts similar to the basic ideas of the existing support tool for timetable compilation - namely the idea of occupation times for block sections and the specific consideration of conflicts between train movements - and enables new applications in this area by introducing improved strategies of conflict resolution. As a result, the efficiency of IT supported timetable compilation can be improved as the new method creates various conflict resolution alternatives, searches the existing timetable for free train-paths and inserts additional train paths by using remaining infrastructure capacity in an economical manner. The operation simulation procedure embodied in the new technique makes it possible to check the stability of any timetable and thus to provide early quality assurance of timetable planning processes...|$|R
