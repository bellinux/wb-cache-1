34|10000|Public
5000|$|Passport {{focuses on}} its primary client, the cities, universities, transit agencies, and private {{operators}} it provides enterprise software. This {{results in a}} combined B2G, B2B, and B2C approach due to both the influence that municipality government and private operators’ have on which technologies are used in each area along with the significance of increased user adoption. Customers within the agencies Passport serve download mobile applications to use for parking, transit, permits, and to pay parking tickets. Passport's mobile <b>applications</b> <b>are</b> <b>represented</b> {{in cities such as}} Chicago, Boston, Detroit, Toronto, and Louisville.|$|E
5000|$|On {{a simplistic}} level, {{horizontal}} carousels are also {{often used as}} [...] "rotating shelving." [...] 'With simple [...] "fetch" [...] command items are brought to the operator and otherwise wasted space is eliminated.AS/RS Applications: Most applications of AS/RS technology {{have been associated with}} warehousing and distribution operations. An AS/RS {{can also be used to}} store raw materials and work in process in manufacturing. Three application areas can be distinguished for AS/RS: (1) Unit load storage and handling, (2) Order picking, and (3) Work in process storage. Unit load storage and retrieval <b>applications</b> <b>are</b> <b>represented</b> by unit load AS/RS and deep-lane storage systems. These kinds of applications are commonly found in warehousing for finishing goods in a distribution centre, rarely in manufacturing. Deep-lane systems are used in the food industry. As described above, order picking involves retrieving materials in less than full unit load quantities. Minilpass, man-on board, and items retrieval systems are used for this second application area.|$|E
40|$|This paper explores two {{potential}} {{applications of}} Virtual Reality (VR) to international nuclear safeguards: {{training and information}} organization and navigation. The <b>applications</b> <b>are</b> <b>represented</b> by two existing prototype systems, one for training nuclear weapons dismantlement and one utilizing a VR model to facilitate intuitive access to related sets of information...|$|E
5000|$|In Ember, {{the state}} of an <b>application</b> <b>is</b> <b>represented</b> by a URL. Each URL has a {{corresponding}} route object that controls what is visible to the user.|$|R
5000|$|Influence {{lines are}} based on Betti's theorem. From there, {{consider}} two external force systems, [...] and , each one associated with a displacement field whose displacements measured in the force's point of <b>application</b> <b>are</b> <b>represented</b> by [...] and [...]|$|R
5000|$|The latter {{notation}} {{is especially}} useful {{in combination with}} the currying isomorphism. Given a function , its <b>application</b> <b>is</b> <b>represented</b> as [...] by the former notation and [...] by the latter. However, functions in curried form [...] can <b>be</b> <b>represented</b> by juxtaposing their arguments: , rather than [...] This relies on function application being left-associative.|$|R
40|$|Many 3 D models used in engineering, scientific, and {{visualization}} <b>applications</b> <b>are</b> <b>represented</b> by {{an irregular}} mesh of bounding quadrilaterals. We propose a scheme for compressing the connectivity of irregular quadrilateral meshes in 0. 26 - 1. 7 bits/quad, a 25 - 45 % savings over randomly splitting quads into triangles and applying triangle mesh compression. Our approach {{is an extension}} of the Edgebreaker compression approach and of the Wrap&Zip decompression technique...|$|E
3000|$|We {{consider}} a discrete time model. The network consists of multiple solar-powered sensor nodes denoted as n ∈N where N {{is a set}} of all available sensor nodes. Tasks are units of execution that make up an application. The application for wireless sensor networks can be target tracking, event detection, etc. A single application may perform a variety of tasks such as sensing, computation, storage, and communication. <b>Applications</b> <b>are</b> <b>represented</b> by a DAG, composed of all tasks m ∈M where M is the set of tasks that must be completed for the application. L [...]...|$|E
40|$|Abstract This paper {{discusses}} {{platform independent}} Web application modeling {{and development in}} the context of model-driven engineering. A specific metamodel (and associated notation) is introduced and motivated for the modeling of dynamic Web specific concerns. Web <b>applications</b> <b>are</b> <b>represented</b> via three independent but related models (business, hypertext and presentation). A kind of action language (based on OCL and Java) is used all over these models to write methods and actions, specify constraints and express conditions. The concepts described in the paper have been implemented in the Netsilon tool and operational modeldriven Web information systems have been successfully deployed by translation from abstract models to platform specific models...|$|E
5000|$|... {{allowing}} CI+ CAM <b>applications</b> to <b>be</b> <b>represented</b> in the Host's channel line-up in form {{of virtual}} channels.|$|R
5000|$|Completeness; {{the degree}} to which all {{necessary}} concepts of the <b>application</b> domain <b>are</b> <b>represented</b> in the way of modeling.|$|R
40|$|The paper {{presents}} applications developed using AutoCAD and 3 D Studio MAX programs. The {{purpose of}} the <b>applications</b> <b>is</b> <b>represented</b> {{by the development of}} the spatial abilities of the students and they have frequent use in teaching technical drawing, for the understanding of the representation of the orthogonal projections of the parts, {{as well as for the}} construction of their axonometric projection...|$|R
40|$|Abstract. This paper {{discusses}} {{platform independent}} web application modeling {{in the context}} of model-driven engineering. A specific metamodel (and associated notation), companion of the UML metamodel, is introduced and motivated for the modeling of dynamic web specific concerns. Web <b>applications</b> <b>are</b> <b>represented</b> in three independent aspects (business, hypertext and presentation). A kind of action language (based on OCL and Java) is used throughout these aspects to write methods and actions, specify constraints and express conditions. The concepts described in the paper have been implemented in a tool and operational model-driven web information systems have been successfully deployed. Keywords: model-driven engineering, MDA, web, metamodel, PIM. ...|$|E
40|$|This paper {{discusses}} {{platform independent}} Web application modeling {{and development in}} the context of model-driven engineering. A specific metamodel (and associated notation) is introduced and motivated for the modeling of dynamic Web specific concerns. Web <b>applications</b> <b>are</b> <b>represented</b> via three independent but related models (business, hypertext and presentation). A kind of action language (based on OCL and Java) is used all over these models to write methods and actions, specify constraints and express conditions. The concepts described in the paper have been implemented in the Netsilon tool and operational model-driven Web information systems have been successfully deployed by translation from abstract models to platform specific models...|$|E
40|$|An Adaptive Object Model (AOM) is {{a common}} {{architectural}} style for systems in which classes, attributes, relationships and behaviors of <b>applications</b> <b>are</b> <b>represented</b> as metadata, allowing them to be changed at runtime not only by programmers, but also by end users. Frequently, behavior is added to AOM systems by increasingly adding expressiveness to the model. However, this approach {{can result in a}} full blown programming language, which is not desirable. This pattern describes a solution for adding behavior to AOM systems by using metadata to identify points in the application where behavior can be dynamically added. This solution may limit the expressive power of the model, but can also simplify it, since points of extension are well defined in the system...|$|E
50|$|The Model, View and Controller <b>application</b> tiers <b>are</b> <b>represented</b> {{by three}} Singletons (a class of which only one {{instance}} may be created).|$|R
50|$|Function <b>application</b> will <b>be</b> <b>represented</b> {{using the}} lambda {{calculus}} syntax. So multiplication will <b>be</b> <b>represented</b> by a dot. Also, for some examples, the let expression will be used.|$|R
50|$|The {{research}} project {{was inspired by}} Squeak. Squawk has a Java ME heritage and features a small memory footprint. It was developed to be simple with minimal external dependencies. Its simplicity made it portable and easy to debug and maintain. Squawk also provides an isolated mechanism by which an <b>application</b> <b>is</b> <b>represented</b> as an object. In Squawk, one or more applications can run in the single JVM. Conceptually, each <b>application</b> <b>is</b> completely isolated from all other applications.|$|R
40|$|This paper {{considers}} {{the problem of}} scheduling streaming applications on uniprocessors {{in order to minimize}} the num-ber of cache-misses. Streaming <b>applications</b> <b>are</b> <b>represented</b> as a directed graph (or multigraph), where nodes are com-putation modules and edges are channels. When a mod-ule fires, it consumes some data-items from its input chan-nels and produces some items on its output channels. In addition, each module may have some state (either code or data) which represents the memory locations that must be loaded into cache in order to execute the module. We con-sider synchronous dataflow graphs where the input and output rates of modules are known in advance and do not change during execution. We also assume that the state size of modules is known in advance...|$|E
40|$|The Adaptive Object Model (AOM) is {{a common}} {{architectural}} style for systems in which classes, attributes, relationships and behaviors of <b>applications</b> <b>are</b> <b>represented</b> as metadata, allowing them to be changed at runtime not only by programmers, but also by end users. Frequently, behavior is added to AOM systems by increasingly adding expressiveness to the model. However, this approach {{can result in a}} full blown programming language, which is not desirable. This pattern describes a solution for adding behavior to AOM systems by using metadata to identify points in the application where behavior can be added. This solution allows code to be used to express behavior, which simplifies its implementation and also eases the reuse of this new behavior code among different applications...|$|E
40|$|Highly {{elaborated}} visualization {{techniques that}} are based on surfaces often are independent from the origin of the surface data. For re-using advanced visualization methods for surfaces of various kind, we developed an abstract surface interrogation layer called Smurf. In this paper we discuss the steps necessary to unify multiple types of surfaces under a shared general purpose interface. Keywords: visualization, surfaces 1 INTRODUCTION Surfaces are important geometric primitives for scientific visualization [13]. Useful techniques are available to render surfaces of various kind. For instance, scalar data volumes from medical <b>applications</b> <b>are</b> <b>represented</b> using iso-surfaces [11]. Three-dimensional vector fields from flow analysis are visualized by the use of stream surfaces [8]. Interrante et al., for example, showed how curvature-based techniques enhance the use of surfaces for the visualization of volumetric data [9, 10]. Surface curvature also {{plays an important role in}} sur [...] ...|$|E
40|$|The paper {{presents}} applications {{developed for}} teaching descriptive geometry. The {{purpose of the}} <b>applications</b> <b>is</b> <b>represented</b> by {{the understanding of the}} basic elements of the descriptive geometry – the lines and the planes and their relative positions in space. The <b>applications</b> <b>are</b> focused on the line contained in a plane, this item being very important for the other relative positions of a line and a plane – the line concurrent with a plane and the line parallel to a plane...|$|R
40|$|This paper {{focuses on}} global {{consistency}} preservation for dynamic reconfiguration. Global consistency requires no <b>application</b> computation <b>be</b> interrupted in reconfiguration. Among the existing methods for global consistency preservation, version management {{is of the}} most advantages. But the version-management transparency and old-version-removal problems have not been well solved. In this paper, a novel component model is proposed. Based on the model, an <b>application</b> <b>is</b> <b>represented</b> as a data flow diagram; <b>application</b> computations <b>are</b> <b>represented</b> as designed routes. Data visibility control and flow trace are implemented to solve the above two problems. Data visibility control is used to hide the version management mechanism from the component developers; flow trace is used to determine when the old components should be removed. Experimental results have demonstrated {{the advantages of the}} version management method and the effectiveness of the data visibility control and flow trace mechanisms...|$|R
5000|$|Some of the <b>applications</b> where {{information}} <b>is</b> <b>represented</b> as attribute-value pairs are: ...|$|R
40|$|Abstract—Dataflow-based {{application}} specifications {{are widely}} used in model-based design methodologies for signal processing systems. In this paper, we develop a new model called the dataflow schedule graph (DSG) for representing a broad class of dataflow graph schedules. The DSG provides a graphical representation of schedules based on dataflow semantics. In conventional approaches, <b>applications</b> <b>are</b> <b>represented</b> using dataflow graphs, whereas schedules for the graphs are represented using specialized notations, such as various kinds of sequences or looping constructs. In contrast, the DSG approach employs dataflow graphs for representing both application models and schedules that are derived from them. Our DSG approach provides a precise, formal framework for unambiguously representing, analyzing, manipulating, and interchanging schedules. We develop detailed formulations of the DSG representation, and present examples and experimental results that demonstrate the utility of DSGs {{in the context of}} heterogeneous signal processing system design. Keywords-dataflow graphs, heterogeneous computing, models of computation, scheduling. I...|$|E
40|$|In {{system-level}} design, <b>applications</b> <b>are</b> <b>represented</b> as task graphs where tasks (called nodes) have {{moderate to}} large granularity and each node has several implementation options differing in area and execution time. We define the extended partitioning problem as the joint {{determination of the}} mapping (hardware or software), the implementation option (called implementation bin), {{as well as the}} schedule, for each node, so that the overall area allocated to nodes in hardware is minimum and a deadline constraint is met. This problem is considerably harder (and richer) than the traditional binary partitioning problem that determines just the best mapping and schedule. Both binary and extended partitioning problems are constrained optimization problems and are NP-hard. We first present an efficient (O(N²)) heuristic, called GCLP, to solve the binary partitioning problem. The heuristic reduces the greediness associated with traditional list-scheduling algorithms by formulating a global m [...] ...|$|E
40|$|We {{present a}} new {{representation}} that {{is guaranteed to}} encode any planar triangle graph of V vertices in less than 3. 67 V bits. Our code improves on all prior solutions to this well studied problem and lies within 13 % of the theoretical lower limit of the worst case guaranteed bound. It {{is based on a}} new encoding of the CLERS string produced by Rossignacs Edgebreaker compression [Rossignac 99]. The elegance and simplicity of this technique makes it suitable for a variety of 2 D and 3 D triangle mesh compression applications. Simple and fast compression/decompression algorithms with linear time and space complexity are available. Keywords: 3 D representations, triangle meshes, planar graph encoding, geometry compression. 1. INTRODUCTION Many 3 D models used in engineering, scientific, medical, geographical, and visualization <b>applications</b> <b>are</b> <b>represented</b> by an irregular mesh of bounding triangles. The simplest representation of such a mesh stores the geometry (a table of the coordinates of i [...] ...|$|E
5000|$|In service-oriented {{architectures}} an <b>application</b> can <b>be</b> <b>represented</b> {{through an}} executable workflow, where different, possibly geographically distributed, service components interact {{to provide the}} corresponding functionality {{under the control of}} a workflow management system.|$|R
40|$|We {{present a}} method for porous media flow in the {{presence}} of complex fracture networks. The approach uses the Mimetic Finite Difference method (MFD) and takes advantage of MFD's ability to solve over a general set of polyhedral cells. This flexibility is used to mesh fracture intersections in two and three-dimensional settings without creating small cells at the intersection point. We also demonstrate how to use general polyhedra for embedding fracture boundaries in the reservoir domain. The target <b>application</b> <b>is</b> <b>representing</b> fracture networks inferred from microseismic analysis...|$|R
50|$|Today the Broads Society has a {{membership}} of about 1200, and it monitors {{pressures on the}} unique Broads environment, as well as commenting on planning <b>applications.</b> It <b>is</b> <b>represented</b> on the Broads Authority's Broads Forum.|$|R
40|$|Abstract. Cloud {{computing}} environment {{has the ability}} to scale-up or scale-down the amount of resources provisioned to an application to balance the demand. This elastic nature of the cloud is also limited by the ownership and locality. The emergence of Hybrid cloud (combination of private and public cloud) arises as a solution. In a cloud {{computing environment}}, task scheduling becomes more complex due its transparency and flexibility. As the beneficiaries of cloud are small and medium enterprises, cost of using the resources, forms the important factor in task scheduling. The user <b>applications</b> <b>are</b> <b>represented</b> by the Directed Acyclic Graph (DAG) which includes the communication cost and computation cost of the various tasks in the graph. Some applications are termed as communication intensive (course-grained) and the rest are computation intensive (fine-grained). The aim {{of this paper is to}} apply the Customer Facilitated Cost-based Scheduling algorithm (CFCSC) to both communication intensive and computation intensive DAGs. This paper also records the performance of the CFCSC for better service...|$|E
40|$|Distributed memory {{machines}} {{equipped with}} CPUs and GPUs (hybrid comput-ing nodes) {{are hard to}} program because of the multiple layers of memory and heterogeneous computing configurations. In this paper, we introduce a region template abstraction for the efficient management of common data types used in analysis of large datasets of high resolution images on clusters of hybrid com-puting nodes. The region template provides a generic container template for common data structures, such as points, arrays, regions, and object sets, within a spatial and temporal bounding box. The region template abstraction enables different data management strategies and data I/O implementations, while pro-viding a homogeneous, unified interface to the application for data storage and retrieval. The execution of region templates applications is coordinated by a runtime system that supports efficient execution in hybrid machines. Region templates <b>applications</b> <b>are</b> <b>represented</b> as hierarchical dataflow in which each computing stage may be represented as another dataflow of finer-grain tasks. ...|$|E
40|$|Many current {{distributed}} applications {{are based on}} the exchange of XML messages. Scaling such applications to the high processing volume demanded by Internet-scale deployment typically requires costly redesign and coding. In this paper, we investigate how a declarative specification of such applications can simplify the task of deploying them on a large number of host machines. In our model, <b>applications</b> <b>are</b> <b>represented</b> as a graph of message queues connected by message flow rules. The state of application instances is encoded in the message history of the queues and accessed using XQuery expressions. We show how to split such an application into distributable fragments using graph partitioning and discuss different algorithms for placing the fragments on hosts. Typically, an initial application specification contains data dependencies that place an upper limit on the number of fragments, and hence the number of usable machines. We describe transformations that increase the number of possible fragments by converting data dependencies into message flow. An evaluation using the TPC-App benchmark and a runtime system prototype confirms the feasibility and performance benefits of this approach. 1...|$|E
40|$|This {{document}} {{describes the}} current UML profile of Gaspard 2. This profile extends the UML semantics {{to allow the}} user to describe a SoC (System-on-Chip) in three steps: the application (behavior of the Soc), the hardware architecture, and the association of the application to the hardware architecture. The <b>application</b> <b>is</b> <b>represented</b> following a data flow model, but additional mechanisms permit the usage of control flow on those applications. In addition to those notions, the profile contains a package introducing factorization mechanisms to enable the compact description of massively parallel and repetitive systems...|$|R
40|$|Since the {{expansion}} of their market and their challenging requirements, Massively Multiplayer Online Games are gaining increasing attention in the scientific community. One of the key factors {{in this kind of}} <b>application</b> <b>is</b> <b>represented</b> by the ability to rapidly deliver game events among the various players over the network. Employing in this context Mirrored Game Server architecture and adapting RED (Random Early Detection) techniques borrowed from network queuing management, we are able to show sensible benefits in upholding interactivity and scalability, whilst preserving game state consistency and game evolution fluency at the player's side...|$|R
5000|$|The <b>application</b> {{manifest}} <b>is</b> internally <b>represented</b> as XML. The URN {{associated with}} SxS manifests is [...] "urn:schemas-microsoft-com:asm.v1".|$|R
