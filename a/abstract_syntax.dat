1712|68|Public
25|$|Each {{front end}} uses a parser {{to produce the}} <b>abstract</b> <b>syntax</b> tree of a given source file. Due to the syntax tree abstraction, source files {{of any of the}} {{different}} supported languages can be processed by the same back end. GCC started out using LALR parsers generated with Bison, but gradually switched to hand-written recursive-descent parsers; for C++ in 2004, and for C and Objective-C in 2006. Currently all front ends use hand-written recursive-descent parsers.|$|E
25|$|The Ericsson Erlang {{implementation}} loads {{virtual machine}} bytecode which {{is converted to}} threaded code at load time. It also includes a native code compiler on most platforms, developed by the High Performance Erlang Project (HiPE) at Uppsala University. Since October 2001 the HiPE system is fully integrated in Ericsson's Open Source Erlang/OTP system. It also supports interpreting, directly from source code via <b>abstract</b> <b>syntax</b> tree, via script as of R11B-5 release of Erlang.|$|E
25|$|BIND {{is based}} on a data {{specification}} written using <b>Abstract</b> <b>Syntax</b> Notation 1 (ASN.1) language. ASN.1 is used also by NCBI when storing data for their Entrez system and because of this BIND uses the same standards as NCBI for data representation. The ASN.1 language is preferred because it can be easily translated into other data specification languages (e.g. XML), can easily handle complex data and can be applied to all biological interactions – not just proteins. Bader and Hogue (2000) have prepared a detailed manuscript on the ASN.1 data specification used by BIND.|$|E
50|$|Presentation Model: {{it expresses}} the layout and graphic {{appearance}} of pages, {{independently of the}} output device and of the rendition language, {{by means of an}} <b>abstract</b> XML <b>syntax.</b> Presentation specifications are either page-specific or generic.|$|R
40|$|A key {{aspect of}} {{successfully}} using UML is understanding the semantics of the notations. UML 2 {{will increase the}} already substantial collection of notations supported by UML 1. x. At the same time, this will augment the difficulty users experience in understanding semantics. In this paper we propose that while the diverse notations may render concepts differently, the concepts can often be considered semantically equivalent. This gives rise to an architecture where two single <b>abstract</b> <b>syntaxes</b> (structure and behaviour) underpin UML 2 ’s seven concrete syntax. Because there a fewer semantically distinct concepts, this makes UML both easier to understand and substantially easier to implement. ...|$|R
40|$|In this paper, we {{show how}} the OMG's metamodelling {{approach}} to domain-specific language definition can be exploited to infer human-usable textual notations (concrete syntaxes) from the conceptualization provided by metamodels (<b>abstract</b> <b>syntaxes).</b> We give general rules to derive a context-free EBNF (Extended Backus-Naur Form) grammar from a MOF-compliant metamodel, and we show how to instruct a parser generator by these rules for generating a compiler which is able to parse the grammar and to transfer information about models into a MOF-based instance repository. The approach is exemplified for the Abstract State Machines Metamodel (AsmM), a metamodel for the Abstract State Machine (ASM) formal method, by illustrating the derivation of a textual notation to write ASM specifications conforming to the AsmM, and the process to input ASM models into a MOF repository...|$|R
25|$|Rakudo Perl 6 targets {{a number}} of virtual machines, such as MoarVM, the Java Virtual Machine and JavaScript. MoarVM is a virtual machine built {{especially}} for Rakudo Perl 6 and the NQP Compiler Toolchain. There is a layer between Perl 6 and the virtual machines called Not Quite Perl 6, or NQP, which implements Perl 6 rules for parsing Perl 6, {{as well as an}} <b>Abstract</b> <b>syntax</b> tree and backend-specific code generation. Large portions of Rakudo are written in Perl 6 itself, or in its subset NQP. Rakudo is not a completely self-hosting implementation, nor are there concrete plans at this point to make Rakudo a bootstrapping compiler.|$|E
2500|$|Each of the {{language}} compilers is a separate program that reads source code and outputs machine code. All have a common internal structure. A per-language front end parses the source code in that language and produces an <b>abstract</b> <b>syntax</b> tree ("tree" [...] for short).|$|E
2500|$|This tree {{is called}} a parse tree or [...] "concrete syntax tree" [...] of the string, by {{contrast}} with the <b>abstract</b> <b>syntax</b> tree. In this case the presented leftmost and the rightmost derivations define the same parse tree; however, there is another (rightmost) derivation of the same string ...|$|E
40|$|The {{purpose of}} this report is twofold: first, it {{attempts}} to generalise the notion of 'attribute grammar' {{to the concept of}} attributation as an algebraic specification formalism, which {{can be used as a}} meta-language to describe programming or specification languages. This view on attributation gives access to well-known and powerful structuring mechanisms like parametrisation and implementation (used for viewing on <b>abstract</b> <b>syntaxes),</b> which are studied in detail. Second, the syntax, typing and semantics of the concrete attributation language LIMA are defined, that implement these concepts. As an abstract interfaces to purely functional programming language specifications we use in the LCF-like algebraic specification language SPECTRUM. (orig.) SIGLEAvailable from TIB Hannover: RO 802 (1994, 11) / FIZ - Fachinformationszzentrum Karlsruhe / TIB - Technische InformationsbibliothekBundesministerium fuer Forschung und Technologie (BMFT), Bonn (Germany) DEGerman...|$|R
40|$|<b>Abstract.</b> Space <b>syntax</b> {{was used}} toanalysequantificationally unapproved overall {{planning}} of Harbin in 2004 andapproved overall planning of Harbin in 2011 in this paper. Comparing to global integration, local integration and spatial intelligence degree of space syntax analysis results,summarize the evolution characteristics {{and come to}} conclusion that contains law of development and prospect of Harbin center city. It can provide reference for future planning...|$|R
40|$|Abstract: Safety {{critical}} software requires integrating verification techniques in software development methods. Software architectures must guarantee that developed systems will meet safety requirements and safety analyses are frequently {{used in the}} assessment. Safety engineers and software architects must reach a common understanding on an optimal architecture from both perspectives. Currently both groups of engineers apply different modelling techniques and languages: safety analysis models and software modelling languages. The solutions proposed seek to integrate both domains coupling the languages of each domain. It constitutes a sound example {{of the use of}} language engineering to improve efficiency in a software-related domain. A model-driven development approach and the use of a platform-independent language are used {{to bridge the gap between}} safety analyses (failure mode effects and criticality analysis and fault tree analysis) and software development languages (e. g. unified modelling language). Language <b>abstract</b> <b>syntaxes</b> (metamodels), profiles, language mappings (model transformations) and language refinements, support the direct application of safety analysis to software architectures for the verification of safety requirements. Model consistency and the possibility of automation are found among the benefits. ...|$|R
2500|$|In 1961 Dijkstra first {{described}} the shunting-yard algorithm, {{a method for}} parsing mathematical expressions specified in infix notation, in the Mathematisch Centrum report. It {{can be used to}} produce output in Reverse Polish notation (RPN) or as an <b>abstract</b> <b>syntax</b> tree (AST). The algorithm was named the [...] "shunting yard" [...] algorithm because its operation resembles that of a railroad shunting yard. The shunting-yard algorithm is commonly used to implement operator-precedence parsers.|$|E
50|$|SGML has an <b>abstract</b> <b>syntax</b> {{implemented}} by many possible concrete syntaxes, however, {{this is not}} the same usage as in an <b>abstract</b> <b>syntax</b> tree and as in a concrete syntax tree. In the SGML usage, a concrete syntax is a set of specific delimiters, while the <b>abstract</b> <b>syntax</b> is the set of names for the delimiters. The XML Infoset corresponds more to the programming language notion of <b>abstract</b> <b>syntax</b> introduced by John McCarthy.|$|E
50|$|In {{computer}} science, higher-order <b>abstract</b> <b>syntax</b> (abbreviated HOAS) is {{a technique}} for the representation of <b>abstract</b> <b>syntax</b> trees for languages with variable binders.|$|E
40|$|The Resource Description Framework (RDF) is a {{language}} for metadata assertions about information {{resources on the}} World-Wide Web, and is thus a foundation for a future Semantic Web. The atomic construct of RDF are statements, which are triples consisting of the resource being described, a property, and a property value. A collection of RDF statements can be intuitively understood as a graph: resources are nodes and statements are arcs connecting the nodes. The graph nature of this <b>abstract</b> triple <b>syntax</b> is indeed appealing, but the RDF specification does not distinguish clearly among (1) the term of RDF Graph (merely a set of triples, thus not a standard graph), (2) the mathematical concept of graph, and (3) the graph-like visualization of RDF data (“node and directed-arc diagrams”). This thesis argues that there is need for an explicit graph representation for RDF, which allows the application of technics and results from graph theory and which serves as an intermediate model between the <b>abstract</b> triple <b>syntax</b> and task-specific serialization of RDF data. Directed labeled graphs currently use...|$|R
40|$|<b>Abstract.</b> The <b>syntax</b> of SOM-G —a sound {{synthesis}} language for granular synthesis — is described. Since SOM-G is a descendant from the additive synthesis language SOM-A, it has inherited {{most of its}} concise and efficient syntatic structure, being arranged so as for allowing the definition of orchestras of granular synthesis instruments having {{a high degree of}} control over granular parameters as well as the interpretation and rendering into digital audio of polyphonic scores using these instruments. 1...|$|R
40|$|Euler {{diagrams}} {{have been}} used for centuries to convey logical information and have been formalized for this purpose. Related notations, such as Venn-II, Euler/Venn, spider diagrams, and constraint diagrams, have been developed and fully formalized as logics in their own right. Issues regarding their <b>abstract</b> (type) <b>syntax</b> and concrete (token) syntax have been discussed in the literature but there are more fine grained levels of syntax that have not, to the authors’ knowledge, been given serious consideration. We discuss different levels of Euler diagram syntax. These include the drawn level, where the images of the diagrams live, for example, on a computer screen, a piece of paper, or a whiteboard; mathematical models of the drawn diagrams; the dual graph of an Euler diagram; and the <b>abstract</b> level of <b>syntax</b> that captures the semantic information present in the diagram and forgets all geometric and topological properties that have no impact on the semantics...|$|R
50|$|Frama-C {{relies on}} CIL (C Intermediate Language) to {{generate}} an <b>abstract</b> <b>syntax</b> tree.The <b>abstract</b> <b>syntax</b> tree supports annotations written in ANSI/ISO C Specification Language (ACSL).|$|E
5000|$|... 'Quasi-quote' {{brackets}} [...] and [...] {{are used}} to get the <b>abstract</b> <b>syntax</b> tree for the enclosed expression and 'splice' brackets [...] and [...] {{are used to}} convert from <b>abstract</b> <b>syntax</b> tree into code.|$|E
50|$|Abstract syntaxes are {{classified}} as first-order <b>abstract</b> <b>syntax</b> (FOAS), if the structure is abstract but names (identifiers) are still concrete (and thus requires name resolution), and higher-order <b>abstract</b> <b>syntax,</b> if the names themselves are abstract.|$|E
40|$|We {{propose a}} general markup {{framework}} for integrity and derivation rules (R 2 ML). Rule concepts are defined {{with the help}} of MOF/UML, a subset of the UML class modeling language proposed by the Object Management Group (OMG) for the purpose of 2 ̆ 7 meta-modeling 2 ̆ 7, i. e. for defining languages conceptually on the level of an <b>abstract</b> (semi-visual) <b>syntax.</b> From these MOF/UML language models we can obtain concrete markup syntax by applying a mapping procedure for generating corresponding languages from parameterized DTDs...|$|R
40|$|Abstract. This {{document}} describes part of {{an effort}} to achieve in Nuprl a practical reflection of its expression syntax. This reflection is done at the granularity of the operators; in particular, each operator of the syntax is denoted by another operator of the same syntax. Further, the syntax has binding operators, and we organize reflection not around the concrete binding syntax, but instead, around the <b>abstract</b> higher-order <b>syntax.</b> We formulate and prove the correctness of a core rule for inferring well-formedness of instances of operator-denoting operators. ...|$|R
40|$|AbstractThe {{quality of}} compiler-optimized code for {{high-performance}} applications is far behind what optimization and domain experts can achieve by hand. Although {{it may seem}} surprising at first glance, the performance gap has been widening over time, due to the tremendous complexity increase in microprocessor and memory architectures, and to the rising level of abstraction of popular programming languages and styles. This paper explores in-between solutions, neither fully automatic nor fully manual ways to adapt a computationally intensive application to the target architecture. By mimicking complex sequences of transformations useful to optimize real codes, we show that generative programming is a practical means to implement architecture-aware optimizations for high-performance applications. This work explores the promises of generative programming languages and techniques for the high-performance computing expert. We show that complex, architecture-specific optimizations can be implemented in a type-safe, purely generative framework. Peak performance is achievable through the careful combination of a high-level, multi-stage evaluation language–MetaOCaml–with low-level code generation techniques. Nevertheless, our results also show that generative approaches for high-performance computing do not come without technical caveats and implementation barriers concerning productivity and reuse. We describe these difficulties and identify ways to hide or overcome them, from <b>abstract</b> <b>syntaxes</b> to heterogeneous generators of code generators, combining high-level and type-safe multi-stage programming with a back-end generator of imperative code...|$|R
50|$|In {{computer}} science, the <b>abstract</b> <b>syntax</b> of data is {{its structure}} {{described as a}} data type (possibly, but not necessarily, an abstract data type), independent of any particular representation or encoding. This is particularly used in the representation of text in computer languages, which are generally stored in a tree structure as an <b>abstract</b> <b>syntax</b> tree. <b>Abstract</b> <b>syntax,</b> which only consists {{of the structure of}} data, is contrasted with concrete syntax, which also includes information about the representation. For example, concrete syntax includes features like parentheses (for grouping) or commas (for lists) which are not included in the <b>abstract</b> <b>syntax,</b> as they are implicit in the structure.|$|E
50|$|It allows compile-time metaprogramming and {{generative}} programming {{by means}} of manipulating <b>abstract</b> <b>syntax</b> trees and '' results back into a program. The <b>abstract</b> <b>syntax</b> is represented using ordinary Haskell data types and the manipulations are performed using ordinary Haskell functions.|$|E
50|$|Computer {{scientists}} {{often need}} to manipulate <b>abstract</b> <b>syntax</b> trees. For instance, compiler writers perform many manipulations of <b>abstract</b> <b>syntax</b> trees during the various optimisation and elaboration phases of compiler execution. In particular, {{when working with}} <b>abstract</b> <b>syntax</b> trees with name binding constructs, we often want to work on alpha-equivalence classes, implement capture-avoiding substitutions, and {{make it easy to}} generate fresh names. How best to do this, in a bug free and reliable manner, motivates a large amount of research.|$|E
40|$|Current formal {{software}} engineering methodologies provide {{a vast array}} of languages for specifying correctness properties, as well as a wide assortment automated tools that aid in the verification of specified properties. Unfortunately, the implementation of each such tool requires an early commitment to a particular methodology and language, in terms of both high-level semantic concerns and the lower-level syntactic representations of properties and proofs. In this paper, we present Prufrock, a novel approach to automated reasoning systems, which abstracts semantic concerns over entire classes of potential implementation languages. Prufrock is a modular prover framework written in the Haskell programming language. It consists of a set of largely independent logic modules, which define the semantics required for proof over entire classes of <b>abstract</b> <b>syntaxes,</b> using polytypic programming techniques. Any given representation language may be used for specifying and verifying properties in Prufrock, so long as it provides a semantics consistent with the logic modules that required for a proof. The implementation details of the reasoning system thus remain independent of the structure specification language, facilitating large-scale reuse in the construction of automated reasoning tools. At the same time, Prufrock aids in closing the gap between actual source-level implementation and the formal specification and verification of correctness properties. This paper provides an overview of the major design philosophy behind Prufrock, as well as {{a brief description of the}} polytypic techniques that make its implementation possible. 1...|$|R
40|$|This is the author's {{version of}} the work. It is posted here for your {{personal}} use. Not for redistribution. The definitive Version of Record was published in Proceedings of the 6 th International Workshop on Multi-Paradigm Modeling, [URL] systems require descriptions using multiple modelling languages, or languages able to express different concerns, like timing or data dependencies. In this paper, we propose techniques for the modular definition and composition of languages, including their <b>abstract,</b> concrete <b>syntax</b> and semantics. These techniques are based on (meta-) model templates, where interface elements and requirements for their connection can be established. We illustrate the ideas using the MetaDepth textual meta-modelling tool...|$|R
40|$|The <b>abstract</b> (or semantic) <b>syntax</b> of the Pascal {{language}} IS identIfied and {{a linear}} representation {{for the trees}} so formed within tne framework of the concrete syntax for that language is imposed. The indentation seneme 50 formed. augmented with {{a small number of}} pragmaticconsiaerations. is compared with several previously proposed formatting schemes for Pascal and an example of rne use of tnls new method is given...|$|R
50|$|As well as lexers and parsers, ANTLR {{can be used}} to {{generate}} tree parsers. These are recognizers that process <b>abstract</b> <b>syntax</b> trees which can be automatically generated by parsers. These tree parsers are unique to ANTLR and greatly simplify the processing of <b>abstract</b> <b>syntax</b> trees.|$|E
5000|$|A compiler's {{internal}} {{representation of a}} program will typically be specified by an <b>abstract</b> <b>syntax</b> in terms of categories such as [...] "statement", [...] "expression" [...] and [...] "identifier". This is independent of the source syntax (concrete syntax) of the language being compiled (though it will often be very similar). A parse tree is similar to an <b>abstract</b> <b>syntax</b> tree but it will typically also contain features such as parentheses which are syntactically significant but which are implicit {{in the structure of}} the <b>abstract</b> <b>syntax</b> tree.|$|E
50|$|Automatic {{generation}} of strictly-typed <b>abstract</b> <b>syntax</b> trees.|$|E
40|$|This paper {{discusses}} {{the design of}} integrity and derivation rules on the ba-sis of Rule Markup Language (RuleML) and Semantic Web Rule Language (SWRL). We propose a general markup framework for integrity and deriva-tion rules (R 2 ML). Rule concepts are defined {{with the help of}} MOF/UML, a subset of the UML class modeling language proposed by the Object Man-agement Group (OMG) for the purpose of ’meta-modeling’, i. e. for defin-ing languages conceptually on the level of an <b>abstract</b> (semi-visual) <b>syntax.</b> From these MOF/UML language models we can obtain concrete markup syntax by applying a mapping procedure for generating corresponding lan-guages from parameterized DTDs. Keywords:rule markup languages, in-tegrity rules derivation rules, rule meta-models...|$|R
40|$|In this paper, we {{identify}} main challenges for domain specific modeling frameworks. Arbitrary <b>abstract</b> to concrete <b>syntax</b> mapping enables the toolsmith to create visual representation to complex logical models {{with the possibility}} to determine what detail to show and what to hide in a flexible way. Interactive model simulation based on a model transformation architecture allows for the design time analysis and precise fine tuning of behavioral aspects. ...|$|R
40|$|We {{describe}} how multimodal grammars for dialogue {{systems can be}} written using the Grammatical Framework (GF) formalism. A proof-of-concept dialogue system constructed using these techniques is also presented. The software engineering problem of keeping grammars for different languages, modalities and systems (such as speech recognizers and parsers) in sync is reduced by the formal relationship between the <b>abstract</b> and concrete <b>syntaxes,</b> and by generating equivalent grammars from GF grammars. ...|$|R
