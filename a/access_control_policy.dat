616|10000|Public
50|$|Many network {{capabilities}} {{can be made}} to {{rely upon}} authentication technologies for the provisioning of an <b>access</b> <b>control</b> <b>policy.</b>|$|E
5000|$|How can <b>access</b> <b>control</b> <b>policy</b> be {{authored}} {{and reviewed}} {{in a manner}} that is human readable - allowing auditors and non-technical people to understand such policies? ...|$|E
50|$|Trusted system {{services}} (TSS) software executes in ring 1. TSS implements file systems, implements TCP/IP, and enforces the discretionary <b>access</b> <b>control</b> <b>policy</b> on file system objects. TSS's data is local {{to the process}} within which it is executing.|$|E
40|$|Specifying and {{managing}} <b>access</b> <b>control</b> <b>policies</b> for large distributed systems is a non-trivial task. Commonly, <b>access</b> <b>control</b> <b>policies</b> are specified in natural language and later reformulated {{in terms of}} a particular <b>access</b> <b>control</b> model. This paper presents and discusses concepts for an object-oriented access model that is more suitable for describing <b>access</b> <b>control</b> <b>policies</b> for CORBA objects than the default access model specified in the OMG security service specification...|$|R
40|$|Abstract — With {{the growth}} of Enterprises and organizations, the paper-based systems are {{replaced}} with software systems. These software systems are built to support a multitude of users {{with a variety of}} roles accessing the resources from anywhere and at any time. These operations are regulated through proper definition of <b>Access</b> <b>control</b> <b>policies</b> (Permissions); this {{plays a major role in}} protecting the system and its resources. Initially the software developers focused solely on the customer's requirements without concentrating on <b>access</b> <b>control</b> <b>policies</b> [1]. The later inclusion of them in the software system always created problems that resulted in financial loss, data loss and integrity loss of critical systems [2]. The significance of the <b>Access</b> <b>control</b> <b>policies</b> has made the researchers to recommend its adoption in the early phases of the software development. Unlike olden days, today's business processes are evolving day by day. The <b>Access</b> <b>control</b> <b>policies</b> also continually evolve to meet the organization's business needs and customer's interest. This issue is serious because if the evolving <b>Access</b> <b>control</b> <b>policies</b> are not handled properly, the system is continuously vulnerable to data loss, financial loss and integrity loss. The existing works in the literature rarely address the approaches for handling the evolving <b>Access</b> <b>control</b> <b>policies</b> [3]. New abstraction and approaches are needed to represent such policies specific during the software design. This paper discusses research directions that could result in approaches for handling the evolving <b>access</b> <b>control</b> <b>policies</b> in the design phase. This should also ensure the early inclusion of the <b>access</b> <b>control</b> <b>policies</b> at design phase...|$|R
40|$|<b>Access</b> <b>control</b> {{is one of}} {{the most}} {{fundamental}} and widely used security mechanisms. <b>Access</b> <b>control</b> mechanisms control which principals such as users or processes have access to which resources in a system. To facilitate managing and maintaining <b>access</b> <b>control,</b> <b>access</b> <b>control</b> <b>policies</b> are increasingly written in specification languages such as XACML. The specification of <b>access</b> <b>control</b> <b>policies</b> itself is often a challenging problem. Furthermore, XACML is intentionally designed to be generic: it provides the freedom in describing <b>access</b> <b>control</b> <b>policies,</b> which are well-known or invented ones. But the flexibility and expressiveness provided by XACML come at the cost of complexity, verbosity, and lack of desirable-property enforcement. Often common properties for specific <b>access</b> <b>control</b> <b>policies</b> may not be satisfied when these policies are specified in XACML, causing the discrepancy between what the policy authors intend to specify and what the actually specified XACML policies reflect. In this position paper, we propose an approach for conducting conformance checking of <b>access</b> <b>control</b> <b>policies</b> specified in XACML based on existing verification and testing tools for XACML policies. 1...|$|R
5000|$|XACML {{stands for}} [...] "eXtensible Access Control Markup Language". The {{standard}} defines a declarative fine-grained, attribute-based <b>access</b> <b>control</b> <b>policy</b> language, an architecture, and a processing model describing how to evaluate access requests {{according to the}} rules defined in policies.|$|E
5000|$|... (3) VO Management. Virtual {{organization}} in VegaGOS, called Agora, supplies distributed resources, users and <b>access</b> <b>control</b> <b>policy</b> management, {{and has the}} characteristic of single sign-on and single system image. Agora, as a common trusted third-party super-organization, achieves the unified cross-domain access control mechanisms while keeping autonomy.|$|E
5000|$|In modern SQL implementations, ACL also manage {{groups and}} {{inheritance}} in {{a hierarchy of}} groups. So [...] "modern ACLs" [...] can express all that RBAC express, and are notably powerful (compared to [...] "old ACLs") {{in their ability to}} express <b>access</b> <b>control</b> <b>policy</b> in terms {{of the way in which}} administrators view organizations.|$|E
40|$|Automated trust {{negotiation}} is a {{new approach}} to establishing trust between strangers through the exchange of property-based digital credentials, and the use of mobile <b>access</b> <b>control</b> <b>policies</b> that specify what combinations of credentials a stranger must supply in order to gain access to each local service or credential. In this paper, we show that <b>access</b> <b>control</b> <b>policies</b> can also contain sensitive information that should be protected from inappropriate access by strangers during negotiation. We present and analyze two automated trust negotiation strategies that support protection for <b>access</b> <b>control</b> <b>policies.</b> The first is the relevant credentials set strategy, which does not directly disclose <b>access</b> <b>control</b> <b>policies</b> and has a fast running time, but may disclose more credentials than strictly necessary. The second strategy is the all relevant policies strategy, which freely discloses all relevant <b>access</b> <b>control</b> <b>policies</b> that the other negotiating party has earned access to during negotia [...] ...|$|R
40|$|Commodity {{software}} components are intrinsically untrustworthy. It is highly insecure {{to use them}} directly in mission critical systems. Part of the insecurity {{can be attributed to}} the common-used but flawed mechanisms for discretionary <b>access</b> <b>control,</b> which is coarsegrained and based on user's privileges. Many alternative mechanisms have been investigated to provide mandatory <b>access</b> <b>control</b> that is fine-grained and specific to individual {{software components}}. A predominate approach to this end is to classify processes into domains and roles, and to configure <b>access</b> <b>control</b> accordingly. However, this approach has limited applications in practice due to inconvenience in its manual procedure for <b>access</b> <b>control</b> configuration. This position paper introduces a new approach to address the limitation. Our approach differentiates static from dynamic <b>access</b> <b>control</b> <b>policies</b> such that only a small amount of <b>access</b> <b>control</b> <b>policies</b> needs to be configured statically, and that a large amount of <b>access</b> <b>control</b> <b>policies</b> can be configured dynamically through automatic composition. The differentiation and composition together allow flexible and convenient management of <b>access</b> <b>control,</b> even when it is mandatory and is configured with a highly fine granularity. This paper presents background and details of our approach, specifically differentiation of static from dynamic <b>access</b> <b>control</b> <b>policies,</b> configuration of static <b>access</b> <b>control</b> <b>policies,</b> and composition of dynamic <b>access</b> <b>control</b> <b>policies.</b> Keywords Component-specific <b>access</b> <b>control,</b> highly fine-grained <b>access</b> <b>control,</b> <b>access</b> <b>control</b> configuration, <b>access</b> <b>control</b> management, <b>access</b> <b>control</b> composition I...|$|R
40|$|Programmers of {{relational}} database applications use software solutions (Hibernate, JDBC, LINQ, ADO. NET) {{to ease the}} development process of business tiers. These software solutions were not devised to address <b>access</b> <b>control</b> <b>policies,</b> much less for evolving <b>access</b> <b>control</b> <b>policies,</b> {{in spite of their}} unavoidable relevance. Currently, <b>access</b> <b>control</b> <b>policies,</b> whenever implemented, are enforced by independent components leading to a separation between policies and their enforcement. This paper proposes a new approach based on an architectural model referred to here as the Access Controldriven Architecture with Dynamic Adaptation (ACADA). Solutions based on ACADA are automatically built to statically enforce <b>access</b> <b>control</b> <b>policies</b> based on schemas of Create, Read, Update and Delete (CRUD) expressions. Then, CRUD expressions are dynamically deployed at runtime driven by established <b>access</b> <b>control</b> <b>policies.</b> Any update in the policies is followed by an adaptation process to keep <b>access</b> <b>control</b> mechanisms aligned with the policies to be enforced. A proof of concept based on Java and Java Database Connectivity (JDBC) is also presented...|$|R
50|$|The XACML's {{obligation}} can be {{an effective}} way to meet formal requirements (non-repudiation for example) that can be hard to implement as access control rules. Furthermore, any formal requirements {{will be part of the}} <b>access</b> <b>control</b> <b>policy</b> as obligations and not as separate functions, which makes policies consistent and centralization of the IT environment easier to achieve.|$|E
50|$|Solaris Trusted Extensions {{enforce a}} {{mandatory}} <b>access</b> <b>control</b> <b>policy</b> on {{all aspects of}} the operating system, including device access, file, networking, print and window management services. This is achieved by adding sensitivity labels to objects, thereby establishing explicit relationships between these objects. Only appropriate (and explicit) authorization allows applications and users read and/or write access to the objects.|$|E
50|$|The use of RBAC {{to manage}} user {{privileges}} (computer permissions) {{within a single}} system or application is widely accepted as a best practice. A 2010 report prepared for NIST by the Research Triangle Institute analyzed the economic value of RBAC for enterprises, and estimated benefits per employee from reduced employee downtime, more efficient provisioning, and more efficient <b>access</b> <b>control</b> <b>policy</b> administration.|$|E
40|$|Abstract. Recently, {{describing}} {{behavior of}} web services {{is becoming more}} and more important. This behavior can be described by business protocols representing the possible sequences of message exchanges. Since a lot of web services use <b>access</b> <b>control</b> <b>policies</b> to restrict the access to authorized consumers, these policies should be part of the service description. Studying the behavior of web services by analyzing their business protocol after assigning the <b>access</b> <b>control</b> <b>policies</b> is the main contribution of this work. <b>Access</b> <b>control</b> <b>policies</b> will be presented using ontology which eases policy specification and management and add some flexibility in the policy comparison. This paper introduces notions of compatibility and replaceability w. r. t. business protocols with <b>access</b> <b>control</b> <b>policies</b> annotations, together with the corresponding verification algorithms. ...|$|R
40|$|Specifying and {{managing}} <b>access</b> <b>control</b> <b>policies</b> for large distributed systems is a non [...] trivial task. Commonly, <b>access</b> <b>control</b> <b>policies</b> are specified in natural language and later reformulated {{in terms of}} a particular <b>access</b> <b>control</b> mechanism. Management of policies is thus done in terms of low [...] level constructs rather than in terms of the specification. This paper presents and discusses concepts for a declarative specification language for <b>access</b> <b>control</b> <b>policies</b> in distributed object systems such as CORBA. By providing appropriate constructs, such a language would support a unified view throughout the lifetime of a policy, i. e. through both specification and management...|$|R
5000|$|XACML — eXtensible <b>Access</b> <b>Control</b> Markup Language, a {{standard}} XML-based protocol for <b>access</b> <b>control</b> <b>policies.</b>|$|R
5000|$|In {{operating}} systems architecture a reference monitor concept defines {{a set of}} design requirements on a reference validation mechanism, which enforces an <b>access</b> <b>control</b> <b>policy</b> over subjects' (e.g., processes and users) ability to perform operations (e.g., read and write) on objects (e.g., files and sockets) on a system. The properties of a reference monitor are captured by the acronym NEAT, which means: ...|$|E
50|$|The {{claim is}} that a {{reference}} validation mechanism that satisfies the reference monitor concept will correctly enforce a system's <b>access</b> <b>control</b> <b>policy,</b> as it must be invoked to mediate all security-sensitive operations, must not be tampered, and has undergone complete analysis and testing to verify correctness. The abstract model of a reference monitor has been widely applied to any type of system that needs to enforce access control, and is considered to express the necessary and sufficient properties for any system making this security claim.|$|E
50|$|The {{access control}} domain deals with {{implementation}} of access controls across all electronic forms of information processing systems like operating systems, applications, networks or mobile platforms. Access control is the selective restriction {{of access to}} a place or other resource. Typically an organization's <b>access</b> <b>control</b> <b>policy</b> establishes the requirement of controls {{that need to be}} implemented for controlling access to information, information processing facilities and business processes on the basis of business and security requirements. The policy should aim to control the assimilation, authorization, and dissemination of information in a controlled manner. The typical organizational objectives of the <b>access</b> <b>control</b> <b>policy</b> are to establish a procedure for user registration and de-registration, establish a procedure to grant the correct level of access privilege, establish a procedure to control password use, password change and password removal, establish a procedure for managements review of access rights, establish a procedure for unattended equipment, maintain a clear desk policy, establish a procedure to control network service access, establish a control method for authentication of remote users, establish a procedure for configuration ports, establish a procedure to segregate networks, establish a procedure to use precise routing controls, establish a procedure to control system utilities and to establish a procedure to secure communications over mobile computing devices.|$|E
40|$|Abstract — <b>Access</b> <b>control</b> {{requires}} authorization {{rules and}} constraints. To express <b>access</b> <b>control</b> <b>policies,</b> several languages, such as XACML, EPAL or PONDER, are used. These languages specify which subjects can (or cannot) access sets of resources or services to perform specific actions. A user can define several <b>access</b> <b>control</b> <b>policies</b> and rules, but these <b>access</b> <b>control</b> languages {{do not offer}} any mechanism to avoid conflicts and inconsistencies among them. In fact, it can happen {{that more than a}} rule or a policy, with opposite decisions, is applicable in a given context. We propose a method based on first order logic modeling to detect and visualize possible conflicts within sets of <b>access</b> <b>control</b> <b>policies</b> expressed in XACML. We translate the model into a relational first order logic language called Alloy. Alloy allows to specify sets of predicates and assertions defining the desired properties of a system. We can then analyze interactions and conflicts among <b>access</b> <b>control</b> <b>policies</b> by using the Alloy Analyzer tool. I...|$|R
40|$|Security-sensitive environments {{protect their}} {{information}} resources against unauthorized use by enforcing <b>access</b> <b>control</b> mechanisms driven by <b>access</b> <b>control</b> <b>policies.</b> Due {{to the need}} to compare, contrast, and compose such protected information resources, <b>access</b> <b>control</b> <b>policies</b> regulating their manipulation need to be compared, contrasted, and composed. An algebra for manipulating such <b>access</b> <b>control</b> <b>policies</b> at a higher (propositional) level, where the operations of the algebra are abstracted from their specification details, {{is the subject of this}} paper. This algebra is applicable to <b>policies</b> that have <b>controlled</b> nondeterminism and all or nothing assignments of access privileges in their specification. These requirements reflect current practices in discretionary and role-based <b>access</b> <b>control</b> models. Therefore, the proposed algebra can be used to reason about role-based <b>access</b> <b>control</b> <b>policies</b> combined with other forms of discretionary policies. We show how to use algebraic identities to reason about consistency, completeness, and determinacy of composed policies using similar properties of their constituents...|$|R
40|$|We {{examine the}} problem of {{negotiating}} <b>access</b> <b>control</b> <b>policies</b> between autonomous domains. Our objective is to develop software agents that can automatically negotiate <b>access</b> <b>control</b> <b>policies</b> between autonomous domains with minimal human guidance. In this paper we show a mathematical framework {{that is capable of}} expressing many such negotiation problems, and illustrate its application to some practical scenarios...|$|R
50|$|Software-defined Protection (SDP) is a {{computer}} network security architecture and methodology that combines network security devices and defensive protections which leverage {{both internal and external}} intelligence sources. An SDP infrastructure is designed to be modular, scalable, and secure. The SDP architecture partitions the security infrastructure into three interconnected layers. The Enforcement Layer inspects traffic and enforces protection within well-defined network segments. The Control Layer generates security policies and deploys those protections to enforcement points. The Management Layer orchestrates the infrastructure and integrates security with business processes. The SDP architecture supports traditional network security and <b>access</b> <b>control</b> <b>policy</b> requirements, as well as the threat prevention required for enterprises implementing technologies such as mobile computing and Software-defined Networking (SDN).|$|E
5000|$|In {{attribute-based}} {{access control}} (ABAC), access is granted {{not based on}} the rights of the subject associated with a user after authentication, but based on attributes of the user. The user has to prove so-called claims about his attributes to the access control engine. An attribute-based <b>access</b> <b>control</b> <b>policy</b> specifies which claims need to be satisfied in order to grant access to an object. For instance the claim could be [...] "older than 18". Any user that can prove this claim is granted access. Users can be anonymous when authentication and identification are not strictly required. One does, however, require means for proving claims anonymously. This can for instance be achieved using anonymous credentials. XACML (extensible access control markup language) is a standard for attribute-based access control. XACML 3.0 was standardized in January 2013.|$|E
5000|$|Traditionally, access has {{the purpose}} of restricting access, thus most access control models follow the [...] "default deny principle", i.e. if a {{specific}} access request is not explicitly allowed, it will be denied. This behavior might conflict with the regular operations of a system. In certain situations, humans {{are willing to take}} the risk that might be involved in violating an <b>access</b> <b>control</b> <b>policy,</b> if the potential benefit that can be achieved outweighs this risk. This need is especially visible in the health-care domain, where a denied access to patient records can cause the death of a patient. Break-Glass (also called break-the-glass) try to mitigate this by allowing users to override access control decision. Break-Glass can either be implemented in an access control specific manner (e.g. into RBAC), or generic (i.e., independent from the underlying access control model).|$|E
40|$|Managing <b>access</b> <b>control</b> <b>policies</b> {{in modern}} {{computer}} {{systems can be}} challenging and error-prone, especially when multiple access policies are combined to form new policies, possibly introducing unintended consequences. In this paper we present a framework for automated verification of <b>access</b> <b>control</b> <b>policies.</b> We introduce a formal model for systematically specifying access to resources. We show that the <b>access</b> <b>control</b> <b>policies</b> in the XACML <b>access</b> <b>control</b> language can be translated to a simple form which partitions the input domain to four classes: permit, deny, error, and notapplicable. We present several ordering relations for <b>access</b> <b>control</b> <b>policies</b> {{which can be used}} to specify the properties of the policies and the relationships among them. We then show how to automatically check these ordering relations using an existing automated analysis tool. In particular, we translate XACML policies to the Alloy language and check their properties using the Alloy Analyzer. Our experimental results demonstrate that automated verification of XACML policies is feasible...|$|R
40|$|Abstract—As {{the number}} and sophistication of on-line ap-plications increase, {{there is a growing}} concern on how access to {{sensitive}} resources (e. g., personal health records) is regulated. Since ontologies can support the definition of fine-grained policies as well as the combination of heterogeneous policies, semantic technologies are expected {{to play an important role}} in this context. But understanding the implications of the <b>access</b> <b>control</b> <b>policies</b> of the needed complexity goes beyond the ability of a security administrator. Automatic support to the analysis of <b>access</b> <b>control</b> <b>policies</b> is therefore needed. In this paper we present an automatic analysis technique for <b>access</b> <b>control</b> <b>policies</b> that reduces the reachability problem for <b>access</b> <b>control</b> <b>policies</b> to satisfiability problems in a decidable fragment of first-order logic for which efficient solvers exist. We illustrate the application of our technique on an <b>access</b> <b>control</b> model inspired by a Personal Health Application of real-world complexity. Keywords-semantic-aware access control; automatic analysis; logic-based methods; I...|$|R
40|$|Abstract. Identity {{management}} and <b>access</b> <b>control</b> are essential in the enterprise IT landscape {{in order to}} <b>control</b> <b>access</b> to applications and to fulfil laws or regulations. The global competition of enterprises leads to short development cycles and fast changes of IT applications, which requires also an error-free and quick adaption of its security. The model-driven development of <b>access</b> <b>control</b> <b>policies</b> promises {{to cope with this}} situation. This work introduces an mda-based environment for generating <b>access</b> <b>control</b> <b>policies.</b> A comprehensive overview is given on the organi-sational aspects, describing details of roles, artefacts and tools involved. On this basis the four phases of a model-driven development process for <b>access</b> <b>control</b> <b>policies</b> and their organisational aspects are presented...|$|R
5000|$|Conceptually a managed card is {{essentially}} a human-friendly [...] "pointer" [...] to a Token Service—a web service (e.g. a STS) from which security tokens can be requested. A security token {{is a set of}} attribute assertions (aka claims) about some party that is cryptographically signed by the issuer (the token service acting as the authority). An r-card, contains a second [...] "pointer" [...] that points to a data entity whose attribute's values (i) shared by all parties to the r-card and (ii) form the underlying attributes that are consumed by the r-card issuer's STS and provide the values of the claims that this STS makes. By including this second [...] "pointer" [...] on the r-card, r-card holders have the potential to access and update some subset of these underlying attributes. The card issuer maintains an <b>access</b> <b>control</b> <b>policy</b> to control who has what level of access.|$|E
30|$|An <b>access</b> <b>control</b> <b>policy</b> can {{be easily}} modified: The {{modification}} of an <b>access</b> <b>control</b> <b>policy</b> shall not involve CPs: the only entity involved in the modification of an <b>access</b> <b>control</b> <b>policy</b> should be the ACP where the policy is stored.|$|E
30|$|An <b>access</b> <b>control</b> <b>policy</b> {{does not}} reveal {{anything}} about the data and the operations it protects: Access control policies should be decoupled from the data and the operations they protect. An <b>access</b> <b>control</b> <b>policy</b> should be defined taking into account solely consumer attributes.|$|E
5000|$|A policy {{language}} {{with which to}} express {{a wide range of}} <b>access</b> <b>control</b> <b>policies</b> including policies that can use consents handled / defined via OAuth.|$|R
40|$|Information Security: basic {{concepts}} • Privacy: {{basic concepts}} and comparison with security • <b>Access</b> <b>control,</b> security <b>policies,</b> and models – <b>Access</b> <b>control</b> <b>policies</b> • the matrix {{model and the}} safety problem • discretionary <b>access</b> <b>control</b> • mandatory <b>access</b> <b>control</b> • role-based and task-based <b>access</b> <b>control</b> • context-based <b>access</b> <b>control</b> • chinese wall access contro...|$|R
40|$|Part 13 : Short PapersInternational audienceIn this paper, {{we propose}} a novel {{approach}} to facilitate the administration of <b>access</b> <b>control</b> <b>policies</b> to ensure the confidentiality of data {{at the level of}} materialized views. A materialized view stores both the definition of the view and the rows resulting from the execution of the view. Several techniques and models have been proposed to <b>control</b> <b>access</b> to databases, but to our knowledge the problem of automatically generating from <b>access</b> <b>control</b> <b>policies</b> defined over base relations the <b>access</b> <b>control</b> <b>policies</b> that are needed to control materialized views is not investigated so far. We are dealing with this problem by resorting to an adaptation of query rewriting techniques. We choose to express fine-grained <b>access</b> <b>control</b> through authorization views...|$|R
