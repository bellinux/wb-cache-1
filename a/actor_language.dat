75|147|Public
5000|$|The SALSA {{programming}} language (Simple <b>Actor</b> <b>Language</b> System and Architecture) is an actor-oriented {{programming language}} that uses concurrency primitives beyond asynchronous message passing, including token-passing, join, and first-class continuations. It also supports distributed computing over the Internet with universal naming, remote communication, and migration linguistic abstractions and associated middleware. For portability, it produces Java code.|$|E
5000|$|CAL (the Cal <b>Actor</b> <b>Language)</b> is a {{high-level}} programming language [...] for writing (dataflow) actors, which are stateful operators that transform input streams of data objects (tokens) into output streams. CAL has been compiled {{to a variety}} of target platforms, including single-core processors, multicore processors, and programmable hardware. It has been used in several application areas, including video and processing, compression and cryptography. The MPEG Reconfigurable Video Coding (RVC) working group has adopted CAL as part of their standardization efforts.|$|E
50|$|The CAL <b>Actor</b> <b>Language</b> was {{developed}} in 2001 {{as part of the}} Ptolemy II project at University of California at Berkeley. CAL is a dataflow language geared towards a variety of application domains, such as multimedia processing, control systems, network processing etc. A good guide for whether dataflow might be a good choice for a given problem domains whether a description of the computation itself (as opposed to, say, the class structure or the use cases) starts with a diagram of blocks connected by arcs that denote the transmission of packets of information. If it is, chances are that this translates well into a dataflow program.|$|E
5000|$|Smalltalk and <b>Actor</b> <b>languages</b> {{permit the}} reification of blocks and messages, which are {{equivalent}} of lambda expressions in Lisp, and thisContext {{which is a}} reification of the current executing block.|$|R
40|$|This paper {{provides}} with {{an actor}} semantics using a formalism called CO-OPN (Concurrent Object Oriented Petri Nets) which is modular and incorporates both concurrency and data structuring features. <b>Actor</b> <b>languages</b> {{are the main}} model of concurrent object oriented languages, but they are rarely well formalized. CO-OPN is a structured extension of Petri nets and algebraic abstract data types. A CO-OPN specification is composed {{of a set of}} objects (algebraic abstract data types and Petri nets), and of a synchronous communication mechanism. These synchronisation mechanism are defined in order to keep object state encapsulation, allowing to specify independantly each object. The translation of an actor program into a CO-OPN specification is done by building objects for actors. The adequacy of CO-OPN to describe the semantics of concurrent object oriented languages is shown by this formal semantic description of <b>actor</b> <b>languages.</b> Some particular implementations are suggested, improving the concurrency of executions of actor programs. Keywords : Specification and verification, Formal program development methodologies, modular specification, semantics, <b>actor</b> <b>languages</b> semantics, high level Petri nets, algebraic abstract data types...|$|R
5000|$|Several early <b>actor</b> <b>languages,</b> {{including}} the Act series, supported both parallel message passing and pipelined message processing, but not promise pipelining. (Although it is technically possible {{to implement the}} last of these features in the first two, {{there is no evidence}} that the Act languages did so.) ...|$|R
50|$|As {{the student}} {{organizers}} {{realized that they}} could not sustain the organization on documentaries alone, they expanded to incorporate fictional and experimental films. While the University's classes are in session, Doc Films hosts nightly screenings of films selected from one of these categories at Max Palevsky Cinema, located in Ida Noyes Hall. Doc's screening selection is eclectic. Each quarter of the academic year, students and members of the public propose series of ten films that are somehow related to each other (filmmaker, <b>actor,</b> <b>language,</b> genre, era, theme, etc.). The Programming Committee, which consists of any interested students or members of the public, then chooses among these proposals to schedule a different series for each weeknight (Sunday through Friday). Recent films, normally delayed one quarter from their nationwide release date, are shown on weekends. Occasionally, Doc screens films which have not yet been released to the general public in the area, including The Rules of the Game and Brokeback Mountain. The goings on of the theater are also completely run by volunteers, being students or interested members of the community. These volunteers collect tickets, present films, and project film.|$|E
40|$|This paper {{describes}} a structured approach to encoding monitors in an <b>actor</b> <b>language.</b> Within a configuration of actors, {{each of which}} publishes a history, a monitor is an independent actor that triggers an action based on patterns occurring in the actor histories. The paper defines a model of monitors using features of an <b>actor</b> <b>language</b> called ESL including time, static types and higher-order functions. An implementation of monitors is evaluated {{in the context of}} a simple case study based on competitive bidding...|$|E
40|$|We {{consider}} how reflection should be introduced into an <b>actor</b> <b>language,</b> where reflection is {{a mechanism for}} allowing a program {{to have access to}} the data structures of its own processor. Rather than introducing meta-objects as in the previous work, we propose to introduce reflection through two kinds of special messages: reifying and reflecting messages. We show that the full range of reflective programming in an <b>actor</b> <b>language</b> is possible without introducing meta-objects, and argue that our approach provides a more uniform interface for actors than the meta-object approach. All the examples in this paper have been tested on our prototype actor system...|$|E
40|$|Distributed Programming is {{not easy}} and {{parallel}} objects <b>languages</b> (for instance <b>Actor</b> <b>languages)</b> are a well suited way to facilitate the programming of Distributed Architectures. Our research team works on the design and the implementation of Parallel Object Languages for Distributed Architectures (multicomputer or Workstation network). We promote a unique structuring entity for the distributed programming: We call it Cac (Communicating Active Component). A Cac is an entity which includes a local context, a mailbox and an activity running a behavioral function. A concurrent application may {{be defined as a}} set of Cac/s communicating by message sending. Before execution, the code of behavioral functions is distributed on several nodes. During execution, the Cac/s of application run concurrently on the network nodes. <b>Actor</b> <b>Languages</b> may be implemented with Cac/s. So the execution of program with Actors produces a real parallelism and a natural distribution of actors over the network. A [...] ...|$|R
40|$|This paper {{describes}} {{a system for}} designing and classifying <b>actor</b> <b>languages.</b> This system, named Actalk, which stands for actors in Smalltalk- 80, is based on some minimal kernel introducing actors into Smalltalk- 80. The Actalk kernel extends passive and sequential objects activated by synchronous message passing into active and concurrent actors communicating by asynchronous message passing. This defines a sub-world of actors embedded into the Smalltalk 80 programming language and environment, which is left unchanged. The Actalk kernel is composed of only two Smalltalk- 80 classes. Simulating current <b>actor</b> <b>languages</b> or designing new ones is achieved by defining subclasses of these two kernel classes. Consequently all such extensions are implicitly classified by the inheritance mechanism and unified into the Actalk environment. We are currently extending the standard Smalltalk- 80 programming environment to design a specific one dedicated to Actalk concurrent actors. In this paper, the moti [...] ...|$|R
40|$|AbstractIn {{this paper}} we present two <b>actor</b> <b>languages</b> and a {{semantics}} preserving translation between them. The {{source of the}} translation is a high-level language that provides object-based programming abstractions. The target is a simple functional language extended with basic primitives for actor computation. The semantics preserved is the interaction semantics of actor systems — sets of possible interactions of a system with its environment. The proof itself is of interest since it demonstrates a methodology based on the actor theory framework for reasoning about correctness of transformations and translations of <b>actor</b> programs and <b>languages</b> and more generally of concurrent object languages...|$|R
40|$|Modern {{distributed}} computing requires a secure framework capable of free code mobility. In this paper, {{we present a}} simple lambda-based <b>actor</b> <b>language</b> with extensions for mobility and security, {{as well as the}} operational semantics to reason about these topics in distributed systems. Finally, we describe our preliminary implementation results. 1...|$|E
40|$|The Agha and Hewitt Actor model [1, 13, 14] is {{a natural}} {{extension}} of the object paradigm as we know it to the field of parallel programming. The model respects the primary principles of object-oriented programming, i. e. abstraction of data and encapsulation, inheritance or delegation, communication via message-sending, modularity and homogeneity. However, it adds the principle of activity, i. e. each actor is an active, independent agent, communicating freely with other actors. This article describes one Actor model implementation on a distributed memory parallel machine: the CLAP <b>actor</b> <b>language.</b> The article is divided into two parts: # We recapitulate the main aspects of the <b>Actor</b> <b>language</b> definition and compare this language to other object-oriented languages such as Smalltalk and ABCL/ 1. We explain why we feel Actor is the best current computation model able to express, on distributed memory parallel machines, the natural parallelism of applications. # We discuss the implementati [...] ...|$|E
40|$|In this paper, we {{introduce}} an <b>actor</b> <b>language</b> {{following a}} "process algebra" notation. The {{idea is to}} define a formalism that enjoys a clean formal definition allowing the reuse of standard results {{of the theory of}} concurrency in a context where an high level object oriented specification style is preserved. To illustrate the expressive power of the language, we provide a specification of the Hurried Philosophers case study...|$|E
50|$|Henry Lieberman, Dan Theriault, et al. {{developed}} Act1, an <b>Actor</b> programming <b>language.</b> Subsequently for his masters thesis, Dan Theriault developed Act2. These early {{proof of}} concept languages were rather inefficient and not suitable for applications. In his doctoral dissertation, Ken Kahn developed Ani, which he used to develop several animations. Bill Kornfeld developed the Ether programming language for the Scientific Community Metaphor in his doctoral disseration. William Athas and Nanette Boden 1988 developed Cantor which is an <b>Actor</b> programming <b>language</b> for scientific computing. Jean-Pierre Briot 1999 developed means to extend Smalltalk 80 for Actor computations. Christine Tomlinson, Mark Scheevel, Greg Lavender, Greg Meredith, et al. 1995 at MCC developed an <b>Actor</b> programming <b>language</b> for InfoSleuth agents in Rosette.|$|R
5000|$|If {{the value}} of a future is {{accessed}} asynchronously, for example by sending a message to it, or by explicitly waiting for it using a construct such as [...] in E, then there is no difficulty in delaying until the future is resolved before the message can be received or the wait completes. This is the only case to be considered in purely asynchronous systems such as pure <b>actor</b> <b>languages.</b>|$|R
50|$|A {{theory of}} first-person {{sentences}} examines {{the expression of}} the intentions of the <b>actor(s)</b> through <b>language</b> and in the first-person.|$|R
40|$|All rights reserved. This {{dissertation}} {{may not be}} {{reproduced in}} whole or in part, by photocopying or other means, without the permission of the author. ii Supervisor: Dr. M. Cheng The Timed Actor model is a concurrent coordination model which extends the basic Actor model of [1] by providing timers and facilities for atomic message processing with local checkpointing. The semantics of our Timed Actor model allows the specification of a timed <b>actor</b> <b>language</b> called COOL, and a virtual machine to accommodate our timed <b>actor</b> <b>language.</b> COOL is the basis of our approach for modelling and implementing distributed applications. COOL provides a high-level description language for specifying the interface, behaviour and coordination of actors. COOL allows a practitioner to specify the expected behaviour of actors by defining the performance and coordination properties of actors. These checkable properties are compilable into online monitors. At run-time monitored activity (observed behaviour) is logged in a format amenable to offline trace analysis. Our trace analyzer validates a COOL specification by comparing observed to expected behaviour. Examiners...|$|E
30|$|The CAL {{dataflow}} language [2] {{was developed}} to address these issues, specifically with a goal to synthesize high-level programs into efficient parallel hardware (see Section 3.2). CAL is an <b>actor</b> <b>language</b> in which program executes based on tokens; therefore, suitable for data intensive algorithms such as in DSP that operates on multiple data. The language was also chosen by the ISO/IECa as a language for the description and specification of video codecs.|$|E
40|$|We discuss {{correctness}} preserving {{transformations of}} specifications {{in the passage}} from the Information viewpoint to the Computational viewpoint of the ODP ISO reference model. In our transformation exercise we use two relatively simple languages {{for each of these}} viewpoints; a class [...] oriented language for the Information viewpoint with the separation of actions from classes as the main distinguishing feature. For the Computational viewpoint the language chosen is a variant of the <b>Actor</b> <b>language...</b>|$|E
30|$|At {{the end of}} {{this period}} we find {{ourselves}} in a situation of cognitive dissonance: the generation who made the strongest effort for the affirmation of planning is now retiring, the tools which have been elaborated to plan urban and metropolitan development are loosing their capacity, spatial relations are re-defined by the immaterial flows of information, the process of fragmentation produces a multiplication of <b>actors,</b> <b>languages,</b> spaces, which are different from the traditional ones.|$|R
40|$|Experiences with {{object-oriented}} group {{support software}} development This paper describes practical {{design and implementation}} experiences gained when creating Group Support Systems (GSS) in a networked personal computer environment. Examples of GSS based on the shared context model and implemented using C, C+ +, and <b>Actor</b> <b>languages</b> are presented. Graphical user interfaces and multitasking extend traditional methods for supporting group work. An objectoriented communication system is introduced comprised of objects that provide support for all inter- and intraprocessor communication...|$|R
40|$|International audienceTo program {{parallel}} systems {{efficiently and}} easily, {{a wide range}} of programming models have been proposed, each with different choices concerning synchronization and communication between parallel entities. Among them, the actor model is based on loosely coupled parallel entities that communicate by means of asynchronous messages and mailboxes. Some <b>actor</b> <b>languages</b> provide a strong integration with object-oriented concepts; these are often called active object languages. This paper reviews four major actor and active object languages and compares them according to carefully chosen dimensions that cover central aspects of the programming paradigms and their implementation...|$|R
40|$|The MPEG Reconfigurable Video Coding (RVC) {{framework}} aims {{to provide}} a unified specification of all video technology. In the RVC framework, a decoder is build in a modular manner as a configuration of video tools taken from the MPEG toolbox library. The elements of the library are specified using the CAL <b>Actor</b> <b>Language</b> (CAL). CAL is a data flow based language providing computation models that are concurrent and modular. This paper describes a synthesis tool that from a CAL specification generates an executable SW module. Code generators are fundamental supports for the deployment and success of the MPEG RVC framework. This paper focuses on the automatic translation of a CAL action, {{which is the first}} step to a complete actor translation. The techniques described here is capable of automatically generating C executable code according to a finite set of rules. This approach has been used to obtain a C implementation of the IDCT module which is one element of the RVC library. The generated code is validated versus the original CAL description and simulated using the Open Dataflow environment. Index Terms — MPEG RVC, Caltrop <b>Actor</b> <b>Language</b> 1...|$|E
40|$|This paper {{presents}} an agent-based simulation platform for evaluating management concepts {{in the domain}} of logistics. It is based on a discrete event simulator HIDES and extends it by adding a third layer, the management level. This management level comprises a management system including an agent community, where agents are in charge of the operational tasks in the logistics system. The management system is designed according to an adaptation of the Viable System Model. Agents are implemented using the ACTALK framework, a generic <b>actor</b> <b>language...</b>|$|E
40|$|ORCA is a {{concurrent}} {{and parallel}} garbage collector for actor programs, {{which does not}} require any STW steps, or synchronization mechanisms, {{and that has been}} designed to support zero-copy message passing and sharing of mutable data. ORCA is part of a runtime for actor-based languages, which was co-designed with the Pony programming language, and in particular, with its data race free type system. By co-designing an <b>actor</b> <b>language</b> with its runtime, it was possible to exploit certain language properties in order to optimize performance of garbage collection. Namely, ORCA relies on the guarantees of absence of race conditions in order to avoid read/write barriers, and it leverages the actor message passing, for synchronization among actors. In this paper we briefly describe Pony and its type system. We use pseudo-code in order to introduce how ORCA allocates and deallocates objects, how it shares mutable data without requiring barriers upon data mutation, and how can immutability be used to further optimize garbage collection. Moreover, we discuss the advantages of co-designing an <b>actor</b> <b>language</b> with its runtime, and we demonstrate that ORCA can be implemented in a performant and scalable way through a set of micro-benchmarks, including a comparison with other well-known collectors. UPMAR...|$|E
40|$|Process types, synchronization, type systems, race-free programs. Process types – {{a kind of}} {{behavioral}} types – specify constraints on message acceptance {{for the purpose of}} synchronization and to determine object usage and component behavior in object-oriented languages. So far process types have been regarded as a purely static concept for <b>Actor</b> <b>languages</b> incompatible with inherently dynamic programming techniques. We propose solutions of related problems causing the approach to become useable in more conventional dynamic and concurrent languagues. The proposed approach can ensure message acceptability and support local and static checking of race-free programs. ...|$|R
40|$|Abstract. Charm++ is a {{parallel}} programming system that {{evolved over the}} past 20 years to become a well-established system for program-ming parallel science and engineering applications, {{in addition to the}} combinatorial search applications with which it started. At its earliest point, the precursor to Charm++, the Chare Kernel, was a purely reac-tive specification, similar to most <b>actor</b> <b>languages.</b> This paper describes the evolution of a series of concurrency control mechanisms that have been deployed in Charm++ to tame this unrestricted concurrency in order to improve code clarity and/or to improve performance. ...|$|R
50|$|The <b>Actor</b> {{programming}} <b>language</b> {{was invented}} by Charles Duff of The Whitewater Group in 1988. It was an offshoot of some object-oriented extensions to the Forth language {{he had been working}} on.|$|R
40|$|Abstract: The Agha and Hewitt Actor model [1, 13, 14] is {{a natural}} {{extension}} of the object paradigm as we know it to the field of parallel programming. The model respects the primary principles of object-oriented programming, i. e. abstraction of data and encapsulation, inheritance or delegation, communication via message-sending, modularity and homogeneity. However, it adds the principle of activity, i. e. each actor is an active, independent agent, communicating freely with other actors. This article describes one Actor model implementation on a distributed memory parallel machine: the CLAP <b>actor</b> <b>language.</b> The article is divided into two parts: � We recapitulate the main aspects of the <b>Actor</b> <b>language</b> definition and compare this language to other object-oriented languages such as Smalltalk and ABCL/ 1. We explain why we feel Actor is the best current computation model able to express, on distributed memory parallel machines, the natural parallelism of applications. � We discuss the implementation, currently in its final phase, of the Actor model on a distributed memory parallel machine, and why choices and compromises were made during the process, i. e. object grain size, the choice of programming language (C++), operating system (Helios), message transmission structures (RPC+XDR), delegation vs inheritance, etc. We then provide an example of a program in CLAP language...|$|E
40|$|The transactor model, an {{extension}} to the actor model, spec-ifies an operational semantics to model concurrent systems with globally consistent distributed state. The semantics for-malizes tracks dependencies among loosely coupled dis-tributed components to ensure fault tolerance through a two-phase commit protocol and to issue rollbacks {{in the presence}} of failures or state inconsistency. In this paper, we introduce the design of a transactor language as {{an extension}} of an ex-isting <b>actor</b> <b>language</b> and highlight the capabilities of this programming model. We developed our transactor language using SALSA, an <b>actor</b> <b>language</b> developed as a dialect of Java. We first develop a basic transactor SALSA/Java library, which implements the fundamental semantics of the trans-actor model following the operational semantics ’ transition rules. We then illustrate two example programs written us-ing this library. Furthermore, we introduce a state storage abstraction known as the Uniform Storage Locator follow-ing the Universal Actor Name and Universal Actor Loca-tor abstractions from SALSA that uses a storage service to maintain checkpointed transactor states. The transactor model guarantees safety but not progress. Therefore, to help develop realistic transactor programs that make progress, we introduce the Consistent Distributed State Protocol and Ping Director that improve upon the Universal Checkpoint-ing Protocol to aid transactor programs in reaching globally consistent distributed states...|$|E
40|$|International audienceThe MPEG Reconfigurable Video Coding {{working group}} is {{developing}} a new library-based process for building the reference codecs of future MPEG standards, {{which is based on}} dataflow and uses an <b>actor</b> <b>language</b> called Cal. The paper presents a code generator producing RTL targeting FPGAs for Cal, outlines its structure, and demonstrates its performance on an MPEG- 4 Simple Profile decoder. The resulting implementation is smaller and faster than a comparable RTL reference design, and {{the second half of the}} paper discusses some of the reasons for this counter-intuitive result...|$|E
40|$|The object {{oriented}} programming style used in the Smalltalk and <b>Actor</b> <b>languages</b> is available in Lisp Machine Lisp, and used by the Lisp Machine software system. It is used to perform generic operations on objects. Part of its implementation is simply a convention in procedure calling style; part is a powerful language feature, called Flavors, for defining abstract objects. This chapter attempts to explain what programming with objects and with message passing means, the various means of implementing these in Lisp Machine Lisp, and when you should use them. It assumes no prior knowledge of any other languages...|$|R
5000|$|Nigar Award for Best <b>Actor</b> in Punjabi <b>language</b> film Ziddi (1973 film) ...|$|R
40|$|Uniform is an AI {{programming}} language under development based upon augmented unification. It {{is an attempt}} to combine, in a simple coherentframework, the most important features of Lisp, <b>actor</b> <b>languages</b> such as Act 1 and SmallTalk, and logic {{programming language}}s such as Prolog. Among the unusual abilities of the language is its ability to use the same program as a function, an inverse function, a predicate, a pattern, or a generator. All of these uses can be performed upon concrete, symbolic, and partially instantiated data. Uniform features automatic inheritance from multiple 3 uper classes, facilities for manipulation of programs, a limited ability to determine progra...|$|R
