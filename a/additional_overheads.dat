64|1078|Public
40|$|International audienceWe use the rho-calculus as an {{intermediate}} language {{in the implementation of}} functional languages with pattern-matching features, and define an interaction net encoding of the rho-terms arising from the compilation, where pattern-matching and 'traditional' rho-reduction can proceed in parallel without <b>additional</b> <b>overheads...</b>|$|E
40|$|Previous {{studies showed}} that {{adaptive}} random testing is an effective alternative to random testing method, but requires <b>additional</b> <b>overheads</b> to evenly spread test cases. Mirroring was introduced to reduce the overheads of adaptive random testing. This paper is the follow-up work to a previous study on the integration of mirroring and adaptive random testing, namely the mirror adaptive random testing. It studies characteristics and effectiveness of mirror adaptive random testing in depth, and provides guidelines on how to apply mirror adaptive random testing in practice...|$|E
40|$|Wireless ad-hoc {{networks}} are characterised {{by lack of}} infrastructure and frequent topological changes. Traditional routing protocols seek only single paths to the desired destinations, while multipath routing obtains multiple paths for only marginal additional overhead. This work argues that multipath routing is advantageous, even allowing for the <b>additional</b> <b>overheads,</b> because of the unproved network load distntiution. ihe ments ot multipatn rouung are snown tnrougn extensive performance evaluation considering packet delivery ratio, average end-to-end delay and routing efficiency, for both mobile and static scenarios. EThOS - Electronic Theses Online ServiceGBUnited Kingdo...|$|E
5000|$|<b>Additional</b> <b>overhead</b> imposed over network {{because all}} {{fragments}} contains their own IP header. <b>Additional</b> <b>overhead</b> = (number_of_fragments - 1) * (ip_header_len); ...|$|R
5000|$|Furthermore, {{the data}} type of its {{arguments}} is [...] If the function is called with arguments of other types (variables or literals), {{there will be}} <b>additional</b> <b>overhead</b> to convert these to [...] There may also be <b>additional</b> <b>overhead</b> to check the argument types and convert one of them {{if they do not}} have the same type.|$|R
50|$|ODUk {{contains}} the OPUk with <b>additional</b> <b>overhead</b> bytes (e.g. TTI, BIP8, GCC1/2, TCM etc.).|$|R
40|$|Abstract. This paper {{presents}} {{a new version}} of the OMPi OpenMP C compiler, enhanced by lightweight runtime support based on user-level multithreading. A large number of threads can be spawned for a parallel region and multiple levels of parallelism are supported efficiently, without introducing <b>additional</b> <b>overheads</b> to the OpenMP library. Management of nested parallelism is based on an adaptive distribution scheme with hierarchical work stealing that not only favors computation and data locality but also maps directly to recent architectural developments in shared memory multiprocessors. A comparative performance evaluation of several OpenMP implementations demonstrates the efficiency of our approach. ...|$|E
40|$|Certificate-based {{public key}} {{infrastructures}} are currently {{widely used in}} computational grids to support security services. From a user’s perspective, however, certificate acquisition is time-consuming and public/private key management is non-trivial. In this paper, we propose a security infrastructure for grid applications, in which users are authenticated using passwords. Our infrastructure allows a user to perform single sign-on based only on a password, without requiring a public key infrastructure. Moreover, hosting servers in our infrastructure {{are not required to}} have public key certificates. Nevertheless, our infrastructure supports essential grid security services, such as mutual authentication and delegation, using public key cryptographic techniques without incurring significant <b>additional</b> <b>overheads</b> in comparison with existing approaches...|$|E
40|$|In {{nowadays}} wireless networks, mobile users frequently {{access context}} dependent Internet services. During handover procedures, {{the management of}} context related information introduces <b>additional</b> <b>overheads</b> to transfer context-aware service sessions. The overhead due to context transfer procedures may {{affect the quality of}} service perceived by mobile users making more difficult to realize seamless handover procedures. Context Transfer Protocol can improve the QoS perceived by mobile nodes that access context dependent services. In this paper we extend motivations for context transfer, and we introduce three different scenarios for Context Transfer Protocol. We propose a performance model to compare these scenarios when context transfer protocol run on top of IPv 6 with fast handover mechanisms...|$|E
2500|$|Instruction set {{simulators}} for monitoring, tracing and debugging where <b>additional</b> <b>overhead</b> is kept to {{a minimum}} ...|$|R
5000|$|Networking {{is based}} on {{isolation}} rather than virtualization, {{so there is no}} <b>additional</b> <b>overhead</b> for packets.|$|R
3000|$|... [...]. This {{is exactly}} the <b>additional</b> <b>overhead</b> {{incurred}} by deciding to adopt an ONDM framework instead of developing against the native client API.|$|R
40|$|The {{ability to}} {{securely}} run arbitrary untrusted code {{on a wide}} variety of execution platforms is a challenging problem in the Grid community. One way to achieve this is to run the code inside a contained, isolated environment, namely a "sandbox". Virtual machines provide a natural solution to the security and resource management issues that arise in sandboxing. We explore different designs for the VM-enabled sandbox and evaluate them with respect to various factors like structure, security guarantees, user convenience, feasibility and overheads in one such grid environment. Our experiments indicate that the use of on-demand VMs imposes a constant startup overhead, with I/O-intensive applications incurring <b>additional</b> <b>overheads</b> depending on the design of the sandbox...|$|E
30|$|The most {{frequently}} used method to carry IP datagrams over MPEG TS is Multiprotocol Encapsulation (MPE);however, MPEG TS is a protocol optimized for broadcasting and not for IP services, so MPE suffers from design constrains as DVB protocol use MPEG TS at the link layer. If we consider the channel bandwidth efficiency, the encapsulation of IP datagrams by the MPEG TS MPE adds <b>additional</b> <b>overheads</b> to the transmitted data, thus reducing efficiency compared to GSE {{that is designed to}} carry general data, mainly over IP protocol. GSE efficiently encapsulates IP datagrams over variable length link layer packets, which are then directly inserted to the physical layer baseband frames. If IP datagrams use GSE, the reduction in overhead is more than two times compared to MPEG-TS transmission.|$|E
40|$|Abstract — We propose k-SACK, a TCP variant {{that has}} {{considerably}} improved throughput characteristics over lossy links. A k-SACK source {{does not consider}} every packet loss {{as an indication of}} congestion. It uses the Selective Acknowledgement option to estimate a parameter lookaheadloss, which is used in congestion detection. Our results demonstrate that k-SACK maintains a steady performance in a non-lossy environment while showing considerable performance improvement over paths spanning lossy links. Throughput gains of more than 90 % are observed over links with packet loss rates of the order of 5 %. We show that when k-SACK is used over wireline internet links, it does not harm the existing TCP variants significantly. k-SACK is simple to implement and does not involve any <b>additional</b> <b>overheads...</b>|$|E
5000|$|This toolkit {{provides}} the error correcting capability {{to the most}} sensitive parts of the payload {{in order to keep}} the <b>additional</b> <b>overhead</b> low.|$|R
3000|$|... -hop {{interference}} range. For scheduled {{communication with}} randomized slot assignment, {{it is essential}} that scheduling conflicts are eliminated implicitly and incur no <b>additional</b> <b>overhead.</b>|$|R
50|$|Time permitting, DFPs can be {{enlarged}} {{to allow}} a machine gun crew and ammunition to be protected, as well as <b>additional</b> <b>overhead</b> cover via timbers.|$|R
30|$|The second {{approach}} {{is more powerful}} than the first approach but requires <b>additional</b> <b>overheads</b> in terms of processing and storage. The second solution is based on data mining and machine learning techniques. In the paper, we demonstrated that our tools first allow new ILs for collecting data and ALs for controlling hardware elements can be easily added to the framework. At the opposite of the existing methods, where the user needs and behaviors are rarely taken into account, in our second solution, we not only take these elements into account but we also classify possible running applications, in terms of resources needs, and we predict the future applications. In comparison to the advanced energy management provided by windows 8.1, for some situations the gain offered by our approach reaches 30 %.|$|E
40|$|Introduction A problem-specific hand-written discrete-event {{simulation}} {{can often}} run very {{much faster than}} an equivalent model written using a simulation package. Why? Overheads. Overheads arise from support for features whose implementations are complex, such as process orientation or modularity; in a parallel context <b>additional</b> <b>overheads</b> arise from synchronization and communication. While modeler productivity can be improved using packages, a user can unwittingly use expensive features when constructing a model, and then find that its execution does not meet his performance requirements. We are engaged in developing a simulator, SIM. CC, suitable for (but not exclusively for) simulation of very large telecommunications systems. One of our design goals has been to provide the simulator with features that simplify the expression of models, but whose implementation still provides a satisfactory level of performance and capability. Still, there are trade-offs to be made. Using...|$|E
40|$|Banking a {{processor}} cache enables non-conflicting reads to occur simultaneously, similar to having multiple read ports. However, bank conflicts expose this faux read port when two accesses must be serialized. We propose BARS, Banked Array of Redundant SRAMs, to emulate a multi-ported cache without paying {{the high price}} for true multiple ports. BARS is influenced directly by RAID techniques for high performance reliable disk storage. While the driving motivation for BARS is to reduce bank conflicts, {{it can also be}} used to increase reliability against errors while still maintaining excellent performance. We approximate the <b>additional</b> <b>overheads</b> required by BARS, such as control complexity, power, etc. Then, using CACTI, we simulate the area, power, and latency of a BARS cache versus a true multi-ported cache. Our preliminary findings show up to a 39 % improvement in area when using BARS without compromising performance. ...|$|E
30|$|Code {{inspection}} in Hibernate OGM {{revealed that}} this platform extensively re-uses components from the Hibernate ORM engine, which {{may result in}} <b>additional</b> <b>overhead</b> due to architectural legacy.|$|R
30|$|In this section, we {{analyze the}} control {{overhead}} {{imposed by the}} OLSR protocol, {{as well as the}} <b>additional</b> <b>overhead</b> introduced by the use of pseudonyms in our HOP solution.|$|R
5|$|Once Perl code is compiled, {{there is}} <b>additional</b> <b>overhead</b> during the {{execution}} phase that typically isn't present for programs written in compiled languages such as C or C++. Examples of such overhead include bytecode interpretation, reference-counting memory management, and dynamic type-checking.|$|R
40|$|In this paper, {{we address}} the problem of {{synthesis}} of application specific multiprocessor SoC architectures for process networks of streaming applications. An application is modeled as Kahn Process Network (KPN) which makes the parallelism present in the application explicit. The synthesis process involves selection of computation modules, memory modules, communication architecture and mapping of processes of KPN on compute units and channels on memory modules. Our solution minimizes hardware cost while taking into account the performance constraints. One of the salient features of our work is that it takes into account the <b>additional</b> <b>overheads</b> because of data communication conflicts. Our method uses average processing requirements of KPN to handle data dependent behavior of processes and cycles within the KPN. In contrast to others, we do not perform static scheduling, only mapping and synthesis is done. 1...|$|E
40|$|In this paper, we {{introduce}} a novel garbage collector for Java {{to be used}} for processors with speculative threads support like the Hydra chip multiprocessor (CMP). Thread speculation permits parallel execution of sections of sequential code with data dependencies enforced in the hardware, eliminating the need for explicit locking. We have augmented Dijkstra’s classical on-the-fly mark and sweep collector {{to take advantage of the}} CMP’s thread-level speculation and low-latency interprocessor communication. The resulting collector can execute concurrently without an explicit collector thread or can increase the collection rate by executing in parallel on all free processors. A dynamically scalable collector provides more control to adjust collection behavior according to the total system load and real-time deadlines. Speculative threads ensured the scalable implementation was simple and required no <b>additional</b> <b>overheads,</b> but we were unable to observe additional performance gains from eliminated explicit synchronization. 1...|$|E
40|$|Opportunistic routing (OR) {{is widely}} {{regarded}} as a promising way to improve the transmission reliability in wireless multi-hop networks. However, <b>additional</b> <b>overheads</b> introduced by OR such as duplicate transmission and collision avoidance overhead degrade the transmission efficiency. In this paper, an analytical model based on open queueing network with markov chains is proposed to evaluate the efficiency. In the analysis, efficiency is expressed by time overhead including the average queue delay and the back off time to transmit. With the knowledge of delivery ratio, the closed form expressions of time overhead could be obtained. In order to validate rationality of the model, three typical ORs were analyzed based on the proposed model {{and at the same time}} a large number of simulation studies have been done. We observed that theoretical value of the proposed model coincides basically with the experimental data with the average error less than 5 %...|$|E
50|$|The in-place technique, which decompresses the {{executable}} into memory, is {{not possible}} on all supported platforms. The rest uses extraction to temporary file. This procedure involves <b>additional</b> <b>overhead</b> and other disadvantages; however, it allows any executable file format to be packed.|$|R
5000|$|Live VM {{migration}} issues: Executing resource-intensive {{mobile application}} via Virtual Machine (VM) migration-based application ofﬂoading involves encapsulation of application in VM instance and migrating {{it to the}} cloud, which is a challenging task due to <b>additional</b> <b>overhead</b> of deploying and managing VM on mobile devices.|$|R
30|$|Performance optimization: As network {{functions}} are executed {{on top of}} a hypervisor (e.g., KVM and Xen), <b>additional</b> <b>overhead</b> is introduced, leading to network performance degradation. Optimization of legacy hypervisors and the introduction of new virtualization technologies (e.g., Docker) are plausible solutions towards minimizing overhead and latency.|$|R
40|$|In this paper, {{we propose}} a {{technique}} for video object segmentation using patch seams across frames. Typically, seams, which are connected paths of low energy, are utilised for retargeting, where the primary {{aim is to}} reduce the image size while preserving the salient image contents. Here, we adapt the formulation of seams for temporal label propagation. The energy function associated with the proposed video seams provides temporal linking of patches across frames, to accurately segment the object. The proposed energy function takes into account the similarity of patches along the seam, temporal consistency of motion and spatial coherency of seams. Label propagation is achieved with high fidelity in the critical boundary regions, utilising the proposed patch seams. To achieve this without <b>additional</b> <b>overheads,</b> we curtail the error propagation by formulating boundary regions as rough-sets. The proposed approach out-perform state-of-the-art supervised and unsupervised algorithms, on benchmark datasets...|$|E
40|$|It {{is known}} that {{grouping}} nodes gives better performance to the group and to the whole system, thereby avoiding unnecessary message forwarding and <b>additional</b> <b>overheads</b> while allows to scale the network considerably. Many routing protocols for ad-hoc networks and sensor networks have been designed, {{but none of them}} is based on groups. In this paper, after a review of group based architectures and of neighbor selection strategies, a planar group-based network architecture is proposed. In the proposal, the network is formed by several groups of ad-hoc devices or sensors. Connections between groups are established {{as a function of the}} proximity and the neighbor's available capacity (based on the ad-hoc device or sensor’s energy). The messages that are needed to the proper operation are shown. It is also simulated how much time is needed to propagate information between groups and it is calculated the diameter for different topologie...|$|E
40|$|Multithreading {{provides}} a means of improving program performance by exposing concurrency. This concurrency can be exploited to hide latency caused by network operations and allows the work in a program to be divided among multiple processors. Thus, multithreading can provide better performance on both single and multiprocessor computers. However, multithreaded programming incurs <b>additional</b> <b>overheads</b> to enable the program to switch between different threads, ensure threads can be restarted, and prevent race conditions in the runtime system. The costs of providing a multithreaded environment set a minimum task size that can be profitably exploited and the minimum amount of latency that can be hidden by other read-to-run threads. This paper examines the costs of basic multithreaded operations on a dual-processor Pentium II PC running Linux. The operations for user-level threads (PMPtheads 1. 8. 7) are significantly less expensive than the kernel-level threads (LinuxThreads 0. 6). The costs o [...] ...|$|E
40|$|At Crypto 2003 Ishai et al. gave a {{protocol}} which given {{a small number}} of (possibly extremely inefficient) oblivious transfers implements an essentially unbounded number of oblivious transfers for an <b>additional</b> <b>overhead,</b> per oblivious transfer, of computing and sending only two hash values. This highly efficient protocol is however only passive secure. To get active security, except with probability 2 −m, the protocol had to suffer an <b>additional</b> <b>overhead</b> of a factor 1 + m. We introduce a new approach to adding robustness. For practical security parameters this approach allows to add robustness while suffering only a small constant overhead over the passive secure protocol. As an example we can generate one million oblivious transfers with security 2 − 42 with an amortized cost of just 9 hash values per oblivious transfer. ...|$|R
25|$|In {{the autumn}} of 2010 debuted the new German company Vossloh Kiepe hybrid system model. It can be {{distinguished}} by <b>additional</b> <b>overhead</b> panels inside. In the engine compartment next to the Cummins engine is an electric traction system, which allows itself to be {{turned off by the}} use of the hybrid engine.|$|R
40|$|This {{project has}} two primary purposes. The first, is to {{implement}} a distributed matrix multiply algorithm using C++ sockets, and Corba objects {{with the objective of}} discovering what <b>additional</b> <b>overhead,</b> if any, exists in a Corba implementation. Secondly, attempt to improve the speedup through the use of stateful servers in the C++ implementation...|$|R
