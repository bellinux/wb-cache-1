316|1062|Public
25|$|In 1954 Hopper {{was named}} the company's first {{director}} of <b>automatic</b> <b>programming,</b> and her department released {{some of the first}} compiler-based programming languages, including MATH-MATIC and FLOW-MATIC.|$|E
2500|$|... 1964: Hopper {{was awarded}} the Society of Women Engineers Achievement Award, the Society’s highest honor, “In {{recognition}} of her significant contributions to the burgeoning computer industry as an engineering manager and originator of <b>automatic</b> <b>programming</b> systems.”.|$|E
2500|$|In 1949, Hopper {{became an}} {{employee}} of the Eckert–Mauchly Computer Corporation as a senior mathematician and joined the team developing the UNIVAC I. [...] Hopper also served as UNIVAC director of <b>Automatic</b> <b>Programming</b> Development for Remington Rand. The UNIVAC was the first known large-scale electronic computer to be on the market in 1950, [...] and was more competitive at processing information than the Mark I.|$|E
40|$|Abstract. The {{object-oriented}} {{style of}} programming facilitates program adaptation and enhances program genericness, {{but at the}} expense of efficiency. <b>Automatic</b> <b>program</b> specialization can be used to generate specialized, efficient implementations for specific scenarios, but requires the program to be structured appropriately for specialization and is yet another new concept for the programmer to understand and apply. We have unified <b>automatic</b> <b>program</b> specialization and inheritance into a single concept, and implemented this approach in a modified version of Java named JUST. When programming in JUST, inheritance is used to control the <b>automatic</b> application of <b>program</b> specialization to class members during compilation to obtain an efficient implementation. This paper presents the language JUST, which integrates object-oriented concepts, block structure, and techniques from <b>automatic</b> <b>program</b> specialization to provide both a generative programming language where object-oriented designs can be efficiently implemented and a simple yet powerful <b>automatic</b> <b>program</b> specializer for an object-oriented language. ...|$|R
5000|$|Partial {{evaluation}} - {{a related}} technique for <b>automatic</b> <b>program</b> optimization ...|$|R
40|$|NUT is a {{programming}} system for knowledge-based programming with facilities for <b>automatic</b> <b>program</b> synthesis. The system allows to specify computational problems in OO style. Concepts and objects {{can be treated}} in NUT as functional constraint networks. Constraint satisfaction problems are solved using algorithms for <b>automatic</b> <b>program</b> synthesis described earlier for the PRIZ system...|$|R
2500|$|In 1954, Eckert–Mauchly chose Hopper to {{lead their}} {{department}} for <b>automatic</b> <b>programming,</b> and {{she led the}} release {{of some of the}} first compiled languages like FLOW-MATIC. In 1959, she participated in the CODASYL consortium, which consulted Hopper to guide them in creating a machine-independent programming language. This led to the COBOL language, which was inspired by her idea of a language being based on English words. In 1966, she retired from the Naval Reserve, but in 1967, the Navy recalled her to active duty. [...] She retired from the Navy in 1986 and found work as a consultant for the Digital Equipment Corporation, sharing her computing experiences.|$|E
5000|$|... <b>automatic</b> <b>programming</b> for {{computer-assisted}} telephone interviewing systems ...|$|E
5000|$|... 2014 <b>Automatic</b> <b>programming</b> POCSAG Transmitter, TE-505NA, TE-505RA ...|$|E
5000|$|He {{received}} the Turing Award in 1978 [...] "for having a clear influence on methodologies {{for the creation}} of efficient and reliable software, and for helping to found the following important subfields of computer science: the theory of parsing, the semantics of <b>programming</b> languages, <b>automatic</b> <b>program</b> verification, <b>automatic</b> <b>program</b> synthesis, and analysis of algorithms".|$|R
5000|$|Automatic Exposure Control: Fully <b>automatic</b> <b>program</b> exposure, EV 5.5-17 in ISO 100 ...|$|R
50|$|<b>Automatic</b> <b>program</b> {{synthesis}} {{began in}} the artificial intelligence field, with software intended for automatic problem solving. The first program synthesizer was developed by Cordell Green in 1969. At about the same time, mathematicians including R. Constable, Z. Manna, and R. Waldinger explained the possible use of formal logic for <b>automatic</b> <b>program</b> synthesis. Practically applicable program synthesizers appeared considerably later.|$|R
50|$|Martin {{then worked}} in <b>automatic</b> <b>programming,</b> {{knowledge}} representation and natural language processing.|$|E
5000|$|XML {{data binding}} for C and C++ based on <b>automatic</b> <b>programming</b> with source-to-source code {{generation}} ...|$|E
50|$|Program {{synthesis}} is {{one type}} of <b>automatic</b> <b>programming</b> where a procedure is created from scratch, based on mathematical requirements.|$|E
40|$|<b>Automatic</b> <b>program</b> {{specialization}} is {{a software}} engineering technique that configures a program fragment by generating an implementation {{dedicated to a}} specific usage context. Given a generic component that solves a whole family of problems and that is implemented in a standard programming language, program specialization can automatically configure this component by generating a specialized implementation. We consider <b>automatic</b> <b>program</b> specialization implemented using partial evaluation, which performs aggressive interprocedural constant propagation of all data types, and performs constant folding and control-flow simplifications based on the usage context [1]. <b>Automatic</b> <b>program</b> specialization has recently been defined {{in the context of}} object-oriented languages, and is here referred to as object-oriented program specialization [4, 5, 6, 7, 8]. As part of this work, we have developed an <b>automatic</b> <b>program</b> specializer for Java, named JSpec, which has been shown to give significant execution-time speedups on large programs. Specialization of an object-oriented program generates new, specialized methods...|$|R
40|$|Abstract. <b>Automatic</b> <b>program</b> {{comprehension}} applications, which try {{to extract}} programming knowledge from program code, share many features of human program comprehension models. However, the human trait of learning {{seems to be}} missing among the shared features. We present an approach to integrate machine learning techniques into <b>automatic</b> <b>program</b> comprehension, and present an example implementation {{in the context of}} automatic analysis of roles of variables...|$|R
5000|$|Neil D. Jones, Carsten K. Gomard, and Peter Sestoft: Partial Evaluation and <b>Automatic</b> <b>Program</b> Generation Book, {{full text}} {{available}} online.|$|R
50|$|Peter Nordin is a Swedish {{computer}} scientist, entrepreneur {{and author}} who {{has contributed to}} artificial intelligence, <b>automatic</b> <b>programming,</b> machine learning, and evolutionary robotics.|$|E
50|$|In 1954 Hopper {{was named}} the company's first {{director}} of <b>automatic</b> <b>programming,</b> and her department released {{some of the first}} compiler-based programming languages, including MATH-MATIC and FLOW-MATIC.|$|E
50|$|In {{computer}} science, {{the term}} <b>automatic</b> <b>programming</b> identifies {{a type of}} computer programming in which some mechanism generates a computer program to allow human programmers to write the code at a higher abstraction level.|$|E
40|$|Abstract. We {{present a}} method for <b>automatic</b> <b>program</b> {{inversion}} in a first-order functional programming language. We formalize the transfor-mation and illustrate it with several examples including the automatic derivation of a program for run-length decoding from a program for run-length encoding. This derivation is not possible with other <b>automatic</b> <b>program</b> inversion methods. One of our key observations is that the du-plication of values and testing of their equality are {{two sides of the}} same coin in program inversion. This leads us to the design of a new self-inverse primitive function that considerably simplifies the <b>automatic</b> inversion of <b>programs.</b> ...|$|R
40|$|NUT is a {{programming}} system for knowledge-based programming with facilities for <b>automatic</b> <b>program</b> synthesis. The system allows to specify computational problems in OO style. Concepts and objects {{can be treated}} in NUT as functional constraint networks. Constraint satisfaction problems are solved using algorithms for <b>automatic</b> <b>program</b> synthesis described earlier for the PRIZ system. 1. 1 Introduction The NUT system is the most advanced representative {{of the family of}} {{programming system}}s called PRIZ. This family includes systems PRIZ ES, Solver, MicroPRIZ, ExpertPRIZ, NUT etc., which have been developed in the last 20 years in the Institute of Cybernetics of the Estonian Academy of Sciences. All these systems support a knowledge-based programming style and they have been successfully used to solve engineering problems as well as in scientific investigations of AI. The NUT language was outlined as an extension of an object-oriented programming language with features of <b>automatic</b> <b>program</b> sy [...] ...|$|R
40|$|One point {{made here}} is that formal {{constructive}} mathematics {{can be interpreted as}} a "high-level" programming language; another point is that there are good reasons for doing so. Among them is the fact that a theoretical basis for <b>automatic</b> <b>program</b> writers (APW's) becomes especially perspicuous (in such a context the problem of assigning meaning to programs a la Floyd [6] is the inverse of program writing). Another reason is that such an interpretation reveals a number off interesting mathematical problems in the theory of computing. While making these points we find occasion to present new observations on the completeness and efficiency of <b>automatic</b> <b>program</b> writers and to formulate a specific example of what we call von Neumann's principle on the logical complexity of systems. We apply the principle in the <b>automatic</b> <b>program</b> writing context and discuss its more general ramifications about the intelligibility of programs...|$|R
5000|$|... 1964: Hopper {{was awarded}} the Society of Women Engineers Achievement Award, the Society’s highest honor, “In {{recognition}} of her significant contributions to the burgeoning computer industry as an engineering manager and originator of <b>automatic</b> <b>programming</b> systems.”.|$|E
5000|$|Improving {{clinical}} outcomes for hearing-impaired {{children and adults}} - <b>Automatic</b> <b>programming</b> for cochlear implants, predicting the benefit gained with hearing devices, improving music perception and appreciation in hearing device users, and improving cochlear implants through novel stimulation strategies, ...|$|E
50|$|Inductive {{programming}} (IP) is {{a special}} area of <b>automatic</b> <b>programming,</b> covering research from artificial intelligence and programming, which addresses learning of typically declarative (logic or functional) and often recursive programs from incomplete specifications, such as input/output examples or constraints.|$|E
50|$|The FCC granted WIPK its {{broadcast}} license on January 27, 2012, {{after it}} had already been operating under <b>automatic</b> <b>program</b> test authority for the two months prior.|$|R
40|$|This paper {{presents}} an <b>automatic</b> <b>program</b> specializer for Java, named JSpec. JSpec combines interprocedural static analyses with aggressive global optimizations, which {{allows it to}} automatically eliminate overheads due {{to the use of}} object-oriented abstractions in generic programs. We describe the complete specialization process implemented by JSpec, including a novel use of aspect-oriented programming to represent specialized programs, and characterize the strengths and limitations of both <b>automatic</b> <b>program</b> specialization and the current implementation of JSpec. We then demonstrate experimentally that program specialization gives significant speedups when combined with state-of-the-art Java compiler technolog...|$|R
50|$|<b>Automatic</b> <b>Program</b> Analyses. These tools {{typically}} {{look for}} restricted classes of bugs (e.g., memory safety errors) or attempt {{to prove their}} absence, but fall short of proving full correctness.|$|R
50|$|Piloty, Bauer and Samelson {{had also}} {{worked on the}} design of PERM, a {{computer}} based partially on the Whirlwind concept. By 1955, the PERM was completed and they continued work that Bauer had begun in 1951 on concepts in <b>automatic</b> <b>programming.</b>|$|E
50|$|Programmation Automatique des Formules is a {{programming}} language designed in 1957-1959 by Dimitri Starynkevitch at SEA, a small French computer company. PAF was similar to FORTRAN. It ran on a drum computer, the CAB500. The title is French for <b>Automatic</b> <b>Programming</b> of Formulae.|$|E
50|$|In {{computer}} science, {{program synthesis}} {{is the task}} to automatically construct a program that satisfies a given high-level specification. In contrast to other <b>automatic</b> <b>programming</b> techniques, the specifications are usually non-algorithmic statements of an appropriate logical calculus. Often, program synthesis employs techniques from formal verification.|$|E
40|$|Abstract—Software bugs {{can cause}} {{significant}} financial loss {{and even the}} loss of human lives. To reduce such loss, developers devote substantial efforts to fixing bugs, which generally requires much expertise and experience. Various approaches have been proposed to aid debugging. An interesting recent research direc-tion is <b>automatic</b> <b>program</b> repair, which achieves promising results, and attracts much academic and industrial attention. However, people also {{cast doubt on the}} effectiveness and promise of this direction. A key criticism is to what extent such approaches can fix real bugs. As only research prototypes for these approaches are available, it is infeasible to address the criticism by evaluating them directly on real bugs. Instead, in this paper, we design and develop BUGSTAT, a tool that extracts and analyzes bug fixes. With BUGSTAT’s support, we conduct an empirical study on more than 9, 000 real-world bug fixes from six popular Java projects. Comparing the nature of manual fixes with <b>automatic</b> <b>program</b> repair, we distill 15 findings, which are further summarized into four insights on the two key ingredients of <b>automatic</b> <b>program</b> repair: fault localization and faulty code fix. In addition, we provide indirect evidence {{on the size of the}} search space to fix real bugs and find that bugs may also reside in non-source files. Our results provide useful guidance and insights for improving the state-of-the-art of <b>automatic</b> <b>program</b> repair. I...|$|R
5000|$|Quasi Art - <b>automatic</b> <b>program</b> for {{generation}} quasi music (algorithm by Lois Alexandre, released 2016). The program creates unimaginable {{and bizarre}} orchestral melodies created programmatically using the built-in synthesizer in realtime.|$|R
40|$|AbstractThe paper {{presents}} a critical {{overview of the}} development {{in the area of}} automating the program formation, seen in a broader perspective from <b>automatic</b> <b>program</b> synthesis to computer aided software engineering. The fundamental problems are identified in the area of <b>automatic</b> <b>program</b> synthesis, intelligent support of software development, computer aided software engineering. The trends in related fields, especially in artificial intelligence are surveyed and the possible influence is evaluated. Need for urgent development of theory of programming is recognised. In parallel, knowledge engineering methods should be considered because they allow building models of the respective domain...|$|R
