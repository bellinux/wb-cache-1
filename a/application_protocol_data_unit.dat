11|10000|Public
2500|$|A smartSD {{memory card}} is a microSD card with an {{internal}} [...] "secure element" [...] {{that allows the}} transfer of ISO 7816 <b>Application</b> <b>Protocol</b> <b>Data</b> <b>Unit</b> commands to, for example, JavaCard applets running on the internal secure element through the SD bus.|$|E
50|$|In {{the context}} of smart cards, an <b>application</b> <b>protocol</b> <b>data</b> <b>unit</b> (APDU) is the {{communication}} unit between a smart card reader and a smart card. The structure of the APDU is defined by ISO/IEC 7816-4 Organization, security and commands for interchange.|$|E
5000|$|A smartSD {{memory card}} is a microSD card with an {{internal}} [...] "secure element" [...] {{that allows the}} transfer of ISO 7816 <b>Application</b> <b>Protocol</b> <b>Data</b> <b>Unit</b> commands to, for example, JavaCard applets running on the internal secure element through the SD bus.|$|E
5000|$|APDU - Allows the {{communication}} between web application and a smart card {{by using the}} <b>Application</b> <b>Protocol</b> <b>Data</b> <b>Units</b> (APDUs).|$|R
5000|$|ISO/IEC 7816-3 {{defines the}} {{transmission}} protocol between chip cards and readers. Using this <b>protocol,</b> <b>data</b> is exchanged in <b>application</b> <b>protocol</b> <b>data</b> <b>units</b> (APDUs). This comprises sending a command to a card, the card processing it, and sending a response. EMV uses the following commands: ...|$|R
40|$|In this paper, {{we present}} a reliable, {{adaptive}} credit-based network protocol for video transport. To do so, we first derive a sufficient condition for ensuring {{the reliability of the}} receiver-based adaptive buffer allocation algorithm. We then present a fair buffer adaptation algorithm that ensures uniform increase in the delays experienced by the <b>application</b> <b>protocol</b> <b>data</b> <b>units</b> of bursty flows during congestion. The adaptive buffer allocation algorithm is then tuned to minimize the end-to-end delay and jitter for VBR encoded video streams. Although such a protocol does not provide delay or delay jitter guarantees, we demonstrate that due to the inherent nature of our algorithm, the network, rather than the source, shapes the traffic, which in turn yields smaller end-to-end delay for video frames as compared to source traffic shaping algorithms. On the other hand, to mask the effects of delay jitter on playback continuity, {{we present a}} simple technique for adapting the playback point at client sites. We experimentally evaluate the adaptive buffer allocation algorithm {{for a wide range of}} parameters and many network configuration and demonstrate it's adaptability and suitability for video transport...|$|R
5000|$|The Interworking MSC of the SMSC, {{on receipt}} of the MAP mo-ForwardSM message, passes the SMS-PP <b>Application</b> <b>Protocol</b> <b>Data</b> <b>Unit</b> (APDU) {{containing}} the text {{message to the}} actual Service Centre (SC) of the SMSC for storing, and subsequent [...] "forwarding" [...] (delivery) to the destination address and the SC returns an acknowledgement indicating success or failure. On receipt of this submission status from the Service Centre, the Interworking MSC will send an appropriate indication back to the VMSC/SGSN of the sending subscriber. The message submission status is then forwarded, over the air interface, to the subscriber's handset.|$|E
40|$|This paper {{reports on}} {{an effort to}} {{increase}} the reliability of JavaCard-based smart cards by means of formal specification and verification of JavaCard source code. As a first step, formal interface specifications, written in the specification language JML, {{have been developed for}} all the classes that make up the JavaCard API. These specifications are “lightweight ” {{in the sense that they}} are incomplete and specify only some aspects of the API, but they already provide a useful addition to the existing informal API specifications. Moreover, the fact that these specification are written in a formal language makes them amenable to tool support, for verification purposes. As an illustration, the JML specifications of the APDU (<b>Application</b> <b>Protocol</b> <b>Data</b> <b>Unit)</b> class in the JavaCard API are discussed in detail...|$|E
40|$|This paper {{reports on}} an eort to {{increase}} the reliability of JavaCard-based smart cards by means of formal speci cation and veri cation of JavaCard source code. As a rst step, formal interface speci cations, written in the speci cation language JML, {{have been developed for}} all the classes that make up the JavaCard API. These speci cations are " {{in the sense that they}} are incomplete and specify only some aspects of the API, but they already provide a useful addition to the existing informal API speci cations. Moreover, the fact that these speci cation are written in a formal language makes them amenable to tool support, for veri cation purposes. As an illustration, the JML speci cations of the APDU (<b>Application</b> <b>Protocol</b> <b>Data</b> <b>Unit)</b> class in the JavaCard API are discussed in detail...|$|E
40|$|In new {{applications}} like groupware systems, broadcast communication {{of various kinds}} of data like transactions and files is required. In these <b>applications,</b> some of <b>protocol</b> <b>data</b> <b>units</b> (PDUs) with control data like transactions have to be delivered earlier than another PDU. One approach to providing various kinds of communications like control data transmission and file transfer by using a common communication channel is to give a priority to each PDU and to deliver PDUs with higher priority to the destination earlier than lower ones. In this paper, we discuss broadcast protocols which provide priority-based receipt ordering of PDUs for entities in the cluster. We present distributed broadcast protocols which provide the prioritybased receipt ordering of PDUs by using a single channel system like Ethernet and radio systems...|$|R
50|$|Media {{access control}} <b>protocol</b> <b>data</b> <b>unit</b> or MPDU {{is a message}} (<b>protocol</b> <b>data</b> <b>unit)</b> {{exchanged}} between media access control (MAC) entities in a communication system based on the layered Open Systems Interconnection model.|$|R
5000|$|The <b>Application</b> <b>Protocol</b> Convergence (APC) Layer, which accepts frames (usually in Ethernet format) {{from the}} upper layer (Application Entity) and encapsulates them into G.hn APC <b>protocol</b> <b>data</b> <b>units</b> (APDUs). The maximum payload of each APDU is 214 bytes.|$|R
40|$|International audienceThe {{electronic}} payment transaction {{involves the use}} of a smart card. A card application is a software, corresponding to standards and non-proprietary and proprietary specifications, and is stored in the smart card. Despite increased security with Europay Mastercard Visa (EMV) specifications, attacks still exist due to anomalies in the card application. The validation of the card application enables the detection of any anomaly, improving the overall security of {{electronic payment}} transactions. Among the different ways of validating a card application, we can use the verification of required behaviors. These behavior can be materialized as properties of commands sent by the terminal and responses from the smart card, using the <b>Application</b> <b>Protocol</b> <b>Data</b> <b>Unit</b> (APDU) from the ISO/IEC 7816 standard. However, the creation of these behaviors is complicated. We propose in this article a way to automatically create such behaviors by using a genetic algorithm technique...|$|E
40|$|International audienceSmart {{cards are}} tamper {{resistant}} devices but vulnerabilities are sometimes discovered. We address {{in this paper}} the security and the functional testing of embedded applications in smart cards. We propose an original methodology {{for the evaluation of}} applications and we show its benefit by comparing it to a classical certification process. The proposed method is based on the observation of the APDU (<b>Application</b> <b>Protocol</b> <b>Data</b> <b>unit)</b> communication with the smart card. Some specific properties are verified as a complementary method in the evaluation process and allows the on-the-fly detection of an anomaly and the reasons that triggered this anomaly during the test. Here are presented two uses of this method: a simple use to illustrate the use of properties to verify an implementation of an application and a more complex illustration by applying the fuzzing method to show what we can obtain with the proposed approach, i. e. an analysis of an anomaly...|$|E
40|$|Syntax Notation One (ANS. 1)), X. 209 [8] (Specification {{of basic}} {{encoding}} rules for Abstract Syntax Notation One (ANS. 1)), X. 219 [9] (Remote operations: model, notation and service definition) and X. 229 [10] (Remote operations: protocol specification). Based on Recommendations X. 208 and X. 209, the following specific encoding apply. A component is {{a sequence of}} data elements {{each of which is}} made up of a tag, a length and a contents. The component type is indicated by the first octet of the Facility information element component. The component types defined for the Facility information element are: [...] - Invoke [...] - Return result [...] - Return error [...] - Reject. Note 1 [...] - Recommendation X. 229 which defines the Remote Operations Service Element (ROSE) uses the term <b>Application</b> <b>Protocol</b> <b>Data</b> <b>Unit</b> (APDU) in place of component. However since this protocol element may be applied to the support of network layer services and of application layer services, the term "component" is more appropriate in [...] ...|$|E
5000|$|The seven SNMP <b>protocol</b> <b>data</b> <b>unit</b> (PDU) {{types are}} as follows: ...|$|R
5000|$|... #Caption: Ethernet Synchronization Message Channel (ESMC) <b>protocol</b> <b>data</b> <b>unit</b> rec. ITU-T G.8264 ...|$|R
5000|$|Each Frame Relay <b>protocol</b> <b>data</b> <b>unit</b> (PDU) {{consists}} of the following fields: ...|$|R
40|$|International audienceSmartcards are {{becoming}} increasingly popular {{as a means for}} personal identification and authentication in many secure application areas such as e-Banking and e-Commerce. Millions of users have a smart card in their pocket without even knowing it. The SecFuNet project proposes solutions for integrating secure microcontrollers in order to develop a security framework for Cloud Computing and virtual environment. This framework introduces, among its many services: authentication and authorization functions for virtual environments, based on Remote Grid of Secure Elements (RG 0 SE). The objective is to implement an open standard framework, based on smart cards and OpenSSL. This framework provides TLS secure channels for establishing trust relationships among Users, Virtual Machines (VMs), Hypervisor (XEN) and RG 0 SE. The authentication is done directly between smart cards (owned by users or associated to VM) and SecFuNet Identity Management (IdM). This framework concerns a highly secure authentication with secure microcontrollers allowing users' (or VMs') strong mutual authentication with SecFuNet Services and provides some libraries to the developers. It defines and describes the features and the modules added to OpenSSL in order to supply easily the <b>Application</b> <b>Protocol</b> <b>Data</b> <b>Unit</b> (APDU) -described by the ISO 7816 standard -transferred to smart cards...|$|E
40|$|As {{the grid}} becomes highly interconnected, power protection, control, and {{monitoring}} in {{transmission and distribution}} substations are increasingly relying on digital controls and digital communication. Rapid penetrations of communication into power grid, and growing concerns about cyber security have attracted significant attention towards smart grid cyber security. Cyber security in the smart grid must be carefully designed to meet power system operation’s functional and reliability requirements. This thesis discusses {{issues related to the}} security of power system communication and their counter measures. It focuses on development of security mechanisms for secure substation communication, and analyzes the impact of security overhead on communication performance. We analyze IPSec as a security protocol on a substation gateway, and propose a secure substation gateway solution. Since security gateway solution does not provide sufficient security against an inside attacker, providing cyber security for each critical IED independently is required. Due to computational constraints, Intelligent Electronic Devices (IEDs) do not have cyber security measures implemented in them. Hence, we propose a security device that provides required cyber-security for an IED. Security device has a bump-in-the-wire IPSec implementation. We examine IPSec tunnel configurations with di erent encryption and authentication algorithms to identify the proper IPSec tunnel configuration for the security device at IED level. Among IEC 61850 messages Sampled Value (SV) and General Object Oriented Substation Event (GOOSE) messages are critical for secure operation, and have very stringent performance requirements. We propose an authentication mechanism for GOOSE messages, that provides message authentication and integrity. We examine performance results of shared-key Hash-based Message Authentication Code (MAC), and argue its competency as an authentication algorithm for GOOSE packet transmission. We analyze GOOSE packet structure, and evaluate performance impact on authenticating only APDU (<b>Application</b> <b>Protocol</b> <b>Data</b> <b>Unit)</b> of the GOOSE packet...|$|E
5000|$|In telecommunications, {{the term}} <b>protocol</b> <b>data</b> <b>unit</b> (PDU) has the {{following}} meanings: ...|$|R
5000|$|A Modbus {{frame is}} {{composed}} of an Application <b>Data</b> <b>Unit</b> (ADU), which encloses a <b>Protocol</b> <b>Data</b> <b>Unit</b> (PDU): ...|$|R
40|$|This paper {{describes}} {{the implementation of}} a proposed IsGroupOf <b>protocol</b> <b>data</b> <b>unit</b> in a series of simulation experiments designed to test its effectiveness in: 1) significantly reducing wide area network bandwidth requirements during multi-site distributed simulation exercises, and 2) providing entity level representations of grouped units which is needed by wide area sensor simulations. These experiments involve the use of a network gateway to group units together using IsGroupOf <b>protocol</b> <b>data</b> <b>units</b> which are subsequently sent onto a wide area network. Our results show that use of the IsGroupOf <b>protocol</b> <b>data</b> <b>units</b> can reduce wide area network bandwidth by as much as 80 - 90 %. Individual entities of a group are also still able to be relatively accurately represented on visual simulators, which is sufficient resolution for wide area sensor simulations. While the work presented here deals with {{the development and implementation of}} Distributed Interactive Simulation (DIS) <b>protocol</b> <b>data</b> <b>unit</b> [...] ...|$|R
50|$|In {{the context}} of packet-switched <b>data</b> networks, a <b>protocol</b> <b>data</b> <b>unit</b> (PDU) is best {{understood}} {{in relation to a}} service <b>data</b> <b>unit</b> (SDU).|$|R
5000|$|Aggregation of MAC <b>protocol</b> <b>data</b> <b>units</b> (MPDUs) at {{the bottom}} of the MAC (referred to as MPDU {{aggregation}} or A-MPDU) ...|$|R
50|$|Simulation state {{information}} is encoded in formatted messages, known as <b>protocol</b> <b>data</b> <b>units</b> (PDUs) and exchanged between hosts using existing transport layer protocols, including multicast, though broadcast User Datagram Protocol is also supported. There are several {{versions of the}} DIS <b>application</b> <b>protocol,</b> not only including the formal standards, but also drafts submitted during the standards balloting process.|$|R
5000|$|The {{data to be}} {{transmitted}} is composed at the topmost layer of the transmitting device (layer N) into a <b>protocol</b> <b>data</b> <b>unit</b> (PDU).|$|R
5000|$|Transfer {{of upper}} layer <b>Protocol</b> <b>Data</b> <b>Units</b> (PDUs) {{in one of}} three modes: Acknowledged Mode (AM), Unacknowledged Mode (UM) and Transparent Mode (TM) ...|$|R
50|$|A frame control (FC) {{field in}} 8 bits {{carrying}} a fixed value. This field exists for compatibility with other protocols using similar <b>protocol</b> <b>data</b> <b>units</b> (PDUs).|$|R
50|$|SNMPv1 {{specifies}} five core <b>protocol</b> <b>data</b> <b>units</b> (PDUs). Two other PDUs, GetBulkRequest and InformRequest {{were added}} in SNMPv2 and the Report PDU was added in SNMPv3.|$|R
5000|$|Assuming {{a message}} that {{complies}} with the Foo Protocol {{and that will be}} sent to the receiving party, this particular message (<b>protocol</b> <b>data</b> <b>unit</b> (PDU)) is: ...|$|R
50|$|TPDU (Transport <b>Protocol</b> <b>Data</b> <b>Unit)</b> is {{a message}} {{encapsulation}} format where there are several bytes of routing header added {{to the front of}} the payload message.|$|R
50|$|In practice, MPLS {{is mainly}} used to forward IP <b>protocol</b> <b>data</b> <b>units</b> (PDUs) and Virtual Private LAN Service (VPLS) Ethernet traffic. Major {{applications}} of MPLS are telecommunications traffic engineering, and MPLS VPN.|$|R
50|$|At {{each level}} N, two {{entities}} at the communicating devices (layer N peers) exchange <b>protocol</b> <b>data</b> <b>units</b> (PDUs) {{by means of}} a layer N protocol. Each PDU contains a payload, called the service <b>data</b> <b>unit</b> (SDU), along with protocol-related headers or footers.|$|R
3000|$|There is {{research}} work proposed in [10 – 19] {{that focus on}} packet aggregation schemes for WLANs. Two-level aggregation techniques, that is, the aggregate MAC service <b>data</b> <b>unit</b> (A-MSDU) and the aggregate MAC <b>protocol</b> <b>data</b> <b>unit</b> (A-MPDU), are exploited in the current IEEE [...]...|$|R
40|$|Abstract- This paper {{presents}} our black-box approach (Tsert Method ©®™) {{in testing}} objectoriented programs {{based on the}} use of <b>protocol</b> <b>data</b> <b>units</b> to communicate with a test-harness, which are built by processing the methods of a given class. Testing object-oriented programs has always been difficult, especially in handling inheritance and polymorphism. The approach to be presented, allows the tester, to test classes in a bottom-up manner, thereby handling inheritance and polymorphism, as the subclasses and classes are processed. The use of <b>Protocol</b> <b>Data</b> <b>Units</b> (PDUs) eliminates the need to generate stubs for classes and constructors. Our black-box approach, by handling only publicly accessible constructs, retain the mai...|$|R
