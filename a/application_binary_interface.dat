78|657|Public
25|$|Efforts toward {{standardization}} included Sun's Public Windows Interface (PWI) for Win16 (see also: Sun Windows <b>Application</b> <b>Binary</b> <b>Interface</b> (Wabi)), Willows Software's Application Programming Interface for Windows (APIW) for Win16 and Win32 (see also: Willows TWIN), and ECMA-234, which {{attempted to}} standardize the Windows API bindingly.|$|E
500|$|... armel: Little-endian ARM {{architecture}} (ARMv4T instruction set) {{on various}} embedded systems (embedded <b>application</b> <b>binary</b> <b>interface</b> (EABI)) ...|$|E
5000|$|System V <b>Application</b> <b>Binary</b> <b>Interface</b> Edition 4.1 (1997-03-18) ...|$|E
5000|$|The primary {{function}} of a FFI is to mate the semantics and calling conventions of one programming language (the host language, or the language which defines the FFI), with the semantics and conventions of another (the guest language). This process must also {{take into consideration the}} runtime environments and/or <b>application</b> <b>binary</b> <b>interfaces</b> of both. This can be done in several ways: ...|$|R
40|$|ZL is a C++-compatible {{language}} in which high-level constructs, such as classes, are defined using macros over a C-like core language. This approach makes {{many parts of the}} language easily customizable. For example, since the class construct can be defined using macros, a programmer can have complete control over the memory layout of objects. Using this capability, a programmer can mitigate certain problems in software evolution such as fragile ABIs (<b>Application</b> <b>Binary</b> <b>Interfaces)</b> due to software changes and incompatible ABIs due to compiler changes. In this paper, we outline the problem of fragile and incompatible ABIs and show how ZL can be used to solve them...|$|R
40|$|Abstract. Pervasive formal {{verification}} of operating systems and hypervisors is, {{due to their}} safety-critical aspects, a highly relevant area of research. Many im-plementations consist of both assembler and C functions. Formal verification of their correctness must consider the correct interaction of code written in these languages, which is, in practice, ensured by using matching <b>application</b> <b>binary</b> <b>interfaces</b> (ABIs). Also, these programs {{must be able to}} interact with hardware. We present an integrated operational small-step semantics model of intermediate-language C and Macro-Assembler code execution for pervasive operating systems and hypervisor verification. Our semantics is based on a compiler calling conven-tion that defines callee- and caller-save registers. We sketch a theory connecting this semantic layer with an ISA-model executing the compiled code for use in a pervasive verification context. This forms a basis for soundness proofs of tools used in the VerisoftXT project and is a crucial step towards arguing formal cor-rectness of execution of the verified code on a gate-level hardware model. ...|$|R
5000|$|PowerPC Embedded <b>Application</b> <b>Binary</b> <b>Interface</b> 32-Bit Implementation (1995-10-01) ...|$|E
5000|$|... 64-bit PowerPC ELF <b>Application</b> <b>Binary</b> <b>Interface</b> Supplement Version 1.9 (2004) ...|$|E
5000|$|An <b>application</b> <b>binary</b> <b>interface</b> (ABI) {{based on}} Executable and Linkable Format (ELF).|$|E
40|$|ZL is a C++-compatible {{language}} in which high-level constructs, such as classes, are de-fined using macros over a C-like core language. This approach is similar in spirit to Scheme and makes {{many parts of the}} language easily customizable. For example, since the class construct can be defined using macros, a programmer can have complete control over the memory layout of objects. Using this capability, a programmer can mitigate certain prob-lems in software evolution such as fragile ABIs (<b>Application</b> <b>Binary</b> <b>Interfaces)</b> due to software changes and incompatible ABIs due to compiler changes. ZL’s parser and macro expander {{is similar to that of}} Scheme. Unlike Scheme, however, ZL must deal with C’s richer syntax. Specifically, support for context-sensitive parsing and multiple syntactic categories (expressions, statements, types, etc.) leads to novel strategies for parsing and macro expansion. In this dissertation we describe ZL’s approach to parsing and macros. We demonstrate how to use ZL to avoid problems with ABI instability through techniques such as fixing the size of class instances and controlling the layout of virtual method dispatch tables. We als...|$|R
40|$|International audienceActorScript(TM) is {{a general}} purpose {{programming}} language for efficiently implementing robust applications (with no single point of failure) using discretionary, adaptive concurrency that manages resources and demand. It is differentiated from previous languages by the following:- Universality* Ability to specify what Actors can do* Specify interface between hardware and software* Everything in the language is accomplished using message passing including {{the very definition of}} ActorScript itself* Functional, Imperative, Logic, and Concurrent programming are integrated. * Concurrency dynamically adapts to resources available and current load. * Programs do not expose low-level implementation mechanisms such as threads, tasks, locks, cores, etc. * Messages can be directly communicated without requiring indirection through brokers, channels, class hierarchies, mailboxes, pipes, ports, queues etc. * Variable races are eliminated. * Binary XML and JSON are data types. * <b>Application</b> <b>binary</b> <b>interfaces</b> are afforded so that no identifier symbol need be looked up at runtime. - Safety and Security* Programs are extension invariant, i. e., extending a program does not change its meaning. * Applications cannot directly harm each other. - Performance* Impose no overhead on implementation of Actor systems* Message passing has essentially same overhead as procedure calling and looping. * Allow execution to be dynamically adjusted for system load and capacity (e. g. cores) * Locality because execution is not bound by a sequential global memory model* Inherent concurrency because execution is not bound by communicating sequential processes* Minimize latency along critical path...|$|R
40|$|ActorScript(TM) is {{a general}} purpose {{programming}} language for implementing discretionary, adaptive concurrency that manages resources and demand. It is differentiated from previous languages by the following: - Universality *** Ability to specify what Actors can do *** Specify interface between hardware and software *** Everything in the language is accomplished using message passing including {{the very definition of}} ActorScript itself *** Functional, Imperative, Logic, and Concurrent programming are integrated. *** Concurrency dynamically adapts to resources available and current load. *** Programs do not expose low-level implementation mechanisms such as threads, tasks, locks, cores, etc. *** Messages can be directly communicated without requiring indirection through brokers, channels, class hierarchies, mailboxes, pipes, ports, queues etc. *** Variable races are eliminated. *** Binary XML and JSON are data types. *** <b>Application</b> <b>binary</b> <b>interfaces</b> are afforded so that no identifier symbol need be looked up at runtime. - Safety and Security *** Programs are extension invariant, i. e., extending a program does not change its meaning. *** Applications cannot directly harm each other. - Performance *** Impose no overhead on implementation of Actor systems *** Message passing has essentially same overhead as procedure calling and looping. *** Allow execution to be dynamically adjusted for system load and capacity (e. g. cores) *** Locality because execution is not bound by a sequential global memory model *** Inherent concurrency because execution is not bound by communicating sequential processes *** Minimize latency along critical pathsComment: Added explanation of facets of an Actor. Admin note: text overlap with arXiv: 1008. 145...|$|R
50|$|By choice, the Linux kernel {{has never}} {{maintained}} a stable in-kernel <b>Application</b> <b>binary</b> <b>interface.</b>|$|E
5000|$|... : Little-endian ARM {{architecture}} (ARMv4T instruction set) {{on various}} embedded systems (embedded <b>application</b> <b>binary</b> <b>interface</b> (EABI)) ...|$|E
5000|$|Lack of {{centralized}} authoritative {{support for}} DLL <b>application</b> <b>binary</b> <b>interface</b> management and safeguards, allowing incompatible DLLs {{with the same}} file name and internal version numbers to be released; ...|$|E
5000|$|In 2014, {{the maximum}} size {{allowed for a}} {{notification}} payload sent through the <b>binary</b> <b>interface</b> was increased from 256 bytes to 2 kilobytes. In December 2015, a new HTTP/2 provider API was released by Apple, effectively replacing the now-legacy <b>binary</b> <b>interface.</b> The maximum notification payload size allowed using the HTTP/2 API is 4 kilobytes.|$|R
5000|$|It {{eliminates}} the fragile <b>binary</b> <b>interface</b> problem; superclasses can change sizes without affecting binary compatibility.|$|R
50|$|Other {{compiler}} improvements included whole program optimization (WPO) and devirtualization and ARM embedded-application <b>binary</b> <b>interface</b> (EABI) support.|$|R
5000|$|The same {{application}} programming interface (API) and <b>application</b> <b>binary</b> <b>interface</b> (ABI), so application {{programs can}} be transferred between MFT and MVT without even needing to be modified or re-assembled or re-compiled.|$|E
50|$|In 1992, Brown joined Sun Microsystems. He helped {{establish}} the process {{used for the}} company's system software architecture, {{and then went on}} to define the <b>application</b> <b>binary</b> <b>interface</b> for Solaris, Sun's principal system software product.|$|E
50|$|Symbian OS 9 and the Symbian {{platform}} use a new <b>application</b> <b>binary</b> <b>interface</b> (ABI) {{and needed}} a different compiler. A choice of compilers is available including a newer version of GCC (see external links below).|$|E
5000|$|The call to {{the library}} {{function}} itself does not cause a switch to kernel mode (if the execution was not already in kernel mode) and is usually a normal subroutine call (using, for example, a [...] "CALL" [...] assembly instruction in some Instruction set architectures (ISAs)). The actual system call does transfer control to the kernel (and is more implementation-dependent and platform-dependent than the library call abstracting it). For example, in Unix-like systems, [...] and [...] are C library functions that in turn execute instructions that invoke the [...] and [...] system calls. Making the system call directly in the application code is more complicated and may require embedded assembly code to be used (in C and C++) as well as knowledge of the low-level <b>binary</b> <b>interface</b> for the system call operation, which {{may be subject to}} change over time and thus not be part of the <b>application</b> <b>binary</b> interface; the library functions are meant to abstract this away.|$|R
50|$|An embedded-application <b>binary</b> <b>interface</b> (EABI) {{specifies}} standard conventions for file formats, data types, register usage, stack frame organization, {{and function}} parameter passing of an embedded software program, {{for use with}} an embedded operating system.|$|R
50|$|In {{the early}} to mid-1990s, Microsoft heavily {{promoted}} its COM standard as a <b>binary</b> <b>interface</b> between different OOP programming languages. COM programming equally promoted early and late binding, with many languages supporting both at the syntax level.|$|R
50|$|An API {{differs from}} an <b>application</b> <b>binary</b> <b>interface</b> (ABI) in that an API is source code based while an ABI is binary based. For instance, POSIX {{provides}} APIs, while the Linux Standard Base provides an ABI.|$|E
50|$|The Jazelle state {{relies on}} an agreed calling {{convention}} between the JVM and the Jazelle hardware state. This <b>application</b> <b>binary</b> <b>interface</b> is not published by ARM, rendering Jazelle an undocumented feature for most users and Free Software JVMs.|$|E
5000|$|On some {{computer}} architectures the <b>application</b> <b>binary</b> <b>interface</b> also supports an sbss segment for [...] "small data". Typically, these data items {{can be accessed}} using shorter instructions that may {{only be able to}} access a certain range of addresses.|$|E
50|$|The fragile <b>binary</b> <b>interface</b> {{problem or}} FBI is a {{shortcoming}} of certain object-oriented programming language compilers, in which internal changes to an underlying class library can cause descendant libraries or programs to cease working. It {{is an example}} of software brittleness.|$|R
50|$|SPARC {{architecture}} {{has provided}} continuous <b>application</b> <b>binary</b> compatibility {{from the first}} SPARC V7 implementation in 1987 through the Sun UltraSPARC Architecture implementations.|$|R
2500|$|<b>Application</b> <b>binary</b> data formats, such as {{for example}} MATLAB [...]mat files, or the [...]BIL data format, used in topography, are usually endianness-independent. This is {{achieved}} by: ...|$|R
50|$|Solaris also {{supports}} the Linux platform <b>application</b> <b>binary</b> <b>interface</b> (ABI), allowing Solaris to run native Linux binaries on x86 systems. This feature is called Solaris Containers for Linux Applications (SCLA), {{based on the}} branded zones functionality introduced in Solaris 10 8/07.|$|E
50|$|The ALP SDK used an Eclipse-based {{integrated}} {{development environment}} (IDE), with added plug-ins, as did its predecessor Palm OS development environment. The compilers used were embedded <b>application</b> <b>binary</b> <b>interface</b> (EABI) enabled ARM versions of the standard GNU Compiler Collection (GCC) tool chain.|$|E
50|$|C's <b>application</b> <b>binary</b> <b>interface</b> (ABI) is {{supported}} {{as well as}} all of C's fundamental and derived types, enabling direct access to existing C code and libraries. D bindings are available for many popular C libraries. Additionally, C's standard library is a part of standard D.|$|E
50|$|Languages that {{implement}} {{data abstraction}} include Ada and Modula-2. Object-oriented languages are commonly claimed to offer data abstraction; however, their inheritance concept tends to put {{information in the}} interface that more properly belongs in the implementation; thus, changes to such information ends up impacting client code, leading directly to the Fragile <b>binary</b> <b>interface</b> problem.|$|R
5000|$|Autopackage was {{designed}} for installing binary, or pre-compiled, versions of non-core applications such as word processors, web browsers, and personal computer games, rather than core libraries and applications such as operating system shells. Concept of autopackage was to [...] "improve" [...] Linux to a desktop platform, with stable <b>binary</b> <b>interfaces</b> comparable to Windows and MacOS.|$|R
50|$|High-level {{programming}} languages {{can suffer}} from performance penalties because glue code must {{run through the}} language interpreter, even when connecting high-performance subsystems. If performance is crucial, using configuration scripting is often preferred to directly connecting <b>binary</b> <b>interfaces</b> of components. In object-oriented scripting languages, glue code often {{eliminates the need for}} class hierarchies and large numbers of classes.|$|R
