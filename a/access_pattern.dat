965|2624|Public
25|$|The memory <b>access</b> <b>pattern</b> of AI {{calculations}} {{differs from}} graphics: a more predictable but deeper dataflow, benefiting {{more from the}} ability to keep more temporary variables on-chip (e.g. in scratchpad memory rather than caches); GPUs by contrast devote silicon to efficiently dealing with highly non-linear gather-scatter addressing between texture maps and frame-buffers, and texture filtering, as is needed for their primary role in 3D rendering.|$|E
50|$|A linear <b>access</b> <b>pattern</b> {{is closely}} related to 'strided', where a memory address may be {{computed}} from a linear combination of some index. Stepping through indices sequentially with a linear pattern yields strided access. A linear <b>access</b> <b>pattern</b> for writes (with any <b>access</b> <b>pattern</b> for non overlapping reads) may guarantee that an algorithm can be parallelised, which is exploited in systems supporting compute kernels.|$|E
50|$|In most conditions, even if {{the data}} is encrypted, the <b>access</b> <b>pattern</b> can be achieved, and this pattern can leak some {{important}} information such as encryption keys. And in the outsourcing of cloud data, this leakage of <b>access</b> <b>pattern</b> is still very serious. An <b>access</b> <b>pattern</b> is a specification of an access mode for every attribute of a relation schema. For example, the sequences of user read or write the data in the cloud are access patterns.|$|E
40|$|Visualization of Web {{information}} {{is an active}} research topic. We have researched on a visualization technique for <b>access</b> <b>patterns</b> and link structures of web sites. This poster presents an interactive visualization technique which visualizes user-selected <b>access</b> <b>patterns.</b> This enables users to compare <b>access</b> <b>patterns</b> from each user’s viewpoint, and the users can analyze a visualization result united with each user’s concern. Moreover, it enables to choose <b>access</b> <b>patterns</b> extracted from the access log stored over a long time. This {{will enable us to}} analyze more detail, for example, we can compare <b>access</b> <b>patterns</b> in the same month or same patterns through every year...|$|R
40|$|Web usage mining discovers {{interesting}} and frequent user <b>access</b> <b>patterns</b> from web logs. Most {{of the previous}} works have focused on mining common sequential <b>access</b> <b>patterns</b> of web <b>access</b> events that occurred within the entire duration of all web access transactions. However, many useful sequential <b>access</b> <b>patterns</b> occur frequently only during a particular periodic time interval due to user browsing behaviors and habits. It is therefore important to mine periodic sequential <b>access</b> <b>patterns</b> with periodic time constraints. In this paper, we propose an efficient approach, known as TCS-mine (Temporal Conditional Sequence mining algorithm), for mining periodic sequential <b>access</b> <b>patterns</b> based on calendar-based periodic time constraints. The calendar-based periodic time constraints are used for describing real-life periodic time concepts such as the morning of every weekend. The mined periodic sequential <b>access</b> <b>patterns</b> {{can be used for}} temporal-based personalized web recommendations. The performance of the proposed TCS-mine algorithm is evaluated and compared with a modified version of WAP-mine for mining periodic sequential <b>access</b> <b>patterns...</b>|$|R
40|$|Algorithms that exhibit {{irregular}} memory <b>access</b> <b>patterns</b> {{are known}} to show poor performance on multiprocessor architectures, particularly when memory access latency is variable. Many common data structures, including graphs, trees, and linked-lists, exhibit these irregular memory <b>access</b> <b>patterns.</b> While FPGA-based code accelerators have been successful on applications with regular memory <b>access</b> <b>patterns,</b> {{they have not been}} further explored for irregular memory <b>access</b> <b>patterns.</b> Multithreading {{has been shown to be}} an e↵ective technique in masking long latencies. We describe the compiler generation of concurrent hardware threads for FPGAs with the objective of masking the memory latency caused by irregular memory <b>access</b> <b>patterns.</b> We extend the ROCCC compiler to generate customized state information for each dynamically generated thread...|$|R
5000|$|Advisor [...] "Memory Access Pattern" [...] {{analyzes}} the memory <b>access</b> <b>pattern</b> (stride).|$|E
50|$|Locality of {{reference}} {{refers to a}} property exhibited by memory access patterns.A programmer will change the memory <b>access</b> <b>pattern</b> (by reworking algorithms) to improve the locality {{of reference}}, and/or to increase potential for parallelism. A programmer or system designer may create frameworks or abstractions (e.g. C++ templates or higher-order functions) that encapsulate a specific memory <b>access</b> <b>pattern.</b>|$|E
5000|$|A scatter memory <b>access</b> <b>pattern</b> {{combines}} sequential reads with indexed/random addressing for writes.|$|E
40|$|Abstract—Web usage mining is an {{interesting}} application of data mining which provides insight into customer behaviour on the Internet. An important technique to discover user access and navigation trails is based on sequential patterns mining. One of the key challenges for web <b>access</b> <b>patterns</b> mining is tackling the problem of mining richly structured patterns. This paper proposes a novel model called Web <b>Access</b> <b>Patterns</b> Graph (WAP-Graph) to represent all of the <b>access</b> <b>patterns</b> from web mining graphically. WAP-Graph also motivates the search for new structural relation patterns, i. e. Concurrent <b>Access</b> <b>Patterns</b> (CAP), to identify and predict more complex web page requests. Corresponding CAP mining and modelling methods are proposed and shown {{to be effective in}} the search for and representation of concurrency between <b>access</b> <b>patterns</b> on the web. From experiments conducted on large-scale synthetic sequence data as well as real web access data, it is demonstrated that CAP mining provides a powerful method for structural knowledge discovery, which can be visualised through the CAP-Graph model. Keywords—concurrent <b>access</b> <b>patterns</b> (CAP), CAP mining and modelling, CAP-Graph, web <b>access</b> <b>patterns</b> (WAP), WAP-Graph, Web usage mining. I...|$|R
40|$|Mining {{web access}} log data {{is a popular}} {{technique}} to identify frequent <b>access</b> <b>patterns</b> of website users. There are many mining techniques such as clustering, sequential pattern mining and association rule mining to identify these frequent <b>access</b> <b>patterns.</b> Each can find interesting <b>access</b> <b>patterns</b> and group the users, but they cannot identify the slight differences between <b>accesses</b> <b>patterns</b> included in individual clusters. But in reality these could refer to important information about attacks. This paper introduces a methodology to identify these <b>access</b> <b>patterns</b> {{at a much lower}} level than what is provided by traditional clustering techniques, such as nearest neighbour based techniques and classification techniques. This technique makes use of the concept of episodes to represent web sessions. These episodes are expressed in the form of regular expressions. To the best of our knowledge, {{this is the first time}} to apply the concept of regular expressions to identify user <b>access</b> <b>patterns</b> in web server log data. In addition to identifying frequent patterns, we demonstrate that this technique is able to identify <b>access</b> <b>patterns</b> that occur rarely, which would have been simply treated as noise in traditional clustering mechanisms. INSTICC - Institute for Systems and Technologies of Information, Control and Communicatio...|$|R
40|$|This paper {{builds on}} the {{original}} data mining and modelling research which has proposed the discovery of novel structural relation patterns, applying the approach in web usage mining. The focus of attention here is on concurrent <b>access</b> <b>patterns</b> (CAP), where an overarching framework illuminates the methodology for web <b>access</b> <b>patterns</b> post-processing. Data pre-processing, pattern discovery and patterns analysis all proceed in association with <b>access</b> <b>patterns</b> mining, CAP mining and CAP modelling. Pruning and selection of <b>access</b> <b>patterns</b> takes place as necessary, allowing further CAP mining and modelling to be pursued {{in the search for}} the most interesting concurrent <b>access</b> <b>patterns.</b> It is shown that higher level CAPs can be modelled in a way which brings greater structure to bear on the process of knowledge discovery. Experiments with real-world datasets highlight the applicability of the approach in web navigation...|$|R
5000|$|This {{interface}} {{must provide}} sufficiently fast read operations with a random <b>access</b> <b>pattern,</b> ...|$|E
5000|$|... #Caption: <b>Access</b> <b>pattern</b> (white) {{and writing}} pattern (yellow) for the in-place Cholesky—Banachiewicz {{algorithm}} on a 5×5 matrix.|$|E
5000|$|In a gather memory <b>access</b> <b>pattern,</b> reads are {{randomly}} addressed or indexed, whilst the writes are sequential (or linear).|$|E
40|$|We {{introduce}} {{a set of}} state <b>access</b> <b>patterns</b> suitable for managing accesses to state in parallel computations operating on streams. The state <b>access</b> <b>patterns</b> are useful for modelling typical stream parallel applications. We present a classification of the patterns according to the extent and {{way in which the}} state can be structured and accessed. We define precisely the state <b>access</b> <b>patterns</b> and discuss possible implementation schemas, performances and possibilities to manage adaptivity (parallelism degree) in the patterns. We present experimental results relative to implementations built on top of the structured parallel programming framework FastFlow that demonstrate the feasibility and efficiency of the proposed <b>access</b> <b>patterns...</b>|$|R
40|$|Web usage mining is an {{interesting}} application of data mining which provides insight into customer behaviour on the Internet. An important technique to discover user access and navigation trails is based on sequential patterns mining. One of the key challenges for web <b>access</b> <b>patterns</b> mining is tackling the problem of mining richly structured patterns. This paper proposes a novel model called Web <b>Access</b> <b>Patterns</b> Graph (WAP-Graph) to represent all of the <b>access</b> <b>patterns</b> from web mining graphically. WAP-Graph also motivates the search for new structural relation patterns, i. e. Concurrent <b>Access</b> <b>Patterns</b> (CAP), to identify and predict more complex web page requests. Corresponding CAP mining and modelling methods are proposed and shown {{to be effective in}} the search for and representation of concurrency between <b>access</b> <b>patterns</b> on the web. From experiments conducted on large-scale synthetic sequence data as well as real web access data, it is demonstrated that CAP mining provides a powerful method for structural knowledge discovery, which can be visualised through the CAP-Graph model...|$|R
40|$|Dynamic {{tables that}} support search, insert and delete {{operations}} are fundamental and well studied in computer science. There are many well known data structures that solve this problem, including balanced binary trees, skip lists and tries among others. Many {{of the existing}} data structures work efficiently when the <b>access</b> <b>patterns</b> are uniform, but in many circumstance <b>access</b> <b>patterns</b> are biased. Various data structures have been proposed that exploit bias in <b>access</b> <b>patterns</b> to improve efficiency for the operations they support. In this pape...|$|R
5000|$|PayPal - Developing and {{designing}} a shared central system that designers {{can use to}} <b>access</b> <b>pattern</b> guidance, images and assets.|$|E
5000|$|At the {{opposite}} extreme {{is a truly}} random memory <b>access</b> <b>pattern.</b> A few multiprocessor systems are specialised to deal with these.|$|E
5000|$|... and programmers understand,analyse {{and improve}} the memory <b>access</b> <b>pattern,</b> e.g., VTune, Vectorization Advisor, and others, {{including}} tools to address GPU memory access patterns ...|$|E
40|$|Characterizing malware {{behavior}} {{using its}} control flow faces several challenges, such as obfuscations in static analysis {{and the behavior}} variations in dynamic analysis. This paper introduces {{a new approach to}} characterizing kernel malware’s behavior by using kernel data <b>access</b> <b>patterns</b> unique to the malware. The approach neither uses malware’s control flow consisting of temporal ordering of malware code execution, nor the code-specific information about the malware. Thus, the malware signature based on such data <b>access</b> <b>patterns</b> is resilient in matching malware variants. To evaluate the effectiveness of this approach, we first generated the signatures of three classic rootkits using their data <b>access</b> <b>patterns,</b> and then matched them with a group of kernel execution instances which are benign or compromised by 16 kernel rootkits. The malware signatures did not trigger any false positives in benign kernel runs; however, kernel runs compromised by 16 rootkits were detected due to the data <b>access</b> <b>patterns</b> shared with the compared signature(s). We further observed similar data <b>access</b> <b>patterns</b> in the signatures of the tested rootkits and exposed popular rootkit attack operations by ranking common data behavior across rootkits. Our experiments show that our approach is effective not only to detect the malware whose signature is available, but also to determine its variants which share kernel data <b>access</b> <b>patterns.</b> Categories andSubjectDescriptor...|$|R
40|$|Most wide-area {{information}} servers are instrumented {{to collect}} statistics about documents that clients retrieve. However, instrumenting wide-area information servers presents a limited picture of client <b>access</b> <b>patterns.</b> To characterize client patterns that involve several protocols and many servers in a wide-area information system, {{it is necessary}} to instrument clients as well as servers. Precise characterization of client <b>access</b> <b>patterns</b> can be used effectively to decrease network load, server load, and client access latency. This report describes a tracing facility for collecting wide-area information <b>access</b> <b>patterns.</b> November 1, 1994 Computer Science Department The Pennsylvania State University University Park, PA 16802 - 6103 1 Introduction Most wide-area information servers are instrumented to collect statistics about documents that clients retrieve. However, instrumenting wide-area information servers presents a limited picture of client <b>access</b> <b>patterns.</b> To characterize client [...] ...|$|R
30|$|Scalable Workload-Driven Partitioning (Partitioning {{based on}} Data <b>Access</b> <b>Patterns)</b> Scalable workload-driven {{partitioning}} is not static or dynamic partitioning scheme. It lays between static and dynamic partitioning scheme. In this partitioning, the transaction logs {{and the data}} <b>access</b> <b>patterns</b> are analyzed (that is, which warehouse is more probable to supply to particular warehouse). This analysis is performed periodically and the partitions are formed based on data <b>access</b> <b>patterns.</b> Once the partitions are formed, they may change in future, based on data <b>access</b> <b>patterns.</b> Therefore, this scheme cannot be classified as static or dynamic partitioning. The advantage of using this partitioning scheme is partitions are formed after performing an analysis. Therefore the least number of distributed transactions occur. This analysis is performed periodically and therefore the reorganization of application data is not frequent. Thus the cost is also minimized.|$|R
50|$|This three-tiered data <b>access</b> <b>pattern,</b> {{makes it}} easy to keep {{temporary}} data away from slow memories, thus making the silicon implementation highly efficient and power-saving.|$|E
5000|$|In computing, {{a memory}} <b>access</b> <b>pattern</b> or IO <b>access</b> <b>pattern</b> is the pattern with which a system or program reads and writes memory or {{secondary}} storage. These patterns {{differ in the}} level of locality of reference and drastically affect cache performance, and also have implications for the approach to parallelism and distribution of workload in shared memory systems. [...] Further, cache coherency issues can affect multiprocessor performance, which means that certain memory access patterns place a ceiling on parallelism (which manycore approaches seek to break).|$|E
50|$|The {{simplest}} extreme is the sequential <b>access</b> <b>pattern,</b> where data is read, processed, {{and written}} out with straightforward incremented/decremented addressing. These access patterns are highly amenable to prefetching.|$|E
50|$|Data {{warehouses}} are {{optimized for}} analytic <b>access</b> <b>patterns.</b> Analytic <b>access</b> <b>patterns</b> generally involve selecting specific fields and rarely if ever 'select *' as {{is more common}} in operational databases. Because of these differences in <b>access</b> <b>patterns,</b> operational databases (loosely, OLTP) benefit from the use of a row-oriented DBMS whereas analytics databases (loosely, OLAP) benefit from the use of a column-oriented DBMS. Unlike operational systems which maintain a snapshot of the business, data warehouses generally maintain an infinite history which is implemented through ETL processes that periodically migrate data from the operational systems over to the data warehouse.|$|R
40|$|A major {{constraint}} in high-level synthesis (HLS) {{for large-scale}} ASIC systems is memory <b>access</b> <b>patterns.</b> Typically, most state-of-the-art HLS tools severely constrain {{the kinds of}} memory references allowed in the source, requiring them to have predictable <b>access</b> <b>patterns</b> or requiring dependencies between them to be statically determinable. This paper shows how these constraints can be eliminated. We present a...|$|R
50|$|Array accesses with statically {{predictable}} <b>access</b> <b>patterns</b> are a {{major source}} of data parallelism.|$|R
50|$|ORAMs were {{introduced}} by Goldreich and Ostrovsky {{where in the}} key motivation was stated as software protection from an adversary who can observe the memory <b>access</b> <b>pattern</b> (but not {{the contents of the}} memory).|$|E
50|$|We say if {{a machine}} is {{oblivious}} if the sequence {{in which it}} accesses is equivalent for any two input with the same running time. So the data <b>access</b> <b>pattern</b> is independent from the input.|$|E
50|$|Locality of {{reference}} may also refer to individual variables (e.g. {{the ability of}} a compiler to cache them in registers), whilst the term memory <b>access</b> <b>pattern</b> only refers to data held in an indexable memory (especially main memory).|$|E
40|$|Abstract. Much {{work has}} been done on characterizing the {{workload}} of a database system. Previous studies focused on providing different types of statistical summaries, and modeling the run-time behavior on the physical resource level as well. In this paper, we focus on characterizing the database system’s workload from the view of database user. We use user <b>access</b> <b>patterns</b> to describe how a client application or a group of users access the data of a database system. The user <b>access</b> <b>patterns</b> include a set of user access events that represent the format of the queries and a set of user access graphs that represent the query execution orders. User <b>access</b> <b>patterns</b> can help database administrators tune the system, help database users optimize queries, and help to predict and cache future queries. In this paper, we will present several approaches to use user <b>access</b> <b>patterns</b> to improve system performance, and report some experimental results. ...|$|R
40|$|Files are a {{tried and}} true {{operating}} system abstraction. They present a simple byte-stream model of I/O that has proven intuitive for application programmers and efficient for operating system builders. However, current file systems do not provide good support for adaptive continuous media (CM) applications - an increasingly important class of applications that exhibit complex <b>access</b> <b>patterns</b> and are particularly sensitive to variations in I/O performance. To address these problems we propose synthetic files. Synthetic files are specialized views of underlying regular files, and convert complex file <b>access</b> <b>patterns</b> into simple sequential synthetic file <b>access</b> <b>patterns.</b> Synthetic file construction {{can be viewed as}} a declarative meta-interface for I/O, enabling application-driven prefetching strategies that can hide device access latency even for applications with complex <b>access</b> <b>patterns.</b> Synthetic files can be realized dynamically, incremen-tally, or even optimistically. In this paper we outline a feedback-driven, incremental creation strategy that hides variations in device access latency for QoS-adaptive CM applications...|$|R
30|$|Rule 3.2 : Column {{families}} in the same HTable should generally have the same <b>access</b> <b>patterns.</b>|$|R
