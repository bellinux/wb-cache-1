32|76|Public
2500|$|Though not {{directly}} related to the numerical interpretation of binary symbols, sequences of bits may be manipulated using Boolean logical operators. When a string of binary symbols is manipulated in this way, it is called a bitwise operation; the logical operators AND, OR, and XOR may be performed on corresponding bits in two binary numerals provided as input. The logical NOT operation may be performed on individual bits in a single binary numeral provided as input. Sometimes, such operations may be used as arithmetic short-cuts, and may have other computational benefits as well. [...] For example, an <b>arithmetic</b> <b>shift</b> left of a binary number is the equivalent of multiplication by a (positive, integral) power of 2.|$|E
50|$|Because the {{denominator}} is a {{power of}} two the multiplication can be implemented as an <b>arithmetic</b> <b>shift</b> {{to the left and}} the division as an <b>arithmetic</b> <b>shift</b> to the right; on many processors shifts are faster than multiplication and division.|$|E
50|$|In binary (base 2) math, {{multiplication}} by a {{power of}} 2 is merely a register shift operation. Thus, multiplying by 2 is calculated in base-2 by an <b>arithmetic</b> <b>shift.</b> The factor (2−1) is a right <b>arithmetic</b> <b>shift,</b> a (0) results in no operation (since 20 = 1, is the multiplicative identity element), and a (21) results in a left arithmetic shift.The multiplication product can now be quickly calculated using only <b>arithmetic</b> <b>shift</b> operations, addition and subtraction.|$|E
25|$|SIMD {{operations}} are basic <b>arithmetic,</b> <b>shifts</b> and some multiply-accumulate type operations.|$|R
3000|$|... [4]. This packet size {{ensures that}} the <b>arithmetic</b> <b>shifts</b> {{implement}} delay (not cyclic shifts). Therefore, the overall effective rate for [...]...|$|R
50|$|<b>Arithmetic</b> left <b>shifts</b> are {{equivalent}} to multiplication by a (positive, integral) {{power of the}} radix (e.g., a multiplication by a power of 2 for binary numbers). <b>Arithmetic</b> left <b>shifts</b> are, with two exceptions, identical in effect to logical left shifts. Exception one is the minor trap that <b>arithmetic</b> <b>shifts</b> may trigger <b>arithmetic</b> overflow whereas logical shifts do not. Obviously, that exception occurs in real world use cases only if a trigger signal for such an overflow is needed by the design it is used for. Exception two is the MSB is preserved. Processors usually do not offer logical and <b>arithmetic</b> left <b>shift</b> operations with a significant difference, if any.|$|R
50|$|An <b>arithmetic</b> <b>shift</b> left of a {{balanced}} ternary number {{is the equivalent of}} multiplication by a (positive, integral) power of 3; and an <b>arithmetic</b> <b>shift</b> right of {{a balanced}} ternary number is the equivalent of division by a (positive, integral) power of 3.|$|E
5000|$|In an <b>arithmetic</b> <b>shift,</b> {{the bits}} that are shifted out of either end are discarded. In a left <b>arithmetic</b> <b>shift,</b> zeros are shifted {{in on the}} right; in a right <b>arithmetic</b> <b>shift,</b> the sign bit (the MSB in two's complement) is shifted in on the left, thus {{preserving}} {{the sign of the}} operand. This statement is not reliable in the latest C language draft standard, however. If the value being shifted is negative, the result is [...] "implementation-defined," [...] indicating the result is not necessarily consistent across platforms.|$|E
5000|$|The formal {{definition}} of an <b>arithmetic</b> <b>shift,</b> from Federal Standard 1037C is that it is: ...|$|E
2500|$|Shifting: (logical, i.e. right shifts put zero in the most-significant bit) LSL, LSR, (<b>arithmetic</b> <b>shifts,</b> i.e. sign-extend the most-significant bit) ASR, ASL, (rotates through eXtend and not) ROXL, ROXR, ROL, ROR ...|$|R
5000|$|... #Subtitle level 3: Equivalence of <b>arithmetic</b> left <b>shift</b> and {{multiplication}} ...|$|R
5000|$|... #Subtitle level 3: Non-equivalence of <b>arithmetic</b> right <b>shift</b> and {{division}} ...|$|R
50|$|A left <b>arithmetic</b> <b>shift</b> by n is {{equivalent}} to multiplying by 2n (provided the value does not overflow), while a right <b>arithmetic</b> <b>shift</b> by n of a two's complement value {{is equivalent}} to dividing by 2n and rounding toward negative infinity. If the binary number is treated as ones' complement, then the same right-shift operation results in division by 2n and rounding toward zero.|$|E
5000|$|... {{replacing}} integer division or multiplication by a {{power of}} 2 with an <b>arithmetic</b> <b>shift</b> or logical shift ...|$|E
50|$|A shift, {{applied to}} the {{representation}} of a number in a fixed radix numeration system and in a fixed-point representation system, and in which only the characters representing the fixed-point part of the number are moved. An <b>arithmetic</b> <b>shift</b> is usually equivalent to multiplying the number by a positive or a negative integral power of the radix, except for the effect of any rounding; compare the logical shift with the <b>arithmetic</b> <b>shift,</b> {{especially in the case}} of floating-point representation.|$|E
2500|$|MIPS I has {{instructions}} to perform {{left and right}} logical <b>shifts</b> and right <b>arithmetic</b> <b>shifts.</b> The operand is obtained from a GPR (rt), {{and the result is}} written to another GPR (rd). The shift distance is obtained from either a GPR (rs) or an 5-bit [...] "shift amount" [...] (the [...] "sa" [...] field).|$|R
5000|$|Logical right <b>shift</b> {{differs from}} <b>arithmetic</b> right <b>shift.</b> Thus, many {{languages}} have different operators for them. For example, in Java and JavaScript, the logical right shift operator is >>>, but the <b>arithmetic</b> right <b>shift</b> operator is >>. (Java {{has only one}} left shift operator (<<), because left shift via logic and arithmetic have the same effect.) ...|$|R
50|$|The binary GCD {{algorithm}}, {{also known}} as Stein's algorithm, is an algorithm that computes the greatest common divisor of two nonnegative integers. Stein's algorithm uses simpler arithmetic operations than the conventional Euclidean algorithm; it replaces division with <b>arithmetic</b> <b>shifts,</b> comparisons, and subtraction. Although the algorithm was first published by the Israeli physicist and programmer Josef Stein in 1967, {{it may have been}} known in 1st-century China.|$|R
5000|$|The {{following}} Python code simulates {{the aging}} algorithm.Counters [...] are initialized with [...] and updated {{as described above}} via , using <b>arithmetic</b> <b>shift</b> operators.|$|E
5000|$|... #Caption: A left <b>arithmetic</b> <b>shift</b> of {{a binary}} number by 1. The empty {{position}} in the least significant bit is filled with a zero.|$|E
5000|$|... l-sequences {{have many}} {{excellent}} statistical properties {{that make them}} candidates for use in applications, including near uniform distribution of sub-blocks, ideal arithmetic autocorrelations, and the <b>arithmetic</b> <b>shift</b> and add property. They are the with-carry analog of m-sequences or maximum length sequences.|$|E
50|$|Variants of {{existing}} instructions operate on these data types, performing saturating <b>arithmetic,</b> logical, <b>shift,</b> compare and align operations.|$|R
50|$|Logical right shifts are {{equivalent}} to division by {{a power of}} the radix (usually 2) only for positive or unsigned numbers. <b>Arithmetic</b> right <b>shifts</b> are {{equivalent to}} logical right shifts for positive signed numbers. <b>Arithmetic</b> right <b>shifts</b> for negative numbers in N&minus;1's complement (usually two's complement) is roughly equivalent to division by a power of the radix (usually 2), where for odd numbers rounding downwards is applied (not towards 0 as usually expected).|$|R
5000|$|A fixed-point {{overflow}} exceptionPoOps {{is recognized}} when significant bits are {{lost in a}} fixed point <b>arithmetic</b> or <b>shift</b> instruction, other than divide.|$|R
50|$|HD1080 is 1920x1080 pixels, so {{dividing}} the resolution by 4 in each axis gives 480x270 pixels. This is a computationally convenient process, as HD1080 content can be scaled down simply by summing blocks of 16 pixels and dividing by 16 (<b>arithmetic</b> <b>shift</b> right 4 bits).|$|E
50|$|The shifter {{contains}} a 32-bit input and output. The output is connected {{directly to the}} C bus. The shifter is used to perform logical and <b>arithmetic</b> <b>shift</b> operations, by simply setting respectively the control signal SLL8 (Shift Left Logical) and SRA1 (Shift Right Arithmetic).|$|E
50|$|The {{programming}} languages C, C++, and Go, however, {{have only}} one right shift operator, >>. Most C and C++ implementations, and Go, choose which right shift to perform {{depending on the type}} of integer being shifted: signed integers are shifted using the <b>arithmetic</b> <b>shift,</b> and unsigned integers are shifted using the logical shift.|$|E
50|$|ASH, ASHC <b>arithmetic</b> - <b>shift</b> a {{register}} or {{a register}} pair. For a positive number it will shift left, and {{right for a}} negative one.|$|R
50|$|<b>Arithmetic</b> <b>shifts</b> can {{be useful}} as {{efficient}} ways to perform multiplication or division of signed integers by powers of two. Shifting left by n bits on a signed or unsigned binary number {{has the effect of}} multiplying it by 2n. Shifting right by n bits on a two's complement signed binary number has the effect of dividing it by 2n, but it always rounds down (towards negative infinity). This is different from the way rounding is usually done in signed integer division (which rounds towards 0). This discrepancy has led to bugs in more than one compiler.|$|R
5000|$|It is {{frequently}} stated that <b>arithmetic</b> right <b>shifts</b> are equivalent to division by a (positive, integral) {{power of the}} radix (e.g., a division by a power of 2 for binary numbers), and hence that division by a power of the radix can be optimized by implementing it as an <b>arithmetic</b> right <b>shift.</b> (A shifter is much simpler than a divider. On most processors, shift instructions will execute faster than division instructions.) Large number of 1960s and 1970s programming handbooks, manuals, and other specifications from companies and institutions such as DEC, IBM, Data General, and ANSI make such incorrect statements [...]|$|R
50|$|Booth's {{algorithm}} can {{be implemented}} by repeatedly adding (with ordinary unsigned binary addition) one of two predetermined values A and S to a product P, then performing a rightward <b>arithmetic</b> <b>shift</b> on P. Let m and r be the multiplicand and multiplier, respectively; and let x and y represent the number of bits in m and r.|$|E
50|$|Here blank {{spaces are}} {{generated}} simultaneously {{on the left}} when the bits are shifted to the right. When performed on an unsigned type, the operation performed is a logical shift, causing the blanks to be filled by 0s (zeros). When performed on a signed type, the result is technically undefined and compiler dependant, however most compilers will perform an <b>arithmetic</b> <b>shift,</b> causing the blank {{to be filled with}} the sign bit of the left operand.|$|E
50|$|In {{computer}} programming, {{a circular}} shift (or bitwise rotation) is a shift operator that shifts all bits of its operand. Unlike an <b>arithmetic</b> <b>shift,</b> a circular shift does not preserve a number's sign bit or distinguish a number's exponent from its significand (sometimes {{referred to as}} the mantissa). Unlike a logical shift, the vacant bit positions are not filled in with zeros but are filled in with the bits that are shifted out of the sequence.|$|E
50|$|<b>Arithmetic</b> right <b>shifts</b> for {{negative}} numbers are equivalent to division using rounding towards 0 in one's complement representation of signed numbers as {{was used by}} some historic computers, {{but this is no}} longer in general use.|$|R
40|$|Multistage {{detectors}} {{have been}} accepted in designs for next generation CDMA base stations because they are less complex than some other multiuser detectors. In this thesis, we propose a differencing method to further reduce complexity. It achieves both high performance in the interference cancellation and computational efficiency. When interference cancellation converges, the difference of the detection vectors between two consecutive stages is mostly zero. We recode the estimation bits, mapping from ± 1 to 0 and ± 2. Bypassing all the zero terms saves computations. Multiplication by ± 2 can be easily implemented in hardware as <b>arithmetic</b> <b>shifts.</b> The system delay of a five-stage detector will be reduced by 75...|$|R
5000|$|Shift and Rotate [...] - [...] <b>Arithmetic</b> and Logical <b>Shifts,</b> 16- and 17-bit Rotates ...|$|R
