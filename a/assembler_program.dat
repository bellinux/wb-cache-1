35|111|Public
25|$|An <b>assembler</b> <b>program</b> creates {{object code}} by {{translating}} combinations of mnemonics and syntax for operations and addressing modes into their numerical equivalents. This representation typically includes an operation code ("opcode") {{as well as}} other control bits and data. The assembler also calculates constant expressions and resolves symbolic names for memory locations and other entities. The use of symbolic references is a key feature of assemblers, saving tedious calculations and manual address updates after program modifications. Most assemblers also include macro facilities for performing textual substitution – e.g., to generate common short sequences of instructions as inline, instead of called subroutines.|$|E
500|$|... {{summarizes}} {{the early history}} of linear probing. It was the first open addressing method, and was originally synonymous with open addressing. According to Knuth, it was first used by Gene Amdahl, Elaine M. McGraw (née Boehme), and Arthur Samuel in 1954, in an <b>assembler</b> <b>program</b> for the IBM 701 computer. The first published description of linear probing is by , who also credits Samuel, Amdahl, and Boehme but adds that [...] "the system is so natural, that it very likely may have been conceived independently by others either before or since that time". Another early publication of this method was by Soviet researcher Andrey Ershov, in 1958.|$|E
2500|$|It is also {{possible}} to use solely the macro processing abilities of an assembler to generate code written in completely different languages, for example, to generate a version of a program in COBOL using a pure macro <b>assembler</b> <b>program</b> containing lines of COBOL code inside assembly time operators instructing the assembler to generate arbitrary code. IBM OS/360 uses macros to perform system generation. The user specifies options by coding a series of assembler macros. [...] Assembling these macros generates a job stream to build the system, including job control language and utility control statements.|$|E
50|$|As the 1400 series matured {{additional}} <b>assemblers,</b> <b>programming</b> {{languages and}} report generators became available, replacing SPS in most sites.|$|R
50|$|To {{enhance the}} {{mathematical}} abilities of BASIC, (and <b>assembler</b> <b>programs)</b> an AMD AM9511 floating point co-processor (compatible with the Intel 8231) could be added.|$|R
50|$|In <b>assembler</b> <b>programming,</b> {{the term}} 'clobbered {{registers}}' {{is used to}} denote any registers whose value may be overwritten {{during the course of}} executing an instruction or procedure.|$|R
50|$|The {{following}} listing shows a card deck that compiles {{and runs}} an <b>Assembler</b> <b>program</b> that lists {{a deck of}} cards to the line printer.|$|E
50|$|A machine instruction, usually {{generated}} by an <b>assembler</b> <b>program,</b> is often considered the smallest unit of processing {{although this is}} not always the case. It typically performs what is perceived to be one operation such as copying a byte or string of bytes from one computer memory location to another or adding one processor register to another.|$|E
50|$|In 1975, Michael Shrayer {{had moved}} to California after 20 years as a New York filmmaker. Enjoying {{assembling}} electronic kits, he purchased and assembled a MITS Altair 8800 computer, then modified a public domain <b>assembler</b> <b>program</b> for the Processor Technology Sol-20. Fellow computer hobbyists wanted to buy the improved program, giving Shrayer an unexpected and lucrative new business.|$|E
40|$|ABSTRACT Digital Signal Processors {{are widely}} used in {{critical}} embedded systems to pilot low-level, often critical functionalities. We describe a static analyzer based on abstract interpretation and designed to validate industrial <b>assembler</b> <b>programs</b> for a DSP. The validation consists of guaranteeing the absence of runtime errors such as incorrect memory accesses and of tracking the sources of inaccuracies introduced by floating-point computations. Our first contribution is a new static analysis for relocatable <b>assembler</b> <b>programs</b> {{able to cope with}} dynamically computed branching addresses. Our second contribution is the analyzer itself and its graphical interface which helps the user to understand the numerical inaccuracies...|$|R
50|$|With the {{so-called}} ’’Basic Assembler Tool for MikroSim’’ MikroBAT, simple {{programs can be}} developed in <b>assembler</b> <b>programming</b> language. Here, all supported mnemonics of the <b>assembler</b> <b>programming</b> language {{are determined by the}} user’s self-created machine’s instruction set on micro instruction level. The add-on tool is able to translate the assembly language program into machine code and data and transferring the binary code into the external RAM for subsequent simulations. Together with MikroBAT the microcode simulator MikroSim supports the didactical introduction of teaching aspects in technical computer science from a switch-controlled calculating machine to an assembler programmable application.|$|R
25|$|Multiple sets of {{mnemonics}} or assembly-language syntax {{may exist}} {{for a single}} instruction set, typically instantiated in different <b>assembler</b> <b>programs.</b> In these cases, the most popular one is usually that supplied by the manufacturer and used in its documentation.|$|R
50|$|Bootstrapping {{can also}} {{refer to the}} {{development}} of successively more complex, faster programming environments. The simplest environment will be, perhaps, a very basic text editor (e.g., ed) and an <b>assembler</b> <b>program.</b> Using these tools, one can write a more complex text editor, and a simple compiler for a higher-level language and so on, until one can have a graphical IDE and an extremely high-level programming language.|$|E
50|$|Devpac Assembler by HiSoft was a {{professional}} <b>assembler</b> <b>program</b> that became the de facto standard for assembly programming. It was also able {{to be used for}} Cross-platform development for any other Motorola 68k-based device, such as the Atari ST. It was common for programs to be jointly written for the Amiga and Atari using Devpac on the Amiga. However, since the Atari ST was the less capable of the two machines, programs would be tested on and built primarily for the ST.|$|E
50|$|The N8VEM {{boards are}} {{designed}} with the free KiCad Electronic design automation (EDA) toolset. Printed circuit board routing provided by FreeRouting.net. Software is developed in Z80/8085 assembly language using the MS-DOS Telemark Cross <b>Assembler</b> <b>program</b> (TASM), {{as well as the}} open source Small Device C Compiler. A major design goal is to use freely available tools to the maximum extent possible. The printed circuit board design is supplemented using component libraries available at KiCad Libraries, specifically the Zilog Z80 CPU and Intel 8255 PPI chips.|$|E
40|$|Assembler Encoding is a neuro-evolutionary {{method in}} which a neural network is {{represented}} {{in the form of}} a simple <b>program</b> called <b>Assembler</b> Encoding <b>Program.</b> The task of the program is to create the so-called Network Definition Matrix which maintains all the information necessary to construct the network. To generate <b>Assembler</b> Encoding <b>Programs</b> and the subsequent neural networks evolutionary techniques are used. The performance of Assembler Encoding strongly depends on operations used in <b>Assembler</b> Encoding <b>Programs.</b> To select the most effective operations, experiments in the optimization and the predator-prey problem were carried out. In the experiments, <b>Assembler</b> Encoding <b>Programs</b> equipped with different types of operations were tested. The results of the tests are presented at the end of the paper...|$|R
50|$|Input was {{normally}} {{done with}} a hexadecimal keyboard, using a machine language monitor program, and the display only consisted of a 7-segment display. Backup storage of written <b>assembler</b> <b>programs</b> was primitive: only a cassette type interface was typically provided, or the serial Teletype interface was used to read (or punch) a papertape.|$|R
40|$|Research in Worst-Case Execution Time (WCET) {{analysis}} aims at integrating WCET {{analysis with}} program compilation. This integration increases compiler complexity and forces real-time software developers to use specific compilers. This paper describes a simple approach to WCET analysis {{that is not}} compiler specific: A software tool reads the path information contained in source programs and maps this information onto the respective <b>assembler</b> <b>programs.</b> A low-level WCET analysis tool then computes detailed timing information of the annotated <b>assembler</b> <b>programs</b> and passes the information back to the source level. Experiments demonstrate the feasibility of the approach. 1 Introduction In the past years worst-case execution time (WCET) analysis has become an acknowledged part {{in the theory of}} real-time systems construction. Researchers working on WCET analysis introduced extensions of high-level programming languages to describe possible execution paths [Kligerman, Stoyenko 1986, [...] ...|$|R
50|$|It is also {{possible}} to use solely the macro processing abilities of an assembler to generate code written in completely different languages, for example, to generate a version of a program in COBOL using a pure macro <b>assembler</b> <b>program</b> containing lines of COBOL code inside assembly time operators instructing the assembler to generate arbitrary code. IBM OS/360 uses macros to perform system generation. The user specifies options by coding a series of assembler macros. Assembling these macros generates a job stream to build the system, including job control language and utility control statements.|$|E
5000|$|Using the opcode 29 as an illustration, the {{assembler}} code (AD X2,X1,offset) {{causes the}} contents of the memory location 'offset(X1)' to be added to register X2. Thus, register X1 is being used as the index register, and the offset, v, is specified in the second byte of the instruction. G is a dummy index register whose value is alway zero, and hence causes the offsets to be treated as absolute addresses in the zeroth (global) segment. (Incidentally, since X3 is the standard index register, the <b>assembler</b> <b>program</b> allows ',X3,address' to be abbreviated to ',address'.) ...|$|E
50|$|Historically, {{bootstrapping}} also {{refers to}} an early technique for computer program development on new hardware. The technique described in this paragraph {{has been replaced by}} the use of a cross compiler executed by a pre-existing computer. Bootstrapping in program development began during the 1950s when each program was constructed on paper in decimal code or in binary code, bit by bit (1s and 0s), because there was no high-level computer language, no compiler, no assembler, and no linker. A tiny <b>assembler</b> <b>program</b> was hand-coded for a new computer (for example the IBM 650) which converted a few instructions into binary or decimal code: A1. This simple <b>assembler</b> <b>program</b> was then rewritten in its just-defined assembly language but with extensions that would enable the use of some additional mnemonics for more complex operation codes. The enhanced assembler's source program was then assembled by its predecessor's executable (A1) into binary or decimal code to give A2, and the cycle repeated (now with those enhancements available), until the entire instruction set was coded, branch addresses were automatically calculated, and other conveniences (such as conditional assembly, macros, optimisations, etc.) established. This was how the early assembly program SOAP (Symbolic Optimal Assembly Program) was developed. Compilers, linkers, loaders, and utilities were then coded in assembly language, further continuing the bootstrapping process of developing complex software systems by using simpler software.|$|E
5000|$|In IBM {{mainframe}} operating systems, such as OS/360, MVS, z/OS, a Data Control Block (DCB) is {{a description}} of a dataset in a program. A DCB is coded in <b>Assembler</b> <b>programs</b> using the DCB macro instruction (which expands into a large number of [...] "define constant" [...] instructions). High level language programmers use library routines containing DCBs.|$|R
40|$|Previous work on {{formally}} modelling and analysing {{program compilation}} {{has shown the}} need for a simple and expressive semantics for <b>assembler</b> level <b>programs.</b> <b>Assembler</b> <b>programs</b> contain unstructured jumps and previous formalisms have modelled these by using continuations, or by embedding the program in an explicit emulator. We propose a simpler approach, which uses techniques from compiler theory in a formal setting. This approach is based on an interpretation of programs as collections of program paths, each of which has a weakest liberal precondition semantics. We then demonstrate, by example, how we can use this formalism to justify the compilation of block-structured high-level language <b>programs</b> into <b>assembler...</b>|$|R
50|$|FMS, the Fortran Monitor System, {{was a more}} {{lightweight}} {{but still}} very effective system optimized for batch FORTRAN and <b>assembler</b> <b>programming.</b> The <b>assembler</b> provided, FAP, (FORTRAN Assembly Program), was somewhat less complete than MAP, but provided excellent capabilities for the era. FMS also incorporated a considerably enhanced derivative of the FORTRAN compiler originally written for the 704 by Backus and his team.|$|R
50|$|An <b>assembler</b> <b>program</b> creates {{object code}} by {{translating}} combinations of mnemonics and syntax for operations and addressing modes into their numerical equivalents. This representation typically includes an operation code ("opcode") {{as well as}} other control bits and data. The assembler also calculates constant expressions and resolves symbolic names for memory locations and other entities. The use of symbolic references is a key feature of assemblers, saving tedious calculations and manual address updates after program modifications. Most assemblers also include macro facilities for performing textual substitution - e.g., to generate common short sequences of instructions as inline, instead of called subroutines.|$|E
5000|$|Macros {{are used}} to make a {{sequence}} of computing instructions available to the programmer as a single program statement, making the programming task less tedious and less error-prone. (Thus, they are called [...] "macros" [...] because a [...] "big" [...] block of code can be expanded from a [...] "small" [...] sequence of characters.) Macros often allow positional or keyword parameters that dictate what the conditional <b>assembler</b> <b>program</b> generates and have been used to create entire programs or program suites according to such variables as operating system, platform or other factors. The term derives from [...] "macro instruction", and such expansions were originally used in generating assembly language code.|$|E
5000|$|... {{summarizes}} {{the early history}} of linear probing. It was the first open addressing method, and was originally synonymous with open addressing. According to Knuth, it was first used by Gene Amdahl, Elaine M. McGraw (née Boehme), and Arthur Samuel in 1954, in an <b>assembler</b> <b>program</b> for the IBM 701 computer. The first published description of linear probing is by , who also credits Samuel, Amdahl, and Boehme but adds that [...] "the system is so natural, that it very likely may have been conceived independently by others either before or since that time". Another early publication of this method was by Soviet researcher Andrey Ershov, in 1958.|$|E
25|$|Michael Singer, PDP-11. <b>Assembler</b> Language <b>Programming</b> and Machine Organization, John Wiley & Sons, NY: 1980.|$|R
50|$|Endevor administrators can modify Endevor {{functions}} and capture information using exits. There are several exit types, each {{attached to a}} specific Endevor function. Exits are generally written as COBOL or <b>Assembler</b> <b>programs</b> but theoretically can be any language that can be compiled and linked on z/OS. An exit will specify where in the exit tree that the code will be executed and what will be affected.|$|R
5000|$|IL (instruction list) is an <b>assembler</b> like <b>programming</b> {{language}} (Is now deprecated but {{available for}} backward compatibilty [...] ) ...|$|R
50|$|Some simple {{applications}} such as text editors were entirely coded in Imlac assembler and could run without much involvement with a larger computer. Hofstadter composed his book Gödel, Escher, Bach on an Imlac editor. But most graphics applications required strong floating point support, compilers, and a file system. Those applications ran mostly on an expensive timeshared computer, which sent digested image data to the Imlac, which ran a small <b>assembler</b> <b>program</b> emulating a generic graphics terminal. A typical use was rendering architectural drawings and animated walkthroughs that had been previously drawn offline. PDS-1 use was held back for several years by not having a standard program library supporting animation or interactive drawing and dragging of objects.|$|E
5000|$|Unlike the octal-oriented PDP-11, the VAX-11 was a hexadecimal-oriented machine (4-bit sub-byte). This {{resulted}} in 16 logical addressing modes (0-15), however, addressing modes 0-3 were [...] "short immediate" [...] for immediate data of 6 bits or less (the 2 low-order {{bits of the}} addressing mode being the 2 high-order bits of the immediate data, when prepended to the remaining 4 bits in that data-addressing byte). Since addressing modes 0-3 were identical, this made 13 (electronic) addressing modes, but as in the PDP-11, {{the use of the}} Stack Pointer (R14) and Program Counter (R15) created a total of over 15 conceptual addressing modes (with the <b>assembler</b> <b>program</b> translating the source code into the actual stack-pointer or program-counter based addressing mode needed).|$|E
50|$|While macro {{instructions}} can {{be defined}} by a programmer for any set of native <b>assembler</b> <b>program</b> instructions, typically macros are associated with macro libraries delivered with the operating system allowing access to operating system functions such as peripheral access by access methods (including macros such as OPEN, CLOSE, READ and WRITE) and other operating system functions such as ATTACH, WAIT and POST for subtask creation and synchronization. Typically such macros expand into executable code, e.g., for the EXIT macroinstruction, a list of define constant instructions, e.g., for the DCB macro, {{or a combination of}} code and constants, with the details of the expansion depending on the parameters of the macro instruction (such as a reference to a file and a data area for a READ instruction); he executable code often terminated in either a branch and link register instruction to call a routine, or a supervisor call instruction to call an operating system function directly.|$|E
40|$|We {{prove the}} {{correctness}} of {{the translation of}} a prototypic While-language with nested, parameterless procedures to an abstract assembler language with finite stacks. A variant of the well-known wp and wlp predicate transformers, the weakest relative precondition transformer wrp, together with a symbolic approach for describing semantics of assembler code allows us to explore <b>assembler</b> <b>programs</b> in a manageable way and to ban finiteness from the scene early...|$|R
40|$|Two subroutines, DBGON and DBGOFF, {{designed}} to give users {{more control over the}} debug options supplied with the IBM 360 FORTRAN IV [G] compiler are described. Examples of the use of these subroutines in the debugging of a FORTRAN program are presented. Macros developed to simulate FORTRAN I/O in <b>Assembler</b> <b>programs</b> are also described, and their value to programmers converting FORTRAN <b>programs</b> into <b>Assembler</b> language routines is demonstrated...|$|R
40|$|Abstract: Assembler Encoding {{represents}} {{neural network}} {{in the form of}} a simple <b>program</b> called <b>Assembler</b> Encoding <b>Program.</b> The task of the program is to create the so-called Network Definition Ma-trix which maintains the whole information necessary to construct the network. To generate <b>Assembler</b> Encoding <b>Programs</b> and in consequence neural networks evolutionary techniques are used. In order to use evolutionary techniques to construct <b>Assembler</b> Encoding <b>Programs</b> it is necessary to encode them in the form of chromosomes. The simplest solution is to place the whole information necessary to construct the program into one chromosome. The paper suggests another approach. Methods proposed in the paper are an adaptation of Symbiotic Adaptive Neuro-evolution. To test the methods proposed they were used to solve a few simple optimization problems...|$|R
