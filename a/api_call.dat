101|617|Public
2500|$|Facebook {{originally}} used 'Facebook Markup Language (FBML)' {{to allow}} Facebook Application developers to customize the [...] "look and feel" [...] of their applications, {{to a limited}} extent. FBML is a specification of how to encode content so that Facebook's servers can read and publish it, which is needed in the Facebook-specific feed so that Facebook's system can properly parse content and publish it as specified. FBML set by any application is cached by Facebook until a subsequent <b>API</b> <b>call</b> replaces it. Facebook also offers a specialized Facebook JavaScript (FBJS) library.|$|E
50|$|Threading {{allows a}} {{separate}} sequence of execution for each <b>API</b> <b>call</b> that can block. This can prevent the overall application from stalling {{while waiting for}} a resource. This has the benefit {{that none of the}} information {{about the state of the}} <b>API</b> <b>call</b> is lost while other activities take place.|$|E
5000|$|Real-time {{guarantees}} (each <b>API</b> <b>call</b> is quick, {{but more}} importantly, time-bound) ...|$|E
50|$|Several {{adapters}} {{have been}} developed that expose a CIMI API endpoint for client applications to consume and translate <b>API</b> <b>calls</b> to the proprietary <b>API</b> <b>calls</b> of supported target cloud provider(s).|$|R
50|$|Transactions {{can either}} be {{controlled}} using SQL or <b>API</b> <b>calls.</b> It is recommended to use <b>API</b> <b>calls</b> for enabling and disabling the auto commit mode and for committing and rolling back transactions.|$|R
40|$|Abstract. For {{the problem}} that static {{disassembly}} can expose system <b>API</b> <b>calls</b> in programs, this paper proposes a kind of code obfuscation aimed at hiding system <b>API</b> <b>calls</b> from reverse analysis. The algorithm is implemented by creating a system API address table and constructing secret index variables. During execution, the program looks up the table for the correct <b>API</b> to <b>call,</b> thus keeping the semantic unchanged. Analysis and experiments show that the algorithm can effectively protect system <b>API</b> <b>calls</b> from static reverse analysis...|$|R
50|$|PhishTank data is {{provided}} gratis for download or for access via an <b>API</b> <b>call,</b> including for commercial use, under a restrictive license.|$|E
5000|$|INI mapping {{takes this}} Profile <b>API</b> <b>call,</b> ignores any {{path in the}} given {{filename}} and checks {{to see if there}} is a Registry key matching the filename under: ...|$|E
5000|$|There are {{two basic}} {{categories}} of devices as viewed by Windows and by AutoPlay. The volume based devices are those for which the GetDriveType Windows <b>API</b> <b>call</b> returns one of: ...|$|E
25|$|A {{version for}} the Android {{operating}} system was announced on 10 April 2008. Rather than port the code to Android, a wrapper {{was created to}} translate Java ME <b>API</b> <b>calls</b> to Android <b>API</b> <b>calls.</b>|$|R
40|$|Android, Google {{open source}} {{operating}} system for mobile devices, has been rapidly grown. Android applications (apps) are uploaded {{to not only}} official market, play store, but also other alternative markets. These markets have no inspection system for detecting malicious apps. So, malicious apps can be easily uploaded on the market. Many studies have presented to detect malicious apps for the secure Android mobile environment. But without user participation, {{it is difficult to}} detect all of malicious apps. We present a Warning System for detecting malicious applications on Android system. The warning system monitors <b>API</b> <b>calls</b> related suspicious behaviors running on the service layer. After analysis malicious apps, we find that almost malicious apps use similar <b>API</b> <b>calls.</b> We proposed modified Android platform to warn suspicious <b>API</b> <b>calls</b> are running on the service layer. The warning system lets user realize the information of suspicious <b>API</b> <b>calls</b> and block the <b>API</b> <b>calls...</b>|$|R
50|$|Most of the Native <b>API</b> <b>calls</b> are {{implemented}} in ntoskrnl.exe and {{are exposed to}} user mode by ntdll.dll. The entry point of ntdll.dll is LdrInitializeThunk. Native <b>API</b> <b>calls</b> are handled by the kernel via the System Service Descriptor Table (SSDT).|$|R
50|$|SQLite Workbench {{is a free}} online GUI to create, edit {{and manage}} SQLite databases. It also allows {{exporting}} data or accessing it through a remote REST <b>API</b> <b>call,</b> giving a full cloud database based on SQLite.|$|E
5000|$|The {{application}} program proceeded to execute normal machine code instructions {{right up to}} its first macro level <b>API</b> <b>call,</b> thus adding zero overhead to the program until that point. As soon as the <b>API</b> <b>call</b> left the {{application program}}, Command-CICS code would gain control and replace the original linkage with its own, equivalent, Command-level call.In original earlier command level CICS versions (that supported both Macro and Command level programs), the CICS [...] "Exec Interface Program" [...] (DFHEIP) converted the Command level call to an actual macro level call. This would add a very small additional overhead only during CICS calls. Later versions of CICS, however, executed the CICS API directly, imposing no additional [...] "backward compatibility" [...] overhead.|$|E
50|$|As an example, the TCP call blocks until a {{response}} becomes available from a remote server. This occurs {{every time you}} perform an action with a web browser. Intensive calculations cause lengthy delays with the same effect as a blocked <b>API</b> <b>call.</b>|$|E
40|$|Because {{we spend}} alot of time {{developing}} POC projects and those projects aren’t always successful, I {{have created a}} program, that {{will be able to}} generate API application using a simple configuration file. This application contains a database that can be accessed through web <b>API</b> <b>calls.</b> If required, <b>API</b> <b>calls</b> can be restricted by user, frequency and number of concurrent access to <b>API</b> <b>calls.</b> The service owner can monitor the statistics of <b>API</b> <b>calls</b> to insure its best posible operation. The Developer needs to add the implementation to the generated project. Result of this thesis is successful generation of API application using the configuration file, which creates the whole project, this includes the source code, documentation and tests. ...|$|R
40|$|We {{mine the}} <b>API</b> method <b>calls</b> used by Android App {{developers}} to (1) suggest related <b>API</b> <b>calls</b> {{based on the}} version history of Apps, (2) suggest related <b>API</b> <b>calls</b> based on StackOverflow posts, and (3) find potential App copyright and license vio- lations based the similarity of <b>API</b> <b>calls</b> made by them. Zimmermann et al suggested that ï¿½Programmers who changed these functions also changedï¿½ functions that could be mined from previous groupings of functions found in the version history of a system. Our first contribution is to expand this approach to a community of Apps. Android developers use a set of <b>API</b> <b>calls</b> when creating Apps. These API methods are used in similar ways across multiple applications. Clustering co-changing API methods used by 230 Android Apps, {{we are able to}} predict the changes to API methods that individual App developers will make to their application with an average precision of 73...|$|R
2500|$|As an autorun.inf file is a {{standard}} Windows INI file, the appropriate <b>API</b> <b>calls</b> are used by Windows when fetching its settings. These <b>API</b> <b>calls</b> can be redirected using the INI file mapping method. The following Registry file illustrates the workaround, where all autorun.inf settings are taken solely from the HKEY_LOCAL_MACHINE\Software\DoesNotExist Registry key: ...|$|R
50|$|Users {{are able}} to specify the media type in order to limit the types seen. This allows them to access {{information}} in the member’s URL record and response headers from http servers {{and access to the}} member’s data in a single <b>API</b> <b>call.</b>|$|E
5000|$|The SQL {{communications}} area (SQLCA) {{structure is}} used within the DB2 program to return error {{information to the}} application program. This information in the SQLCA and the SQLCODE field is updated after every <b>API</b> <b>call</b> for the SQL statement...SQLCA contains ERROR HANDLING data ...|$|E
50|$|Timers allow a {{blocked call}} to be interrupted. A {{periodic}} timer allows the programmer to emulate treading. Interrupts typically destroy any {{information related to}} the state of a blocked <b>API</b> <b>call</b> or intensive calculation, so the programmer must keep track of this information separately.|$|E
50|$|Unlike other true Macintosh emulators, Executor {{requires}} no startup ROM images or other Apple intellectual property. Executor, much like Wine for running Windows applications on Unix-like platforms, translates Macintosh Toolbox <b>API</b> <b>calls</b> and QuickDraw routines into equivalent Win32 or POSIX <b>API</b> <b>calls.</b> The MS-DOS version of Executor runs using the CWSDPMI protected mode DOS extender.|$|R
50|$|The code above can be {{substituted}} with the following FSPath <b>API</b> <b>calls...</b>|$|R
5000|$|The ARINC 653 APEX {{services}} are <b>API</b> <b>calls</b> belonging in six categories: ...|$|R
5000|$|And the {{following}} {{variant of the}} same code, which instead uses an inline Windows <b>API</b> <b>call</b> with no need for declarations or other external references, will create an even smaller 2.0 KB (2,048 bytes) standalone x86 executable for Windows. MessageBox_(0, [...] "Hello World", [...] "Message Box", 0) ...|$|E
50|$|As a {{web service}} {{running in the}} {{computing}} cloud, Amazon ElastiCache is designed to simplify the setup, operation, and scaling of memcached and Redis deployments. Complex administration processes like patching software, backing up and restoring data sets and dynamically adding or removing capabilities are managed automatically. Scaling ElastiCache resources can be performed by a single <b>API</b> <b>call.</b>|$|E
5000|$|The InvokeProgID and InvokeVerb {{values are}} used to start the {{application}} via the ShellExecuteEx <b>API</b> <b>call.</b> This is the same method used to, say, start Notepad when a user double-clicks on a [...]txt file; the application is not started directly. The values are Registry keys under HKEY_CLASSES_ROOT. In the example above, the relevant key would be: ...|$|E
50|$|An {{application}} is idle {{if it is}} waiting for some external event to occur, for example for a keystroke or a mouse movement, or for a fixed {{amount of time to}} pass. The DR-DOS kernel monitors all DOS <b>API</b> <b>calls</b> building up a profile of the applications behavior. Certain combinations of <b>API</b> <b>calls</b> suggest that the {{application is}} idle.|$|R
40|$|Abstract — Detection of zero day malware {{has been}} the great {{challenge}} for researchers from long time. Traditional signature based antimalware scanners detect malware based on their unique signatures. The major drawback of such traditional signatures based scanners {{is that it has}} no protection against zero-day or unseen malware. Further usage of packers and obfuscation techniques empowered the malware writers to recreate malware variants quickly with slight or no change in malcode. These new variants are undetectable by traditional signature based scanner until their signatures are not present in database. Therefore researchers are working towards finding patterns or features which have unchangeable characteristics of malware even though the malware mutates or obfuscates itself. To address the limitation of traditional signature based scanner, we propose the malware detection method based on extracting relevant application programming interface (<b>API)</b> <b>calls</b> from sub categories of malware. These malware are categorized based on their infection mechanism and actions performed. And because of their fundamental difference in infection mechanism, they do not share similar type of <b>API</b> <b>calls</b> in all malware categories. In this paper, we elucidate an automated framework for analyzing and classifying executables based on their relevant <b>API</b> <b>calls.</b> We explain all the software components used to make the framework fully automatic for extracting <b>API</b> <b>calls.</b> We further explain the Document Class wise Frequency feature selection measure (DCFS) to get the relevant <b>API</b> <b>calls</b> from the extracted <b>API</b> <b>calls</b> to increase the detection rate. We conclude the paper with our experimental result and discussion...|$|R
50|$|Custom {{integration}} of third party tools {{can be achieved}} via FUDforum's provided <b>API,</b> <b>called</b> FUDAPI.|$|R
50|$|AlchemyAPI uses {{technology}} {{similar to}} IBM's Watson computer. It gets paid per <b>API</b> <b>call,</b> and does over 3 billion API calls per month. A TechCrunch article highlights {{that even though}} the technology is similar, AlchemyAPI offers its technology in the form of software as a service (by allowing people to make API calls), making its technological capabilities more accessible to people.|$|E
5000|$|Depending on the context, compiler, or assembler, a {{software}} interrupt number is often given as a hexadecimal value, sometimes with a prefix 0x or the suffix h. For example, [...] will generate the software interrupt 0x21 (33 in decimal), causing the function pointed {{to by the}} 34th vector in the interrupt table to be executed, which is typically an MS-DOS <b>API</b> <b>call.</b>|$|E
5000|$|BD-09 is a {{geographic}} coordinate system used by Baidu Maps, adding further obfuscation {{to the already}} encrypted GCJ-02 [...] "to better protect user's privacy".Baidu provides an <b>API</b> <b>call</b> to convert from Google or GPS (WGS-84) coordinates into Baidu coordinates. Similar to GCJ-02, there are no APIs to convert in the other direction, but open source implementations in R and various other languages exist.|$|E
5000|$|Technically, {{it is an}} X/Open {{library for}} the Windows 32-bit {{application}} programming interface (<b>API),</b> <b>called</b> Win32.|$|R
40|$|Outages to {{the cloud}} {{infrastructures}} {{have been widely}} publicized {{and it would be}} easy to conclude that application developers only need to be concerned with large scale cloud provider infrastructure outages. Unfortunately, this is not the case. In-cloud applications heavily rely on cloud infrastructure APIs (directly or indirectly through scripts and consoles) for many sporadic activities such as deployment change, scaling out/in, backup, recovery and migration. Failures and/or issues around <b>API</b> <b>calls</b> are a large source of faults that could lead to application failures, especially during sporadic activities. Infrastructure outages can also be greatly exacerbated by API-related issues. In this paper we present an empirical study of issues in Amazon EC 2 APIs. Some of the major findings around API issues include: 1) A majority (60 %) of the cases of API failures are related to “stuck ” <b>API</b> <b>calls</b> or unresponsive <b>API</b> <b>calls.</b> 2) A significant portion (12 %) of the cases of API failures are about slow responsive <b>API</b> <b>calls.</b> 3) 19 % of the cases of API failures are related to the output issues of <b>API</b> <b>calls,</b> including failed calls with unclear error messages, as well as missing output, wrong output, and unexpected output of <b>API</b> <b>calls.</b> 4) There are 9 % cases of API failures reporting that their calls (performing some actions and expecting a state change) were pending for a certain time and then returned to the original state without informing the caller properly or the calls were reported to be successful first but failed later. We also classify the causes of API issues and discuss the impact of API issues on application architectures...|$|R
50|$|In {{addition}} to the programming language APIs available with ImageMagick, GraphicsMagick also includes a Tcl <b>API,</b> <b>called</b> TclMagick.|$|R
