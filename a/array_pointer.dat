1|181|Public
5000|$|The {{overhead}} in [...] "tight" [...] loops often {{consists of}} instructions to increment a pointer or index {{to the next}} element in an <b>array</b> (<b>pointer</b> arithmetic), as well as [...] "end of loop" [...] tests. If an optimizing compiler or assembler is able to pre-calculate offsets to each individually referenced array variable, these can be built into the machine code instructions directly, therefore requiring no additional arithmetic operations at run time.|$|E
50|$|Action! {{also has}} <b>ARRAYs,</b> <b>POINTERs</b> and {{user-defined}} TYPEs. No floating point support is provided.|$|R
50|$|<b>Arrays</b> and <b>Pointers</b> can be {{considered}} to have similar constructs and also suffer from {{the same kind of}} problems. <b>Arrays</b> and <b>pointers</b> create problems during symbolic execution as it complicates the substitution since their values are not known. Also, in order to generate input for <b>arrays</b> and <b>pointers</b> there are multiple problems like the index of the array, or the structure of the input that needs to be given to the pointer. This is further compounded by the possibility of dynamic allocation of <b>arrays</b> and <b>pointers.</b>|$|R
40|$|Buffer {{overflow}} attacks {{cause serious}} security problems. <b>Array</b> & <b>pointer</b> bound checking {{is one of}} the most effective approaches for defending against buffer overflow attacks when source code is available. However; original <b>array</b> & <b>pointer</b> bound checking causes too much overhead since it is designed to catch memory errors and it puts too many checks. In this paper, we propose an efficient <b>array</b> & <b>pointer</b> bound checking strategy to defend against buffer overflow attacks. In our strategy, only the bounds of write operations are checked. We discuss the optimization strategy via hardware/software and conduct experiments. The experimental results show that our strategy can greatly reduce the overhead of <b>array</b> & <b>pointer</b> bound checking. Our conclusion is that based on our strategy, <b>array</b> & <b>pointer</b> bound checking can be a practical solution for defending systems against buffer overflow attacks with tolerable overhead. Department of ComputingRefereed conference pape...|$|R
2500|$|Argument envp is an <b>array</b> of <b>pointers</b> to {{environment}} settings.|$|R
40|$|This course {{introduces}} advanced constructs, algorithms, {{and data}} {{structures in the}} C programming language. Emphasis is on problem solving and techniques useful to engineers. Topics include functions, <b>array,</b> <b>pointers,</b> structures as well as sorting algorithms, linked lists, complex numbers, and numerical methods applications. 4 credit hours. Prerequisite: CEG 220 (Introduction to C Programming for Engineers) ...|$|R
5000|$|<b>Array</b> <b>pointers</b> were 3-word {{constructs}} {{that included}} both the base address, the lower bound {{and the higher}} bound of the array; this {{made it possible to}} do reliable run-time checking of array boundaries, and made the kind of [...] "pointer arithmetic" [...] that makes C such an [...] "interesting" [...] language much less tempting to write.|$|R
5000|$|In C, since <b>arrays</b> and <b>pointers</b> {{have a close}} equivalence, the {{following}} are the same: ...|$|R
2500|$|... e – An <b>array</b> of <b>pointers</b> to {{environment}} variables {{is explicitly}} {{passed to the}} new process image.|$|R
5000|$|The {{following}} example builds an <b>array</b> of <b>pointers</b> to all {{the date}} fields present in the database: ...|$|R
5000|$|... e - An <b>array</b> of <b>pointers</b> to {{environment}} variables {{is explicitly}} {{passed to the}} new process image.|$|R
50|$|An <b>array</b> {{containing}} <b>pointers</b> to {{the right}} and left neighbor in the node's doubly linked at level i.|$|R
5000|$|The type {{system in}} C is static and weakly typed, {{which makes it}} similar to the type system of ALGOL {{descendants}} such as Pascal. [...] There are built-in types for integers of various sizes, both signed and unsigned, floating-point numbers, and enumerated types (...) [...] Integer type [...] is often used for single-byte characters. C99 added a boolean datatype. There are also derived types including <b>arrays,</b> <b>pointers,</b> records (...) , and untagged unions (...) [...]|$|R
40|$|Information flow {{analysis}} checks whether certain pieces of (confidential) data {{may affect the}} results of computations in unwanted ways and thus leak information. Dynamic information {{flow analysis}} adds instrumentation code to the target software to track flows at run time and raise alarms if a flow policy is violated; hybrid analyses combine this with preliminary static analysis. Using a subset of C as the target language, we extend previous work on hybrid information flow analysis that handled pointers to scalars. Our extended formulation handles <b>arrays,</b> <b>pointers</b> to <b>array</b> elements, and <b>pointer</b> arithmetic. Information flow through <b>arrays</b> of <b>pointers</b> is tracked precisely while arrays of non-pointer types are summarized efficiently. A prototype of our approach is implemented using the Frama-C program analysis and transformation framework. Work on a full machine-checked proof of the correctness of our approach using Isabelle/HOL is well underway; we present the existing parts and sketch {{the rest of the}} correctness argument. Comment: In Proceedings VPT 2016, arXiv: 1607. 0183...|$|R
50|$|The next example below {{illustrates}} how {{a similar effect}} can be achieved in languages that do not support pointer definitions in data structures but do support indexed branching to a subroutine - contained within a (0-based) <b>array</b> of subroutine <b>pointers.</b> The table (CT2) is used to extract the index (from 2nd column) to the <b>pointer</b> <b>array</b> (CT2P). If <b>pointer</b> <b>arrays</b> are not supported, a SWITCH statement or equivalent {{can be used to}} alter the control flow to one of a sequence of program labels (e.g.: case0,case1,case2,case3,case4) which then either process the input directly, or else perform a call (with return) to the appropriate subroutine (default,Add,Subtract,Multiply or Divide,..) to deal with it.|$|R
2500|$|..... The {{scheme of}} type {{composition}} adopted by C owes considerable debt to Algol 68, {{although it did}} not, perhaps, emerge {{in a form that}} Algol's adherents would approve of. The central notion I captured from Algol was a type structure based on atomic types (including structures), composed into <b>arrays,</b> <b>pointers</b> (references), and functions (procedures). Algol 68's concept of unions and casts also had an influence that appeared later. Dennis Ritchie Apr 1993.|$|R
5000|$|In 1999, when id Software {{released}} the code from Quake's engine under the GNU General Public License (GPL), {{the workings of}} the bytecode interpreter were examined and new QuakeC compilers were released, such as J.P. Grossman's [...] and a new version of FrikQCC. These compilers took advantage of newly discovered features in a backwards-compatible way so that the bytecode could still be properly interpreted by unmodified Quake engines. New features include <b>arrays,</b> <b>pointers,</b> integers, for loops and string manipulation.|$|R
40|$|We present our tool SpC {{which enables}} the {{synthesis}} of C behavioral models with pointers and complex data structures. For both analysis and synthesis, memory is represented by location sets. During memory partitioning, these location sets are either mapped to simple variables or <b>arrays.</b> <b>Pointers</b> are encoded and loads/stores are replaced by assignments in which data are directly accesses. Finally, dynamic memory allocation and deallocation are performed within user-defined memory segments by an optimized hardware allocator instantiated from a library...|$|R
40|$|International audienceThis paper {{discusses}} four store-based concrete memory models. We characterize memory models by {{the class}} of pointers they support and whether they use numerical or symbolic offsets to address values in a block. We give the semantics of a C-like language within each of these memory models to illustrate their differences. The language we consider is a fragment of Leroy's Clight, including <b>arrays,</b> <b>pointer</b> arithmetics but excluding casts. All along the paper, we link these concrete memory models with existing shape analyses...|$|R
50|$|In {{many older}} languages, arrays and strings are not first-class: they cannot be {{assigned}} as objects or passed as parameters to a subroutine. For example, neither Fortran IV nor C supports array assignment, {{and when they}} are passed as parameters, only the position of their first element is actually passed—their size is lost. C appears to support assignment of <b>array</b> <b>pointers,</b> but in fact these are simply <b>pointers</b> to the <b>array's</b> first element, and again do not carry the array's size.|$|R
40|$|ESBMC is a context-bounded {{symbolic}} model checker {{that allows}} the verification of single- and multi-threaded C code with shared variables and locks. ESBMC supports full ANSI-C, and can verify programs that make use of bit-level operations, <b>arrays,</b> <b>pointers,</b> structs, unions, memory allocation and foating-point arithmetic. It can reason about arithmetic under- and overflows, pointer safety, memory leaks, array bounds violations, atomicity and order violations, local and global deadlocks, data races, and user-specified assertions. However, as other bounded model checkers, ESBMC is in general incomplete...|$|R
40|$|This paper presentsanovel interprocedural, #ow-sensitive, and {{context-sensitive}} pointer analysis algorithm for multithreaded {{programs that}} may concurrently update shared pointers. For each pointer and each program point, the algorithm computes a conservative approximation {{of the memory}} locations to which that pointer may point. The algorithm correctly handles {{a full range of}} constructs in multithreaded programs, including recursive functions, function <b>pointers,</b> structures, <b>arrays,</b> nested structures and <b>arrays,</b> <b>pointer</b> arithmetic, casts between pointer variables of di#erenttypes, heap and stack allocated memory, shared global variables, and thread-private global variables...|$|R
40|$|This report {{presents}} RT++, {{a software}} package that provides higherorder threads in the programming language C++. Its features include a type-safe functional thread interface, lazy thread creation, garbage-collected types (lists, <b>arrays,</b> <b>pointer</b> structures) and controlled non-determinism (thread bags). Threads are first-order objects {{that can be}} used like any other objects and that are automatically reclaimed when they are not referenced any more. The package has been ported to numerous types of mono-processors and shared memory multiprocessors and can be easily embedded into existing application frameworks...|$|R
5000|$|The size of {{an element}} can be {{determined}} by applying the operator [...] to any dereferenced element of , as in [...] or , {{and the number of}} elements in a declared array [...] can be determined as [...] The latter only applies to array names: variables declared with subscripts (...) [...] Due to the semantics of C, {{it is not possible to}} determine the entire size of <b>arrays</b> through <b>pointers</b> to <b>arrays</b> or those created by dynamic allocation (...) code such as [...] (where [...] designates a pointer) will not work since the compiler assumes the size of the pointer itself is being requested. Since array name arguments to [...] are not converted to pointers, they do not exhibit such ambiguity. However, arrays created by dynamic allocation are accessed by pointers rather than true array variables, so they suffer from the same [...] issues as <b>array</b> <b>pointers.</b>|$|R
40|$|This paper {{presents}} a novel interprocedural, flow-sensitive, and context-sensitive pointer analysis algorithm for multithreaded programs that may concurrently update shared pointers. For each pointer and each program point, the algorithm computes a conservative approximation {{of the memory}} locations to which that pointer may point. The algorithm correctly handles {{a full range of}} constructs in multithreaded programs, including recursive functions, function <b>pointers,</b> structures, <b>arrays,</b> nested structures and <b>arrays,</b> <b>pointer</b> arithmetic, casts between pointer variables of different types, heap and stack allocated memory, shared global variables, and thread-private global variables. We hav...|$|R
5000|$|... char cff 55; /* {{array of}} arrays of chars */char *cfp 5; /* <b>array</b> of <b>pointers</b> to chars */char **cpp; /* pointer to pointer to char ("double pointer") */char (*cpf) 5; /* <b>pointer</b> to <b>array(s)</b> of chars */char *cpF (...) /* {{function}} which returns a pointer to char(s) */char (*CFp) (...) /* pointer to a function which returns a char */char (*cfpF (...) [...] )5; /* function which returns <b>pointer</b> to an <b>array</b> of chars */char (*cpFf5) (...) /* an <b>array</b> of <b>pointers</b> to functions which return a char */The (...) and [...] {{have a higher}} priority than *.|$|R
5000|$|A basic {{example of}} {{multiple}} pointer indirection is the argv argument {{to the main}} function in C (and C++), which is given in the prototype as [...] The name of the invoked program executable, {{as well as all}} command line arguments that followed, are stored as independent character strings. An <b>array</b> of <b>pointers</b> to [...] contains pointers to the first character of each of these strings, and this <b>array</b> of <b>pointers</b> is passed to the [...] function as the [...] argument. The passed array itself [...] "decays" [...] to a pointer, thus [...] is actually a pointer to a pointer to , even though it stands for an <b>array</b> of <b>pointers</b> to [...] (similarly, the <b>pointers</b> in the <b>array,</b> while each formally pointing to a single , actually point to what are strings of characters). The accompanying [...] argument, , provides the size of the array (i.e. the number of strings pointed to by the elements of the array), as the size of an (outmost) array is otherwise lost when it is passed to a function and converted to a pointer. Thus, [...] is a pointer to the 0th element of an <b>array</b> of <b>pointers</b> to , , which in turn is a pointer to , a character (precisely, the 0th character of the first argument string, which by convention {{is the name of the}} program).|$|R
50|$|As can be seen, {{again the}} length isn't {{maintained}} automatically, and reallocation should use an additional variable {{to protect against}} not enough memory error.Assignment between dynamic <b>arrays</b> follows <b>pointer</b> assignment rule.|$|R
5000|$|Due to <b>arrays</b> and <b>pointers</b> being interchangeable, the {{addresses}} {{of each of}} the array elements can be expressed in equivalent pointer arithmetic. The following table illustrates both methods for the existing array: ...|$|R
5000|$|Storing {{contents}} {{in multiple}} smaller arrays, allocating additional arrays {{at the beginning}} or end as needed. Indexing is implemented by keeping a dynamic <b>array</b> containing <b>pointers</b> {{to each of the}} smaller arrays.|$|R
40|$|We {{describe}} a symbolic heap abstraction that unifies reasoning about <b>arrays,</b> <b>pointers,</b> and scalars, and we define a fluid update operation on this symbolic heap that relaxes the dichotomy between strong and weak updates. Our technique is fully automatic, does not {{suffer from the}} kind of state-space explosion problem partition-based approaches are prone to, and can naturally express properties that hold for non-contiguous array elements. We demonstrate the effectiveness of this technique by evaluating it on challenging array benchmarks and by automatically verifying buffer accesses and dereferences in five Unix Coreutils applications with no annotations or false alarms...|$|R
5000|$|Function <b>pointer</b> <b>arrays</b> of {{addresses}} to {{functions as}} used in branch tables ...|$|R
50|$|Oberon-2 is an {{extension}} of the original Oberon programming language that adds limited reflection and object-oriented programming facilities, open <b>arrays</b> as <b>pointer</b> base types, read-only field export and reintroduces the FOR loop from Modula-2.|$|R
50|$|Go has built-in, language-level {{support for}} {{associative}} arrays, called maps. A map's key type {{may only be}} a boolean, numeric, string, <b>array,</b> struct, <b>pointer,</b> interface, or channel type. A map type is written like this: mapkeytypevaluetype.|$|R
2500|$|... v – Command-line {{arguments}} are {{passed to the}} function as an <b>array</b> (vector) of <b>pointers.</b>|$|R
5000|$|... at offset 0x10. This table stores an <b>array</b> of <b>pointers</b> {{to other}} tables; {{you have to}} walk through them searching for [...] "MCFG" [...] signature. Finally, at offset 0x2C in the MCFG table is stored searched base {{physical}} address.|$|R
