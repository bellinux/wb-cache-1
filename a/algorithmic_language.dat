132|76|Public
25|$|Mar. 1968: Draft Report on the <b>Algorithmic</b> <b>Language</b> ALGOL 68 - Edited by: A. van Wijngaarden, B.J. Mailloux, J.E.L. Peck and C.H.A. Koster.|$|E
25|$|Oct. 1968: Penultimate Draft Report on the <b>Algorithmic</b> <b>Language</b> ALGOL 68 – Chapters 1-9 Chapters 10-12 – Edited by: A. van Wijngaarden, B.J. Mailloux, J.E.L. Peck and C.H.A. Koster.|$|E
25|$|Dec. 1968: Report on the <b>Algorithmic</b> <b>Language</b> ALGOL 68 – Offprint from Numerische Mathematik, 14, 79-218 (1969); Springer-Verlag. – Edited by: A. van Wijngaarden, B.J. Mailloux, J.E.L. Peck and C.H.A. Koster.|$|E
5000|$|Stack {{architecture}} (to support high-level <b>algorithmic</b> <b>languages)</b> ...|$|R
40|$|We {{investigate}} {{the consequences of}} assuming integer variables of <b>algorithmic</b> <b>languages</b> to be finite vs. infinite in number and/or range. We suggest that different groups of computer scientists use different postulates about <b>algorithmic</b> <b>languages.</b> This leads to difficulty in communication, since the assumptions are usually unstated. Key words and phrases: Algol vs. FORTRAN, finiteness assumptions, intellectual isolation, integer variable range, memory finiteness, finite word size...|$|R
50|$|Yushchenko {{worked on}} {{probability}} theory, <b>algorithmic</b> <b>languages</b> and programming languages, and developing methods of {{automated data processing}} systems.|$|R
25|$|Sep. 1973: Revised Report on the <b>Algorithmic</b> <b>Language</b> Algol 68 - Springer-Verlag 1976 - Edited by: A. van Wijngaarden, B.J. Mailloux, J.E.L. Peck, C.H.A. Koster, M. Sintzoff, C.H. Lindsey, L.G.L.T. Meertens and R.G. Fisker.|$|E
25|$|ALGOL 68 (short for <b>Algorithmic</b> <b>Language</b> 1968) is an {{imperative}} {{computer programming}} language that was {{conceived as a}} successor to the ALGOL 60 programming language, designed {{with the goal of}} a much wider scope of application and more rigorously defined syntax and semantics.|$|E
25|$|The Scheme {{community}} actively maintains {{over twenty}} implementations. Several significant new implementations (Chicken, Gambit, Gauche, Ikarus, Larceny, Ypsilon) {{have been developed}} {{in the last few}} years. The Revised5 Report on the <b>Algorithmic</b> <b>Language</b> Scheme standard of Scheme was widely accepted in the Scheme community. The Scheme Requests for Implementation process has created a lot of quasi standard libraries and extensions for Scheme. User communities of individual Scheme implementations continue to grow. A new language standardization process was started in 2003 and led to the R6RS Scheme standard in 2007. Academic use of Scheme for teaching computer science seems to have declined somewhat. Some universities, such as MIT, are no longer using Scheme in their computer science introductory courses.|$|E
50|$|IFIP Working Group 2.1 on <b>Algorithmic</b> <b>Languages</b> and Calculi is {{a working}} group of the International Federation for Information Processing (IFIP).|$|R
50|$|Creators of <b>algorithmic</b> <b>languages</b> try {{to avoid}} ambiguities. Many <b>algorithmic</b> <b>languages</b> (C++ and Fortran) require the {{character}} * as symbol of multiplication. The Wolfram Language used in Mathematica allows the user to omit the multiplication symbol, but requires square brackets to indicate the argument of a function; square brackets are not allowed for grouping of expressions. Fortran, in addition, does not allow use {{of the same name}} (identifier) for different objects, for example, function and variable; in particular, the expression f=f(x) is qualified as an error.|$|R
50|$|He was {{a member}} of IFIP Working Group 2.1 on <b>Algorithmic</b> <b>Languages</b> and Calculi, and IFIP Working Group 2.3 on Programming Methodology, which he also chaired from 2003-2006.|$|R
2500|$|The form of {{the titles}} of the {{standards}} documents since R3RS, [...] "Revisedn Report on the <b>Algorithmic</b> <b>Language</b> Scheme", is {{a reference to the}} title of the ALGOL 60 standard document, [...] "Revised Report on the <b>Algorithmic</b> <b>Language</b> Algol 60," [...] The Summary page of R3RS is closely modeled on the Summary page of the ALGOL 60 Report.|$|E
2500|$|Dijkstra, Edsger W.: A Primer of ALGOL 60 Programming: Together with Report on the <b>Algorithmic</b> <b>Language</b> ALGOL 60. (New York: Academic Press, 1962) ...|$|E
2500|$|The Scheme {{language}} is standardized {{in the official}} IEEE standard and a de facto standard called the Revised Report on the <b>Algorithmic</b> <b>Language</b> Scheme (RnRS). The most widely implemented standard is R5RS (1998); Report on the <b>Algorithmic</b> <b>Language</b> Scheme |url=http://www.schemers.org/Documents/Standards/R5RS/ |journal=Higher-Order and Symbolic Computation |volume=11 |issue=1 |pages=7–105 |doi=10.1023/A:1010051815785 |accessdate=2012-08-09 |author2=William Clinger |author3=Jonathan Rees |display-authors=3 |last4=Rozas |first4=G.J. |last5=Adams Iv |first5=N.I. |last6=Friedman |first6=D.P. |last7=Kohlbecker |first7=E. |last8=Steele Jr. |first8=G.L. |last9=Bartley |first9=D.H.}} a new standard, R6RS, Report on the <b>Algorithmic</b> <b>Language</b> Scheme (R6RS) |last1=Sperber |first1=Michael |last2=Dybvig |first2=R. Kent |last3=Flatt |first3=Matthew |last4=Van Straaten |first4=Anton|date=August 2007 |publisher=Scheme Steering Committee |accessdate=2011-09-13|display-authors=etal}} was ratified in 2007. Scheme has a diverse user base due to its compactness and elegance, but its minimalist philosophy has also caused wide divergence between practical implementations, {{so much that the}} Scheme Steering Committee calls it [...] "the world's most unportable programming language" [...] and [...] "a family of dialects" [...] rather than a single language.|$|E
5000|$|Subscripts {{are often}} used to {{indicate}} arguments, typically integers.In a few cases, the semicolon ( [...] ;) or even backslash (\) {{is used as a}} separator.In this case, the translation to <b>algorithmic</b> <b>languages</b> admits ambiguity and may lead to confusion.|$|R
40|$|In {{this book}} we {{describe}} {{the basic elements of}} present computational technologies that use the <b>algorithmic</b> <b>languages</b> C/C++. The emphasis is on GNU compilers and libraries, FOSS for the solution of computational mathematics problems and visualization of the obtained data. |$|R
40|$|SSL (Software Specification Language) {{is a new}} {{formalism}} for {{the definition}} of specifications for software systems. The language provides a linear format for {{the representation of the}} information normally displayed in a two-dimensional module inter-dependency diagram. In comparing SSL to FORTRAN or ALGOL, it is found to be largely complementary to the <b>algorithmic</b> (procedural) <b>languages.</b> SSL is capable of representing explicitly module interconnections and global data flow, information which is deeply imbedded in the <b>algorithmic</b> <b>languages.</b> On the other hand, SSL is not designed to depict the control flow within modules. The SSL level of software design explicitly depicts intermodule data flow as a functional specification...|$|R
2500|$|In the R5RS {{standard}} {{and also in}} later reports, the syntax of Scheme can easily be extended via the macro system. The R5RS standard introduced a powerful hygienic macro system that allows the programmer to add new syntactic constructs to the language using a simple pattern matching sublanguage (R5RS sec 4.3). [...] Prior to this, the hygienic macro system had been relegated to an appendix of the R4RS standard, as a [...] "high level" [...] system alongside a [...] "low level" [...] macro system, {{both of which were}} treated as extensions to Scheme rather than {{an essential part of the}} language. Report on the <b>Algorithmic</b> <b>Language</b> Scheme |author=William Clinger and Jonathan Rees, editors |url=http://www.cs.indiana.edu/scheme-repository/R4RS/r4rs_toc.html |journal=ACM Lisp Pointers |volume=4 |issue=3 |pages=1–55 |year=1991 |accessdate=2012-08-09 |postscript=}} ...|$|E
2500|$|Scheme is a statically scoped and {{properly}} tail-recursive dialect of the Lisp programming language invented by Guy L. Steele, Jr. and Gerald Jay Sussman. It {{was designed to}} have exceptionally clear and simple semantics and few different ways to form expressions. [...] Designed about a decade earlier than Common Lisp, Scheme is a more minimalist design. It has a much smaller set of standard features but with certain implementation features (such as tail-call optimization and full continuations) not specified in Common Lisp. A wide variety of programming paradigms, including imperative, functional, and message passing styles, find convenient expression in Scheme. Scheme continues to evolve {{with a series of}} standards (Revisedn Report on the <b>Algorithmic</b> <b>Language</b> Scheme) and a series of Scheme Requests for Implementation.|$|E
2500|$|ALGOL was {{the result}} of a {{collaboration}} of American and European committees. ALGOL 60 (short for <b>ALGOrithmic</b> <b>Language</b> 1960) is a member of the ALGOL family of computer programming languages. It followed on from ALGOL 58 and inspired many languages that followed it. It gave rise to many other programming languages, including BCPL, B, Pascal, Simula and C. Algol 60 was a sophisticatedly designed computer language and it provided a large number of hitherto unknown implementation challenges. As Bjarne Stroustrup notes, [...] "one problem with Algol60 was that no one knew how to implement it." [...] A major new challenge in Algol 60 implementation was the run-time allocation and management of data. In 1960 Dijkstra and Zonneveld showed how recursive procedures could be executed using a run-time stack of activation records, and how to efficiently access identifiers from statically enclosing scopes using the so-called 'display'. The ALGOL 60 compiler was one of the first to support recursion employing a novel method to do so. Dijkstra's short book Primer of Algol 60 Programming, originally published in 1962, was the standard reference for the language for several years.|$|E
50|$|Meertens {{was one of}} {{the editors}} of the Revised ALGOL 68 Report.He was the {{originator}} and one of the designers of the ABC programming language.He was chairman of the Dutch Pacifist Socialist Party (PSP) from 1975 until 1981.He was co-designer of the Bird-Meertens formalism.He was chair of IFIP Working Group 2.1 on <b>Algorithmic</b> <b>Languages</b> and Calculi from 1999 to 2009.|$|R
50|$|In 1992 {{he began}} working on his <b>algorithmic</b> {{composition}} <b>language,</b> Tabula Vigilans, designed for real-time performance.|$|R
5000|$|When the Mesa {{designers}} {{wanted to}} implement an exception facility, they hired a recent M.S. graduate from Colorado {{who had written}} his thesis on exception handling facilities in <b>algorithmic</b> <b>languages.</b> This led to the richest exception facility for its time, with primitives , , , , , and [...] Because the language did not have type-safe checks to verify full coverage for signal handling, uncaught exceptions were a common cause of bugs in released software.|$|R
2500|$|While {{working on}} his Z4 computer, Zuse {{realised}} that programming in machine code was too complicated. He started working on a PhD thesis containing groundbreaking research years ahead of its time, mainly the first high-level programming language, Plankalkül ("Plan Calculus") and, as an elaborate example program, the first real computer chess engine. After the 1945 Luisenstadt bombing, he flew from Berlin for the rural Allgäu, and, unable to do any hardware development, he continued working on the Plankalkül, eventually publishing some brief excerpts of his thesis in 1948 and 1959; the work in its entirety, however, remained unpublished until 1972. The PhD thesis was submitted at University of Augsburg, but rejected for formal reasons, because Zuse forgot to pay the 400 Mark university enrollment fee. (The rejection did not bother him.) Plankalkül slightly influenced the design of ALGOL 58 but was itself only implemented in 1975 in a dissertation by Joachim Hohmann. Heinz Rutishauser, one of the inventors of ALGOL, wrote: [...] "The very first attempt to devise an <b>algorithmic</b> <b>language</b> was undertaken in 1948 by K. Zuse. His notation was quite general, but the proposal never attained the consideration it deserved". Further implementations followed in 1998 and then in 2000 by a team from the Free University of Berlin. Donald Knuth suggested a thought experiment: What might have happened, had the bombing not taken place, and had the PhD thesis accordingly been published as planned? ...|$|E
5000|$|He was the [...] "first et al editor" [...] of the {{original}} Report on the <b>Algorithmic</b> <b>Language</b> ALGOL 68 and the Revised Report on the <b>Algorithmic</b> <b>Language</b> ALGOL 68.|$|E
50|$|ALGOL 68-R was {{the first}} {{implementation}} of the <b>Algorithmic</b> <b>language</b> ALGOL 68.|$|E
5000|$|There are {{extensive}} {{accounts of}} the early applications, the equipmentand the PAGE I <b>algorithmic</b> typesetting <b>language</b> for the Videocomp, that introduced elaborate formatting ...|$|R
50|$|When {{informatics}} arose {{at about}} 1967 {{he switched to}} topics of combinatorics and graph theory. In 1977-78 he got his habilitation in informaticsat TU München and in 1980 was promoted to professorship. Shortly after that, he was appointed to hold {{the chair of the}} late Klaus Samelson for one and a half years.Together with Thomas Ströhlein the books Relationen und Graphen and Relations and Graphs have appeared. His teaching requiredMathematical Logics, Semantics of Programming <b>Languages,</b> Compiler Construction, <b>Algorithmic</b> <b>Languages</b> and all the cycles of beginners courses.|$|R
5000|$|DRAKON is a {{general-purpose}} <b>algorithmic</b> modeling <b>language</b> for specifying software-intensive systems, {{a schematic}} representation of an algorithm or a stepwise process, {{and a family}} of programming languages.|$|R
5000|$|The form of {{the titles}} of the {{standards}} documents since R3RS, [...] "Revisedn Report on the <b>Algorithmic</b> <b>Language</b> Scheme", is {{a reference to the}} title of the ALGOL 60 standard document, [...] "Revised Report on the <b>Algorithmic</b> <b>Language</b> Algol 60," [...] The Summary page of R3RS is closely modeled on the Summary page of the ALGOL 60 Report.|$|E
50|$|He {{was one of}} {{the editors}} of the Revised Report on the <b>Algorithmic</b> <b>Language</b> Algol 68.|$|E
5000|$|... #Caption: Revised Report on the <b>Algorithmic</b> <b>Language</b> - Algol 68 Edited by: A. van Wijngaarden & al, Sep 1973 ...|$|E
5000|$|DRAKON, an <b>algorithmic</b> visual {{programming}} <b>language</b> {{developed for the}} Buran space project.|$|R
40|$|AbstractIn {{this article}} we review {{the current state of}} {{concurrency}} theory with respect to its industrial impact. This review is both retrospective and prospective, and naturally encompasses process calculi, which are a major vector for spreading concurrency theory concepts. Considering the achievements, but also the failures, we try to identify the causes that, so far, prevented a larger dissemination of process calculi. This suggests a new generation of formal specification languages that would combine the concurrent features of process calculi with the standard concepts present in <b>algorithmic</b> <b>languages.</b> Finally, we underline two major evolutions in the software and hardware industries that open new application domains for the concurrency theory community...|$|R
50|$|Most special {{functions}} are {{considered as a}} function of a complex variable. They are analytic; the singularities and cuts are described; the differential and integral representations are known and the expansion to the Taylor series or asymptotic series are available.In addition, sometimes there exist relations with other special functions; a complicated special function can be expressed in terms of simpler functions. Various representations can be used for the evaluation; the simplest way to evaluate a function is to expand it into a Taylor series.However, such representation may converge slowly if at all. In <b>algorithmic</b> <b>languages,</b> rational approximations are typically used, although they may behave badly in the case of complex argument(s).|$|R
