1151|2465|Public
5|$|The Drexler–Smalley {{debate on}} {{molecular}} nanotechnology {{was a public}} dispute between K. Eric Drexler, the originator of the conceptual basis of molecular nanotechnology, and Richard Smalley, a recipient of the 1996 Nobel prize in Chemistry for {{the discovery of the}} nanomaterial buckminsterfullerene. The dispute was about the feasibility of constructing molecular <b>assemblers,</b> which are molecular machines which could robotically assemble molecular materials and devices by manipulating individual atoms or molecules. The concept of molecular <b>assemblers</b> was central to Drexler's conception of molecular nanotechnology, but Smalley argued that fundamental physical principles would prevent them from ever being possible. The two also traded accusations that the other's conception of nanotechnology was harmful to public perception of the field and threatened continued public support for nanotechnology research.|$|E
25|$|Some <b>assemblers</b> {{may also}} be able to perform some simple types of {{instruction}} set-specific optimizations. One concrete example of this may be the ubiquitous x86 <b>assemblers</b> from various vendors. Most of them are able to perform jump-instruction replacements (long jumps replaced by short or relative jumps) in any number of passes, on request. Others may even do simple rearrangement or insertion of instructions, such as some <b>assemblers</b> for RISC architectures that can help optimize a sensible instruction scheduling to exploit the CPU pipeline as efficiently as possible.|$|E
25|$|The {{following}} {{table lists}} notable <b>assemblers</b> {{that have a}} de-novo assembly capability {{on at least one}} of the supported technologies.|$|E
5000|$|Assemblers: ASM-One Macro <b>Assembler,</b> Devpac <b>Assembler,</b> Metacomco Macro <b>Assembler,</b> SEKA <b>Assembler</b> ...|$|R
30|$|Note {{that the}} <b>assembler</b> is also {{represented}} in F {{and the first}} row of F is 0 as the <b>assembler</b> does not produce products but only procures them. In {{the case that the}} <b>assembler</b> also produces products, we represent the <b>assembler</b> by a supplying plant, and add a dummy <b>assembler</b> in row 0 with a single link to the actual <b>assembler</b> whose reliability is 1.|$|R
25|$|The Cosmos Project {{team have}} also created an <b>assembler</b> that is {{designed}} to eventually become the main <b>assembler</b> for the Cosmos system. However, the <b>assembler</b> is still inefficient and slow, and so the Netwide <b>Assembler</b> (NASM) is used instead.|$|R
25|$|Faced {{with the}} {{challenge}} of assembling the first larger eukaryotic genomesthe fruit fly Drosophila melanogaster in 2000 and the human genome just a year later,scientists developed <b>assemblers</b> like Celera Assembler and Arachne able to handle genomes of 100-300 million base pairs. Subsequent to these efforts, several other groups, mostly at the major genome sequencing centers, built large-scale <b>assemblers,</b> and an open source effort known as AMOS was launched to bring together all the innovations in genome assembly technology under the open source framework.|$|E
25|$|In addition, it was {{designed}} to have all of the power possessed by earlier general macro <b>assemblers</b> but with the unfortunate syntactic and semantic difficulties removed.|$|E
25|$|<b>Assemblers</b> {{can be used}} to {{generate}} blocks of data, with no high-level language overhead, from formatted and commented source code, to be used by other code.|$|E
40|$|In {{this paper}} we {{describe}} the legacy <b>assembler</b> problem and describe how the FermaT transformation system is used to reengineer <b>assembler</b> systems and migrate from <b>assembler</b> to C and COBOL. 1. Legacy <b>Assembler</b> A legacy is “something handed down or received from an ancestor or predecessor”. A legacy <b>assembler</b> system may be defined as any system which: 1. is implemented in <b>assembler,</b> or has substantial components implemented in assembler; 2. was developed some {{years ago and has}} been handed down to the current maintainers; 3. is nevertheless essential to the smooth running of the organisation...|$|R
50|$|<b>Assembler</b> XF was {{an upgrade}} of <b>Assembler</b> F which {{included}} the new System/370 architecture instructions. This version provided a common <b>assembler</b> for OS/VS and DOS/VS systems. Other changes included relaxing restrictions on expressions and macro processing. <b>Assembler</b> XF required a minimum partition/region size of 64 KB (virtual). Recommended size was 128 KB.|$|R
40|$|The {{development}} of a reconfigurable micro-assembler to provide the micro-programmer the capability to specify micro-instructions in concise, meaningful terms is discussed. The implementation plan for the {{development of}} the micro-assembler was predicted on the existing capabilities of the SUMC Reconfigurable <b>Assembler.</b> Utilizing the reconfigurable <b>assembler</b> as a base, new directives and existing directive modifications were implemented to provide the micro-assembly as a new capability of the reconfigurable <b>assembler.</b> The micro-assembler language allows the specification of all micro-instruction control field settings in one concise <b>assembler</b> source statement. The language appears very similar to a conventional machine instruction <b>assembler</b> language. The machine instruction <b>assembler</b> language has the characteristic of one operation specification per statement whereas, the micro-instruction <b>assembler</b> language allows multiple operations to be designated per statement...|$|R
25|$|Multi-pass <b>assemblers</b> {{create a}} table with all symbols and their values in the first passes, then use the table in later passes to {{generate}} code.|$|E
25|$|Despite {{the power}} of macro processing, it fell into disuse in many high level {{languages}} (major exceptions being C, C++ and PL/I) while remaining a perennial for <b>assemblers.</b>|$|E
25|$|Mnemonics are {{arbitrary}} symbols; in 1985 the IEEE published Standard 694 for {{a uniform}} set of mnemonics {{to be used}} by all <b>assemblers.</b> The standard has since been withdrawn.|$|E
40|$|One of {{the most}} {{challenging}} tasks a programmer can face is attempting to analyse and understand a legacy <b>assembler</b> system. Many features of <b>assembler</b> make analysis difficult, and these are the same features which make migration from <b>assembler</b> to a high level language difficult. In this paper we discuss the application of program transformation technology to assist with analysing and understanding legacy <b>assembler</b> systems. We briefly introduce the fundamentals of our program transformation theory and program slicing which generalises to conditional semantic slicing. These transformations are applied to a large commercial <b>assembler</b> system to automatically generate high-level abstract descriptions of the behaviour of each <b>assembler</b> module, with error handling code sliced away. The <b>assembler</b> system was then migrated to C. The result is a dramatic improvement in the understandability of the programs: on average a 6, 000 line <b>assembler</b> listing is condensed down to a 132 line high level language abstraction. A second case study, involving over one million lines of source code from many different <b>assembler</b> system...|$|R
50|$|The {{geometry}} processor {{contains the}} Geometry <b>Assembler,</b> the Tesselator and the Vertex <b>Assembler.</b>|$|R
50|$|Basic <b>assembler</b> {{language}} did {{not support}} macros.Later <b>assembler</b> versions allowed the programmer to group instructions together into macros and add them to a library, which can then be invoked in other programs, usually with parameters, like the preprocessor facilities in C and related languages. Macros can include conditional <b>assembler</b> instructions, such as AIF (an IF construct), used to generate different code according to the chosen parameters. That makes the macro facility of this <b>assembler</b> very powerful. While multiline macros in C are an exception, macro definitions in <b>assembler</b> can easily be hundreds of lines.|$|R
25|$|An {{assembler}} program creates object code by translating combinations of mnemonics and syntax for operations and addressing modes into their numerical equivalents. This representation typically includes an operation code ("opcode") {{as well as}} other control bits and data. The assembler also calculates constant expressions and resolves symbolic names for memory locations and other entities. The use of symbolic references is a key feature of <b>assemblers,</b> saving tedious calculations and manual address updates after program modifications. Most <b>assemblers</b> also include macro facilities for performing textual substitution – e.g., to generate common short sequences of instructions as inline, instead of called subroutines.|$|E
25|$|During the {{development}} of TTM, {{it became apparent that}} applications other than assembler macro processing were possible. These include data editing, text manipulation, expression compiling, and macro processing for language processors other than <b>assemblers.</b>|$|E
25|$|Assembly {{language}} uses a mnemonic {{to represent}} each low-level machine instruction or opcode, typically also each architectural register, flag, etc. Many operations require {{one or more}} operands in order to form a complete instruction and most <b>assemblers</b> can take expressions of numbers and named constants as well as registers and labels as operands, freeing the programmer from tedious repetitive calculations. Depending on the architecture, these elements may also be combined for specific instructions or addressing modes using offsets or other data as well as fixed addresses. Many <b>assemblers</b> offer additional mechanisms to facilitate program development, to control the assembly process, and to aid debugging.|$|E
40|$|In {{this paper}} we {{describe}} the legacy <b>assembler</b> problem and describe how the FermaT transformation system is used to reengineer <b>assembler</b> systems and migrate from <b>assembler</b> to C and COBOL. Legacy <b>assembler</b> presents unique challenges to automated analysis and migration. The paper discusses these challenges and the solutions implemented in the FermaT system. A successful migration project is described: this involved migrating over 3000 <b>assembler</b> source modules to efficient and maintainable C code. Very few research outputs report on "real" software systems. This paper is one of them...|$|R
5000|$|MAC/65 is {{structured}} similarly to the Atari <b>Assembler</b> Editor cartridge, combining a line editor, <b>assembler,</b> and debugger {{into a single}} package. Its reputation was based on being much faster than either the <b>Assembler</b> Editor or the standalone Atari Macro <b>Assembler.</b> Brian Moriarty of Infocom wrote, [...] "No <b>assembler</b> {{the time on the}} C64 even comes CLOSE to MAC/65. Take it from someone who looked for one." [...] It was used to write numerous commercial games and applications, and the majority of assembly language listings in ANALOG Computing were written with MAC/65.|$|R
40|$|<b>Assembler</b> Encoding is a neuro-evolutionary {{method in}} which a neural network is {{represented}} {{in the form of}} a simple program called <b>Assembler</b> Encoding Program. The task of the program is to create the so-called Network Definition Matrix which maintains all the information necessary to construct the network. To generate <b>Assembler</b> Encoding Programs and the subsequent neural networks evolutionary techniques are used. The performance of <b>Assembler</b> Encoding strongly depends on operations used in <b>Assembler</b> Encoding Programs. To select the most effective operations, experiments in the optimization and the predator-prey problem were carried out. In the experiments, <b>Assembler</b> Encoding Programs equipped with different types of operations were tested. The results of the tests are presented at the end of the paper...|$|R
25|$|Initially, TTM {{was planned}} as the macro {{processing}} portion of an assembler for the IBM System/360 and, as such, {{was designed to}} overcome the restrictions and inconsistencies which existed in the standard <b>assemblers</b> for that system.|$|E
25|$|Like early {{programming}} languages such as Fortran, Algol, Cobol and Lisp, <b>assemblers</b> {{have been}} available since the 1950s and the first generations of text based computer interfaces. However, <b>assemblers</b> came first as they are far simpler to write than compilers for high-level languages. This is because each mnemonic along with the addressing modes and operands of an instruction translates rather directly into the numeric representations of that particular instruction, without much context or analysis. There have also been several classes of translators and semi automatic code generators with properties similar to both assembly and high level languages, with speedcode as {{perhaps one of the}} better known examples.|$|E
25|$|Many <b>assemblers</b> support {{predefined}} macros, {{and others}} support programmer-defined (and repeatedly re-definable) macros involving sequences of text lines in which variables and constants are embedded. This sequence of text lines may include opcodes or directives. Once a macro {{has been defined}} its name {{may be used in}} place of a mnemonic. When the assembler processes such a statement, it replaces the statement with the text lines associated with that macro, then processes them as if they existed in the source code file (including, in some <b>assemblers,</b> expansion of any macros existing in the replacement text). Macros in this sense date to IBM autocoders of the 1950s.|$|E
50|$|Open Watcom <b>Assembler</b> or WASM is an x86 <b>assembler</b> {{produced}} by Watcom and included {{as part of}} the Watcom C/C++ compiler. Further development is being done on the 32- and 64-bit JWASM project,. which more closely matches the syntax of Microsoft's <b>assembler.</b>|$|R
5000|$|The High Level <b>Assembler</b> Toolkit is a {{separately}} priced {{accompaniment to}} the High Level <b>Assembler.</b> The toolkit contains: ...|$|R
40|$|Abstract. In [1] {{the almost}} {{complete}} formal verification {{of a small}} hypervisor with the automated C code verifier VCC [2] was reported: the correctness of the C portions of the hypervisor and of the guest simulation was established; the verification of the <b>assembler</b> portions of the code was left as future work. Suit-able methodology for the verification of Macro <b>Assembler</b> programs in VCC was given without soundness proof in [3]. A joint semantics of C + Macro <b>Assembler</b> necessary for such a soundness proof was introduced in [4]. In this paper i) we observe that for two instructions (that manipulate stack pointers) of the hyper-visor code the C + Macro <b>Assembler</b> semantics does not suffice; therefore we extend it to C + Macro <b>Assembler</b> + <b>assembler,</b> ii) we argue the soundness of the methodology from [3] {{with respect to this}} new semantics, iii) we apply the methodology from [3] to formally verify the Macro <b>Assembler</b> + <b>assembler</b> por-tions of the hypervisor from [1], completing the formal verification of the small hypervisor in the automated tool VCC. ...|$|R
25|$|In New Zealand, the Ford Laser and Telstar were {{assembled}} {{alongside the}} Mazda 323 and 626 until 1997, at the Vehicle <b>Assemblers</b> of New Zealand (VANZ) plant in Wiri, Auckland. The Sierra wagon was also assembled in New Zealand, {{owing to the}} popularity of station wagons in that market.|$|E
25|$|There {{has been}} little {{apparent}} demand for more sophisticated <b>assemblers</b> since the decline of large-scale assembly language development. In spite of that, they are still being developed and applied in cases where resource constraints or peculiarities in the target system's architecture prevent the effective use of higher-level languages.|$|E
25|$|Some <b>assemblers,</b> such as NASM, provide {{flexible}} symbol management, letting programmers manage different namespaces, automatically calculate offsets within data structures, and assign labels that {{refer to}} literal values or {{the result of}} simple computations performed by the assembler. Labels {{can also be used}} to initialize constants and variables with relocatable addresses.|$|E
50|$|The Microsoft Macro <b>Assembler</b> (MASM) is an x86 <b>assembler</b> {{that uses}} the Intel syntax for MS-DOS and Microsoft Windows. Beginning with MASM 8.0 there are two {{versions}} of the <b>assembler</b> - one for 16-bit and 32-bit assembly sources, and another (ML64) for 64-bit sources only.|$|R
40|$|ABSTRACT <b>Assembler</b> Encoding is a neuro-evolutionary {{method in}} which a neural network is {{represented}} {{in the form of}} a simple program called <b>Assembler</b> Encoding Program. The task of the program is to create the so-called Network Definition Matrix which maintains all the information necessary to construct the network. To generate <b>Assembler</b> Encoding Programs and the subsequent neural networks evolutionary techniques are used. The performance of <b>Assembler</b> Encoding strongly depends on operations used in <b>Assembler</b> Encoding Programs. To select the most effective operations, experiments in the optimization and the predator-prey problem were carried out. In the experiments, <b>Assembler</b> Encoding Programs equipped with different types of operations were tested. The results of the tests are presented at the end of the paper...|$|R
50|$|Integrated {{programming}} languages: TI-BASIC {{and machine}} code. Assembly requires a {{computer with a}} Z80 <b>assembler</b> or an on-calc <b>assembler.</b>|$|R
