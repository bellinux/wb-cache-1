0|6905|Public
50|$|Sets of Latin squares {{that are}} {{orthogonal}} {{to each other}} have found an <b>application</b> as <b>error</b> correcting <b>codes</b> in situations where communication is disturbed by more types of noise than simple white noise, such as when attempting to transmit broadband Internet over powerlines.|$|R
40|$|When {{applying}} conventional standard video codecs in wireless video <b>applications,</b> <b>error</b> {{resilience and}} <b>coding</b> efficiency {{are the two}} main issues need to be considered. Since {{it is difficult to}} corroborate robust quality of service (QoS) in wireless networks, transmitted video packets are sometime lost or corrupted due to fading and shadowing effect of wireles...|$|R
40|$|AbstractIn this paper, we {{introduce}} {{the notion of}} “dynamical Gröbner bases” of polynomial ideals over a principal ring. As application, we solve dynamically a fundamental algorithmic question {{in the theory of}} multivariate polynomials over the integers called “Kronecker's problem,” that is the problem of finding a decision procedure for the ideal membership problem for Z[X 1,…,Xn]. The notions of Gröbner bases over Noetherian valuation rings and dynamical Gröbner bases over principal rings have <b>applications</b> in <b>error</b> correcting <b>codes...</b>|$|R
40|$|In {{a variety}} of networks, packet losses occur in bursts. Conventional <b>application</b> of <b>error</b> {{correcting}} <b>codes</b> for packet recovery often requires interleaving and long decoder delays. These long delays are usually unacceptable in real-time multimedia communication applications such as Voice over IP (VoIP). Consequently erasure correction codes with severe limits on delay are desirable. We present various codes suitable for correcting bursts of lost packets. In addition, we show these codes have the shortest possible decoding delay. To demonstrate the practical benefits of these codes for (VoIP), we present results of informal mean opinion score listening tests conducted with various codes...|$|R
40|$|Affine {{projection}} (AP) algorithms {{are commonly}} used to implement active noise control (ANC) systems because they provide fast convergence. However, their high computational complexity can restrict their use in certain practical <b>applications.</b> The <b>Error</b> <b>Coded</b> Affine Projection-Like (ECAP-L) algorithm has been proposed to reduce the computational burden while maintaining the speed of AP, but no version of this algorithm has been derived for active noise control, for which the adaptive structures {{are very different from}} those of other configurations. In this paper, we introduce a version of the ECAP-L for single-channel and multichannel ANC systems. The proposed algorithm is implemented using the conventional filtered-x scheme, which incurs a lower computational cost than the modified filtered-x structure, especially for multichannel systems. Furthermore, we present an evolutionary method that dynamically decreases the projection order {{in order to reduce the}} dimensions of the matrix used in the algorithm’s computations. Experimental results demonstrate that the proposed algorithm yields a convergence speed and a final residual error similar to those of AP algorithms. Moreover, it achieves meaningful computational savings, leading to simpler hardware implementation of real-time ANC applications...|$|R
40|$|Normal basis {{multiplication}} in finite fields {{is vastly}} utilized in different <b>applications,</b> including <b>error</b> control <b>coding</b> {{and the like}} due to its advantageous characteristics {{and the fact that}} squaring of elements can be obtained without hardware complexity. In this brief, we present decomposition algorithms to develop novel systolic structures for digit-level Gaussian normal basis multiplication over GF(2 m). The proposed architectures are suitable for high-performance applications, which require fast computations in finite fields with high throughputs. We also present the results of our application-specific integrated circuit synthesis using a 65 -nm standard-cell library to benchmark the effectiveness of the proposed systolic architectures. The presented architectures for multiplication can result in more efficient and high-performance VLSI systems...|$|R
40|$|International Telemetering Conference Proceedings / October 26 - 29, 1998 / Town & Country Resort Hotel and Convention Center, San Diego, CaliforniaThis paper {{describes}} {{techniques for}} error location analysis {{used in the}} design and testing of high-speed instrumentation data recording and communications applications. It focuses on the differences between common bit error rate testing and new error location analysis. Examples of techniques presented include separating bit and burst error components, studying probability of burst occurrences, looking at error free interval occurrence rates as well as auto-correlating error position. Each technique contributes {{to a better understanding of}} the underlying error phenomenon and enables higher-quality digital recording and communication. Specific <b>applications</b> in <b>error</b> correction <b>coding</b> emulation, magnetic media error mapping and systematic error interference are discussed...|$|R
40|$|A List Viterbi {{detector}} {{produces a}} rank ordered {{list of the}} N globally best candidates in a trellis search. A List Viterbi detector structure is proposed that incorporates the noise prediction with periodic state-metric updates based on outer <b>error</b> detection <b>codes</b> (EDCs). More specifically, a periodic decision making process is utilized for a non-overlapping sliding windows of P bits based {{on the use of}} outer EDCs. In a number of magnetic recording <b>applications,</b> <b>Error</b> Correction <b>Coding</b> (ECC) is adversely effected by the presence of long and dominant error events. Unlike the conventional post processing methods that are usually tailored to a specific set of dominant error events or the joint modulation code trellis architectures that are operating on larger state spaces at the expense of increased implementation complexity, the proposed detector does not use any a priori information about the error event distributions and operates at reduced state trellis. We present pre ECC bit error rate performance as well as the post ECC codeword failure rates of the proposed detector using perfect detection scenario as well as practical detection codes as the EDCs are not essential to the overall design. Furthermore, it is observed that proposed algorithm does not introduce new error events. Simulation results show that the proposed algorithm gives improved bit error and post ECC codeword failure rates at the expense of some increase in complexity. Comment: 4 pages, 3 figures, Proceedings of the ASME 2013 Conference on information storage and processing systems (ISPS 2013...|$|R
40|$|Abstract: This paper {{underlines the}} {{importance}} of security awareness whilst pro-gramming Java applications. Several problems in current JDK implementations are demonstrated that allow to undermine the security of Java <b>applications.</b> <b>Coding</b> <b>errors</b> and quality problems in current Java distributions create possibilities to create covert channels, cause resource blocking and denial-of-service attacks. To make things worse Java components are often deployed according to the AllPermissions antipattern with non-restrictive security settings, which allows bugs on the system layer to be exploited by attackers. Coping with this antipattern from the user side is connected with the definition of adequate permission sets. A tool that automates this time consuming task {{is presented as a}} refactoring for the AllPermission antipattern. ...|$|R
40|$|Abstract — In today’s {{world there}} is a great need for the design of low power and area {{efficient}} high performance DSP system. FIR filter is considered to be the fundamental device in the broad application of wireless as well as the video and image processing system. With the aim of getting the reliable operation, these filters are protected using the <b>Error</b> correction <b>Code.</b> The pipelined FIR filter design which reduces the critical path by interleaving the pipelined latches along the datapath, with the sense of increasing the number of latches and then the system latency. But the parallel processed FIR filter design increases the sample rate thereby replicating the hardware, so that the multiple number of inputs gets processed parallely {{and at the same time}} generating multiple number of outputs with the disadvantage of increased area in the design. To overcome this disadvantage and in the sense of retaining these such advantage of parallel processing,the hardware efficient filter structure is to be proposed, and these filter structure is to be recovered from <b>error</b> by the <b>application</b> of <b>Error</b> Correction <b>Code...</b>|$|R
40|$|In {{this paper}} {{we focus on}} Gröbner bases over rings for the {{univariate}} case. We identify a useful property of minimal Gröbner bases, that we call the “predictable leading monomial (PLM) property”. The property is stronger than “row reducedness ” and is crucial {{in a range of}} applications. The first part of the paper is tutorial in outlining how the PLM property enables straightforward solutions to classical realization problems of linear systems over fields. In {{the second part of the}} paper we use the ideas of [20] on polynomial matrices over the finite ring Zpr (with p a prime integer and r a positive integer) in the more general setting of Gröbner bases and introduce the notion of “Gröbner p-basis ” to achieve a predictable leading monomial property over Zpr. This theory finds <b>applications</b> in <b>error</b> control <b>coding</b> over Zpr. Through this approach we are extending the ideas of [20] to a more general context where the user chooses an ordering of polynomial vectors. ...|$|R
40|$|LDPC {{code and}} RS code are error-correcting codes which are {{researched}} much more at present, {{and in the}} two-dimensional bar <b>code’s</b> <b>applications</b> the <b>error</b> correction <b>code</b> plays an important role. In order to accurately identify the two-dimensional bar code, error-correcting code’s performance should be further enhanced. There is a simple introduction of the LDPC decoder based on BP algorithm and decoding algorithm for RS, and it gives MATLAB simulations in different iterations while in the same code length and code rate for LDPC code and RS code. Simulation {{results show that the}} greater the number of iterations the better the LDPC decoding performance, and the more errors can be rectified; based on the same code length and rate of the cases and less than 512 yards long, LDPC decoding performance is significantly higher than the RS code. It can be seen that LDPC code can do better than the RS codes on identifying two-dimensional bar code, and the information which we want can be reproduced clearly...|$|R
40|$|A new parallel-in-parallel-out bit-level pipelined {{multiplier}} {{is presented}} to perform multiplication in GF(2 m). The existing designs use m 2 identical cells each having 7 latches and have a system latency of 3 m. We start with the Dependence Graph (DG) of the algorithm and pipleine it to achieve a critical path equal to the delay of a 2 -input AND and XOR gate. The critical path in the proposed design {{is the same as}} in previous designs. The number of latches required per cell has however, been reduced from 7 to 3. This results in considerable hardware savings and the system latency is also reduced form the present 3 m to m+ 1 in the proposed design. A chip has been designed using Magic to implement the proposed multiplier. Introduction In recent years, Finite Fields have received a lot of attention because of their <b>application</b> in <b>error</b> control <b>coding</b> [1] [2]. They have also been used in digital signal processing, pseudorandom number generation, encryption and decryption protocols in [...] ...|$|R
50|$|HRESULTs are {{numerical}} <b>error</b> <b>codes.</b> Various bits {{within an}} HRESULT encode {{information about the}} nature of the <b>error</b> <b>code,</b> and where it came from.|$|R
40|$|Abstract-Arithmetic <b>error</b> <b>codes</b> {{constitute}} {{a class of}} <b>error</b> <b>codes</b> that are preserved during most arithmetic operations. Effectiveness studies for arithmetic <b>error</b> <b>codes</b> have shown their value for concurrent detection of faults in arithmetic processors, data transmission subsystems, and main storage units in fault-tolerant computers In this paper, it is shown that the same class of codes is also quite effective for detecting storage errors in both shift-register and magnetic-recording mass memories. Some of the results are more general and deal with properties of arithmetic <b>error</b> <b>codes</b> in detecting unidirectional failures. For example, it is shown that a low-cost arithmetic <b>error</b> <b>code</b> with check modulus A = 2 - 1 can detect any unidirectional failure which affects fewer than N bits. The use of arithmetic <b>error</b> <b>codes</b> for checking of mass memories is further justified since it {{eliminates the need for}} hard-core or self-checking code translators and reduces the number of different types of cod...|$|R
40|$|Discrete Fourier transforms~(DFTs) over finite fields have {{widespread}} <b>applications</b> in <b>error</b> correction <b>coding.</b> Hence, {{reducing the}} computational complexities of DFTs {{is of great}} significance, especially for long DFTs as increasingly longer <b>error</b> control <b>codes</b> are chosen for digital communication and storage systems. Since DFTs involve both multiplications and additions over finite fields and multiplications are much more complex than additions, recently proposed cyclotomic fast Fourier transforms (CFFTs) are promising due to their low multiplicative complexity. Unfortunately, they have very high additive complexity. Techniques such as common subexpression elimination (CSE) {{can be used to}} reduce the additive complexity of CFFTs, but their effectiveness for long DFTs is limited by their complexity. In this paper, we propose prime factor cyclotomic Fourier transforms (PFCFTs), which use CFFTs as sub-DFTs via the prime factor algorithm. When the length of DFTs is prime, our PFCFTs reduce to CFFTs. When the length has co-prime factors, since the sub-DFTs have much shorter lengths, this allows us to use CSE to significantly reduce their additive complexity. In comparison to previously proposed fast Fourier transforms, our PFCFTs achieve reduced overall complexity when the length of DFTs is at least 255, and the improvement significantly increases as the length grows. This approach also enables us to propose efficient DFTs with very long length (e. g., 4095 -point), first efficient DFTs of such lengths in the literature. Finally, our PFCFTs are also advantageous for hardware implementation due to their regular structure. Comment: submitted to SiPS 2010, accepte...|$|R
40|$|My {{areas of}} {{research}} lie on the interface of algebra and combinatorics, and touch on several other areas of mathematics such as orthogonal polynomials and number theory. The main objects of my considerations are Bose-Mesner algebras, subconstituent algebras, Leonard pairs, spin models, and planar algebras. I am particularly interested in duality (Section 2), spin models (Section 3), algebraic characterizations of combinatorial properties (Section 4), and Leonard pairs (Sections 5 and 6) and tridiagonal pairs (Sections 7 and 8) in representation theory. In these areas I often focus on examples related to distance-regular graphs and connection to quantum groups. I have also studied some combinatorial planar algebras (Section 9). Recently I have used linear algebra to study Fibonacci numbers (Section 10). 1 Background: Bose-Mesner algebras Bose-Mesner algebras arose independently in three areas during the 1950 ’s and 1960 ’s: statistical designs, centralizer algebras of permutation groups, and distance-transitive graphs. A period {{of growth in the}} subject occurred in the 1970 ’s and 1980 ’s after Delsarte and others unified these examples and demonstrated <b>applications</b> to <b>error</b> correcting <b>codes,</b> combinatorial designs, and found connections to orthogonal polynomials. The classification of finite simple groups also motivated an...|$|R
5000|$|In the [...]NET Framework, HRESULT/IErrorInfo <b>error</b> <b>codes</b> are {{translated}} into CLR exceptions when transitioning from native to managed code; and CLR exceptions are translated to HRESULT/IErrorInfo <b>error</b> <b>codes</b> when transitioning from managed to native COM code.|$|R
50|$|The {{original}} purpose of HRESULTs was to formally lay out ranges of <b>error</b> <b>codes</b> for {{both public and}} Microsoft internal use {{in order to prevent}} collisions between <b>error</b> <b>codes</b> in different subsystems of the OS/2 operating system.|$|R
5000|$|... For MASM/TASM [...]MODEL SMALL [...]STACK [...]CODE main PROC NEAR MOV AH, 4Ch Service 4Ch - Terminate with <b>Error</b> <b>Code</b> MOV AL, 0 <b>Error</b> <b>code</b> INT 21h Interrupt 21h - DOS General Interrupts main ENDP END main Starts at main ...|$|R
3000|$|... 5. Hindering: the {{controller}} fails {{to return a}} correct <b>error</b> <b>code,</b> which may hinder error recovery. The difference between a silent failure and this case is that, here, an error is acknowledged by {{the controller}} but the returned <b>error</b> <b>code</b> is incorrect.|$|R
40|$|The {{application}} of error-detecting or error-correcting codes in digital computer design requires studies of cost and effectiveness tradeoffs {{to supplement the}} knowledge of their theoretical properties. General criteria for cost and effectiveness studies of <b>error</b> <b>codes</b> are developed, and results are presented for arithmetic <b>error</b> <b>codes</b> with the low-cost check modulus 2 super a - 1. Both separate (residue) and nonseparate (AN) codes are considered. The class of multiple arithmetic <b>error</b> <b>codes</b> is developed {{as an extension of}} low-cost single codes...|$|R
30|$|Hindering The {{returned}} <b>error</b> <b>code</b> is incorrect.|$|R
50|$|The <b>error</b> <b>codes</b> {{returned}} are AFP result codes.|$|R
5000|$|<b>Error</b> <b>codes</b> were {{displayed}} on a two-digit seven-segment display (one of the first seen, and built with lamps rather than LEDs). The range of <b>error</b> <b>codes</b> included not only decimal and hexadecimal digits (as seven-segment displays are commonly used) but also a limited set of other letters; for example, [...] "P3" [...] {{was one of several}} printer <b>error</b> <b>codes.</b> A thick manual that came with the System/3 aided the operator in interpreting the <b>error</b> <b>codes</b> and suggested recovery procedures. The System/3 had no audible warning device, so a program that was not printing, reading cards, or causing other obvious activity could halt and the operator would not know it unless he or she happened to look at the status display. Models with the Dual Program Feature had two separate status displays.|$|R
50|$|<b>Error</b> <b>codes</b> {{are slowly}} disappearing from the programmer's {{environment}} as modern object-oriented programming languages {{replace them with}} exceptions. Exceptions {{have the advantage of}} being handled with explicit blocks of code, separate {{from the rest of the}} code. While it is considered poor practice in methodologies that use <b>error</b> <b>codes</b> and return codes to indicate failure, programmers often neglect to check return values for error conditions. That negligence can cause undesirable effects, as ignored error conditions often cause more severe problems later in the program. Exceptions are implemented in such a way as to separate the <b>error</b> handling <b>code</b> from the rest of the <b>code.</b> Separating the <b>error</b> handling <b>code</b> from the normal logic makes programs easier to write and understand, since one block of <b>error</b> handling <b>code</b> can service <b>errors</b> from any number of function calls. Exception handling also makes the code more readable than implementations with <b>error</b> <b>codes,</b> since exception handling does not disrupt the flow of the code with frequent checks for error conditions.|$|R
5000|$|RFC 2034, SMTP Service Extension for Returning Enhanced <b>Error</b> <b>Codes,</b> ...|$|R
5000|$|... #Subtitle level 2: Microsoft Internet Server 404 substatus <b>error</b> <b>codes</b> ...|$|R
50|$|<b>Error</b> <b>coding</b> can {{be chosen}} to {{be more or less}} robust.|$|R
50|$|An HRESULT value has 32 bits {{divided into}} three fields: a {{severity}} code, a facility <b>code,</b> and an <b>error</b> <b>code.</b> The severity code indicates whether the return value represents information, warning, or <b>error.</b> The facility <b>code</b> identifies {{the area of the}} system responsible for the <b>error.</b> The <b>error</b> <b>code</b> is a unique number that is assigned to represent the exception. Each exception is mapped to a distinct HRESULT.|$|R
50|$|Xbox 360 {{consoles}} {{which have}} a hardware failure will display a secondary <b>error</b> <b>code</b> by blinking a sequence of LED's when the correct button sequence is pushed. An <b>error</b> <b>code</b> of 0001 may represent a defect in the power supply, rather than the Xbox itself, or a short within the Xbox, or a blown capacitor.|$|R
5000|$|An XML-based {{specification}} {{format for}} projects, APIs, functions, types and <b>error</b> <b>codes</b> ...|$|R
5000|$|Generic error-handling code (e.g. which {{displays}} the HTTP <b>Error</b> <b>Code</b> 500 page) ...|$|R
5000|$|Check for any <b>Error</b> <b>codes</b> in the ECU {{and take}} {{corrective}} action.|$|R
5000|$|... <b>error</b> <b>code</b> ({{parameter}} 1, parameter 2, parameter 3, parameter 4) error name ...|$|R
5000|$|AIS implementers {{must also}} {{ensure that they}} respect the version numbers {{provided}} by the application when the library is initialized, with regard to new or modified <b>error</b> <b>codes</b> and do not expose <b>error</b> <b>codes</b> that only apply to functions {{in the most recent}} version of the specification to applications written to an older version of the specification.|$|R
