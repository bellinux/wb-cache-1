148|83|Public
5|$|C# {{provides}} properties as syntactic sugar for {{a common}} pattern in which a pair of methods, <b>accessor</b> (getter) and mutator (setter) encapsulate operations on a single attribute of a class. No redundant method signatures for the getter/setter implementations need be written, and the property may be accessed using attribute syntax rather than more verbose method calls.|$|E
500|$|Tempt, Tease and Touch {{received}} a mixed response since its release. A writer from Easy Lifestyle praised the scents, {{and found that}} they were as [...] "feminine, sophisticated and sexy as the Babes themselves". The writer felt {{the design of the}} bottles made the fragrances [...] "stylish must-have <b>accessor</b> enhancing any dressing table and come in black, pink and silver, reflecting the mood of the fragrance inside". In October 2010, Glamour magazine listed the perfumes as among the best/most popular [...] "celebrity scents", calling the bottle designs [...] "cute and curvy" [...] and describing the smells as [...] "sweet and fruity". A writer from Look highlighted Tempt as their favorite from the three due to its scent, and also praised the collection as a whole. A writer for the Daily Mirror, however, called the perfumes' release an act of [...] "desperation" [...] by a band fading in relevance.|$|E
2500|$|One of the {{differences}} of Ruby compared to Python and Perl is that Ruby keeps all of its instance variables completely private to the class and only exposes them through <b>accessor</b> methods (attr_writer, attr_reader, etc.). Unlike the [...] "getter" [...] and [...] "setter" [...] methods of other languages like C++ or Java, <b>accessor</b> methods in Ruby can be created with a single line of code via metaprogramming; however, <b>accessor</b> methods can also be created in the traditional fashion of C++ and Java. As invocation of these methods {{does not require the}} use of parentheses, it is trivial to change an instance variable into a full function, without modifying a single line of calling code or having to do any refactoring achieving similar functionality to C# and VB.NET property members.|$|E
25|$|The default {{modifiers}} for the <b>accessors</b> are {{inherited from}} the property. Note that the <b>accessor's</b> modifiers can only be equal or more restrictive than the property's modifier.|$|R
25|$|A {{feature of}} C# 3.0 is auto-implemented properties. You define <b>accessors</b> without bodies and the {{compiler}} will generate a backing {{field and the}} necessary code for the <b>accessors.</b>|$|R
40|$|CONTEXT: Data <b>accessors</b> {{allow one}} {{to read and}} write {{components}} of a data structure, such as the fields of a record, the variants of a union, or the elements of a container. These data <b>accessors</b> are collectively known as optics; they are fundamental to programs that manipulate complex data. INQUIRY: Individual data <b>accessors</b> for simple data structures are easy to write, for example as pairs of "getter" and "setter" methods. However, it is not obvious how to combine data <b>accessors,</b> {{in such a way that}} data <b>accessors</b> for a compound data structure are composed out of smaller data <b>accessors</b> for the parts of that structure. Generally, one has to write a sequence of statements or declarations that navigate step by step through the data structure, accessing one level at a time - which is to say, data <b>accessors</b> are traditionally not first-class citizens, combinable in their own right. APPROACH: We present a framework for modular data access, in which individual data <b>accessors</b> for simple data structures may be freely combined to obtain more complex data <b>accessors</b> for compound data structures. Data <b>accessors</b> become first-class citizens. The framework is based around the notion of profunctors, a flexible generalization of functions. KNOWLEDGE: The language features required are higher-order functions ("lambdas" or "closures"), parametrized types ("generics" or "abstract types"), and some mechanism for separating interfaces from implementations ("abstract classes" or "modules"). We use Haskell as a vehicle in which to present our constructions, but languages such as Java, C#, or Scala that provide the necessary features should work just as well. GROUNDING: We provide implementations of all our constructions, in the form of a literate program: the manuscript file for the paper is also the source code for the program, and the extracted code is available separately for evaluation. We also prove the essential properties demonstrating that our profunctor-based representations are precisely equivalent to the more familiar concrete representations. IMPORTANCE: Our results should pave the way to simpler ways of writing programs that access the components of compound data structures...|$|R
2500|$|Today he is a writer, speaker, {{author and}} a {{disability}} rights activist - as a fervent advocate for inclusion {{of all people}} by design - most importantly as a widely experienced and highly competent accessibility [...] and an <b>accessor,</b> befittingly recognised by three learned societies and several reputed bodies overseas.|$|E
2500|$|In the {{terminology}} of Perl 6, $.x is called an [...] "attribute". Some languages call these fields or members. The method used to access an attribute is called an [...] "accessor". Auto-accessors are methods that are created automatically, as the method x {{is in the}} example above. These <b>accessor</b> functions return {{the value of the}} attribute. When a class or individual attribute is declared with the is rw modifier (short for [...] "read/write"), the auto-accessor can be passed a new value to set the attribute to, or it can be directly assigned to as an lvalue (as in the example). Auto-accessors can be replaced by user-defined methods, should the programmer desire a richer interface to an attribute. Attributes can only be accessed directly from within a class definition. All other access must go through the <b>accessor</b> methods.|$|E
5000|$|... class OurFamily{private long familyMember = new long7; public {{long this}} index { // The get <b>accessor</b> get { return familyMemberindex; } // The set <b>accessor</b> with [...] set { familyMemberindex = value; } }} ...|$|E
40|$|Data <b>accessors</b> {{allow one}} {{to read and}} write {{components}} of a data structure, such as the fields of a record, the variants of a union, or the elements of a container. These data <b>accessors</b> are collectively known as optics; they are fundamental to programs that manipulate complex data. Individual data <b>accessors</b> for simple data structures are easy to write, for example as pairs of ‘getter’ and ‘setter’ methods. However, it is not obvious how to combine data <b>accessors,</b> {{in such a way that}} data <b>accessors</b> for a compound data structure are composed out of smaller data <b>accessors</b> for the parts of that structure. Generally, one has to write a sequence of statements or declarations that navigate step by step through the data structure, accessing one level at a time—which is to say, data <b>accessors</b> are traditionally not first-class citizens, combinable in their own right. We present a framework for modular data access, in which individual data <b>accessors</b> for simple data structures may be freely combined to obtain more complex data <b>accessors</b> for compound data structures. Data <b>accessors</b> become first-class citizens. The framework is based around the notion of profunctors, a flexible generalization of functions. The language features required are higher-order functions (‘lambdas’ or ‘closures’), parametrized types (‘generics’ or ‘abstract types’) of higher kind, and some mechanism for separating interfaces from implementations (‘abstract classes’ or ‘modules’). We use Haskell as a vehicle in which to present our constructions, but other languages such as Scala that provide the necessary features should work just as well. We provide implementations of all our constructions, in the form of a literate program: the manuscript file for the paper is also the source code for the program, and the extracted code is available separately for evaluation. We also prove the essential properties, demonstrating that our profunctor-based representations are precisely equivalent to the more familiar concrete representations. Our results should pave the way to simpler ways of writing programs that access the components of compound data structures. </p...|$|R
5000|$|Ruby code generation: constructors, overrides, templates, <b>accessors</b> ...|$|R
5000|$|... #Subtitle level 3: Establishing private {{variables}} and <b>accessors</b> ...|$|R
50|$|The {{alternative}} to defining mutator and <b>accessor</b> methods, or property blocks, {{is to give}} the instance variable some visibility other than private and access it directly from outside the objects. Much finer control of access rights can be defined using mutators and accessors. For example, a parameter may be made read-only simply by defining an <b>accessor</b> but not a mutator. The visibility of the two methods may be different; it is often useful for the <b>accessor</b> to be public while the mutator remains protected, package-private or internal.|$|E
5000|$|Bean Info: exposes JavaBean property, <b>accessor</b> and mutator {{metadata}} (primarily used {{by other}} add-ons) ...|$|E
5000|$|In D version 2, each {{property}} <b>accessor</b> or mutator must {{be marked}} with @property: ...|$|E
40|$|The {{semantics}} of {{the core}} features of XML Schema in terms of XQuery 1. 0 and XPath 2. 0 data model algebraically defined is given. The database state is represented as a many sorted algebra whose sorts are sets of data type values and different kinds of nodes and whose operations are data type operations and node <b>accessors.</b> The values of some node <b>accessors,</b> such as “parent”, “children ” and “attributes”, define a document tree with a definite order of nodes. The values of other node <b>accessors</b> help to make difference between kinds of nodes, learn the names, types and values associated with the corresponding document entities, etc., i. e., provide primitive facilities for a query language. As a result, a document can be easily mapped to its implementation in terms of nodes and <b>accessors</b> defined on them...|$|R
50|$|Perrigan, Rufus. History of Regular Baptist and Their Ancestors and <b>Accessors.</b>|$|R
5000|$|... #Subtitle level 3: The {{accessibility}} of property <b>accessors</b> {{can be set}} independently ...|$|R
5000|$|Members of s {{imported}} to {{the current}} file, can be accessed with no preceding container <b>accessor</b> ...|$|E
5000|$|In Common Lisp Object System, slot {{specifications}} within class definitions may {{specify any}} of the , [...] and [...] options (even multiple times) to define reader methods, setter methods and <b>accessor</b> methods (a reader method and the respective [...] method). Slots are always directly accessible through their names {{with the use of}} [...] and , and the slot <b>accessor</b> options define specialized methods that use [...]|$|E
5000|$|In {{place of}} {{constructor}} parameters, Scala has class parameters, which {{are placed on}} the class, similar to parameters to a function. When declared with a [...] or [...] modifier, fields are also defined with the same name, and automatically initialized from the class parameters. (Under the hood, external access to public fields always goes through <b>accessor</b> (getter) and mutator (setter) methods, which are automatically created. The <b>accessor</b> function has the same name as the field, which is why it's unnecessary in the above example to explicitly declare <b>accessor</b> methods.) Note that alternative constructors can also be declared, as in Java. Code that {{would go into the}} default constructor (other than initializing the member variables) goes directly at class level.|$|E
40|$|R topics documented: simFrame-package [...] . 3 <b>accessors</b> [...] 5 aggregate-methods [...] . 11 BasicVector-class [...] 13 clusterRunSimulation [...] 1...|$|R
5000|$|Lack {{of static}} type [...] "safety" [...] checks. Typed <b>accessors</b> are {{sometimes}} utilized as {{one way to}} mitigate this.|$|R
5000|$|Modern {{programming}} languages often {{offer the}} ability to generate the boilerplate for mutators and <b>accessors</b> in a single line - as for example C#'s [...] and Ruby's [...] In these cases, no code blocks are created for validation, preprocessing or synthesis. These simplified <b>accessors</b> still retain the advantage of encapsulation over simple public instance variables, but it is common that, as system designs progress, the software is maintained and requirements change, the demands on the data become more sophisticated. Many automatic mutators and <b>accessors</b> eventually get replaced by separate blocks of code. The benefit of automatically creating them {{in the early days}} of the implementation is that the public interface of the class remains identical whether or not greater sophistication is added, requiring no extensive refactoring if it is.|$|R
5000|$|Data persistence: {{ensured by}} <b>accessor</b> objects called Models, they allow easy creation, {{migration}} {{and access to}} records.|$|E
5000|$|An attribute's {{characteristics}} {{may include}} a read/write flag, a type, <b>accessor</b> method names, delegations, a default value and lazy initialization.|$|E
5000|$|... class C {public: void mutator(int x) { myValue = x; } int <b>accessor</b> (...) const { return myValue; }private: int myValue;}; ...|$|E
5000|$|In {{order to}} use dot {{notation}} to invoke property <b>accessors</b> within an instance method, the [...] "self" [...] keyword should be used: ...|$|R
5000|$|Spy - A spy captures {{and makes}} {{available}} parameter and state information, publishing <b>accessors</b> to test code for private information allowing for more advanced state validation.|$|R
25|$|Direct State Access (DSA) – object <b>accessors</b> enable {{state to}} be queried and {{modified}} without binding objects to contexts, for increased application and middleware efficiency and flexibility.|$|R
50|$|Here is {{an example}} in Smalltalk, of a typical <b>accessor</b> method to return {{the value of a}} {{variable}} using lazy initialization.|$|E
5000|$|One of the {{differences}} of Ruby compared to Python and Perl is that Ruby keeps all of its instance variables completely private to the class and only exposes them through <b>accessor</b> methods ( [...] , , etc.). Unlike the [...] "getter" [...] and [...] "setter" [...] methods of other languages like C++ or Java, <b>accessor</b> methods in Ruby can be created with a single line of code via metaprogramming; however, <b>accessor</b> methods can also be created in the traditional fashion of C++ and Java. As invocation of these methods {{does not require the}} use of parentheses, it is trivial to change an instance variable into a full function, without modifying a single line of calling code or having to do any refactoring achieving similar functionality to C# and VB.NET property members.|$|E
5000|$|Its use is not {{transparent}} as {{it requires}} to be declared necessary object attributes as properties and appropriate <b>accessor</b> methods {{must be provided}} ...|$|E
50|$|Special public member methods - <b>accessors</b> (aka getters) and mutator methods (often called setters) {{are used}} to control changes to class {{variables}} {{in order to prevent}} unauthorized access and data corruption.|$|R
5000|$|A {{feature of}} C# 3.0 is auto-implemented properties. You define <b>accessors</b> without bodies and the {{compiler}} will generate a backing {{field and the}} necessary code for the accessors.public double Width{ get; private set;} ...|$|R
50|$|Members may be {{declared}} public {{to avoid the}} effort or syntactic overhead of providing proper <b>accessors</b> for them. This may increase readability of the class, but {{at the cost of}} the consequences described above.|$|R
