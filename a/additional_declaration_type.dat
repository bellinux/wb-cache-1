0|380|Public
40|$|In {{this paper}} we propose a type-based {{framework}} for using logic programming for XML processing. We transform XML documents into terms and DTDs into regular types. We implemented a standard type inference algorithm for logic programs and use the types corresponding to the DTDs as <b>additional</b> <b>type</b> <b>declarations</b> for logic programs for XML processing. Due to the correctness of the type inference this makes it possible to use logic programs as an implicitly typed processing language for XML with static type (in this case DTDs) validation. As far as we know this is the first work adding type validation at compile time to the use of logic programming for XML processing...|$|R
40|$|The work {{concerns}} environmental <b>declarations</b> <b>type</b> III alias system EPD. A reader {{should be}} given a complex sight of kinds of environmental notation, especially environmental <b>declarations</b> <b>type</b> III. The work interpret present systems EPD on the world and evaluace the present state of exploitation of system EPD in Czech Republic. At the close of my work are put mind to question of implementation of environmental <b>declarations</b> <b>type</b> III in Czech Republic...|$|R
5000|$|... 1579 - The Union of Utrecht {{included}} a decree of toleration allowing personal freedom of religion. An <b>additional</b> <b>declaration</b> allowed provinces and cities that wished to remain Catholic {{to join the}} Union.|$|R
40|$|We {{investigate}} type inference {{for programming}} languages with subtypes. As described in previous work, {{there are several}} type inference problems for anygiven expression language, depending on {{the form of the}} subtype partial order andtheability todefine newsubtypes in programs. Our first main result is that foranyspecific subtype partial order, the problem of determining whether alambda term is typable is algorithmically (polynomial-time) equivalent to a form of satisfiability problem over thesame partial order. This gives the first exact characterization of the problem that is independent of the syntax of expressions. In addition, since this form of satisfiability problem is l%p, 4 CE-hard over certain partial orders, this equivalence strengthens the previous lower bound of iw’-hard to pspAcE-hard. Our second main result is a lower bound on the length of most general types when the subtype hierarchy may change as a result of <b>additional</b> <b>type</b> <b>declarations</b> within the program. More specifically, given any input expression, a type inference algorithm tries to find a most general (or prtncipal) typing. The prop-erty of a most general typing is that it has all other possible typings as instances. However, there are several sound notions of instance in the presence of subtyping. Our lower bound is that no sound definition of instance would allow the set of additional subtyping hypotheses about a term to grow less than linearly {{in the size of the}} term...|$|R
50|$|The Union of Utrecht allowed {{complete}} {{personal freedom}} of religion and was thus {{one of the first}} unlimited edicts of religious toleration. An <b>additional</b> <b>declaration</b> allowed provinces and cities that wished to remain Catholic to join the Union.|$|R
5000|$|... void : Used as the <b>declaration</b> <b>type</b> for {{the return}} value of a function, {{specifies}} that the function will not return a value. Available in all known drivers.|$|R
50|$|Other JavaScript frameworks, such as JQuery, {{can work}} {{side-by-side}} with WinJS. The library comes with <b>additional</b> <b>declaration</b> files for a rich developer experience using TypeScript, a strict superset of JavaScript with annotations. TypeScript enables for code completion and refactoring while maintaining compatibility with JavaScript.|$|R
5000|$|The XML <b>declaration</b> and {{document}} <b>type</b> <b>declaration</b> are removed ...|$|R
5|$|PHP 7 also {{introduced}} new language features, including return <b>type</b> <b>declarations</b> for functions, which complement the existing parameter <b>type</b> <b>declarations,</b> {{and support for}} the scalar types (integer, float, string, and boolean) in parameter and return <b>type</b> <b>declarations.</b>|$|R
50|$|Scala is able {{to infer}} types by usage. This makes most static <b>type</b> <b>declarations</b> optional. Static <b>types</b> need not be {{explicitly}} declared unless a compiler error indicates the need. In practice, some static <b>type</b> <b>declarations</b> are included {{for the sake of}} code clarity.|$|R
50|$|YAML {{lacks the}} notion of tag {{attributes}} that are found in XML. Instead YAML has extensible <b>type</b> <b>declarations</b> (including class <b>types</b> for objects).|$|R
25|$|Mode <b>declarations</b> allow <b>types</b> to be recursive: defined {{directly}} or indirectly in terms of themselves.|$|R
2500|$|Procedure (proc) <b>declarations</b> require <b>type</b> {{specifications}} {{for both the}} parameters and the result (void if none): ...|$|R
50|$|A common {{misconception}} {{holds that}} a non-validating XML parser {{does not have}} to read document <b>type</b> <b>declarations,</b> when in fact, the document <b>type</b> <b>declarations</b> must still be scanned for correct syntax as well as validity of declarations, and the parser must still parse all entity declarations in the internal subset, and substitute the replacement texts of internal entities occurring anywhere in the document <b>type</b> <b>declaration</b> or in the document body.|$|R
25|$|Modifiers are {{keywords}} used {{to modify}} <b>declarations</b> of <b>types</b> and type members. Most notably {{there is a}} sub-group containing the access modifiers.|$|R
2500|$|Type-parameters are names used {{in place}} of {{concrete}} types when defining a new generic. They {{may be associated with}} classes or methods by placing the type parameter in angle brackets [...] When instantiating (or calling) a generic, you can then substitute a concrete type for the type-parameter you gave in its <b>declaration.</b> <b>Type</b> parameters may be constrained by use of the [...] keyword and a constraint specification, any of the six comma separated constraints may be used: ...|$|R
50|$|In {{order to}} {{validate}} an XHTML document, a Document <b>Type</b> <b>Declaration,</b> or DOCTYPE, may be used. A DOCTYPE declares to the browser the Document Type Definition (DTD) {{to which the}} document conforms. A Document <b>Type</b> <b>Declaration</b> should be placed before the root element.|$|R
5000|$|If the <b>type</b> <b>declaration</b> on {{the first}} line were omitted, the program would trigger an error on compilation, as the {{variable}} [...] "p" [...] would not be defined. But the program would still be syntactically correct since <b>type</b> <b>declarations</b> provide only semantic information.|$|R
50|$|An SGML {{document}}, all {{of whose}} document instances are fully tagged. There {{need not be}} a document <b>type</b> <b>declaration</b> associated with any of the instances. Note: If there is a document <b>type</b> <b>declaration,</b> the instance can be parsed with or without reference to it.|$|R
5000|$|Early C {{had neither}} {{constant}} <b>declarations</b> nor <b>type</b> <b>declarations,</b> and the C language was originally defined as needing a [...] "preprocessor"; a separate program, and pass, that handled constant, include and macro definitions, to keep memory usage down. Later, with ANSI C, it obtained constant and type definitions features and the preprocessor also {{became part of}} the language itself, leading to the syntax we see today.|$|R
40|$|MacLISP {{provides}} a compiler which produces numerical code competitive in speed with some FORTRAN implementations and yet {{compatible with the}} rest of the MacLISP system. All numerical programs can be run under MacLISP interpreter. <b>Additional</b> <b>declarations</b> to the compiler specify type information which allows the generation of optimized numerical code which generally does not require the garbage collection of temporary numerical results. Array accesses are almost as fast as in FORTRAN, and permit the use of dynamically allocated arrays of varying dimensions. Here we discuss the implementation decisions regarding user interface, data representations, and interfacing conventions which allow the generation of fast numerical LISP code...|$|R
40|$|Following {{difficult}} negotiations, the European institutions eventually, in May 2006, {{arrived at}} a consensus on a new Financial Framework for the European Union's budget over the years 2007 to 2013. In an <b>additional</b> <b>declaration,</b> the European Commission was invited to undertake a full review covering all aspects of EU spending until 2008 - 09. A mid-term review, however, should deal with the fundamental issue of which political tasks are best assigned to the EU and which tasks {{should be left to}} the responsibility of the member states. This problem is addressed by the economic theory of fiscal federalism. EU Finanzrahmen 2006 - 2013 Fiskalföderalismus...|$|R
5000|$|Policy form - The definitions, {{insuring}} agreement, exclusions, {{and conditions}} are typically combined {{into a single}} integrated document called a policy form, coverage form, or coverage part. When multiple coverage forms are packaged into a single policy, the declarations will state as much, and then there may be <b>additional</b> <b>declarations</b> specific to each coverage form. Traditionally, policy forms have been so rigidly standardized {{that they have no}} blank spaces to be filled in. Instead, they always expressly refer to terms or amounts stated in the declarations. If the policy needs to be customized beyond what is possible with the declarations, then the underwriter attaches endorsements or riders.|$|R
5000|$|Mode <b>declarations</b> allow <b>types</b> to be recursive: defined {{directly}} or indirectly in terms of themselves.This is subject to some restrictions - for instance, these declarations are illegal: ...|$|R
40|$|Abstract data <b>type</b> <b>declarations</b> {{appear in}} <b>typed</b> {{programming}} languages like Ada, Alphard, CLU and ML. This form of declaration binds {{a list of}} identifiers to a type with associated operations, a composite “value ” we call a data algebra. We use a second-order typed lambda calculus SOL to show how data algebras may be given types, passed as parameters, and returned as results of function calls. In the process, we discuss the semantics of abstract data <b>type</b> <b>declarations</b> and review a connection between typed programming languages and constructive logic...|$|R
50|$|In the C-family of {{programming}} languages, declarations are often collected into header files, which {{are included in}} other source files that reference and use these declarations, but don't {{have access to the}} definition. The information in the header file provides the interface between code that uses the declaration and that which defines it, a form of information hiding. A declaration is often used in order to access functions or variables defined in different source files, or in a library. A mismatch between the definition <b>type</b> and the <b>declaration</b> <b>type</b> generates a compiler error.|$|R
5000|$|Parallel {{processes}} {{communicate by}} sending typed messages through channels created dynamically. Channels are not variables in themselves, but are identified by a unique value {{known as the}} channel reference, which are held by channel variables. A channel is declared, for example, by the <b>declaration</b> <b>type</b> channel = *(boolean, integer);var c: channel;which defines a new (mixed) type named channel and a variable of this type named c. A mixed type channel is restricted to transmitting only the specified types, in this case boolean and integer values. The channel c is initialised by the [...] statement: ...|$|R
40|$|One of the {{disadvantages}} of statically typed languages is the programming overhead caused by writing {{all the necessary}} type information: Both <b>type</b> <b>declarations</b> and <b>type</b> definitions are typically required. Traditional type inference aims at relieving the programmer from the former. We present a rule-based constraint rewriting algorithm that reconstructs both <b>type</b> <b>declarations</b> and <b>type</b> definitions, allowing the programmer to effectively program type-less in a strictly typed language. This effectively combines strong points of dynamically typed languages (rapid prototyping) and statically typed ones (documentation, optimized compilation). Moreover it allows to quickly port code from a statically untyped to a statically typed setting. Our constraint-based algorithm reconstructs uniform polymorphic definitions of algebraic data types and simultaneously infers the types of all expressions and functions (supporting polymorphic recursion) in the program. The declarative nature of the algorithm allows us to easily show {{that it has a}} number of highly desirable properties such as soundness, completeness and various optimality properties. Moreover, we show how to easily extend and adapt it to suit a number of different language constructs and type system features. status: publishe...|$|R
5000|$|For example, a {{vector space}} {{comes with an}} {{associated}} field of scalar numbers. Let W and N denote the sort of vectors and numbers, respectively, let VW and VN be the set of vector and number variables, respectively, and CW and CN the set of vector and number constants, respectively. Then e.g. [...] and , and the vector addition, the scalar multiplication, and the inner product is declared as , and , respectively. Assuming variable symbols [...] and , the term [...] is well-sorted, while [...] is not (since + doesn't accept a term of sort N as 2nd argument). In order to make [...] a well-sorted term, an <b>additional</b> <b>declaration</b> [...] is required. Function symbols having several declarations are called overloaded.|$|R
50|$|The {{application}} programming interface (API) of the C standard {{library is}} declared {{in a number of}} header files. Each header file contains one or more function <b>declarations,</b> data <b>type</b> definitions, and macros.|$|R
40|$|Environmental {{labels and}} {{declarations}} as market oriented approach {{of environmental protection}} can lead to sustainable production and consumption through credible and verifiable labeling schemes. Ecolabel provides consumers information about environmental impacts of the product that they can include in their purchase decisions. The goal {{of this paper is}} to determine how companies evaluate effects resulting from use of one of the types of environmental labeling in the Czech Republic. Environmental labeling encompasses three types - ecolabeling (Type I), self-declared environmental claims (Type II) and Environmental product <b>declaration</b> (<b>Type</b> III). Main objective is the evaluation of environmental labels as a communication tool between company and consumer...|$|R
2500|$|When an SGML {{comment or}} other unrecognized content appears before the {{document}} <b>type</b> <b>declaration</b> ...|$|R
50|$|Another {{important}} component is the HTML document <b>type</b> <b>declaration,</b> which triggers standards mode rendering.|$|R
5000|$|When an SGML {{comment or}} other unrecognized content appears before the {{document}} <b>type</b> <b>declaration</b> ...|$|R
5000|$|The Lisp {{family of}} {{languages}} are all [...] "strongly typed" [...] {{in the sense that}} typing errors are prevented at runtime. Some Lisp dialects like Common Lisp or Clojure do support various forms of <b>type</b> <b>declarations</b> and some compilers (CMUCL and related) use these <b>declarations</b> together with <b>type</b> inference to enable various optimizations and also limited forms of compile time type checks.|$|R
40|$|A constraint-based {{method for}} {{deriving}} <b>type</b> <b>declarations</b> from program statements is described. The relation between declarations and a correctly typed {{program can be}} characterized by means of instance constraints and the present paper describes experiences using constraint solving techniques to synthesize the <b>type</b> <b>declarations</b> inherent in a given program. Such a facility {{may turn out to}} be useful from the viewpoint of programming methodology. It may suggests an integration of an experimental and "untyped" style with the higher degree of robustness gained with typed languages. 1 Introduction <b>Type</b> <b>declarations</b> in programming languages are praised because it leads to more robust programs and it is a common observation that many programming errors are detected by the type checker or even by the programmer himself, when he is designing the declarations. On the other hand, it can be argued that the additional burden of writing <b>type</b> <b>declarations</b> does not fit with the fast and experimental [...] ...|$|R
