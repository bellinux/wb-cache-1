449|10000|Public
2500|$|Well-written {{and tested}} <b>abstract</b> <b>data</b> <b>type</b> {{libraries}} which centralize and automatically perform buffer management, including bounds checking, {{can reduce the}} occurrence and impact of buffer overflows. [...] The two main building-block data types in these languages in which buffer overflows commonly occur are strings and arrays; thus, libraries preventing buffer overflows in these data types can provide {{the vast majority of}} the necessary coverage. [...] Still, failure to use these safe libraries correctly can result in buffer overflows and other vulnerabilities; and naturally, any bug in the library itself is a potential vulnerability. [...] "Safe" [...] library implementations include [...] "The Better String Library", Vstr [...] and Erwin. The OpenBSD operating system's C library provides the strlcpy and strlcat functions, but these are more limited than full safe library implementations.|$|E
5000|$|Associative array for {{the more}} {{fundamental}} <b>abstract</b> <b>data</b> <b>type</b> ...|$|E
5000|$|<b>Abstract</b> <b>data</b> <b>type</b> for an {{abstract}} {{description of a}} set of data ...|$|E
40|$|The {{concept of}} dynamic <b>abstract</b> <b>data</b> <b>types</b> was {{recently}} proposed {{by two of}} the authors as a dynamic extension of the well-known concept of <b>abstract</b> <b>data</b> <b>types,</b> motivated by several recent approaches in the area of algebraic specifications, object orientation, evolving algebras, and graph transformations. The basic idea of dynamic <b>abstract</b> <b>data</b> <b>types</b> is to extend <b>abstract</b> <b>data</b> <b>types</b> by dynamic operations which are tranformations between <b>abstract</b> <b>data</b> <b>types.</b> In this paper we consider a specific kind of dynamic <b>abstract</b> <b>data</b> <b>types</b> where the transformations are defined by rules in the sense of algebraic graph transformations. The concept of attributed graph transformations is used to define this new version of dynamic <b>abstract</b> <b>data</b> <b>types</b> and to show some important properties of the corresponding transition category. The constructions are illustrated by a small example from the area of data bases...|$|R
40|$|Ada 83 did {{not provide}} enough control on the creation, assignment, and {{destruction}} of objects of userdefined types. This lack of control restricted type composition and prevented the full exercise of information hiding for <b>abstract</b> <b>data</b> <b>types.</b> Ada 9 X brings new mechanisms supporting the full control of <b>abstract</b> <b>data</b> <b>types,</b> powerful type composition, and more extensive information hiding. With better control of <b>abstract</b> <b>data</b> <b>types,</b> Ada code {{will be easier to}} write, understand, maintain, and reuse. Thus, applications written in Ada 9 X will be safer. KEYWORDS. <b>Abstract</b> <b>data</b> <b>types,</b> Information hiding, Ada 9 X, Object initialization, User-defined assignment, Object finalization, Memory reclamation, Storage management, Reference counting, Type composition, Collections. 1. INTRODUCTION Ada is known for the quality of its design and the power of its basic mechanisms, especially in support of the construction and composition of <b>abstract</b> <b>data</b> <b>types</b> (ADTs). Today, Ada is emerging from its firs [...] ...|$|R
40|$|In this paper, we give simple example <b>abstract</b> <b>data</b> <b>types,</b> with atomic operations, {{that are}} related by data {{refinement}} under a definition used widely in the literature, but these same <b>abstract</b> <b>data</b> <b>types</b> are not related by singleton failure refinement. This contradicts results found in the literature...|$|R
5000|$|An {{event is}} an <b>abstract</b> <b>data</b> <b>type</b> with a boolean {{state and the}} {{following}} operations: ...|$|E
5000|$|Stack (<b>abstract</b> <b>data</b> <b>type)</b> - the [...] "opposite" [...] of a queue: LIFO (Last In First Out) ...|$|E
5000|$|Arrays, hash {{maps and}} structs {{are not a}} {{hard-coded}} feature. Instead they are defined as <b>abstract</b> <b>data</b> <b>type</b> in libraries.|$|E
40|$|Using a {{categorical}} {{model of}} <b>abstract</b> <b>data</b> <b>types</b> [2, 3, 13, 15], we show, following the Kozen's technique [10] and Tarjan's constructions for a deterministic automaton [16], that if two unambiguous regular expressions dene the same regular language, then they represent two isomorphic <b>abstract</b> <b>data</b> <b>types.</b> ...|$|R
2500|$|High-level <b>abstract</b> <b>data</b> <b>types,</b> {{including}} structures/records, unions, classes, {{and sets}} ...|$|R
40|$|Reusable <b>abstract</b> <b>data</b> <b>types</b> may be {{implemented}} in Ada as generic packages. First we will state some design goals, then outline our solution, address its rationale and show why alternatives have to be rejected. The presented design rules have already been applied successfully for implementing a rather wide set of <b>abstract</b> <b>data</b> <b>types...</b>|$|R
5000|$|Structures {{and classes}} are a complex (<b>abstract)</b> <b>data</b> <b>type</b> {{that can be}} {{operated}} in MQL4. Classes differ from structures in the following characteristics: ...|$|E
50|$|In {{computer}} science, a mergeable heap (also {{called a}} meldable heap) is an <b>abstract</b> <b>data</b> <b>type,</b> {{which is a}} heap supporting a merge operation.|$|E
50|$|Serialization {{breaks the}} opacity of an <b>abstract</b> <b>data</b> <b>type</b> by {{potentially}} exposing private implementation details. Trivial implementations which serialize all data members may violate encapsulation.|$|E
40|$|Abstract: This {{tutorial}} collects and elaborates {{arguments for}} distinguishing between object-oriented programming and <b>abstract</b> <b>data</b> <b>types.</b> The basic distinction is that object-oriented programming achieves data abstraction {{by the use}} of procedural abstraction, while <b>abstract</b> <b>data</b> <b>types</b> depend upon type abstraction. Object-oriented programming and <b>abstract</b> <b>data</b> <b>types</b> can also be viewed as complementary implementation techniques: objects are centered around the constructors of a <b>data</b> abstraction, while <b>abstract</b> <b>data</b> <b>types</b> are organized around the operations. These differences have consequences relating to extensibility, efficiency, typing, and verification; in many cases the strengths of one paradigm are the weaknesses of the other. Most object-oriented programming languages support aspects of both techniques, not a unification of them, so an understanding of their relative merits is useful in designing programs. Published in the Proceedings of the REX Workshop/School on the Foundations of Object-Oriented Languages, LNCS 173, Springer-Verlag, 1990, pp. 151 - 178...|$|R
40|$|The main {{objective}} of this course is to provide an introduction to basic data structures and manipulating them, by using C programming language. Course Outcomes: Having successfully completed this course, the student will be able to: 1. apply advance C programming techniques such as pointers, dynamic memory allocation, structures to developing solutions for particular problems; 2. design and implement <b>abstract</b> <b>data</b> <b>types</b> such as linked list, stack, queue and tree by using C as the programming language using static or dynamic implementations; 3. evaluate and choose appropriate <b>abstract</b> <b>data</b> <b>types</b> to solve particular problems; 4. design and implement C programs that apply <b>abstract</b> <b>data</b> <b>types.</b> Unit I: Introduction to data structures...|$|R
40|$|This paper {{investigates the}} {{desirable}} properties of programming language constructs that support encapsulation of environments and <b>abstract</b> <b>data</b> <b>types.</b> These properties are illustrated {{by using a}} simple multiuser file system as a model. The require-ments for such a file system are outlined; then the model file system design is described by a hierarchy of encapsulated <b>abstract</b> <b>data</b> <b>types</b> and environments. The high-level language constructs necessary to directly implement the model file system design are identified. It is concluded that environment encapsulation and <b>abstract</b> <b>data</b> <b>types</b> must be supported by different constructs, and the desirable properties of such constructs are outlined. A superset of Ada e that effectively supports both environments and <b>abstract</b> <b>data</b> <b>types</b> is introduced and used to implement the model file system. The encapsulation constructs of several modern systems programming languages are evaluated. Each of these languages is shown to be insufficient for a direct implementation of the model file system design...|$|R
50|$|In {{computer}} science, a graph is an <b>abstract</b> <b>data</b> <b>type</b> that {{is meant}} to implement the undirected graph and directed graph concepts from mathematics, specifically the field of graph theory.|$|E
50|$|In {{solving a}} problem, a data {{structure}} is generally {{an integral part}} of the algorithm. In modern programming style, algorithms and data structures are encapsulated together in an <b>abstract</b> <b>data</b> <b>type.</b>|$|E
50|$|Languages with <b>abstract</b> <b>data</b> <b>type</b> support {{which may}} be used to {{resemble}} OO programming, but without all features of object-orientation. This includes object-based and prototype-based languages. Examples: JavaScript, Lua, Modula-2, CLU.|$|E
50|$|Together with Gordon Plotkin {{he noted}} the {{connection}} between existential <b>types</b> and <b>abstract</b> <b>data</b> <b>types.</b>|$|R
40|$|This paper {{introduces}} {{the concept of}} normal forms for algebraic specifications of Ada packages defining <b>abstract</b> <b>data</b> <b>types.</b> The normal form {{is used in the}} process of reusable software component retrieval via formal specifications. We review the use of algebras for the specification of <b>abstract</b> <b>data</b> <b>types.</b> Then, using a concrete example, we define normal forms and present the details of algorithms to automate the normalization process...|$|R
40|$|In this draft paper a {{technique}} for specifying shared <b>abstract</b> <b>data</b> <b>types</b> is proposed. After {{a review of}} traditional transaction management techniques, the approach given by Spector [Spector 84] is discussed. Starting from such approach, we present the outlines of a different, homogeneous, style of shared <b>abstract</b> <b>data</b> <b>types</b> definition, able to express ali the semantic knowledge needed to avoid the unnecessary constraints on concurrency usually imposed by traditional transaction management approaches. Doing so, {{it is possible to}} obtain the massimum level of parallelism admitted by the notion of consistency on data. Our approach allows both the <b>abstract</b> <b>data</b> <b>types</b> and concurrency constraints to be defined using the same technique, which is the well known algebraic metho...|$|R
50|$|In {{computer}} science, a semaphore is {{a variable}} or <b>abstract</b> <b>data</b> <b>type</b> {{used to control}} access to a common resource by multiple processes in a concurrent system such as a multiprogramming operating system.|$|E
5000|$|This {{differs from}} the queue <b>abstract</b> <b>data</b> <b>type</b> or First-In-First-Out List (FIFO), where {{elements}} can only be added to one end and removed from the other. This general data class has some possible sub-types: ...|$|E
50|$|A CO-OPN {{specification}} {{consists of}} a collection of two different modules: the <b>abstract</b> <b>data</b> <b>type</b> modules and the object modules. The <b>abstract</b> <b>data</b> <b>type</b> modules concern the data structure component of the specifications, and many sorted algebraic specifications are used when describing these modules. Furthermore, the object modules represent the concept of encapsulated entities that possess an internal state and provide the exterior with various services. For this second sort of modules, an algebraic net formalism has been adopted. Algebraic Petri nets, a kind of high level nets, are a great improvement over the Petri nets, i.e. Petri nets tokens are replaced with data structures which are described by means of algebraic abstract data types. For managing visibility, both <b>abstract</b> <b>data</b> <b>type</b> modules and object modules are composed of an interface (which allows some operations to be visible from the outside) and a body (which mainly encapsulates the operations properties and some operation which are used for building the model). In the case of the objects modules, the stateand the behavior of the objects remain concealed within the body section.|$|E
5000|$|... a {{systematic}} study of specification methods for <b>abstract</b> <b>data</b> <b>types</b> starting in 1979, with John V. Tucker; ...|$|R
50|$|Lists also {{form the}} basis for other <b>abstract</b> <b>data</b> <b>types</b> {{including}} the queue, the stack, and their variations.|$|R
5000|$|In {{computer}} science, Nereus is {{also the}} name of a formal language designed to define <b>abstract</b> <b>data</b> <b>types.</b>|$|R
50|$|Adapting <b>abstract</b> <b>data</b> <b>type</b> design {{methods to}} {{object-oriented}} programming {{results in a}} data-driven design. This type of design is sometimes used in object-oriented programming to define classes during the conception {{of a piece of}} software.|$|E
5000|$|In {{computer}} science, an associative array, map, symbol table, or dictionary is an <b>abstract</b> <b>data</b> <b>type</b> {{composed of}} a collection of (key, value) pairs, such that each possible key appears at most once in the collection.|$|E
50|$|In {{computer}} science, a pile is an <b>abstract</b> <b>data</b> <b>type</b> {{for storing}} data in a loosely ordered way. There are two different usages of the term; one refers to an ordered deque, the other to an improved heap.|$|E
40|$|Abstract. This paper {{introduces}} {{the concept of}} normal forms for algebraic specifications of Ada packages defining <b>abstract</b> <b>data</b> <b>types.</b> The normal form {{is used in the}} process of reusable software component retrieval via formal specifications. We review the use of algebras for the specification of <b>abstract</b> <b>data</b> <b>types.</b> Then, using a concrete example, we define normal forms and present the details of algorithms to automate the normalization process. ...|$|R
40|$|This {{research}} {{describes the}} use of <b>abstract</b> <b>data</b> <b>types</b> as a design and implementation tool for data base management systems. <b>Abstract</b> <b>data</b> <b>types,</b> represented by generic objects and generic procedures, are used to implement a network data base management system. Generic objects are used to represent the data model, instantiations of the objects to represent the user's schema and subschema, and generic procedures to implement the data manipulation language verbs. Traditional database management system design approaches are described in which run-time interpretation of the schema and subschema is employed to preserve data independence. Application of <b>abstract</b> <b>data</b> <b>types</b> {{to the design of}} a data base management system permits the elimination of the time-consuming run-time interpretation without suffering any loss of data independence. Data abstractions which represent the logical structure of the database are bound at compile-time to the user's program. The data manipulation language verbs included in the user's source program are implemented as parameterized calls to the procedures bound to those <b>abstract</b> <b>data</b> <b>types</b> which are used to represent the logical structure of the database...|$|R
5000|$|... <b>abstract</b> <b>data</b> <b>types</b> (which have existential types) {{allow the}} {{definition}} of modules but these do not support dynamic dispatch ...|$|R
