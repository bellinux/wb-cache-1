0|468|Public
5000|$|Hash#dig and Array#dig {{to easily}} extract deeply nested values (e.g. given , the <b>value</b> <b>Foo</b> Baz {{can now be}} {{retrieved}} by [...] ).|$|R
5000|$|Local, global, {{and stored}} <b>array</b> <b>values</b> {{can be set}} using the , , and [...] commands, and they behave just like the {{corresponding}} variables. When a stored <b>array</b> <b>value</b> is set, the entire array is saved.|$|R
3000|$|... lowest {{correlation}} has {{a center}} 0 and off-peak <b>array</b> <b>values</b> of ± (p– 4 (i- 1)). At correlation level i[*]=[*](p[*]+[*] 5)/ 4, the off-peak <b>array</b> <b>values</b> all become − 1. At this point, the cross-correlation reaches the same value as the autocorrelation {{and the two}} spatial domain arrays must be identical, up to a change of sign.|$|R
5000|$|These are <b>array</b> <b>valued</b> for <b>array</b> {{arguments}} (elemental), {{like all}} FORTRAN 77 functions (except LEN): ...|$|R
30|$|The key {{concept is}} that {{discrete}} projection preserves correlation properties. The discrete central slice theorem [7, 8] {{proves that the}} 1 D discrete projection of any 2 D autocorrelation array {{is the same as}} the 1 D autocorrelation of the same 1 D projected view of the original 2 D array. Autocorrelation of discrete projections, and by analogy, cross-correlation, follows definition (1), where role of <b>array</b> <b>values</b> is replaced by the projected sums of <b>array</b> <b>values.</b>|$|R
50|$|An <b>array</b> <b>value</b> (or list) is {{specified}} by listing its elements, separated by commas, enclosed by parentheses (at least where required by operator precedence).|$|R
3000|$|The second lowest {{cross-correlation}} array has {{a center}} 0 and off-peak <b>array</b> <b>values</b> of ± (p− 4), because {{two pairs of}} projections from each array have their signs toggled. The third lowest correlation <b>array</b> has off-peak <b>values</b> of ± (p- 8), the fourth ± (p- 12). The i [...]...|$|R
5000|$|Each {{dimension}} of an <b>array</b> <b>value</b> in Analytica is identified by an Index variable. When slicing or subscripting, the syntax identifies the dimension(s) over {{which you are}} slicing or subscripting by naming the dimension. Such as: ...|$|R
3000|$|The code {{is changed}} {{so that the}} last <b>array</b> <b>value</b> is not {{randomly}} generated, but is the value that makes the sum to be equals to zero. The tests are run and now all pass successfully; [...]...|$|R
50|$|Instead {{of a list}} or {{array of}} object references, {{pointing}} to data values scattered throughout memory, Project Valhalla enhancements will enable list or <b>array</b> <b>values</b> to potentially be laid out linearly—without indirection—as a consecutive block of memory.|$|R
50|$|When data {{objects are}} stored in an array, {{individual}} objects are selected by an index that is usually a non-negative scalar integer. Indexes are also called subscripts. An index maps the <b>array</b> <b>value</b> to a stored object.|$|R
50|$|Perl {{has three}} typedefs that handle Perl's three main data types: Scalar <b>Value</b> (SV), <b>Array</b> <b>Value</b> (AV), Hash Value (HV). Perl uses a special typedef {{for the simple}} signed integer type (IV), {{unsigned}} integers (UV), floating point numbers (NV) and strings (PV).|$|R
50|$|When a {{data set}} may be updated dynamically, {{it may be}} stored in a Fenwick tree data {{structure}}. This structure allows both the lookup of any individual prefix sum value and the modification of any <b>array</b> <b>value</b> in logarithmic time per operation.|$|R
50|$|The diamond-square {{algorithm}} {{begins with}} a 2D square array of width and height 2n + 1. The four corner points of the array must firstly be set to initial values.The diamond and square steps are then performed alternately until all <b>array</b> <b>values</b> have been set.|$|R
5000|$|... {{function}} memoized-call (F is {{a function}} object parameter) if F has no attached <b>array</b> <b>values</b> then allocate an associative array called values; attach values to F; end if; [...] if F.valuesarguments is empty then F.valuesarguments = F(arguments); end if; [...] return F.valuesarguments; [...] end function ...|$|R
5000|$|Vector - A {{variant of}} array {{supported}} only when publishing for Flash Player 10 or above. Vectors are typed, dense <b>Arrays</b> (<b>values</b> must be defined or null) {{which may be}} fixed-length, and are bounds-checked during retrieval. Vectors are not just more typesafe than Arrays but also perform faster.|$|R
5000|$|... yields lines lazily, {{with the}} newline. It has to then be copied with [...] {{to obtain a}} string {{to be used for}} the {{associative}} <b>array</b> <b>values</b> (the [...] property of arrays returns an immutable duplicate of the array, which is required since the [...] type is actually [...] ). Built-in associative arrays require immutable keys.|$|R
50|$|Another {{variant of}} bucket sort known as {{histogram}} sort or counting sort adds an initial pass that counts {{the number of}} elements that will fall into each bucket using a count array. Using this information, the <b>array</b> <b>values</b> can be arranged into a sequence of buckets in-place by a sequence of exchanges, leaving no space overhead for bucket storage.|$|R
50|$|Most nodes handle {{data in a}} {{one-dimensional}} <b>array</b> of <b>values,</b> called Spreads. In {{addition to}} traditional vector algebra this allows programming of particle systems, as also rendering nodes and deal with <b>arrays</b> of <b>values</b> accordingly. If an operation {{has to deal with}} arrays of different lengths, the shorter array gets repeated to fill up the larger.|$|R
5000|$|... An Object or <b>Array</b> of <b>values</b> to {{be passed}} as {{parameters}} to the defined method.|$|R
5000|$|Below is a {{triangular}} <b>array</b> of <b>values</b> for the Stirling {{numbers of the}} second kind : ...|$|R
40|$|A {{variety of}} concepts, laws, and notations are {{presented}} which facilitate reasoning about arrays. The basic concepts include intervals and their partitions, functional restriction, images, pointwise extension of relations, ordering, single-point variation of functions, various equivalence relations for <b>array</b> <b>values,</b> and concatenation. The {{effectiveness of these}} ideas is illustrated by informal descriptions of algorithms for binary search and merging, and by a short formal proof...|$|R
40|$|Motivation: Gene {{expression}} microarray {{data sets}} often contain missing expression values. Robust missing value estimation methods are needed since many algorithms for {{gene expression analysis}} require a complete matrix of gene <b>array</b> <b>values.</b> In this paper, imputation methods based on the least squares and cluster structure are proposed to estimate missing values in the gene expression data, which exploits local and cluster structures in the data...|$|R
5000|$|... {{function}} construct-memoized-functor (F is {{a function}} object parameter) allocate a function object called memoized-version; [...] let memoized-version(arguments) be if self has no attached <b>array</b> <b>values</b> then is a reference to this allocate an associative array called values; attach values to self; end if; [...] if self.valuesarguments is empty then self.valuesarguments = F(arguments); end if; [...] return self.valuesarguments; [...] end let; [...] return memoized-version; end function ...|$|R
50|$|Special <b>Array</b> <b>Value</b> is padlist {{which is}} an array of array. Its 0th element to an AV {{containing}} all lexical variable names (with prefix symbols) used within that subroutine. The padlist's first element points to a scratchpad AV, whose elements contain the values corresponding to the lexical variables named in the 0th row. Another elements of padlist are created when the subroutine recurses or new thread is created.|$|R
40|$|Symbolic {{analysis}} is an enabling technique that improves {{the effectiveness of}} compiler optimizations, by detecting numeric properties of program variables or relationships between the variables, and by exposing such properties to compiler optimizations. Expressing the abstract values of program variables {{in terms of value}} ranges and analyzing expressions using the ranges {{are one of the most}} advanced symbolic analysis techniques to date. Previous work on this symbolic analysis has not fully explore its possibility in terms of coverage and utilization. This thesis aims at investigating possible advances in this symbolic analysis by providing two techniques, interprocedural symbolic range propagation and <b>array</b> <b>value</b> propagation. The two techniques were developed based on the symbolic analysis engine which utilizes the value ranges of variables. Interprocedural symbolic range propagation enables whole-program analysis for propagating scalar <b>value</b> ranges, and <b>array</b> <b>value</b> propagation uncovers <b>value</b> properties of <b>array</b> variables. The evaluation result shows that the two techniques increase the effectiveness of automatic parallelization and provide better compile-time knowledge so that the compiler improve the code quality using the knowledge. ...|$|R
25|$|Block swap: {{exchange}} {{a range of}} <b>values</b> within an <b>array</b> with <b>values</b> in a different range of the array.|$|R
30|$|The {{fraction}} of the initial population is selected with a probability and then mutations are performed on them. Used mutation alters one <b>array</b> <b>value</b> in a chromosome from its initial state. A number between 1 and M + P is selected. Then, mutation operator of the source (Mahdavi et al. 2009) {{is used for the}} mutation. After mutation, the feasibility of constraints (8) and (9) are evaluated. The procedure continues, if it is true, otherwise, the made change returns.|$|R
50|$|The inside-out shuffle {{can be seen}} to {{be correct}} by induction. Assuming a perfect random number generator, every one of the n! {{different}} sequences of random numbers that could be obtained from the calls of random will produce a different permutation of the values, so all of these are obtained exactly once. The condition that checks if j ≠ i may be omitted in languages that have no problems accessing uninitialized <b>array</b> <b>values,</b> and for which assigning is cheaper than comparing.|$|R
5000|$|... in {{computer}} science, an array type is a data type that {{is meant to}} describe a collection of elements (values or variables), each selected {{by one or more}} indices (identifying keys) that can be computed at run time by the program. Such a collection is usually called an <b>array</b> variable, <b>array</b> <b>value,</b> or simply <b>array.</b> [...] By analogy with the mathematical concepts of vector and matrix, array types with one and two indices are often called vector type and matrix type, respectively.|$|R
500|$|Microsoft's [...]NET Framework 2.0 offers static generic {{versions}} of the binary search algorithm in its collection base classes. An example would be System.Array's method BinarySearch(T <b>array,</b> T <b>value).</b>|$|R
40|$|Tuberculous pleuritis (TP) is {{characterized}} by predominant Th 1 immune response. We observed significantly high levels of interferon γ (IFN-γ) and chemokines such as IP- 10, monokine induced by IFN-γ (MIG), interleukin 8 (IL- 8), monocyte chemotactic protein (MCP) - 1, and macrophage inflammatory protein (MIP) - 1 α in tuberculous pleural effusions. In the current study, we evaluated the diagnostic utility of IFN-γ–dependent chemokine especially IP- 10. The receiver operating characteristics (ROC) curve analyses based on cytometric bead <b>array</b> <b>values</b> depicted high sensitivity only for IP- 10 (76. 3...|$|R
5000|$|... {{function}} construct-memoized-functor (F is {{a function}} object parameter) allocate a function object called memoized-version; [...] let memoized-version(arguments) be if self has no attached <b>array</b> <b>values</b> then is a reference to this allocate an associative array called values; attach values to self; allocate a new function object called alias; attach alias to self; later ability to invoke F indirectly self.alias = F; end if; [...] if self.valuesarguments is empty then self.valuesarguments = self.alias(arguments); a direct call to F end if; [...] return self.valuesarguments; [...] end let; [...] return memoized-version; end function ...|$|R
5000|$|ALL True if all {{values are}} true ANY True if any value is true. Example: IF (ANY( [...] a > b)) THEN COUNT Number of true {{elements}} in <b>array</b> MAXVAL Maximum <b>value</b> in an <b>array</b> MINVAL Minimum <b>value</b> in an <b>array</b> PRODUCT Product of array elements SUM Sum of array elements ...|$|R
30|$|We {{know that}} there are some {{arithmetic}} operations that have higher parentheses (executed *, / before +,-) more than the other operations. We has 4 -operations/steps for 4 -equation all should solve in correct order. The student answer (1, 4, 5, 3) is correct 100 %. But to be more specific, some students reach the final correct solution by summarize the number of steps/operations required. We take in consideration this point, so the first row in the evaluation matrix contains the detailed (standard) correct values (1, 4, 5, 3) as a vector of <b>array</b> <b>values,</b> in other problems we may have two or more operations/steps that should be solved with the same parentheses. So we represent all the possible sets of solution for each step in its corresponding order. The 2 nd row contains a number of correct elements less than the 1 st one i.e. student’s solution values are (4, 5, 3) or (1, 5, 3) represent a vector of <b>array</b> <b>values.</b> On the other hand we represent these possible items in the evaluation matrix as ({ 1, 4 }, 5, 3). Both arrays are combined together. So as we move down along the evaluation matrix the number of generated correct values expected to be in each row is less than the number of values that exist in the previous one. The last row has the final correct solution.|$|R
5000|$|Given an <b>array</b> of <b>values</b> to be sorted, {{set up an}} {{auxiliary}} array of initially empty [...] "pigeonholes," [...] one pigeonhole for each key through {{the range of the}} original array.|$|R
