79|1057|Public
25|$|The Incremental Algorithm(IA) by Dale and Reiter was {{the most}} {{influential}} algorithm before 2000. It {{is based on the}} idea of a preferential order of attributes or properties that speakers go by. So in order to run the Incremental Algorithm, first a preference order of attributes has to be given. Now the algorithm follows that order and adds those properties to the description which rule out any remaining distractors. Furthermore, Dale and Reiter stress the <b>attribute</b> <b>type</b> which is always included in their descriptions even if it does not rule out any distractors.|$|E
5000|$|This is {{the case}} for the {{standard}} attributes, or for the preferred NTFS [...] "filename" [...] <b>attribute</b> <b>type,</b> or the [...] "short filename" [...] <b>attribute</b> <b>type,</b> when it is also present (for compatibility with DOS-like applications, see below). It is also possible for a file to contain only a short filename, in which case it will be the preferred one, as listed in the Windows Explorer.|$|E
5000|$|Within X.500 and LDAP schemas and protocols, OIDs uniquely name each <b>attribute</b> <b>type</b> {{and object}} class, and other {{elements}} of schema.|$|E
5000|$|Some <b>attribute</b> <b>types</b> are {{required}} {{and must be}} present in each MFT record, except unused records that are just indicated by null <b>attribute</b> <b>types.</b>|$|R
40|$|RFC 2253 [2] standardises {{a set of}} strings {{that can}} be used to {{represent}} <b>attribute</b> <b>types</b> in LDAP distinguished names. This list is does not cover the full set of <b>attribute</b> <b>types</b> used in the distinguished names of issuers and subjects in public key certificates. This document standardises the strings needed for these additional <b>attribute</b> <b>types.</b> ...|$|R
5000|$|... typesOnly : Return <b>attribute</b> <b>types</b> only, not <b>attribute</b> values.|$|R
5000|$|An {{attribute}} {{has a name}} (an <b>attribute</b> <b>type</b> or attribute description) and one or more values. The attributes {{are defined}} in a schema (see below).|$|E
5000|$|For each file in the MFT, the {{attributes}} identified by <b>attribute</b> <b>type,</b> attribute name must be unique. Additionally, NTFS has some ordering constraints for these attributes.|$|E
50|$|Based on {{an array}} algebra {{specifically}} developed for database purposes, rasdaman adds a new <b>attribute</b> <b>type,</b> array, to the relational model. As this array definition is parametrized it constitutes a second-order construct or template); {{this fact is}} reflected by the second-order functionals in the algebra and query language.|$|E
5000|$|Here {{are some}} <b>attribute</b> <b>types</b> {{supported}} by both SGML and XML: ...|$|R
5000|$|Some <b>attribute</b> <b>types</b> cannot have a {{name and}} must remain anonymous.|$|R
5000|$|Matching Rule Uses—Indicate which <b>attribute</b> <b>types</b> {{may be used}} in {{conjunction}} with a particular matching rule.|$|R
5000|$|Attribute declarations, which define {{properties}} of attributes. Again the properties include the attribute name and target namespace. The <b>attribute</b> <b>type</b> constrains {{the values that}} the attribute may take. An attribute declaration may also include a default value or a fixed value (which is then the only value the attribute may take.) ...|$|E
5000|$|There is a {{predefined}} null <b>attribute</b> <b>type,</b> used {{to indicate}} {{the end of the}} list of attributes in one MFT record. It must be present as the last attribute in the record (all other storage space available after it will be ignored and just consists of padding bytes to match the record size in the MFT).|$|E
50|$|Each {{attribute}} has an <b>attribute</b> <b>type</b> (a fixed-size integer mapping to {{an attribute}} definition in file $AttrDef), an optional attribute name (for example, {{used as the}} name for an alternate data stream), and a value, represented in a sequence of bytes. For NTFS, the standard data of files, the alternate data streams, or the index data for directories are stored as attributes.|$|E
5000|$|PKCS #9. RSA {{standard}} that governs selected <b>attribute</b> <b>types,</b> including those used with PKCS #7, PKCS #8, and PKCS #10.|$|R
40|$|Visualizations of {{tabular data}} are widely used; {{understanding}} their effectiveness in different task and data contexts {{is fundamental to}} scaling their impact. However, {{little is known about}} how basic tabular data visualizations perform across varying data analysis tasks and data <b>attribute</b> <b>types.</b> In this paper, we report results from a crowdsourced experiment {{to evaluate the effectiveness of}} five visualization types [...] - Table, Line Chart, Bar Chart, Scatterplot, and Pie Chart [...] - across ten common data analysis tasks and three data <b>attribute</b> <b>types</b> using two real world datasets. We found the effectiveness of these visualization types significantly varies across task and data <b>attribute</b> <b>types,</b> suggesting that visualization design would benefit from considering context dependent effectiveness. Based on our findings, we derive recommendations on which visualizations to choose based on different task and data contexts...|$|R
50|$|Some <b>attribute</b> <b>types</b> {{function}} differently {{when used}} to modify different element types. For example, the attribute name {{is used by}} several element types, but has slightly different functions in each.|$|R
50|$|In {{the same}} style as {{standard}} database systems do on sets, Array DBMSs offer scalable, flexible storage and flexible retrieval/manipulation on arrays of (conceptually) unlimited size. As in practice arrays never appear standalone, such an array model normally is embedded into some overall data model, {{such as the}} relational model.Some systems implement arrays as an analogy to tables, some introduce arrays as an additional <b>attribute</b> <b>type.</b>|$|E
5000|$|An ER {{model is}} {{typically}} implemented as a database. In a simple relational database implementation, each row {{of a table}} represents one instance of an entity type, and each field in a table represents an <b>attribute</b> <b>type.</b> In a relational database a relationship between entities is implemented by storing the primary key of one entity as a pointer or [...] "foreign key" [...] in the table of another entity ...|$|E
50|$|The {{relational}} data model, which is prevailing today, {{does not directly}} support the array paradigm {{to the same extent}} as sets and tuples. ISO SQL lists an array-valued <b>attribute</b> <b>type,</b> but this is only one-dimensional, with almost no operational support, and not usable for the application domains of Array DBMSs. Another option is to resort to BLOBs ("binary large objects") which are the equivalent to files: byte strings of (conceptually) unlimited length, but again without any query language functionality, such as multi-dimensional subsetting.|$|E
50|$|In {{addition}} to basic identity attribute values like strings and numbers, the data entity {{referred to by}} an r-card can have complex attribute values consisting of aggregates of basic <b>attribute</b> <b>types</b> as well as UDI links to other entities.|$|R
50|$|In {{addition}} to these advances in the file format, HDF5 includes an improved type system, and dataspace objects which represent selections over dataset regions. The API is also object-oriented with respect to datasets, groups, <b>attributes,</b> <b>types,</b> dataspaces and property lists.|$|R
40|$|AbstractIn {{this paper}} we give an {{overview}} of formal concepts for model transformations between visual languages based on <b>typed</b> <b>attributed</b> graph transformation. We start with a basic concept where visual languages are defined by <b>attributed</b> <b>type</b> graphs only and model transformations by basic <b>typed</b> <b>attributed</b> graph transformation systems. We continue with different kinds of extensions of the basic concepts taking into account application conditions, constraints, generating graph grammars and operational semantics. The main aim is to discuss formal correctness criteria for model transformations including syntactical correctness, functional behavior and semantical correctness...|$|R
50|$|The Incremental Algorithm(IA) by Dale and Reiter was {{the most}} {{influential}} algorithm before 2000. It {{is based on the}} idea of a preferential order of attributes or properties that speakers go by. So in order to run the Incremental Algorithm, first a preference order of attributes has to be given. Now the algorithm follows that order and adds those properties to the description which rule out any remaining distractors. Furthermore, Dale and Reiter stress the <b>attribute</b> <b>type</b> which is always included in their descriptions even if it does not rule out any distractors.|$|E
50|$|The rasdaman query language, rasql, embeds {{itself into}} {{standard}} SQL and its set-oriented processing.On the new <b>attribute</b> <b>type,</b> multi-dimensional arrays, {{a set of}} extra operations is provided which {{all are based on}} a minimal set of algebraically defined core operators, an array constructor (which establishes a new array and fills it with values) and an array condenser (which, similarly to SQL aggregates, derives scalar summary information from an array). The query language is declarative (and, hence, optimizable) and safe in evaluation - that is: every query is guaranteed to return after a finite number of processing steps.|$|E
50|$|Athena realizes true rapid {{application}} development by allowing developers to implement changes easily and quickly. Let's say, {{we need to change}} Person.fullName's type from CHAR(100) to NVARCHAR(256). For those who use traditional ORM frameworks, they need to manually change database table's column type and to update XML or Java annotation mapping configuration, and updates the UI validation code. Such steps are time-consuming and error prone. Athena comes to rescue: you only need to change the <b>attribute</b> <b>type</b> and save it on the user friendly Athena Metadata Workbench. Athena automatically update the database schema and generate updated source code. Developers' productivity gets significant boost by Athena.|$|E
40|$|Abstract:- In {{this article}} we present how to {{implement}} fuzzy databases based on the relational model. This approach includes many fuzzy <b>attribute</b> <b>types,</b> which can express the most of fuzzy knowledge <b>types.</b> These fuzzy <b>attribute</b> <b>types</b> include imprecise <b>attributes,</b> fuzzy attributes associated {{to one or more}} attributes or with an independent meaning. In order to represent such fuzzy information we must study two aspects of fuzzy information: how to represent fuzzy data and how to represent fuzzy metaknowledge data. This second information is very important and it must be considered in any fuzzy database. This article study the fuzzy metaknowledge data for any fuzzy attribute and how to represent both in a relational database...|$|R
30|$|Extended profile data: OSNs offer {{a variety}} of {{predefined}} <b>attribute</b> <b>types</b> that may be used to further describe particular aspects of one’s personality. Note that extended profile data solely refers to the user’s profile while other parts of an OSN account are covered by further data types. Consequently, properties of extended profile data are the following: profile-centricity, optionality, predefined <b>attribute</b> <b>types</b> with clear semantics, and in some cases predefined attribute values. Typically, the process of providing extended profile data (activity 7 in Figure 3) is guided by a form that contains input fields for <b>attribute</b> <b>types,</b> like address, education, favorite music, favorite films, hobbies, and interests. The profile picture, which is a common feature of OSNs, is also arranged in this category. According to Figure 2, this is in line with the conceptualizations presented by Schneier [23] and Årnes et al. [29], while the profiles’ category presented by Beye et al. [28] is considered too coarse-grained. From the optionality of this data type, it follows that privacy risks are manageable as it is down to the user to decide whether to disclose a particular personal attribute. On closer examination, available privacy settings are to be considered as these define the granularity of the potential audience that may access an attribute.|$|R
5000|$|Attributes are {{additional}} values {{associated with each}} document {{that can be used}} to perform additional filtering and sorting during search. Attributes are named. Attribute names are case insensitive. Attributes are not full-text indexed; they are stored in the index as is. Currently supported <b>attribute</b> <b>types</b> are: ...|$|R
50|$|The {{concept of}} type {{enforcement}} (TE) {{in the field}} of information technology is related to access control. Implementing TE gives priority to “mandatory access control” (MAC) over “discretionary access control” (DAC). Access clearance is first given to a subject (e.g. process) accessing objects (e.g. files, records, messages) based on rules defined in an attached security context. A security context in a domain is defined by a domain security policy. In the Linux security module (LSM) in SELinux, the security context is an extended <b>attribute.</b> <b>Type</b> enforcement implementation is a prerequisite for MAC, and a first step before “multi-level security” (MLS) or its replacement “multi categories security” (MCS). It is a complement of “role based access control” (RBAC).|$|E
50|$|In {{terms of}} Array DBMS {{implementation}}s, the rasdaman system has the longest implementation {{track record of}} n-D arrays with full query support. Oracle GeoRaster offers chunked storage of 2-D raster maps, albeit without SQL integration. TerraLib is an open-source GIS software that extends object-relational DBMS technology to handle spatio-temporal data types; while main focus is on vector data, {{there is also some}} support for rasters. Starting with version 2.0, PostGIS embeds raster support for 2-D rasters; a special function offers declarative raster query functionality. SciQL is an array query language being added to the MonetDB DBMS. SciDB is a more recent initiative to establish array database support. Like SciQL, arrays are seen as an equivalent to tables, rather than a new <b>attribute</b> <b>type</b> as in rasdaman and PostGIS.|$|E
5000|$|The example above shows a {{notation}} named [...] "type-image-svg" [...] that references {{the standard}} public FPI {{and the system}} identifier (the standard URI) of an SVG 1.1 document, instead of specifying just a system identifier as in the first example (which was a relative URI interpreted locally as a MIME type). This annotation is referenced directly within the unparsed [...] "type" [...] attribute of the [...] "img" [...] element, but its content is not retrieved. It also declares another notation for a vendor-specific application, to annotate the [...] "sgml" [...] root element in the document. In both cases, the declared notation named is used directly in a declared [...] "type" [...] attribute, whose content is specified in the DTD with the [...] "NOTATION" [...] <b>attribute</b> <b>type</b> (this [...] "type" [...] attribute is declared for the [...] "sgml" [...] element, {{as well as for}} the [...] "img" [...] element).|$|E
40|$|Overview of Data Contains 3 {{tables in}} SQL format: **Table 1 (apache_datasources) :** List of Apache Data sources <b>Attributes</b> (Name, <b>Type)</b> : `datasource_id` Integer `item_description` Character `date_posted` Date `date_collected` Date `method` Character `item_url` Character `last_updated` Date **Table 2 (apache_people_projects) :** List of people {{committing}} various projects <b>Attributes</b> (Name, <b>Type)</b> : `svn_id` Character `real_name` Character `web_site` Character `datasource_id` Integer `project_name` Character `role_on_project` Character `details` Character `email` Character `organization` Character `last_updated` Date **Table 3 (apache_unlisted_cla) :** List {{of people with}} signed CLAs but are not committers <b>Attributes</b> (Name, <b>Type)</b> : `real_name` Character `datasource_id` Integer `last_updated` Dat...|$|R
40|$|Almost {{no object}} {{oriented}} programming languages offer distinct language constructs for the definition of types and their implementations; instead these are united into a single class concept. Similarly {{object oriented programming}} languages do not normally distinguish between object types, which may be independently instantiated, and <b>attribute</b> <b>types,</b> which may not. The pape...|$|R
30|$|Corrective action (CA): {{gives the}} student the {{opportunity}} {{to understand how to}} correct the error for this specific problem. For the error in Fig.  2, the CA prompt is asking the student to specify the best way to model the Isbn attribute and giving the different <b>attribute</b> <b>types</b> as options. Not all dialogues have this prompt type.|$|R
