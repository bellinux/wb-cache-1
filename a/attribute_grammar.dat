316|532|Public
5000|$|S-attributed grammar: {{a simple}} type of <b>attribute</b> <b>grammar,</b> using only {{synthesized}} attributes, but no inherited attributes ...|$|E
5000|$|<b>Attribute</b> <b>grammar,</b> a {{formalism}} {{that can}} be used for aspect-oriented programming on top of functional programming languages ...|$|E
5000|$|... “A Family of Pass-Oriented <b>Attribute</b> <b>Grammar</b> Evaluators”, with M. Jazayeri, Proceedings of the ACM 1978 Annual Conference, pp. 261-270, December 1978.|$|E
40|$|<b>Attributed</b> <b>grammars</b> {{can be used}} {{to specify}} both the syntax and the {{semantics}} of programming languages, and provide an implementation for compilers. We discuss extensions to <b>attributed</b> <b>grammars</b> and a generalization of attribute evaluation that allow code optimization techniques to be efficiently implemented and easily specified. A formal definition of the extended <b>attributed</b> <b>grammars,</b> called time-varying <b>attributed</b> <b>grammars,</b> is given. Time-varying <b>attributed</b> <b>grammars</b> provide a high-level, non-procedural specification of iterative algorithms. Evaluators for time-varying <b>attributed</b> <b>grammars</b> are described and potential problems that can result from the use are discussed. Examples of common code optimization techniques are given using time-varying <b>attributed</b> <b>grammars.</b> Techniques that reduce the overhead of evaluation, and also simplify the specifications of <b>attributed</b> <b>grammars</b> are suggested...|$|R
40|$|We {{identify}} {{a new class}} of non-circular <b>attribute</b> <b>grammars,</b> called the multi-plan <b>attribute</b> <b>grammars,</b> for which static evaluation plans can be computed. The class of multi-plan <b>attribute</b> <b>grammars</b> is larger than all currently known classes of non-circular <b>attribute</b> <b>grammars</b> with static evaluation plans. The decision procedure and the procedure for computing evaluation plans take essentially polynomial time under a new, more practical criterion (but the procedures still take exponential time based on the traditional criterion). The multi-plan <b>attribute</b> <b>grammars</b> lead to a new way to classify welldefined <b>attribute</b> <b>grammars</b> into a hierarchy based on the look-ahead behavior of the evaluators. Our work confirms a result of Riis and Skyum, which says that all well-defined <b>attribute</b> <b>grammars</b> can be evaluated with static evaluators. 1. Introduction Since its introduction in 1968 [9], <b>attribute</b> <b>grammars</b> have attracted much research interest. <b>Attribute</b> <b>grammars</b> are a very convenient and powerful [...] ...|$|R
40|$|The {{translational}} {{mechanism of}} <b>attribute</b> <b>grammars</b> using tree automata are investigated. The pushdown tree-to-string transducer {{with a certain}} synchronization facility as a model to realize transformations by <b>attribute</b> <b>grammars</b> is proposed and its basic properties using tree-walking finite state automata are studied. To demonstrate the utility of this model, it is shown that noncircular <b>attribute</b> <b>grammars</b> are equally powerful as arbitrary <b>attribute</b> <b>grammars,</b> and {{a method is provided}} to show that a certain type of transformations is impossible by <b>attribute</b> <b>grammars...</b>|$|R
5000|$|... “Space-Efficient Storage Management in an <b>Attribute</b> <b>Grammar</b> Evaluator”, with M. Jazayeri, ACM Transactions on Programming Languages and Systems volume 3 issue 4, pp. 388-404, October 1981.|$|E
50|$|Advanced Content {{includes}} an XML element grammar based on HTML for content such as images, buttons, text, etc.; An XML <b>attribute</b> <b>grammar</b> based on CSS and XSL to describe layout, color, font types, etc.; and an element and <b>attribute</b> <b>grammar</b> based on SMIL for timing, animation, eventing, and synchronization. Whilst {{it is possible}} to write complex, interactive pages using only the declarative XML dialect, any interactions with the player itself (e.g., to change audio language or jump to a new title) requires imperative code written in ECMAScript.|$|E
50|$|An <b>attribute</b> <b>grammar</b> is {{a formal}} way to define {{attributes}} for the productions {{of a formal}} grammar, associating these attributes with values. The evaluation occurs in the nodes of the abstract syntax tree, when the language is processed by some parser or compiler.|$|E
40|$|Abstract. This {{research}} abstract {{describes the}} research {{plan for a}} Ph. D project. We plan to define a powerful and elegant embedding of modern extensions to <b>attribute</b> <b>grammars.</b> <b>Attribute</b> <b>grammars</b> are a suitable formalism to express complex, multiple traversal algorithms. In recent {{years there has been}} a lot of work in <b>attribute</b> <b>grammars,</b> namely by defining new extensions to the formalism (forwarding and reference <b>attribute</b> <b>grammars,</b> etc), by proposing new attribute evaluation models (lazy and circular evaluators, etc) and by embedding <b>attribute</b> <b>grammars</b> (like first class <b>attribute</b> <b>grammars).</b> We will study how to design such extensions through a zipper-based embedding and we will study efficient evaluation models for this embedding. Finally, we will express several <b>attribute</b> <b>grammars</b> in our setting and we will analyse the performance of our implementation. ...|$|R
40|$|Two {{mappings}} from <b>attribute</b> <b>grammars</b> to lazy functional {{programs are}} defined. One of these mappings is an efficient implementation of <b>attribute</b> <b>grammars.</b> The other mapping yields inefficient programs. It is shown how some transformations of functional programs {{may be better}} understood by viewing the programs as inefficient implementations of <b>attribute</b> <b>grammars...</b>|$|R
40|$|A constraint-based {{graphics}} {{system provides}} a flexible, intuitive framework for describing relationships among graphical objects in {{applications such as}} document preparation, font design, and solid modelling. This paper describes two constraint-based graphics systems, micro-COSM and the IDEAL Synthesizer, and their implementation in terms of <b>attribute</b> <b>grammars.</b> The implementation of these two systems is noteworthy since they represent the first interactive constraint-based graphics systems that are implemented using <b>attribute</b> <b>grammars.</b> Our experiences with <b>attribute</b> <b>grammars</b> suggest that they provide a powerful framework for representing constraints and extracting important semantic information such as the equations to be solved by the constraint solver. We discuss the advantages of using <b>attribute</b> <b>grammars</b> in constraint-based graphics and from our experiences make several observations about the way <b>attribute</b> <b>grammars</b> should be used...|$|R
50|$|Compiler-compilers {{exist in}} many flavors, {{including}} bottom-up rewrite machine generators (see JBurg) used to tile syntax trees {{according to a}} rewrite grammar for code generation, and <b>attribute</b> <b>grammar</b> parser generators (e.g. ANTLR {{can be used for}} simultaneous type checking, constant propagation, and more during the parsing stage).|$|E
50|$|DMS {{provides}} <b>attribute</b> <b>grammar</b> evaluators for computing custom analyses over ASTs, such as metrics, {{and including}} special support for symbol table construction. Other program facts can be extracted by built-in control- and data- flow analysis engines, {{local and global}} pointer analysis, whole-program call graph extraction, and symbolic range analysis by abstract interpretation.|$|E
5000|$|The {{following}} <b>attribute</b> <b>grammar</b> {{can be used}} {{to calculate}} the result of an expression written in the grammar. Note that this grammar only uses synthesized values, and is therefore an S-attributed grammar. Expr1 &rarr; Expr2 + Term Expr1.value Expr &rarr; Term Expr.value Term1 &rarr; Term2 * Factor Term1.value Term &rarr; Factor Term.value Factor &rarr; [...] "(" [...] Expr [...] ")" [...] Factor.value Factor &rarr; integer Factor.value ...|$|E
40|$|Projet CHARMEAlthough <b>Attribute</b> <b>Grammars</b> were {{introduced}} thirty years ago, {{their lack of}} expressiveness has resulted in limited use outside the domain of static language processing. In this paper we show {{that it is possible}} to extend this expressiveness. We claim that <b>Attribute</b> <b>Grammars</b> can be used to describe computations on structures that are not just trees, but also on abstractions allowing for infinite structures. To gain this expressiveness, we introduce two new notions: scheme productions and conditional productions. The result is a language that is comparable in power to most first-order functional languages, with a distinctive declarative character. Our extensions deal with a different part of the <b>Attribute</b> <b>Grammars</b> formalism than what is used in most works on <b>Attribute</b> <b>Grammars</b> including global analysis and evaluator generation. Hence, most existing results are directly applicable to our extended <b>Attribute</b> <b>Grammars</b> including efficient implementation (in our case, using the FNC- 2 system [URL] The major contribution of this approach is to restore and re-emphasize the intrinsic power of <b>Attribute</b> <b>Grammars.</b> Furthermore, our extensions call for new studies on applying to functional programming the analysis and implementation techniques developed for <b>Attribute</b> <b>Grammars...</b>|$|R
40|$|The {{objective}} of this thesis is to explore the connections between abstract interpretation and <b>attribute</b> <b>grammars</b> as frameworks in program analysis. Abstract interpretation is a semantics-based program analysis method. A large class of data flow analysis problems can be expressed as non-standard semantics where the “meaning” contains information about the runtime behaviour of programs. In an abstract interpretation the analysis is proved correct by relating it to the usual semantics for the language. <b>Attribute</b> <b>grammars</b> provide a method and notation to specify code generation and program analysis directly from the syntax of the programming language. They are especially used for describing compilation of programming languages and very efficient evaluators {{have been developed for}} subclasses of <b>attribute</b> <b>grammars.</b> By relating abstract interpretation and <b>attribute</b> <b>grammars</b> we obtain a closer connection between the specification and implementation of abstract interpretations which at the same time facilitates the correctness proofs of interpretations. Implementation and specification of abstract interpretations using circular <b>attribute</b> <b>grammars</b> is realised with an evaluator system for a class of domain theoretic <b>attribute</b> <b>grammars.</b> In this system thecircularity of <b>attribute</b> <b>grammars</b> is resolved by fixpoint iteration. The use of finite lattices in abstract interpretations requires automatic generation of specialised fixpoint iterators. This is done using a technique called lazy fixpoint iteration which is presented in the thesis. Methods from abstract interpretation can also be used in correctness proofs of <b>attribute</b> <b>grammars.</b> This proof technique introduces a new class of <b>attribute</b> <b>grammars</b> based on domain theory. This method is illustrated with examples...|$|R
5000|$|<b>Attribute</b> <b>grammars</b> define {{systems that}} {{systematically}} compute [...] "metadata" [...] (called attributes) {{for the various}} cases of the language's syntax. <b>Attribute</b> <b>grammars</b> {{can be understood as}} a denotational semantics where the target language is simply the original language enriched with attribute annotations. Aside from formal semantics, <b>attribute</b> <b>grammars</b> have also been used for code generation in compilers, and to augment regular or context-free grammars with context-sensitive conditions; ...|$|R
5000|$|Some syntax-directed editors monitor {{compliance}} with the context-sensitive constraints of a language such as type correctness. Such static-semantic constraints may be specified imperatively by actions (e.g., as in Gandalf), or declaratively by an <b>attribute</b> <b>grammar</b> (e.g., as in the Synthesizer Generator) or by unification in a many-sorted algebra (e.g., as in PSG [...] ) or a logic program (e.g., as in Centaur and Pan), with compliance checked by the underlying editing machinery. Structured editors vary in {{the degree to which}} they allow their users to perform edits that cause the document to become syntactically or semantically incorrect.|$|E
40|$|AbstractAn <b>{{attribute}}</b> <b>grammar</b> {{is simple}} multi-visit if each attribute of a nonterminal has a fixed visit-number {{associated with it}} such that, during attribute evaluation, the attributes of a node which have visit-number j are computed at the jth visit to the node. An <b>attribute</b> <b>grammar</b> is l-ordered if for each nonterminal a linear order of its attributes exists such that the attributes of a node can always be evaluated in that order (cf. the work of Kastens). An <b>attribute</b> <b>grammar</b> is simple multi-visit {{if and only if}} it is l-ordered. Every noncircular <b>attribute</b> <b>grammar</b> can be transformed into an equivalent simple multi-visit <b>attribute</b> <b>grammar</b> which uses the same semantic operations. For a given distribution of visit-numbers over the attributes, it can be decided in polynomial time whether the attributes can be evaluated according to these visit-numbers. The problem whether an <b>attribute</b> <b>grammar</b> is simple multi-visit is NP-complete...|$|E
40|$|This paper {{presents}} {{techniques for}} the formal specification and efficient incremental implementation of spreadsheet-like tools. The spreadsheets are specified by strong attribute grammars. In {{this style of}} <b>attribute</b> <b>grammar</b> programming every single inductive computation is expressed within the <b>attribute</b> <b>grammar</b> formalism. Well-known <b>attribute</b> <b>grammar</b> techniques are used to reason about such grammars. For example, ordered scheduling algorithms {{can be used to}} statically guarantee termination of the attribute grammars and to derive efficient implementations. A strong <b>attribute</b> <b>grammar</b> for a spreadsheet is defined and the first incremental results are presented...|$|E
40|$|Forwarding is a {{technique}} for providing default attribute definitions in <b>attribute</b> <b>grammars</b> that is helpful in the modular implementation of programming languages. This paper introduces forwarding, and shows how it is but a small extension of standard higher-order <b>attribute</b> <b>grammars.</b> The usual tools for manipulating higher-order <b>attribute</b> <b>grammars,</b> including the circularity check (which tests for cyclic dependencies between attribute values), carries over without modification. The closure test (which checks that each attribute has a defining equation) needs modification, however, because the resulting higher-order <b>attribute</b> <b>grammars</b> may contain spurious attributes that are never evaluated, and indeed that need not be defined...|$|R
40|$|<b>Attribute</b> <b>grammars</b> are a {{formalism}} for specifying computations on syntax trees. SSCC (a Sufficiently Smart Compiler Compiler) is {{a practical}} attribute-grammar system based on a polynomial-time extension to Kastens's ordered <b>attribute</b> <b>grammars.</b> The new class of <b>attribute</b> <b>grammars</b> is strictly larger than the class of ordered <b>attribute</b> <b>grammars</b> and it retains the property {{that there is a}} polynomial-time procedure for finding an evaluation order. The SSCC system comprises of two subsystems. The generation subsystem computes the evaluation order of attribute occurrences in production rules and translates attribute equations into low-level code for a virtual stack machine. The evaluation subsystem invokes tools to perform lexical and syntactic analyses and evaluates the attribute instances during a traversal of the syntax tree. Three features make SSCC capable of performing any desired computation (within the constraints of ordered <b>attribute</b> <b>grammars)</b> : user-defined data types, user-defined [...] ...|$|R
40|$|<b>Attribute</b> <b>grammars</b> are well-designed to {{construct}} complex algorithms by composing several ones together. Actually, {{there exists a}} powerful transformation called descriptional composition which highly simplifies the composition of two <b>attribute</b> <b>grammars</b> by removing useless intermediate constructions. However, most of non-linear algorithms can not be expressed with <b>attribute</b> <b>grammars.</b> Thus, many compositions can not be simplified by the descriptional composition. In this paper, we present Equational Semantics, a formalism largely inspired by <b>attribute</b> <b>grammars</b> but where nonlinear algorithms can be encoded. More precisely, instead of being restricted to one input static tree {{as it is the}} case for <b>attribute</b> <b>grammars,</b> an algorithm encoded with Equational Semantics may use dynamically constructed trees. This formalism consists in an very poor abstract syntax. We present its semantics and some of its transformations such as partial evaluation and descriptional composition (also called defores [...] ...|$|R
40|$|The {{language}} {{design process}} should {{be supported by}} modularity and abstraction {{in a manner that}} allows incremental changes as easily as possible. To at least partially fullfil this ambitious goal a new object-oriented <b>attribute</b> <b>grammar</b> specication language which supports multiple <b>attribute</b> <b>grammar</b> inheritance is introduced. Multiple <b>attribute</b> <b>grammar</b> inheritance is a structural organization of attribute grammars where the <b>attribute</b> <b>grammar</b> inherits the specifications from ancestor attribute grammars, may add new specifications or may override some specifications from ancestor specifications. With the proposed approach a language designer has the chance to design incrementally a language or reuse some fragments from other programming language specifications. The multiple <b>attribute</b> <b>grammar</b> inheritance is first introduced using an example, and thereafter by a formal model. The proposed approach is successfully implemented in the compiler/interpreter generator tool LISA ver. 2. 0...|$|E
40|$|Although {{attribute}} grammars {{have been}} applied successfully to the specification of many different phases of analysis and transformation of complex language processing systems, including type checking, data flow analysis, constant propagation and dead code elimination, little success has been achieved in applying attribute grammars to the specification of complete systems such as multiple pass code optimizers or automatic parallelizers. This is {{the direct result of}} the failure of typical <b>attribute</b> <b>grammar</b> dialects to provide any means for composing <b>attribute</b> <b>grammar</b> specifications of subcomputations to create a specification of a complete hierarchical computation. This dissertation introduces the notion of hierarchical attribute grammars, a set of <b>attribute</b> <b>grammar</b> dialects that are suitably expressive to permit the natural description of complex computations through the composition of <b>attribute</b> <b>grammar</b> specified sub-computations {{within the context of the}} original <b>attribute</b> <b>grammar</b> formalism. The set of hierarchical dialects includes Schulz's attributed transformations, the Attribute Coupled Grammars of Ganzinger and Giegerich, SSL, the specification language of the Synthesizer Generator of Reps and Teitelbaum, the Higher Order Attribute Grammars of Vogt, Swierstra and Kuiper, and a new dialect Modular Attribute Grammars. The relationships between these five dialects are examined, and examples of Modular <b>Attribute</b> <b>Grammar</b> specifications are presented. For hierarchical <b>attribute</b> <b>grammar</b> dialects to be useful, efficient batch and incremental evaluators for hierarchical dialects must be developed. Therefore, the majority of this dissertation is dedicated to the presentation of new batch and incremental evaluation algorithms for hierarchical specifications...|$|E
40|$|An <b>attribute</b> <b>grammar</b> AG {{generates the}} {{language}} consisting of all strings {{that have a}} legal parse tree in AG. Because of the predicates, a parse tree of the original context-free grammar {{may no longer be}} a legal parse tree of the <b>attribute</b> <b>grammar,</b> and thus the language generated by an <b>attribute</b> <b>grammar</b> is in general a subset of the corresponding context-free language. It is clear that any context-free language can be generated by an <b>attribute</b> <b>grammar</b> with trivial attributes, functions, and predicates, but the converse is not valid. It is easy to construct simple attribute grammars that accept languages that are not context-free. Two questions are investigated: what exactly is the expressive power of attribute grammar; and which superset of the context-free languages do they exactly define...|$|E
40|$|Recent {{research}} in programming environments {{has focused on}} the generation of software tools from specifications. Several specification mechanisms have been proposed, and the most successful of these has been <b>attribute</b> <b>grammars.</b> <b>Attribute</b> <b>grammars</b> have been successfully applied to compile-time tools such as type checkers and code generators, which perform static analysis of the program, but have hitherto seemed unsuited to the description of run-time tools such as interpreters and debuggers that involve dynamic interaction with the user of the programming environment. This report describes an extension to <b>attribute</b> <b>grammars</b> that solves this problem. The extended <b>attribute</b> <b>grammars</b> are suitable for the specification of all semantics processing performed by single-user programming environments...|$|R
40|$|Abstract. Forwarding is a {{technique}} for providing default attribute definitions in <b>attribute</b> <b>grammars</b> that is helpful in the modular implementation of programming languages. It complements existing techniques such as default copy rules. This paper introduces forwarding, and shows how it is but a small extension of standard higher-order <b>attribute</b> <b>grammars.</b> The usual tools for manipulating higher-order <b>attribute</b> <b>grammars,</b> including the circularity check (which tests for cyclic dependencies between attribute values), carry over without modification. The closure test (which checks that each attribute has a defining equation) needs modification, however, because the resulting higher-order <b>attribute</b> <b>grammars</b> may contain spurious attributes that are never evaluated, and indeed that need not be defined. ...|$|R
40|$|<b>Attribute</b> <b>grammars</b> {{are useful}} in {{integrated}} editing environments for obtaining automatic incremental compilation features. However, traditional <b>attribute</b> <b>grammars</b> use aggregated values during name resolution, resulting in large sets of affected attribute instances after edits. In this paper, we show how reference <b>attribute</b> <b>grammars</b> (RAGs) can significantly {{reduce the number of}} affected attributes. We also introduce a notion of cache independent attributes used to limit propagation after edits. Our results indicate that RAGs are a highly viable alternative for use in editing environments...|$|R
40|$|This {{work was}} also {{published}} as a Rice University thesis/dissertation: [URL] attribute grammars {{have been applied}} successfully to the specification of many different phases of analysis and transformation of complex language processing systems, including type checking, data flow analysis, constant propagation and dead code elimination, little success has been achieved in applying attribute grammars to the specification of complete systems such as multiple pass code optimizers or automatic parallelizers. This is {{the direct result of}} the failure of typical <b>attribute</b> <b>grammar</b> dialects to provide any means for composing <b>attribute</b> <b>grammar</b> specifications of sub-computations to create a specification of a complete hierarchical computation. This dissertation introduces the notion of hierarchical attribute grammars, a set of <b>attribute</b> <b>grammar</b> dialects that are suitably expressive to permit the natural description of complex computations through the composition of <b>attribute</b> <b>grammar</b> specified sub-computations {{within the context of the}} original <b>attribute</b> <b>grammar</b> formalism. The set of hierarchical dialects includes Schulz's attributed transformations, the Attribute Coupled Grammars of Ganzinger and Giegerich, SSL, the specification language of the Synthesizer Generator of Reps and Teitelbaum, the Higher Order Attribute Grammars of Vogt, Swierstra and Kuiper, and a new dialect Modular Attribute Grammars. The relationships between these five dialects are examined, and examples of Modular <b>Attribute</b> <b>Grammar</b> specifications are presented. For hierarchical <b>attribute</b> <b>grammar</b> dialects to be useful, efficient batch and incremental evaluators for hierarchical dialects must be developed. Therefore, the majority of this dissertation is dedicated to the presentation of new batch and incremental evaluation algorithms for hierarchical specifications...|$|E
40|$|This paper relates our {{experience}} implementing a production compiler from an <b>attribute</b> <b>grammar.</b> The compiler is Intel Corporation's Pascal- 80 compiler. It runs on a microcomputer-based development system without virtual memory. An <b>attribute</b> <b>grammar</b> was written describing semantic analysis, storage allocation, and translation to intermediate code. Attribute evaluation {{is done in}} two alternating passes and the program tree is kept in intermediate files on disk. The first version of the compiler was manually implemented from the <b>attribute</b> <b>grammar.</b> Using what was learned from this experience, an automatic attribute evaluator-generator was then written and a new version or the compiler was mechanically created from the <b>attribute</b> <b>grammar.</b> Various techniques for optimizing the evaluator were tried. Their degree or success is reported and they are compared with other ideas from the literature. Complex attribute-values, such as sets, sequences and finite functions, were carefully implemented using applicative data structure in order to conserve memory. The <b>attribute</b> <b>grammar</b> was designed using the principles or data abstraction and information-hiding. The internal organization or many types or attributes is completely hidden from the <b>attribute</b> <b>grammar</b> author and the attribute evaluator. These values are manipulated only by specific out-of-line semantic functions that {{can be viewed as}} the operators or an abstract data type for this attribute. This also contributed to an efficient use of memory...|$|E
40|$|Abstract. We {{describe}} how the standard genotype-phenotype mapping process of Grammatical Evolution (GE) {{can be enhanced}} with an <b>attribute</b> <b>grammar</b> to allow GE to operate as a decoder-based Evolutionary Algorithm (EA). Use of an <b>attribute</b> <b>grammar</b> allows GE to maintain context-sensitive and semantic information pertinent to the capacity constraints of the 01 Multiconstrained Knapsack Problem (MKP). An <b>attribute</b> <b>grammar</b> specification is used to perform decoding similar to a first-fit heuristic. The results presented are encouraging, demonstrating that GE in conjunction with attribute grammars can provide an improvement over the standard context-free mapping process for problems in this domain. ...|$|E
40|$|Corp oration Abstract. Forwar ding is a tec hnique for pro viding default {{attribute}} definitions in <b>attribute</b> <b>grammars</b> that is helpful in the mo dular implementation of programming languages. It complemen ts existing tec hniques suc h as default cop y rules. This pap er in tro duces forw arding, and sho ws ho w it {{is but a}} small extension of standard higher-order <b>attribute</b> <b>grammars.</b> The usual to ols for manipulating higher-order <b>attribute</b> <b>grammars,</b> including the circularit y che...|$|R
40|$|AbstractThis paper {{shows that}} logic {{programs}} and <b>attribute</b> <b>grammars</b> are closely related. Constructions are fiven which transform logic programs into semantically equivalent <b>attribute</b> <b>grammars,</b> and vice versa. This opens for application in logic programming of some methods developed for <b>attribute</b> <b>grammars.</b> These results {{are used to}} find a sufficient condition under which no infinite term can be created during a computation of a logic program, and to define a nontrivial class of logic programs which can be run without employing unification in its general form...|$|R
40|$|Abstract. Reference <b>attributed</b> <b>grammars</b> (RAGs) extend Knuth’s <b>attribute</b> <b>grammars</b> with {{references}}. These references {{can be used}} {{to extend}} the abstract syntax tree to a graph. We investigate how RAGs can be used for implementing tools for visual languages. Programs in those languages can often be expressed as graphs. ...|$|R
