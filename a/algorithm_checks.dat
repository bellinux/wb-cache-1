147|2566|Public
500|$|For example, to find {{a number}} in a sorted list, the binary search <b>algorithm</b> <b>checks</b> the middle entry and {{proceeds}} with the half {{before or after the}} middle entry if the number is still not found. This algorithm requires, on average, [...] comparisons, where N is the list's length. Similarly, the merge sort algorithm sorts an unsorted list by dividing the list into halves and sorting these first before merging the results. Merge sort algorithms typically require a time approximately proportional to [...] The base of the logarithm is not specified here, because the result only changes by a constant factor when another base is used. A constant factor is usually disregarded in the analysis of algorithms under the standard uniform cost model.|$|E
500|$|Each {{iteration}} of {{the binary}} search procedure defined above makes {{one or two}} comparisons, checking if the middle element {{is equal to the}} target in each iteration. Again assuming that each element is equally likely to be searched, each iteration makes 1.5 comparisons on average. A variation of the <b>algorithm</b> <b>checks</b> whether the middle element is equal to the target {{at the end of the}} search, eliminating on average half a comparison from each iteration. This slightly cuts the time taken per iteration on most computers, while guaranteeing that the search takes the maximum number of iterations, on average adding one iteration to the search. Because the comparison loop is performed only [...] times in the worst case, the slight increase in comparison loop efficiency does not compensate for the extra iteration for all but enormous [...] [...] gives a value of [...] (more than 73 quintillion) for n = 0..1000]. Part of OEIS [...] Retrieved 30 April 2016. elements for this variation to be faster.|$|E
5000|$|A brute-force {{substring}} search <b>algorithm</b> <b>checks</b> all possible positions: ...|$|E
40|$|Abstract. Binding of Duty (BOD) {{constraints}} define {{that the}} same subject (or role) who performed a certain task t 1 must also perform a corresponding bound task t 2. In this paper, we describe <b>algorithms</b> for <b>checking</b> the satisfiability of binding constraints in a business process context. In particular, these <b>algorithms</b> <b>check</b> the configuration of a process-related RBAC model to find satisfiability conflicts. Furthermore, we discuss options to resolve satisfiability conflicts. Key words: access control, binding of duty, business processes...|$|R
50|$|Haken {{sketched out}} a proof of an <b>algorithm</b> to <b>check</b> if two Haken {{manifolds}} were homeomorphic or not. His outline was filled in by substantive efforts by Waldhausen, Johannson, Hemion, Matveev, et al. Since {{there is an}} <b>algorithm</b> to <b>check</b> if a 3-manifold is Haken (cf. Jaco-Oertel), the basic problem of recognition of 3-manifolds can {{be considered to be}} solved for Haken manifolds.|$|R
40|$|Abstract: Using an {{algebraic}} analysis approach, we derive {{a necessary}} and sufficient condition {{so that we}} can parametrize all solutions of a multidimensional linear system by glueing the controllable sub-behaviour with the autonomous elements. Effective <b>algorithms</b> <b>checking</b> this condition are obtained. This result generalizes a result of 1 -D linear systems for a class of multidimensional linear systems. Copyright c ○ 2005 IFA...|$|R
50|$|If x is false, the <b>algorithm</b> <b>checks</b> {{the value}} of z and returns it.|$|E
5000|$|Verification - This <b>algorithm</b> <b>checks</b> for the {{authenticity}} of the message by verifying it along with the signature and public key.|$|E
5000|$|Thus this <b>algorithm</b> <b>checks</b> 17 {{points for}} each macro-block and the {{worst-case}} scenario involves checking 33 locations, which is still much faster than TSS ...|$|E
5000|$|... an <b>algorithm</b> to <b>check</b> {{that the}} {{derivatives}} are correct {{with respect to}} finite difference approximations; ...|$|R
5000|$|... #Subtitle level 2: Fast <b>algorithm</b> to <b>check</b> if a {{positive}} number {{is a power}} of two ...|$|R
40|$|A general {{framework}} for collision detection is presented. Then, {{we look at}} each stage and compare different approaches by extensive benchmarks. The result suggest a way to optimize {{the performance of the}} overall framework. A benchmarking procedure for comparing <b>algorithms</b> <b>checking</b> a pair of objects is presented and applied to three different hierarchical algorithms. A new convex algorithm is evaluated and compared with other approaches to the neighbor-finding problem...|$|R
5000|$|A safe jump can {{be found}} by simply evaluating, for every value , the {{shortest}} prefix of [...] inconsistent with [...] In other words, if [...] is a possible value for , the <b>algorithm</b> <b>checks</b> {{the consistency of the}} following evaluations: ...|$|E
50|$|This {{function}} is not evasive, {{because there is}} a decision tree that solves it by checking exactly two variables: The algorithm first checks the value of x. If x is true, the <b>algorithm</b> <b>checks</b> the value of y and returns it.|$|E
5000|$|We will exhibit {{an adversary}} that {{produces}} a worst-case input [...] - [...] for every leaf that the <b>algorithm</b> <b>checks,</b> the adversary will answer 0 if the leaf's parent is an Or node, and 1 if the parent is an And node.|$|E
40|$|We {{provide an}} O˜(n^ 2) time {{randomized}} <b>algorithm</b> to <b>check</b> whether a given operation f:S×S→S is associative (letting n=|S|). They prove this performance is optimal (up to polylogarithmic factors) even {{in case the}} operation is “cancellative”. No sub-n^ 3 algorithm was previously known for this task. More generally they give an O(n^c) time randomized <b>algorithm</b> to <b>check</b> whether a collection of c-ary operations satisfy any given “read-once” identity...|$|R
50|$|Hsiang (1985) gave a {{rule-based}} <b>algorithm</b> to <b>check</b> whether two arbitrary expressions {{denote the}} same value in every Boolean ring.|$|R
5000|$|In practice, the <b>algorithm</b> can <b>check</b> the {{evaluations}} above {{at the same}} time it is checking the consistency of [...]|$|R
50|$|An {{application}} {{that uses a}} Happy Eyeballs <b>algorithm</b> <b>checks</b> both IPv4 and IPv6 connectivity (with a preference for IPv6) and uses the first connection that is returned. The addresses are often chosen from the DNS with a round-robin algorithm. Implementations of Happy Eyeballs stacks exist in Google's Chrome web browser, Opera 12.10, Firefox version 13, OS X, and cURL.|$|E
50|$|Separation logic {{supports}} the developing {{field of research}} described by Peter O'Hearn and others as local reasoning, whereby specifications and proofs of a program component mention only the portion of memory used by the component, and not the entire global state of the system. Applications include automated program verification (where an <b>algorithm</b> <b>checks</b> the validity of another algorithm) and automated parallelization of software.|$|E
50|$|The {{remaining}} sub-graph (g) {{produced by}} the algorithm is not disconnected since the <b>algorithm</b> <b>checks</b> for that in line 7. the result sub-graph cannot contain a cycle since if it does then when moving along the edges we would encounter the max edge in the cycle and we would delete that edge.thus g must be a spanning tree of the main graph G.|$|E
40|$|International audienceWe {{define a}} multi-dimensional {{geometric}} extension of cutwidth. A graph has d-cutwidth at most k {{if it can}} be embedded in the d-dimensional euclidean space so that no hyperplane can intersect more than k of its edges. We prove a series of combinatorial results on d-cutwidth which imply that for every d and k, there is a linear time <b>algorithm</b> <b>checking</b> whether the d-cutwidth of a graph G is at most k...|$|R
40|$|We discuss an {{experimental}} approach to open problems in toric geometry: are smooth projective toric varieties (i) projectively normal and (ii) defined by degree 2 equations? We discuss {{the creation of}} lattice polytopes defining smooth toric varieties as well as <b>algorithms</b> <b>checking</b> properties (i) and (ii) and further potential properties, in Particular a weaker version of (ii) asking for scheme-theoretic definition in degree 2. Comment: Funal version with small corrections and updated reference...|$|R
3000|$|... [...]. Further we use ∆ as a {{matching}} <b>algorithm</b> for <b>checking</b> correctness of the biometric data, and the function δ [...]...|$|R
5000|$|PP also {{contains}} NP. To prove this, {{we show that}} the NP-complete satisfiability problem belongs to PP. Consider a probabilistic algorithm that, given a formula F(x1, x2, ..., xn) chooses an assignment x1, x2, ..., xn uniformly at random. Then, the <b>algorithm</b> <b>checks</b> if the assignment makes the formula F true. If yes, it outputs YES. Otherwise, it outputs YES with probability 1/2 and NO with probability 1/2.|$|E
5000|$|In {{the second}} step, the <b>algorithm</b> <b>checks</b> which {{elements}} of the entire dataset {{are consistent with the}} model instantiated by the estimated model parameters obtained from the first step. A data element will be considered as an outlier if it does not fit the fitting model instantiated by the set of estimated model parameters within some error threshold that defines the maximum deviation attributable to the effect of noise.|$|E
5000|$|The {{idea behind}} the {{algorithm}} is that given a candidate key and a functional dependency ,the reverse application of the functional dependency yieldsthe set [...] ,which is a key, too.It may however be covered by other already known candidate keys.(The <b>algorithm</b> <b>checks</b> this case using the 'found' variable.)If not, then minimizing the new key yields a new candidate key.The key insight is that all candidate keys can be created this way.|$|E
5000|$|This input (0 for all Or nodes' children, and 1 for all And nodes' children) {{forces the}} <b>algorithm</b> to <b>check</b> all nodes: ...|$|R
40|$|Abstract. In {{this work}} we {{consider}} modeling of workflow systems with Petri nets. The problem of replacing some resources by others retaining the correct {{functioning of the}} system is studied. The relation of resource s-equivalence is defined. Some properties of this relation are studied. It is proved that s-equivalence is decidable provided the set of all minimal sound resources for a given control state is computable. For structured WF-nets with resources an <b>algorithm</b> <b>checking</b> S-equivalence is presented. ...|$|R
40|$|In {{this paper}} we study about x-geodominating set, {{geodetic}} set, geo-set, geo-number of a graph G. We study the binary operation, link vectors and some required results to develop algorithms. First we design two <b>algorithms</b> to <b>check</b> whether given set is an x-geodominating set {{and to find}} the minimum x-geodominating set of a graph. Finally we present another two <b>algorithms</b> to <b>check</b> whether a given vertex is geo-vertex or not and to find the geo-number of a graph...|$|R
5000|$|For example, the PreDeCon <b>algorithm</b> <b>checks</b> which {{attributes}} seem {{to support}} a clustering for each point, and adjusts the distance function such that dimensions with low variance are amplified in the distance function. In the figure above, the cluster [...] might be found using DBSCAN with a distance function that places less emphasis on the -axis and thus exaggerates the low difference in the -axis sufficiently enough to group the points into a cluster.|$|E
50|$|The {{backtracking}} algorithm traverses {{this search}} tree recursively, from the root down, in depth-first order. At each node c, the <b>algorithm</b> <b>checks</b> whether c {{can be completed}} to a valid solution. If it cannot, the whole sub-tree rooted at c is skipped (pruned). Otherwise, the algorithm (1) checks whether c itself is a valid solution, and if so reports it to the user; and (2) recursively enumerates all sub-trees of c. The two tests {{and the children of}} each node are defined by user-given procedures.|$|E
5000|$|The <b>algorithm</b> <b>checks</b> {{whether there}} could be any points {{on the other side}} of the {{splitting}} plane that are closer to the search point than the current best. In concept, this is done by intersecting the splitting hyperplane with a hypersphere around the search point that has a radius equal to the current nearest distance. Since the hyperplanes are all axis-aligned this is implemented as a simple comparison to see whether the distance between the splitting coordinate of the search point and current node is lesser than the distance (overall coordinates) from the search point to the current best.|$|E
30|$|The major {{difference}} from K-M algorithm {{is that in}} the table construction phase, the proposed <b>algorithm</b> will <b>check</b> the two capacity constrains accordingly.|$|R
40|$|International audienceThe {{notion of}} {{convexity}} translates non-trivially from Euclidean geometry to discrete geometry, and detecting if a discrete {{region of the}} plane is convex requires analysis. In this paper we study digital convexity from the combinatorics on words point of view, and provide a fast optimal <b>algorithm</b> <b>checking</b> digital convexity of polyominoes coded by the contour word. The result {{is based on the}} Lyndon factorization of the contour word, and the recognition of Christoffel factors that are approximations of digital lines...|$|R
5000|$|For every such {{tree with}} n leaves, the running {{time in the}} worst case is n (meaning that the <b>algorithm</b> must <b>check</b> all the leaves): ...|$|R
