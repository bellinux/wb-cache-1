0|5386|Public
40|$|Flosolver is a {{parallel}} computer {{built at the}} National 13; Aeronautical Laboratory (NAL), Bangalore. 16 Processor 13; Flosolver system at NAL has four nodes each having four 13; processors of Intel 80386 / 80387. Nodes are connected using 13; parallel interface. Many <b>application</b> <b>codes</b> including <b>Panel</b> 13; <b>code,</b> Monsoon code, Transonic flow calculation etc. are 13; operational on this syste...|$|R
40|$|<b>Panel</b> <b>codes</b> {{are used}} by the Maritime Reseach Institute Natherlands (MARIN) to compute flows around ships and propellers. These codes are based on Boundary Element Methods (BEM). A known {{drawback}} of BEM is that it forms dense linear system of equations {{that have to be}} solved. By improving the efficiency of the dense linear solver, the computational time required by <b>panel</b> <b>codes</b> can be significantly reduced. Since <b>applications</b> of <b>panel</b> <b>codes</b> in MARIN include automatic optimization, where a large number of hull forms or propeller geometries have to be evaluated, the reduction of computational time is important. Four strategies were explored to improve the performance of the dense linear solver. First, to replace the current GMRES solver with IDR(s). Second, the updating of a fixed size block Jacobi preconditioner into a variable size block Jacobi preconditioner. Third, to use a hierarchical matrix-vector multiplication in the solver instead of dense matrix-vector multiplication. Lastly, to replace the block Jacobi preconditioner with a hierarchical-LU preconditioner. Out of the four strategies, the use of hierarchical-LU preconditioner was found to speed up the dense linear solver substantially, especially for large systems. The use of IDR(s) instead of GMRES is also recommended as it removes the problems introduced by the need to restart. This report discusses the theory, implementation and test results obtained from the four strategies aforementioned. As a result of this project, the use of IDR(s) combined with hierarchical-LU preconditioner is recommended to be implemented in the <b>panel</b> <b>codes.</b> Applied mathematicsElectrical Engineering, Mathematics and Computer Scienc...|$|R
50|$|Sample <b>application</b> <b>code.</b>|$|R
5000|$|Diverts to reroute traffic without modifying <b>application</b> <b>code</b> ...|$|R
5000|$|Automated <b>application</b> <b>code</b> {{production}} (Java, C#, C++, SQL, …) ...|$|R
5000|$|... #Subtitle level 3: Improving the {{modularity}} of <b>application</b> <b>code</b> ...|$|R
50|$|Below is a table {{indicating}} {{the most common}} <b>application</b> <b>codes.</b>|$|R
5000|$|<b>Application</b> <b>code</b> {{generators}} for persistent layer, programming interface, web services: ...|$|R
40|$|Traditionally {{worst case}} {{execution}} time (WCET) analysis tools {{are designed for}} the analysis of <b>application</b> <b>code.</b> The execution time of Real-Time Operating System (RTOS) services and the interaction between RTOS and application are usually not considered. When performing an RTOS aware schedulability analysis the WCETs of RTOS services are needed. At first sight the application of existing WCET analyzers on RTOS code should be straightforward and should deliver the same accuracy as for <b>application</b> <b>code.</b> The paper explains why this is not the case, and why the presence of an RTOS diminishes the accuracy of <b>application</b> <b>code</b> WCET analysis...|$|R
50|$|The {{conciseness}} of DASL {{can be seen}} also {{in terms}} of the content of the two representations (DASL vs. the generated <b>application</b> <b>code</b> in Java/XML/SQL etc.). Most of the DASL code describes business logic and business processes specific to the application, independent of the deployment middleware, frameworks, and presentation mechanisms. This core business logic typically represents only 2-5% of the generated <b>application</b> <b>code.</b> Thus, writing, understanding, and maintaining the <b>application</b> <b>code</b> is much easier at the DASL level than it is {{at the level of the}} generated code, in which the business logic is scattered within various implementation artifacts.|$|R
5000|$|A repository, {{allowing}} decision {{logic to}} be externalized from core <b>application</b> <b>code</b> ...|$|R
5000|$|They have <b>CODE</b> (<b>application</b> <b>code</b> segment) {{resources}} with resource IDs 0 and 1 ...|$|R
5000|$|Xpediter/TSO offers {{complete}} control of <b>application</b> <b>code</b> execution in the batch testing environment ...|$|R
40|$|In {{this paper}} we show a {{reconfigurable}} hardware archi-tecture for {{the acceleration of}} video-based driver assistance applications in future automotive systems. The concept {{is based on a}} separation of pixel-level operations and high level <b>application</b> <b>code.</b> Pixel-level operations are acceler-ated by coprocessors, whereas high level <b>application</b> <b>code</b> is implemented fully programmable on standard PowerPC CPU cores to allow flexibility for new algorithms. In addi-tion, the <b>application</b> <b>code</b> is able to dynamically reconfig-ure the coprocessors available on the system, allowing for a much larger set of hardware accelerated functionality than would normally fit onto a device. This process makes use of the partial dynamic reconfiguration capabilities of Xilinx Virtex FPGAs. ...|$|R
50|$|This {{solution}} provides {{protection of}} <b>application</b> <b>code</b> without binding to an optical disk or a computer. StarForce Crypto serves {{to counter the}} analysis of the <b>application</b> source <b>code.</b> Companies uses this solution to hide program algorithms from hackers.|$|R
50|$|Early <b>panel</b> <b>codes</b> were {{developed}} in the late 1960s to early 1970s. Advanced <b>panel</b> <b>codes,</b> such as Panair (developed by Boeing), were first introduced in the late 1970s, and gained popularity as computing speed increased. Over time, <b>panel</b> <b>codes</b> were replaced with higher order panel methods and subsequently CFD (Computational Fluid Dynamics). However, <b>panel</b> <b>codes</b> are still used for preliminary aerodynamic analysis as the time required for an analysis run is significantly less due to a decreased number of elements.|$|R
5000|$|... level 0 is {{the normal}} level for {{execution}} of non-interrupt <b>code,</b> including ordinary <b>application</b> <b>code.</b>|$|R
5000|$|Does not {{natively}} enforce {{referential integrity}} constraints, i.e. parent-child relations {{must be maintained}} by <b>application</b> <b>code.</b>|$|R
40|$|Because {{there is}} {{currently}} no formal way to specify user interfaces, nor a clean way to decouple a user interface from its <b>application</b> <b>code,</b> we propose in this position paper the use of Declarative Meta Programming (DMP) to solve these problems. DMP uses facts and rules to write down a user interface in a declarative way, and will provide a more formal way to specify user interfaces. Furthermore DMP cleanly separates user interface from <b>application</b> <b>code.</b> The Declarative Meta Programming language SOUL that we intend to use, combines the declarative paradigm (for the user interface specification) and the objectoriented paradigm (for the <b>application</b> <b>code).</b> This position paper thus describes a case in multiparadigm programming...|$|R
5000|$|In software, {{semantic}} technology encodes meanings {{separately from}} data and content files, and separately from <b>application</b> <b>code.</b>|$|R
50|$|Version 4.0 {{files are}} dated November 11, 2003. 4.0 runtime fully {{supports}} <b>applications</b> <b>coded</b> for 3.0 and 2.0.|$|R
5000|$|In Qt, QMainWindow::createPopupMenu is {{a factory}} method {{declared}} in {{a framework that}} can be overridden in <b>application</b> <b>code.</b>|$|R
40|$|Given a panel {{data set}} {{which has been}} tsset as such, xtpattern generates a string {{variable}} <b>coding</b> <b>panels</b> according to {{presence or absence of}} observation at different times. This variable contains information tabulated by xtdes. The number of observations in each panel must not exceed 80 (or under Stata/SE, 244). xt, panel data, longitudinal data, data management...|$|R
5000|$|... #Caption: 31018, at the National Railway Museum in York, on 3 June 2004. This was {{the first}} {{locomotive}} of the Class {{to be built in}} 1957. It was withdrawn from service in 1976. It currently carries BR Blue livery. Note the absence of over-window head <b>code</b> <b>panel,</b> which were only omitted from the first few locomotives.|$|R
40|$|Framework-specific models {{represent}} {{the design of}} <b>application</b> <b>code</b> from the framework viewpoint by showing how framework-provided concepts are implemented in the code. In this paper, we describe an experimental study of the static analyses necessary to automatically retrieve such models from <b>application</b> <b>code.</b> We reverse engineer a number of applications based on three open-source frameworks and evaluate {{the quality of the}} retrieved models. The models are expressed using framework-specific modeling languages (FSMLs), each designed for one of the open-source frameworks. For reverse engineering, we use prototype implementations of the three FSMLs. Our results show that for the considered frameworks rather simple code analyses are sufficient for automatically retrieving framework-specific models form a large body of <b>application</b> <b>code</b> with high precision and recall...|$|R
5000|$|A device {{independent}} architecture {{that allows the}} application to run on different devices without any change in <b>application</b> <b>code.</b>|$|R
50|$|Version 5.1 {{files are}} dated March 9, 2006. 5.1 runtime {{does not support}} <b>applications</b> <b>coded</b> for 4.0 or before.|$|R
5000|$|POSIX-subsystem allows port of <b>application</b> <b>code</b> from Unix/Linux — {{although}} {{important features}} of Phantom OS {{will not be}} available.|$|R
5000|$|Wireless {{upgrades}} of all SW (OS, HWP, Custom handler and <b>application</b> <b>code)</b> simultaneously for all {{devices in}} a network ...|$|R
40|$|The evolvability and {{adaptability}} are intrinsic {{properties of}} today’s software applications. Unfortunately, {{the urgency of}} evolving/adapting a system often drives the developer to directly modify the <b>application</b> <b>code</b> neglecting to update its design models and documentation. Even, most of the development environments support the code refactoring without supporting the automatic refactoring of the design information. Refactoring, evolution and in general every code changes should be reflected into the design models, so that these models consistently represent the application {{and can be used}} in the successive maintenance steps and for documenting the <b>application.</b> The <b>code</b> evolution should not evolve only the <b>application</b> <b>code</b> but also the application design models. Unfortunately, to co-evolve the <b>application</b> <b>code</b> and its design is an hard job to be carried out automatically, since there is a evident and notorious gap between these two representations. In this paper, we propose a new approach to code evolution (in particular code refactoring) that supports also the automatic coevolution of the corresponding design models. The approach relies on a set of predefined meta-data that the programmer should use to annotate the <b>application</b> <b>code</b> and to highlight the refactoring performed on the code. Then, through reflection, these meta-data are retrieved and used to automatically and consistently update the application design models...|$|R
40|$|Ever-increasing {{complexity}} of large-scale applications and continuous increases in sizes {{of the data}} they process make the problem of maximizing performance of such applications a very challenging task. In particular, many challenging applications from the domains of astrophysics, medicine, biology, computational chemistry, and materials science are extremely data intensive. Such applications typically use a disk system to store and later retrieve their large data sets, and consequently, their disk performance is a critical concern. Unfortunately, while disk density has significantly improved {{over the last couple}} of decades, disk access latencies have not. As a result, I/O is increasingly becoming a bottleneck for dataintensive applications, and has to be addressed at the software level if we want to extract the maximum performance from modern computer architectures. This paper presents a compiler-directed code restructuring scheme for improving the I/O performance of data-intensive scientific applications. The proposed approach improves I/O performance by reducing the number of disk accesses through a new concept called disk reuse maximization. In this context, disk reuse refers to reusing the data in a given set of disks as much as possible before moving to other disks. Our compiler-based approach restructures <b>application</b> <b>code,</b> with the help of a polyhedral tool, such that disk reuse is maximized to the extent allowed by intrinsic data dependencies in the <b>application</b> <b>code.</b> The proposed optimization can be applied to each loop nest individually or to the entire <b>application</b> <b>code.</b> The experiments show that the average I/O improvements brought by the loop nest based version of our approach are 9. 0 % and 2. 7 %, over the original <b>application</b> <b>codes</b> and the codes optimized using conventional schemes, respectively. Further, the average improvements obtained when our approach is applied to the entire <b>application</b> <b>code</b> are 15. 0 % and 13. 5 %, over the original <b>application</b> <b>codes</b> and the codes optimized usin...|$|R
50|$|In fluid dynamics, {{aerodynamic}} {{potential flow}} <b>codes</b> or <b>panel</b> <b>codes</b> {{are used to}} determine the fluid velocity, and subsequently the pressure distribution, on an object. This may be a simple two-dimensional object, such as a circle or wing, or it may be a three-dimensional vehicle.|$|R
5000|$|... #Caption: Adam de la Peña at the San Diego Comic Con's <b>Code</b> Monkeys <b>panel</b> ...|$|R
50|$|Redistributable {{components}} to allow developers to package the engines and runtime with their <b>application</b> <b>code</b> {{to produce a}} single installable application.|$|R
5000|$|Domain: {{a subset}} of nodes (identified by a tag) jobs must be run on (i.e. have a domain for <b>application</b> <b>code).</b>|$|R
40|$|A rapid PCR-enzyme-linked immunosorbent assay for {{identification}} of 10 important emm gene types of Streptococcus pyogenes was developed. The emm genotypes of a <b>coded</b> <b>panel</b> of strains of known M serotype were determined, and in 144 of 149 cases (97 %) {{the results were}} congruous. Strains of types that {{were not included in}} the panel of capture probes were emm genotyped by sequencing...|$|R
