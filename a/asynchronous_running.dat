6|19|Public
40|$|In power {{spectrum}} estimation, the signal under consideration is processed {{in such a}} way, that the distribution of power among its frequency is estimated and phase relations between the frequency components are suppressed. Higher order statistics and their associated Fourier transforms reveal not only amplitude information about a signal, but also phase information. If a non-Gaussian signal is received along with additive Gaussian noise, a transformation to higher order cumulant domain eliminates the noise. These are some methods for estimation of signal components, based on HOS. In the paper we apply the MUSIC method both for the correlation and the 4 th order cumulant, to investigate the state of <b>asynchronous</b> <b>running</b> of synchronous machines and the fault operation of inverter-fed induction motors. When the investigated signal is distorted by a coloured noise, more exact results {{can be achieved by}} applying cumulants...|$|E
40|$|Parallel genetic {{algorithms}} (PGA) use two major modifications {{compared to the}} genetic algorithm. Firstly, selection for mating is distributed. Individuals live in a 2 -D world. Selection of a mate is done by each individual independently in its neighborhood. Secondly, each individual may improve its fitness during its lifetime by e. g. local hill-climbing. The PGA is totally <b>asynchronous,</b> <b>running</b> with maximal efficiency on MIMD parallel computers. The search strategy of the PGA {{is based on a}} small number of intelligent and active individuals, whereas a GA uses a large population of passive individuals. We will show the power of the PGA with two combinatorial problems - the traveling salesman problem and the m graph partitioning problem. In these examples, the PGA has found solutions of very large problems, which are comparable or even better than any other solution found by other heuristics. A comparison between the PGA search strategy and iterated local hill-climbing is made. KEYWORDS [...] ...|$|E
40|$|During {{recent years}} higher order {{statistics}} (HOS) {{have found a}} wide applicability in many diverse fields, e. g. : biomedicine, harmonic retrieval and adaptive filtering. In power spectrum estimation, the signal under consideration is processed in such a way, that the distribution of power among its frequency is estimated and phase relations between the frequency components are suppressed. Higher order statistics and their associated Fourier transforms reveal not only amplitude information about a signal, but also phase information. If a non-Gaussian signal is received along with additive Gaussian noise, a transformation to higher order cumulant domain eliminates the noise. These are some methods for estimation of signal components, based on HOS. In the paper we apply the MUSIC method both for the correlation and the 4 th order cumulant, to investigate the state of <b>asynchronous</b> <b>running</b> of synchronous machines and the fault operation of inverter-fed induction motors. When the investigated signal is distorted by a coloured noise, more exact results {{can be achieved by}} applying cumulants...|$|E
5000|$|Long <b>running</b> <b>asynchronous</b> server tasks: {{client is}} {{notified}} when finished.|$|R
40|$|The software-intensive {{exploration}} {{systems of}} the future will be highly complex, and their operation will be exceptionally visible to the nation. In addition to providing complex functionality, they must tolerate the subtle faults of <b>asynchronous</b> systems <b>running</b> in a hostile environment and be affordable, reliable, flexible, robust, an...|$|R
40|$|Abstract. According to two {{three-phase}} <b>asynchronous</b> motors system <b>running</b> by connectionless-mode, {{and considering}} {{the system to}} be required to run in strict synchronous way under different load, the method of field-oriented vector control is used. Thus, the control loops of rotor flux, torque and rotor speed are constructed to make two-motor system run synchronously by torque distribution. The simulation results illustrate its effectiveness and good dynamic and static performance...|$|R
40|$|The {{parallel}} {{genetic algorithm}} (PGA) is {{a prototype of}} a new kind of a distributed algorithm. It is based on a parallel search by individuals all of which have the complete problem description. The information exchange between the individuals is done by simulating biological principles of evolution. The PGA is totally <b>asynchronous,</b> <b>running</b> with maximal efficiency on MIMD parallel computers. The search strategy of the PGA is based on a small number of intelligent and active individuals, whereas a GA uses a large population of passive individuals. We will show the power of the PGA with two combinatorial problems - the graph partitioning problem and the autocorrelation problem. In these examples, the PGA has found solutions of very large problems, which are comparable or even better than any other solution found by other heuristics. 1 Introduction Random search methods based on evolutionary principles have been already proposed in the 60 's. They did not have a major influence on mainstre [...] ...|$|E
40|$|This {{document}} summarises {{the basic}} {{requirements for the}} buffering, processing, monitoring {{and control of the}} data flowing from the detector front ends through all stages of the trigger. It covers the requirements in the following areas: The buffering and bandwidth required in subdetector frontend electronics {{to meet the demands of}} the Level 0 and Level 1 triggers. The preprocessing and multiplexing of detector data to provide digital, zerosuppressed data to the data acquisition system(DAQ). The bandwidth and buffering required for reading zero suppressed subdetector data into DAQ. Event building with error detection and recovery. The execution of the Level 2 and Level 3 trigger algorithms. The calibration, monitoring and storage of event data. Parallel and <b>asynchronous</b> <b>running</b> of different subdetector configurations using separate trigger sources. The working point of the data acquisition system will be a 40 kHz Level 1 trigger rate and an average event size of, 100 kByte, including an allowance for electronic noise, this giving an event building requirement of, 4 GB/s. The processing requirement for the Level 2 and Level 3 triggers corresponds to, 1400 1000 Mips processors. The principle criteria for the design and implementation of the system, which must develope with running conditions evolving over a long period of time, are also summarised. ...|$|E
40|$|The {{parallel}} {{genetic algorithm}} (PGA) uses two major modi cations {{compared to the}} genetic algorithm. Firstly, selection for mating is distributed. Individuals live ina 2 -Dworld. Selection of a mate is done by each individual independently in its neighborhood. Secondly, each individual may improve its tness during its lifetime by e. g. local hill-climbing. The PGA is totally <b>asynchronous,</b> <b>running</b> with maximal e ciency on MIMD parallel computers. The search strategy of the PGA {{is based on a}} small number of active and intelligent individuals, whereas a GA uses a large population of passive individuals. We will investigate the PGA with deceptive problems and the traveling salesman problem. We outline why and when the PGA is succesful. Abstractly, a PGA is a parallel search with information exchange between the individuals. If we represent the optimization problem as a tness landscape in a certain con guration space, we see, that a PGA tries to jump from two local minima to a third, still better local minima, by using the crossover operator. This jump is (probabilistically) successful, if the tness landscape has a certain correlation. We showthe correlation for the traveling salesman problem by a con guration space analysis. The PGA explores implicitly the above correlation...|$|E
50|$|Similar to C#, Java {{has since}} version 5 {{a higher level}} {{replacement}} for working with threads directly. Executors are capable of <b>running</b> <b>asynchronous</b> tasks and typically manage a pool of threads. All threads of the internal pool will be reused under the hood for revenant tasks, so we can run as many concurrent tasks as we want throughout the life-cycle of our application with a single executor service.|$|R
40|$|Abstract—In this paper, we {{analyze the}} {{potential}} of asynchronous relaxation methods on Graphics Processing Units (GPUs). For this purpose, we developed a set of asynchronous iteration algorithms in CUDA and compared them with a parallel implementation of synchronous relaxation methods on CPU-based systems. For a set of test matrices taken from the University of Florida Matrix Collection we monitor the convergence behavior, the average iteration time and the total time-to-solution time. Analyzing the results, we observe that even for our most basic asynchronous relaxation scheme, despite its lower convergence rate compared to the Gauss-Seidel relaxation (that we expected), the <b>asynchronous</b> iteration <b>running</b> on GPUs is still able to provide solution approximations of certain accuracy in considerably shorter time then Gauss-Seidel running on CPUs. Hence, it overcompensates for th...|$|R
40|$|We {{provide a}} model of {{weighted}} distributed systems and give a logical characterization thereof. Distributed systems are represented as weighted <b>asynchronous</b> cellular automata. <b>Running</b> over directed acyclic graphs, Mazurkiewicz traces, or (lossy) message sequence charts, they allow for modeling several communication paradigms in a unifying framework, among them probabilistic sharedvariable and probabilistic lossy-channel systems. We show that any such system can be described by a weighted existential MSO formula and, vice versa, any formula {{gives rise to a}} weighted asynchronous cellular automaton...|$|R
40|$|As {{transistor}} {{switching speed}} improves, synchronizing a global clock increasingly degrades system performance. Therefore, self-timed asynchronous logic becomes potentially faster than synchronous logic. To do so, however, it must exploit the techniques used in fast synchronous designs, including: redundant logic, inverting logic, transistor size optimization, dynamic logic, and phase alignment. Most techniques {{can be applied}} equally well to asynchronous logic, indeed phase alignment is easier; but combining dynamic and asynchronous logic is more difficult. We must guarantee minimum refresh intervals, together with race and hazard free operation. This paper describes an initial chip implementation, that combines dynamic and <b>asynchronous</b> logic <b>running</b> at 500 MHz in 2 µm CMOS. With the addition of transistor size optimization, simulations show the same circuit running in the same technology at 800 MHz. I. Introduction Some applications, especially those in telecommunications, need both the [...] ...|$|R
40|$|We {{consider}} Muller <b>asynchronous</b> cellular automata <b>running</b> on infinite dags over distributed alphabets. We {{show that}} they have the same expressive power as the existential fragment of a monadic secondorder logic featuring a first-order quantifier to express that there are infinitely many elements satisfying some property. Our result is based on an extension of the classical Ehrenfeucht-Fraïssé game to cope with infinite structures and the new first-order quantifier. As a byproduct, we obtain a logical characterization of unbounded Muller message-passing automata running on infinite message sequence charts...|$|R
40|$|International audienceWe {{consider}} {{a set of}} learning agents in a col-laborative peer-to-peer network, where each agent learns a personalized model according to its own learning objective. The question addressed in this paper is: how can agents improve upon their locally trained model by communicating with other agents that have similar objectives? We introduce and analyze two <b>asynchronous</b> gossip algorithms <b>running</b> in a fully decentralized manner. Our first approach, inspired from label propagation, aims to smooth pre-trained local models over the network while accounting for the confidence that each agent has in its initial model. In our second approach, agents jointly learn and propagate their model by making iterative updates based on both their local dataset and the behavior of their neighbors. To optimize this challenging objective, our decentralized algorithm is based on ADMM...|$|R
40|$|The Long-lived Renaming {{problem is}} an {{important}} subject in Distributed Algorithms. The Renaming problem consists in providing processes with new names from a hopefully smaller name space. In the long-lived version, {{only a fraction of}} the processes request a new name and later on abandon it and this name could be acquired by another processor. A bound is assumed on the number of processors holding simultaneously a name from the smaller name space. Only recently wait-free fast algorithms for long-lived renaming on asynchronous and shared memory distributed systems have been found and analyzed, and they had not been actually implemented. We describe some empirical considerations complementing the formal static analysis, and assess how useful each of them could be in a real application, as a result of the study of their implementations on a <b>running</b> <b>asynchronous</b> distributed system. Postprint (published version...|$|R
40|$|This report {{presents}} {{the design of}} an asynchronous Huffman decoder, implemented in the Balsa synthesis system. Power consumption, speed and area figures from the post layout design have been measured. In addition, a synchronous design was implemented in order to compare to the <b>asynchronous</b> design. When <b>running</b> at the same clock frequency, {{it was found that}} the asynchronous is faster and more power efficient than the synchronous design. However, at the maximum clock frequency for each design, the synchronous design has a higher throughput than the asynchronous design. It was also found that the asynchronous design has an area cost 10 times greater than the synchronous design. In theory, asynchronous circuits is faster and more power efficient than synchronous circuits, however this comes at an area and complexity overhead. In the case of the Huffman decoder implemented in this thesis, the benefits are not enough to compensate for the very large area increase. </p...|$|R
40|$|We {{present a}} hybrid SLAM system for marine environments that {{combines}} cubic splines {{to represent the}} trajectories of dynamic objects, point features to represent stationary objects and an occupancy grid to represent land masses. This hybrid representation enables SLAM to be applied in environments with moving objects, where solutions using point features alone are computationally prohibitive or where dense objects e. g. landmasses {{can not be represented}} correctly using point features. Estimation is achieved using a sliding window framework with reversible data-association and reversible model-selection. Our main contributions are: (i) a hybrid representation of the environment; (ii) occupancy grid fusion is continually refined {{for the duration of the}} sliding window; (iii) the trajectories of dynamic objects are represented using cubic splines and (iv) radar scans are re-rendered at a sub-scan resolution to compensate for the egomotion during the scan acquisition period. We show that the continual refinement of the occupancy grid greatly improves the quality of the resultant map, leading to a better estimate of the egomotion and therefore better estimates of the trajectories of dynamic objects. We also demonstrate that the use of cubic splines to represent trajectories has two major advantages: (i) the state space is compressed i. e. many vehicle poses can be represented using a single spline section and (ii) the trajectory becomes continuous and so fusing information from <b>asynchronous</b> sensors <b>running</b> at multiple frequencies becomes trivial. The efficacy of our system is demonstrated using real marine radar data, showing that it can successfully estimate the positions/velocities of objects and landmasses observed during a typical voyage on a small boat. Charles Bibby, Ian Rei...|$|R
40|$|By {{analyzing}} {{characteristics of}} the DTC (direct torque control) system in electrical driving system, a shortcoming of the classical DTC method is {{to point out that}} it is unable to decouple the mutual interference between torque and speed, so that when a <b>running</b> <b>asynchronous</b> motor subjected to an instantaneous impact load, rotor speed and its deviation appears excessive fluctuations that can not be quickly restored to the initial set value. In this research, under conditions that without sensors for measuring load torque and rotor speed, to an electrical drive systems contains DTC devices, a novel ASCC (active speed compensation control) method is proposed based on ADRC (active disturbance rejection control) theory, on account of DTC model of asynchronous motor, a multiobjective observer is designed to regulate both the speed and the torque, and a proof of asymptotic stability that related this new control systems with the observer is made by theoretical deduction. Finally stimulating results show that this method can overcome the shortcomings of classical DTC system and greatly enhance the ability of the high-speed driving system to deal with unexpected impact loads...|$|R
40|$|This paper {{reports on}} a {{collaboration}} between the authors at the University of Brighton (UK) and the University of Delhi, South Campus. The collaboration came about {{as a result of}} the EU-India Cross-Cultural Innovation Network collaboration programme, a project involving several universities and organizations across Europe and India. The authors of this paper both lecture in the area of computer networking. Following meetings in Delhi, they agreed to work together to produce a Web-based networking resource to be generated by the students of both institutions. The first phase of development involved the mounting of Web-based tutorials and documents produced by the students. The second phase will centre on the development of a knowledge base generated by the interaction of the students within an <b>asynchronous</b> forum. <b>Running</b> alongside these phases will be a collaborative bookmarking system, a database in which the students will post URLs of Web-based resources that they find useful in their studies. This system incorporates a form of collaborative filtering, an evolutionary mechanism which seeks to embody the qualities that students value in resources to provide a dynamic set of ratings to assist in the selection of those of most use. The planning of such a system raises some unusual issues, not least in the process of collaboration itself, with concerns as diverse as technical compatibility, institutional and cultural differences, timezones and the reliability of email. Limited bandwidth between our institutions causes special problems with the interactive elements of the resource. We present the methods we are investigating to reduce the impact of this. The fact that the students share an intellectual discipline but are otherwise separated by a cultural and geographical divide is expected to lead to fruitful diversity in thinking and approaches to problem-solving...|$|R
40|$|This thesis {{describes}} {{the development of}} an object tracking system for unmanned aerial vehicles (UAVs), intended to be used for search and rescue (SAR) missions. The UAV is equipped with a two-axis gimbal system, which houses an infrared (IR) camera used to detect and track objects of interest, and a lower level autopilot. An external computer vision (CV) module is assumed implemented and connected to the object tracking system, providing object positions and velocities to the control system. The realization of the object tracking system includes the design and assembly of the UAV s payload, the design and implementation of a model predictive controller (MPC), embedded in a larger control environment, and the design and implementation of a human machine interface (HMI). The HMI allows remote control of the object tracking system from a ground control station. A toolkit for realizing optimal control problems (OCP), MPC and moving horizon estimators (MHE), called ACADO, is used. To gain real-time communication between all system modules, an <b>asynchronous</b> multi-threaded <b>running</b> environment, with interface to external HMIs, the CV module, the autopilot and external control systems, was implemented. In addition to the IR camera, a color still camera is mounted in the payload, intended for capturing high definition images of objects of interest and relaying the images to the operator on the ground. By using the center of the IR camera image projected down on earth, together with the UAV s and the objects positions, the MPC is used to calculateway-points, path planning for the UAV, and gimbal attitude, which are used as control actions to the autopilot and the gimbal. Communication between the control system and the autopilot is handled by DUNE. If multiple objects are located and are to be tracked, the control system utilizes an object selection algorithm that determines which object to track depending on the distance between the UAV and each object. If multiple objects are clustered together, the object selection algorithm can choose to track all the clustered objects simultaneously. The object selection algorithm features dynamic object clustering, which is capable of tracking multiple moving objects. The system was tested in simulations, where suitable ACADO parameters were found through experimentation. Important requirements for the ACADO parameters are smooth gimbal control, an efficient UAV path and acceptable time consumption. The implemented HMI gives the operator access to live camera streams, the ability to alter system parameters and manually control the gimbal. The object tracking system was tested using hardware-in-loop (HIL) testing, and the results were encouraging. During the first flight of the UAV, without the payload on-board, the autopilot exhibited erroneous behavior and the UAV was grounded. A solution to the problem was not found in time to conduct any further flight tests during this thesis. A prototype for a three-axis stabilized brushless gimbal was designed and 3 D printed. This was {{as a result of the}} two-axis gimbal system s limited stabilizationcapabilities, small range of movement and seemingly fragile construction. Out of a suspected need for damping to improve image quality from the still camera, the process of designing and prototyping a wire vibration isolator camera mount was started. Further work and testing is required to realize both the gimbal and dampened camera mount. The lack of flight tests prohibited the completion of the object tracking system. Keywords: object tracking system, unmanned aerial vehicle (UAV), search and rescue,two-axis gimbal system, infrared (IR) camera, computer vision (CV), model predictivecontrol (MPC), control environment, human machine interface (HMI), remote control, ground control, ACADO, real-time, <b>asynchronous</b> multi-threaded <b>running</b> environment, way-point, path planning, DUNE, dynamic object clustering, multiple moving objects, hardware-in-loop (HIL), three-axis stabilized brushless gimbal, wire vibration isolato...|$|R
40|$|Single Chip Heterogeneous Multiprocessors {{executing}} a {{wide variety}} of software are increasingly common in consumer electronics. Because of the mix of real-time and best effort software across the entire chip, a key design element of these systems is the choice of scheduling strategy. Without task migration, the benefits of single chip processing cannot be fully realized. Previously, high-level modeling environments have not been capable of modeling asynchronous events such as interrupts and preemptive scheduling while preserving the performance benefits of high level simulation. This paper shows how extensions to Modeling Environment for Software and Hardware (MESH) enable precise modeling of these <b>asynchronous</b> events while <b>running</b> more than 1000 times faster than cycle-accurate simulation. We discuss how we achieved this and illustrate its use in modeling preemptive scheduling. We evaluate the potential of migrating running tasks between processors to improve performance in a multimedia cell phone example. We show that by allowing schedulers to rebalance processor loads as new tasks arrive significant performance gains can be achieved over statically partitioned and dynamic scheduling approaches. In our example, we show that system response time can be improved by as much as 1. 96 times when a preemptive migratory scheduler is used, despite the overhead incurred by scheduling tasks across multiple processor...|$|R
40|$|Java {{supports}} distributed programming using threads and Remote Method Invocation (JRMI). However, a Java thread {{does not}} match well with the object concept, and JRMI cannot easily used to synchronize distributed objects. This work proposes a more object oriented model for concurrent and distributed programming using the notion of separate objects. Separate objects are <b>asynchronous</b> objects maybe <b>running</b> on different processors. These objects are also used for synchronization. The presented approach should encourage more seamless designs. The implementation is supported by JOODE (Java Object Oriented Development Environment) which supports {{the use of an}} adaptable platform of a net of processors. 1 IS CONCURRENCY IN JAVA TRULY OBJECT-ORIENTED? To obtain asynchronous behavior of an action, a Java programmer must extend the class Thread, encapsulating the action in the run method. The classic production-consumption example can be illustrated with the following pattern. A class Producer extends Thread and encapsulates the production algorithm in its overridden run method, and a class Consumer, also extending Thread, encapsulates the consumption algorithm. Both, the production and consumption threads, will synchronize using a buffer. To initiate the production-consumption behavior a method must create instances of Producer and Consumer and “activate ” both instances by calling their corresponding start methods (Listing 1). class Producer extends Thread { private Buffer buf; public void produce() { [...] produces an object and puts it in the buffer [...] public void run() ...|$|R
40|$|Copyright © Rui Li et al. This is an {{open access}} article {{distributed}} under the Creative CommonsAttribution License, which permits unrestricted use, distribution, and reproduction in any medium, provided the original work is properly cited. By analyzing characteristics of the DTC (direct torque control) system in electrical driving system, a shortcoming of the classical DTCmethod is {{to point out that}} it is unable to decouple the mutual interference between torque and speed, so that when a <b>running</b> <b>asynchronous</b> motor subjected to an instantaneous impact load, rotor speed and its deviation appears excessive fluctuations that can not be quickly restored to the initial set value. In this research, under conditions that without sensors for measuring load torque and rotor speed, to an electrical drive systems contains DTC devices, a novel ASCC (active speed compensation control) method is proposed based on ADRC (active disturbance rejection control) theory, on account of DTC model of asynchronous motor, a multiobjective observer is designed to regulate both the speed and the torque, and a proof of asymptotic stability that related this new control systems with the observer is made by theoretical deduction. Finally stimulating results show that this method can overcome the shortcomings of classical DTC system and greatly enhance the ability of the high-speed driving system to deal with unexpected impact loads. 1...|$|R

