0|2177|Public
40|$|International audienceThe dynamic {{description}} logic DDL {{provides a}} kind of action theories based on description logics (DLs). Compared with another important DL-based action formalism constructed by Baader et. al., a shortcoming of DDL {{is the absence of}} occlusions and conditional post-conditions in the description of <b>atomic</b> <b>actions.</b> In this paper, we extend <b>atomic</b> <b>action</b> definitions of DDL to overcome this limitation. Firstly, we introduce extended <b>atomic</b> <b>action</b> definitions in which the occlusions and conditional post-conditions are incorporated. Secondly, for each <b>atomic</b> <b>action</b> specified by an extended <b>atomic</b> <b>action</b> definition, a function named Expand is introduced to transform it into a choice action which is composed of <b>atomic</b> <b>actions</b> defined by ordinary <b>atomic</b> <b>action</b> definitions. Finally, based on the Expand function, the satisfiability-checking algorithm of DDL is extended to support occlusions and conditional post-conditions...|$|R
40|$|<b>Atomic</b> <b>actions</b> {{represents}} {{a powerful tool}} for system structuring, controlling accesses to shared data implementing backward error recovery techniques. In this paper properties of <b>atomic</b> <b>actions</b> are analyzed, specifically referring to crash recovery problems. In order to guarantee consistency of shared data in spite of crashes, programs implementing <b>atomic</b> <b>actions</b> must satisfy some constraints...|$|R
30|$|Tasks flows are {{directed}} graphs that represent a hierarchical decomposition {{of the task}} into steps and substeps. Multiple levels may be used until the task is decomposed down to a finite vocabulary of <b>atomic</b> <b>actions.</b> This type of decomposition follows commonly used HTA task decomposition methods such as those described by Annett (2003). The <b>atomic</b> <b>action</b> vocabulary is incrementally developed and iteratively refined during the task analysis. In addition to providing sufficient granularity to represent the task flow, the list of <b>atomic</b> <b>actions</b> is informed by ITS implementation considerations. <b>Atomic</b> <b>actions</b> form conditional clauses that the behavior graph edges encode. In order to automatically trace behavior graphs, {{it is necessary that}} these <b>atomic</b> <b>actions</b> are detectable, by the simulator, when they are performed by the trainee.|$|R
40|$|This report {{discusses}} {{the identification and}} use of Mach kernel <b>atomic</b> <b>actions.</b> Mach kernel calls may be programmed as compositions of these fine-grained steps. An <b>atomic</b> <b>action</b> has well-defined output properties, so a kernel call that is programmed as a sequence of <b>atomic</b> <b>actions</b> has predictable intermediate states. This is important for dealing with such issues as error recovery, pre-emption of kernel calls, security, kernel state testing, and reasoning about the concurrent execution of kernel calls. We also discuss an important related subject: the meaning of locks. The identification of <b>atomic</b> <b>actions</b> {{is based on a}} model of a Mach kernel state in which relations on Mach entities are axiomatically introduced [BS 93]. In this view, the logical form of a datum that is manipulated by the Mach kernel resembles a tuple in a relational database. The <b>atomic</b> <b>action</b> and locking interfaces present this logical view to the programmer, and hide the data structures that implement this view. Section 2 of this report reviews the goals of our modeling work. Section 3 summarizes the main ideas of the Mach kernel state model. Section 4 discusses an interface to kernel <b>atomic</b> <b>actions.</b> Section 5 discusses locking primitives. Section 6 discusses some performance issues pertaining to <b>atomic</b> <b>actions</b> and locks...|$|R
40|$|<b>Atomic</b> <b>actions</b> are an {{important}} dynamic structuring technique that aid the construction of fault-tolerant concurrent systems. Although they were developed some years ago, none of the well-known commerciallyavailable programming languages directly support their use. This paper illustrates how to program <b>atomic</b> <b>action</b> using the facilities of Ada 95. In particular, it shows how packages, protected objects, requeue, exceptions, asynchronous transfer of control, tagged types and controlled types {{can be used as}} building block from which to construct <b>atomic</b> <b>actions</b> with forward and backward error recovery and which are resilient to deserter tasks and task abortion. Distributed execution of <b>atomic</b> <b>actions</b> is also discussed. Keywords: Software fault tolerance, <b>Atomic</b> <b>actions,</b> Ada 95, Exception handling, Recover blocks, Conversations 1 Introduction Software fault tolerance is often classified according to whether it is static (masking) or dynamic. With static redundancy, several versions of a [...] ...|$|R
30|$|The first {{transition}} rule says that each history of an <b>atomic</b> <b>action</b> υ [m] can reverse successfully, {{and leads to}} an <b>atomic</b> <b>action</b> υ. Similarly, the reverse {{transition rule}} /υ [m] ^υ [m]υ implies a successful reverse.|$|R
30|$|BRPA {{includes}} three kind of operators: {{the execution of}} <b>atomic</b> <b>action</b> a, the choice composition operator + and the sequential composition operator ·. Each finite process can be represented by a closed term that is built from the set A of <b>atomic</b> <b>actions</b> or histories of an <b>atomic</b> <b>action,</b> the choice composition operator +, and the sequential composition operator ·. The collection of all basic process terms is called Basic Reversible Process Algebra (BRPA), which is abbreviated to BRPA.|$|R
30|$|RTI 1 –RTI 5 are the {{defining}} equations for the abstraction operator τ _I: RTI 2 and RTI 4 {{says that it}} renames <b>atomic</b> <b>actions</b> from I into τ, while RTI 1, RTI 3, RTI 5 say that it leaves <b>atomic</b> <b>actions</b> outside I and the deadlock δ unchanged.|$|R
40|$|Synchronization of accesses to {{shared data}} and {{recovering}} {{the state of}} such data {{in the case of}} failures are really two aspects of the same problem [...] implementing <b>atomic</b> <b>actions</b> on a related set of data items. In this paper a mechanism that solves both problems simultaneously {{in a way that is}} compatible with requirements of decentralized systems is described. In particular, the correct construction and execution of a new <b>atomic</b> <b>action</b> can be accomplished without knowledge of all other <b>atomic</b> <b>actions</b> in the system that might execute concurrently. Further, the mechanisms degrade gracefully if parts of the system fail: only those <b>atomic</b> <b>actions</b> that require resources in failed parts of the system are prevented from executing, and there is no single coordinator that can fail and bring down the whole system...|$|R
40|$|The paper {{presents}} a general model for persistent replicated object management and identifies what meta information about objects {{needs to be}} maintained by a naming and binding service to ensure that objects named by application programs are bound to only those object replicas which are in a mutually consistent state. These ideas are developed {{within the framework of}} a distributed system in which application programs are composed of <b>atomic</b> <b>actions</b> (<b>atomic</b> transactions) manipulating persistent (long-lived) objects. Key words persistent objects, <b>atomic</b> <b>actions,</b> distributed systems, replication, naming and binding. 1. Introduction We consider a distributed system in which application programs are composed out of <b>atomic</b> <b>actions</b> (<b>atomic</b> transactions) manipulating persistent (long-lived) objects. <b>Atomic</b> <b>actions</b> ensure that only consistent state changes to objects take place despite failures such as node crashes. Objects not in use normally remain in a passive state: their states are stored i [...] ...|$|R
40|$|Limiting {{the extent}} of error {{propagation}} when faults occur and localizing the subsequent error recovery are common concerns {{in the design of}} fault tolerant parallel processing systems, Both activities are made easier if the designer associates fault tolerance mechanisms with the underlying <b>atomic</b> <b>actions</b> of the system, With this in mind, this paper has investigated two methods for the identification of <b>atomic</b> <b>actions</b> in parallel processing systems described using CSP, Explicit trace evaluation forms the basis of the first algorithm, which enables a designer to analyze interprocess communications and thereby locate <b>atomic</b> <b>action</b> boundaries in a hierarchical fashion, The second method takes CSP descriptions of the parallel processes and uses structural arguments to infer the <b>atomic</b> <b>action</b> boundaries. This method avoids the difficulties involved with producing full trace sets, but does incur the penalty of a more complex algorithm...|$|R
40|$|Abstract—Visual {{analysis}} {{of human behavior}} has generated considerable interest {{in the field of}} computer vision because of its wide spectrum of potential applications. Human behavior can be segmented into <b>atomic</b> <b>actions,</b> each of which indicates a basic and complete movement. Learning and recognizing <b>atomic</b> human <b>actions</b> are essential to human behavior analysis. In this paper, we propose a framework for handling this task using variable-length Markov models (VLMMs). The framework is comprised of the following two modules: a posture labeling module and a VLMM <b>atomic</b> <b>action</b> learning and recognition module. First, a posture template selection algorithm, based on a modified shape context matching technique, is developed. The selected posture templates form a codebook that is used to convert input posture sequences into discrete symbol sequences for subsequent processing. Then, the VLMM technique is applied to learn the training symbol sequences of <b>atomic</b> <b>actions.</b> Finally, the constructed VLMMs are transformed into hidden Markov models (HMMs) for recognizing input <b>atomic</b> <b>actions.</b> This approach combines the advantages of the excellent learning function of a VLMM and the fault-tolerant recognition ability of an HMM. Experiments on realistic data demonstrate the efficacy of the proposed system. Index Terms—Atomic <b>action</b> learning, <b>atomic</b> <b>action</b> recognition, human behavior analysis, variable-length Markov models (VLMMs). I...|$|R
40|$|Coordinated <b>Atomic</b> <b>actions</b> {{have proved}} to be a very general concept which can be {{successfully}} applied for structuring complex concurrent systems consisting of elements which both cooperate and compete. The canonical Coordinated <b>Atomic</b> <b>action</b> is built of several cooperating participants (roles) and a set of local objects which represent the action state and provide the feature for cooperation. In addition, Coordinated <b>Atomic</b> <b>actions</b> can compete for external objects which have conventional transactional properties. The intention {{of this paper is to}} offer a general approach to designing distributed Coordinated <b>Atomic</b> <b>action</b> schemes. Problems of action components partitioning and distribution are discussed. We consider ways of dealing with external and local objects within distributed Coordinated <b>Atomic</b> <b>action</b> schemes; several proposals are discussed in detail. The approach proposed relies on using forward error recovery in the form of distributed and concurrent exception handling and resolution. After discussing the general approach, we demonstrate how it can be applied when the standard distributed model of Ada 95 is used. The presentation of the scheme is sufficiently detailed for it to be used in practice. In particular, a thorough description of the action support and all patterns (skeletons) required for designing application software are given...|$|R
40|$|This paper {{describes}} {{the development of}} two kinds of <b>atomic</b> <b>action</b> schemes for Ada 95. We start by discussing the basic features required of an <b>atomic</b> <b>action</b> scheme and what choices, e. g. between synchronous and asynchronous actions, are appropriate for Ada 95. We then present two implementations of actions; first using Ada 95 packages to create asynchronous actions and secondly, as sets of tasks for synchronous actions. For each action type, we present code fragments illustrating their development and use. Finally, we discuss some related issues (exception resolution, action nesting, state restoration, software re-use and extension, preventing information smuggling, distributed execution) which have been addressed in our work and show {{some of the problems}} encountered (the deserter problem, using different sorts of interparticipant communications and resources). 1 Introduction 1. 1 The Basic Requirements of <b>Atomic</b> <b>Actions</b> <b>Atomic</b> <b>actions</b> (AAs) {{can be used as a}} mechanism for structur [...] ...|$|R
40|$|International audienceInspired by the {{properties}} of the refinement development of the Mondex Electronic Purse, we view an isolated <b>atomic</b> <b>action</b> as a family of transitions with a common before-state, and different after-states corresponding to different possible outcomes when the action is attempted. We view a protocol for an <b>atomic</b> <b>action</b> as a computation DAG, each path of which achieves in several steps one of the outcomes of the <b>atomic</b> <b>action.</b> We show that in this picture, the protocol {{can be viewed as a}} relational refinement of the <b>atomic</b> <b>action</b> in a number of ways. Firstly, it yields a ‘big diagram' simulation à la ASM. Secondly, it yields a ‘small diagram' simulation, in which the <b>atomic</b> <b>action</b> is synchronised with an individual step along each path through the protocol, and all the other steps of the path simulate. We show that provided each path through the protocol contains one step synchronised with the <b>atomic</b> <b>action,</b> the choice of synchronisation point can be made freely. We describe the relationship between such synchronisations and forward and backward simulations. We relate this theory to serialisations of system runs containing multiple interleaved transactions, showing how the clean picture of the refinement of an isolated <b>atomic</b> <b>action</b> to an isolated protocol becomes obscured by the details of the interleaving. In effect, the fact that protocols are typically executed by a number of co-operating agents, not all of which embark on executing the protocol at the same moment, results in ‘ragged starts' and ‘ragged ends' to protocol instantiations, leading to potential overlaps between unrelated protocol instances that the theory must handle. We show how existing Mondex refinements embody the ideas developed, and describe a mechanical verification of the results presented...|$|R
5000|$|... {{a process}} {{deleting}} node B requires an <b>atomic</b> <b>action</b> on the node's predecessor ...|$|R
30|$|In {{comparison}} to ACP, {{it is almost}} a brand new algebra for reversible computation which has the same advantages of ACP, such as modularity, axiomatization, etc. Firstly, in RACP, the alternative composition is replaced by choice composition, since in reversible computing, all choice branches should be retained. Secondly, the parallel operator cannot be captured by an interleaving semantics. Thirdly, more importantly to establish a full axiomatization, all the <b>atomic</b> <b>actions</b> are distinct, the same <b>atomic</b> <b>action</b> in different branches (including choice branches and parallel branches) will be deemed as the same one <b>atomic</b> <b>action.</b> Also auto-concurrency is out of scope for our work here.|$|R
30|$|If n is an <b>atomic</b> <b>action,</b> then it {{does not}} contain any {{parallel}} operators.|$|R
5000|$|Activities can be {{decomposed}} into subactivities, {{until at}} the bottom we find <b>atomic</b> <b>actions.</b>|$|R
5000|$|... {{introduces}} the [...] and [...] primitives, allowing alternative <b>atomic</b> <b>actions</b> to be composed together.|$|R
30|$|In this section, we take {{an example}} of {{renaming}} operators which are used to rename the <b>atomic</b> <b>actions.</b>|$|R
40|$|Abstract. Many {{parallel}} {{programs are}} {{expressed in terms of}} conditional <b>atomic</b> <b>actions</b> with different degrees of atomicity. It is known that these synchronization primitives are expensive to implement in its fully generality [2]. Many platforms provide an efficient set of synchronization primitives. Semaphores are a very special case of conditional <b>atomic</b> <b>actions</b> which can be considered a canonical synchronization primitive. There exist methods to transform general conditional <b>atomic</b> <b>actions</b> into these very special ones. One of the simplest is the Change of Variables method introduced in [1, 2] and generalized in [10]. We review and improve this method in the context of formal development of multiprograms [4, 7]. Keywords: Program transformation; Semaphore synchronization; Multiprograms; Program derivation; Theory of Owicki and Gries; Efficien...|$|R
30|$|In GLARE, we {{distinguish}} between <b>atomic</b> and composite <b>actions</b> (plans), where <b>atomic</b> <b>actions</b> represent simple steps in a CIG, and plans represent actions {{that can be}} {{defined in terms of}} their components via the “has-part” relation.|$|R
30|$|RD 6 -RD 8 {{say that}} in ∂ _H(t), all {{transitions}} of t labelled with <b>atomic</b> <b>actions</b> from H are blocked.|$|R
30|$|RTI 6 –RTI 7 {{say that}} in τ _I(t), all {{transitions}} of t labelled with <b>atomic</b> <b>actions</b> from I are renamed into τ.|$|R
50|$|Arvind's {{research}} interests include verification of large-scale digital systems using Guarded <b>Atomic</b> <b>Actions,</b> Memory Models and Cache Coherence Protocols for parallel architectures and languages.|$|R
40|$|Atomic delegation, an {{object-oriented}} linguistic {{mechanism that}} allows the creation of dynamically defined classes of <b>atomic</b> <b>actions</b> is presented. When a type is modified, atomic delegation updates functionalities of the the types that delegate to the modified type. This mechanism permits dynamic binding and code reuse in <b>atomic</b> <b>actions.</b> The Sina language is used to illustrate the utility of atomic delegation in the modeling of a real-world problem, involving an office {{with a number of}} departments, using object-oriented techniques. Implementation issues are discusse...|$|R
40|$|A common {{technique}} for constructing reliable distributed applications {{is to use}} <b>atomic</b> <b>actions</b> for controlling operations on persistent objects. <b>Atomic</b> <b>actions</b> are used to ensure that inconsistencies in application state do not arise when failures occur or when concurrent activities operate on shared objects. Within such an application, objects provide a convenient unit for distribution and concurrency-control. The properties of <b>atomic</b> <b>actions</b> and objects can be exploited together to configure distributed applications, without affecting the correct functioning of the application. This leads {{to the possibility of}} changing the configuration of concurrency and distribution of the distributed application to improve availability and performance. These changes in concurrency and distribution can be achieved by varying the object decomposition within the application. In this paper, we show how some kinds of reconfiguration can be achieved without any modification to client applications. The o [...] ...|$|R
40|$|Arjuna is a fault {{tolerant}} distributed system supporting nested <b>atomic</b> <b>actions</b> (nested <b>atomic</b> transactions) {{that are used}} for controlling operations on objects (instances of C++ classes). Objects are long lived entities (persistent) and are the main repositories for holding system state; {{they are also the}} units of replication for increasing availability. This paper describes the design and implementation of two object replication schemes for Arjuna. Support for replication is provided by a naming and binding service for persistent replicated objects that ensures that applications only ever get to use mutually consistent copies of replicas. Key words <b>Atomic</b> <b>actions,</b> active replication, passive replication, persistent objects. 2 1. Introduction Arjuna is a distributed system, implemented in C++, that provides facilities for constructing applications using persistent objects which can be manipulated under the control of <b>atomic</b> <b>actions</b> (<b>atomic</b> transactions) [1]. Fault tolerance is necess [...] ...|$|R
40|$|The University of Rochester's Rhino {{system is}} a locally {{organized}} cooperative agent architecture that uses observation as its primary means of inter-agent coordination. Observing agents recognize on-going individual actions, and from sequences of actions reason about likely on-going plans. Sets of individual plans are combined to form hypothesized group plans. A key element in the group plan inference process is the recognition of individual agents' actions. Action recognition {{is the problem of}} describing an observed agent's activity as goal-directed behavior. <b>Atomic</b> <b>actions</b> are those whose effects occur instantaneously; composite actions take place over time. This paper proposes a knowledge-based, Bayesian technique for describing, detecting and classifying <b>actions.</b> To recognize <b>atomic</b> <b>actions,</b> we use Bayes nets to detect the corresponding instantaneous changes in world state. Composite actions are recognized by hidden Markov models, which describe them as sequences of <b>atomic</b> <b>actions</b> [...] . ...|$|R
40|$|Record // Important utility class RecoveryRecord // handles object {{recovery}} LockRecord // handles object locking 5 RecordList // Intentions list other management record types 3. 6 Building transactional applications The API relieves programmers {{from having}} to explicitly register resources with a transaction. Neither {{do they have to}} manage persistence or concurrency control, which are managed on their behalf by the JavaArjuna classes StateManager and LockManager. To make use of <b>atomic</b> <b>actions</b> in an application, instances of the class AtomicAction must be declared by the programmer. The operations this class provides (begin, abort, commit) can then be used to start and manipulate <b>atomic</b> <b>actions</b> (including nested actions). The only objects controlled by the resulting <b>atomic</b> <b>actions</b> are those objects which are either instances of JavaArjuna classes or are user-defined classes derived from LockManager and hence are members of the hierarchy shown previously. Most JavaArjuna system classe [...] ...|$|R
40|$|Record // Important utility class RecoveryRecord // handles object {{recovery}} LockRecord // handles object locking RecordList // Intentions list other management record types To {{make use}} of <b>atomic</b> <b>actions</b> in an application, instances of the class AtomicAction must be declared by the programmer in the application as illustrated earlier. The operations this class provides (Begin, Abort, End) can then be used to start and manipulate <b>atomic</b> <b>actions</b> (including nested actions). The only objects controlled by the resulting <b>atomic</b> <b>actions</b> are those objects which are either instances of Arjuna classes or are user-defined classes derived from LockManager and hence {{are members of the}} hierarchy shown above. Most Arjuna system classes are derived from the base class StateManager, which provides primitive facilities necessary for managing persistent and recoverable objects. These facilities include support for the activation and de-activation of objects, and state-based object recovery. Thus, instanc [...] ...|$|R
40|$|Ada 95 is an {{expressive}} {{concurrent programming}} lan-guage, which allows building large multi-tasking applica-tions. Much {{of the complexity}} of these applications stems from the interactions between the tasks. Design abstrac-tions (such as <b>atomic</b> <b>actions,</b> conversations etc.) have been proposed to deal with such complexity. This paper argues that Petri nets offer a promising, tool-supported, technique for checking the logical correctness of abstractions. The paper illustrates the effectiveness of this approach by show-ing the correctness of an Ada implementation of the <b>atomic</b> <b>action</b> protocol using a variety of Petri net tools. 1...|$|R
40|$|Abstract. We {{examine the}} role of {{transactional}} memory from two perspectives: that of a programming language with <b>atomic</b> <b>actions</b> and that of implementations of the language. We {{argue that it is}} difficult to formulate a clean, separate, and generally useful definition of transactional memory. In both programming-language semantics and implementations, the treatment of <b>atomic</b> <b>actions</b> benefits from being combined with that of other language features. In this respect (as in many others), transactional memory is analogous to garbage collection, which is often coupled with other parts of language runtime systems. ...|$|R
40|$|In a UNIX file system, {{metadata}} for {{the file}} objects must be updated {{in a specific}} order such that the file system can be recovered after a crash. Metadata update usually involves several <b>atomic</b> <b>actions</b> and thus a crash can happen in between these <b>atomic</b> <b>actions</b> before the whole update is completed. This paper investigates formally specifying a UNIX file system and these metadata updating operations using the software specification language Alcoa [2]. Alcoa comes with a tool which along with helping to debug the specification, proved useful in investigating various invariants of the system. ...|$|R
40|$|Techniques for {{structuring}} forward {{error recovery}} measures in asynchronous systems are proposed, and recent ideas of <b>atomic</b> <b>actions</b> are generalized {{so as to}} support fault-tolerant interactions between processes. In particular, the proposal generalizes the form of simple recovery facilities supported by nested <b>atomic</b> <b>actions</b> in which the exception mechanisms only permit backward error recovery. It allows for construction of systems employing both forward and backward error recovery and thus allows for exploitation of the complementary benefits of the two schemes. Backward recovery, forward recovery, and normal processing activities can occur concurrently within the organization proposed...|$|R
