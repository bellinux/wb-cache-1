10|15|Public
40|$|Tarragon is an <b>actor-based</b> <b>programming</b> {{model and}} library for {{implementing}} latency tolerant asynchronous event driven simulations. It is novel in {{its support for}} meta data describing run time virtualized process structures, which may be optimized as a free-standing object. We demonstrate early results with a synthetic benchmark, and observe that Tarragon can mask communication costs with ongoing computation. ...|$|E
40|$|International audienceIn this paper, we {{introduce}} a real-time <b>actor-based</b> <b>programming</b> language {{and provide a}} formal but intuitive operational semantics for it. The language supports a general mechanism for handling exceptions raised by missed deadlines and the specification of application-level scheduling policies. We discuss {{the implementation of the}} language and illustrate the use of its constructs with an industrial case study from distributed e-commerce and marketing domain...|$|E
40|$|AbstractThis paper {{deals with}} {{application}} of concurrent object-oriented programming with Actors to solve dynamic programming {{problems in a}} distributed computing environment. This area of research is often called distributed artificial intelligence. Using a dynamic programming example of chained matrix multiplication, a method of managing dynamic programming searches in a distributed programming environment with Actors is presented. Distributed computations with Actors are visualized by means of Time-Varying Automata (for cases with no intra-actor concurrency) or using a class of high-level nets called Hierarchical Colored Petri Nets (for cases with intra-actor concurrency). Design and implementation features of the specific <b>Actor-based</b> <b>programming</b> environment, using a concurrent extension of C++, are also discussed...|$|E
40|$|Properties such as {{the absence}} of errors or bounds on mailbox sizes are hard to deduce statically for <b>actor-based</b> <b>programs.</b> This is because <b>actor-based</b> <b>programs</b> exhibit several sources of unboundedness, in {{addition}} to the non-determinism that is inherent to the concurrent execution of actors. We developed a static technique based on abstract interpretation to soundly reason in a finite amount of time about the possible executions of an <b>actor-based</b> <b>program.</b> We use our technique to statically verify the absence of errors in <b>actor-based</b> <b>programs,</b> and to compute upper bounds on the actors 2 ̆ 7 mailboxes. Sound abstraction of these mailboxes is crucial to the precision of any such technique. We provide several mailbox abstractions and categorize them according {{to the extent to which}} they preserve message ordering and multiplicity of messages in a mailbox. We formally prove the soundness of each mailbox abstraction, and empirically evaluate their precision and performance trade-offs on a corpus of benchmark programs. The results show that our technique can statically verify the absence of errors for more benchmark programs than the state-of-the-art analysis...|$|R
40|$|This {{artifact}} {{is based}} on Scala-AM, a static analysis framework relying on the Abstracting Abstract Machines approach. This version of the framework is extended to support <b>actor-based</b> <b>programs,</b> written in a variant of Scheme. The sound static analysis is performed in order to verify the absence of errors in <b>actor-based</b> <b>program,</b> and to compute upper bounds on actor 2 ̆ 7 s mailboxes. We developed several mailbox abstractions with which the static analysis can be run, and evaluate the precision of the technique with these mailbox abstractions. This artifact contains documentation {{on how to use}} analysis and on how to reproduce the results presented in the companion paper...|$|R
40|$|The actor {{model is}} an {{attractive}} foundation for developing concurrent applications because actors are isolated concurrent entities that communicate through asynchronous messages and do not share state. Thus, they avoid common concurrency bugs such as data races. However, they are not immune to concurrency bugs in general. This paper studies concurrency bugs in <b>actor-based</b> <b>programs</b> reported in literature. We define a taxonomy for these bugs. Furthermore, we analyze the bugs to identify the patterns causing {{them as well as}} their observable behavior. Based on our taxonomy, we further analyze the literature and find that current approaches to static analysis and testing focus on communication deadlocks and message protocol violations. However, they do not provide solutions to identify livelocks and behavioral deadlocks. We propose a research roadmap of the main debugging techniques that can help to support the development of <b>actor-based</b> <b>programs.</b> Comment: Submitted for revie...|$|R
40|$|Erlang is an <b>actor-based</b> <b>programming</b> {{language}} used extensively for building concurrent, reactive {{systems that are}} highlighly available and suffer minimum downtime. Such systems are often mission critical, making system correctness vital. In industrial-scale systems, correctness is usually ascertained through testing, a lightweight verification technique trading analysis completeness for scalability. In such cases, a system is deemed correct whenever it “passes” a suite of tests, each checking for the correct functionality of a particular aspect of a system. This is also true for large Erlang systems: even when correctness specifications are provided, it is commonplace for Erlang developers to use testing tools, automating test-case generation from these specifications. peer-reviewe...|$|E
40|$|Large-scale, dynamic, and {{heterogeneous}} {{networks of}} computational resources promise to provide high performance and scalability to computationally intensive applications, but these environments also introduce {{the need for}} complex resource management strategies. This paper introduces <b>actor-based</b> <b>programming</b> abstractions and a middleware framework to relieve developers from considering non-functional concerns while allowing middleware layers to optimize application performance and global resource utilization. The Internet Operating System (IOS) consists of a peer-to-peer virtual network of middleware agents that trigger application component reconfiguration based on changes in the underlying physical network {{and based on the}} application communication patterns and resource consumption. IOS middleware agents are highly customizable to account for different resource profiling, load balancing, and peer-to-peer interconnection policies...|$|E
40|$|Channel- and <b>actor-based</b> <b>programming</b> {{languages}} are both used in practice, {{but the two}} are often confused. Languages such as Go provide anonymous processes which communicate using buffers or rendezvous points [...] -known as channels [...] -while languages such as Erlang provide addressable processes [...] -known as actors [...] -each with a single incoming message queue. The lack of a common representation {{makes it difficult to}} reason about translations that exist in the folklore. We define a calculus lambda-ch for typed asynchronous channels, and a calculus lambda-act for typed actors. We define translations from lambda-act into lambda-ch and lambda-ch into lambda-act and prove that both are type- and semantics-preserving. We show that our approach accounts for synchronisation and selective receive in actor systems and discuss future extensions to support guarded choice and behavioural types...|$|E
40|$|This paper {{presents}} a safe static analysis which detects all safety orphan messages in <b>actor-based</b> <b>programs.</b> This result extends previous work derived from sequential object-oriented languages type systems to non-uniform behaviors. Most {{of the type}} systems designed for concurrent objects rely on the uniform behavior assumption : an object is a) always able to handle requests to {{the same set of}} methods, and b) always accessible (each method can be handled any number of times). This hypothesis allows the use of type systems designed for sequential object-oriented languages (either kind-based ones as proposed by Vasconcelos and Tokoro [VT 93] and by Kobayashi and Yonezawa [KY 94], or subtype-based ones as advocated by the authors in [CPS 97 b]). In the case of objects with non-uniform behavior (i. e. short lifetime objects or behavior changing actors), an object may be able to handle a request to one of its method at a given time {{and not be able to}} handle it at some other time. If the request cannot be handled, the associated message is called a "safety orphan". The previous type systems could only detect rather trivial safety orphan messages. The system described in this paper extends our subtype-based previous work in order to catch all potential safety orphans in <b>actor-based</b> <b>programs.</b> 1 In this purpose, a new safe type-based abstraction of an actor possible behaviors is proposed. We extend a Primitive Actor Calculus introduced in the first section and defined in a previous paper ([CPS 96, CPS 97 b]) in order to give a simple semantic characterisation of safety orphan messages. A sound type system based on the type abstraction is then presented. It rejects all the programs which may produce safety orphan messages. In conclusion, related works and possible extensions are discus [...] ...|$|R
40|$|We {{present a}} work in {{progress}} report on applying deforestation to distributed, dynamic dataflow programming models. We propose a novel algorithm, dynamic path contraction, that applies and reverses optimizations to a distributed dataflow application as the program executes. With this algorithm, data and control flow is tracked by the runtime system used to identify potential optimizations as the system is running. We demonstrate and present preliminary results regarding this technique on an <b>actor-based</b> distributed <b>programming</b> model, Lasp, implemented on the Erlang virtual machine...|$|R
40|$|Parallel Architecture Applications ProperEXT Extraction ProperDRC Layout Verification ProperTEST ATPG ProperGATEST ATPG ProperSYN Synthesis ProperMIS Synthesis ProperPLACE Placement ProperROUTE Routing ProperHITEC ATPG ProperPROOFS Fault Simulation ProperSIM Circuit Simulation ProperVHDL VHDL Simulation MIS/SIS HITEC/PROOFS TimberWolfSC [...] . 6 Existing Serial Algorithms Parallel Application Figure 1. 1 : An {{overview}} of the ProperCAD project. for unstructured problems. ProperCAD II is an object-oriented library supporting the design of <b>actor-based</b> parallel <b>programs</b> [3, 6]. The library easily allows the design of data structures with parallel semantics for use in irregular applications. Because the foundation is based on C++, inheritance mechanisms allow creation of the distributed data structures from standard C++ objects. The major goal of the ProperCAD project [7] is to develop portable parallel algorithms for VLSI CAD applications that will run {{on a range of}} parallel machines inc [...] ...|$|R
40|$|Stateless code model {{checking}} is {{an effective}} verification technique, which is more applicable than stateful model checking to the software world. Existing stateless model checkers support the verification of neither LTL formulae nor the information flow security properties. This paper proposes a distributed stateless code model checker (DSCMC) designed based on the Actor model, and has the capability of verifying code written in different programming languages. This tool is implemented using Erlang, which is an <b>actor-based</b> <b>programming</b> language. DSCMC is able to detect deadlocks, livelocks, and data races automatically. In addition, the tool can verify information flow security and the properties specified in LTL. Thanks to its actor-based architecture, DSCMC provides {{a wide range of}} capabilities. The parallel architecture of the tool exploiting the rich concurrency model of Erlang is suited to the time-intensive process of stateless code model checking...|$|E
40|$|By {{requiring}} co-ordination to {{take place}} using explicit message passing instead of relying on shared memory, <b>actor-based</b> <b>programming</b> languages {{have been shown to}} be effective tools for building reliable and fault-tolerant distributed systems. Although naturally communication-centric, communication patterns in actor-based applications remain informally specified, meaning that errors in communication are detected late, if at all. Multiparty session types are a formalism to describe, at a global level, the interactions between multiple communicating entities. This article describes the implementation of a prototype framework for monitoring Erlang/OTP gen_server applications against multiparty session types, showing how previous work on multiparty session actors can be adapted to a purely actor-based language, and how monitor violations and termination of session participants can be reported in line with the Erlang mantra of "let it fail". Finally, the framework is used to implement two case studies: an adaptation of a freely-available DNS server, and a chat server. Comment: In Proceedings ICE 2016, arXiv: 1608. 0313...|$|E
40|$|Erlang is an <b>actor-based</b> <b>programming</b> {{language}} used extensively for building concurrent, reactive {{systems that are}} highly available and suff er minimum downtime. Such systems are often mission critical, making system correctness vital. Refactoring is code restructuring that improves the code but does not change behaviour. While using automated refactoring tools is less error-prone than performing refactorings manually, automated refactoring tools still cannot guarantee that the refactoring is correct, i. e., program behaviour is preserved. This leads to lack of trust in automated refactoring tools. We rst survey solutions to this problem proposed in the literature. Erlang refactoring tools as commonly use approximation techniques which do not guarantee behaviour while some other works propose the use of formal methodologies. In this work we aim to develop a formal methodology for refactoring Erlang code. We study behavioural preorders, with a special focus on the testing preorder as it seems most suited to our purpose. peer-reviewe...|$|E
40|$|A {{survey of}} {{concurrent}} object-oriented languages is presented. The survey is organized around three models: the Animation Model that describes {{a variety of}} relationships between threads and objects, an Interaction Model that classi#es the possible semantics of invocations and returns between a client object and a server object, and a Synchronization Model that shows di#erentways in which concurrentinvocations can be managed bya server. Anumber of representative languages are brie#y presented. The problem of synchronization in concurrent object-oriented languages is considered in detail including {{a discussion of the}} inheritance anomaly. A synchronization mechanism, called a behavior set, is shown to avoid this anomaly in certain cases. The implementation of behavior sets in ACT++, an <b>actor-based</b> concurrent <b>programming</b> framework implemented in C++, is described. 1 Introduction This survey of concurrent object-oriented programming languages is organized along the following [...] ...|$|R
40|$|Social {{networking}} applications {{on the web}} {{handle the}} personal data {{of a large number}} of concurrently active users. These applications must comply with complex privacy requirements, while achieving scalability and high performance. Applying constraints to the ﬂow of data through such applications to enforce privacy policy is challenging because individual components process data belonging to many different users. We introduce a practical approach for uniformly enforcing privacy requirements in such applications using the <b>actor-based</b> Erlang <b>programming</b> language. To isolate the personal data of users, we exploit Erlang’s inexpensive process model and use Erlang’s message passing mechanism to add policy checks. We illustrate this approach by describing the architecture of a privacy-preserving message dispatcher in a micro-blogging service. Our performance evaluation of a prototype implementation shows that this approach can enforce ﬁne-grained privacy guarantees with a low performance overhead...|$|R
40|$|In this work, we {{introduce}} a scheme for modelling actor systems within sequential term rewriting. In our proposal, a TRS {{consists of the}} union of three components: the functional part (which is specific of a system), {{a set of rules}} for reducing concurrent actions, and a set of rules for defining a particular scheduling policy. A key ingredient of our approach is that concurrent systems are modelled by terms in which concurrent actions can never occur inside user-defined function calls. This assumption greatly simplifies the definition of the semantics for concurrent actions, since no term traversal will be needed. We prove that these systems are well defined in the sense that concurrent actions can always be reduced. Our approach {{can be used as a}} basis for modelling <b>actor-based</b> concurrent <b>programs,</b> which can then be analyzed using existing techniques for term rewrite systems...|$|R
40|$|Two major {{trends in}} {{computing}} hardware {{during the last}} decade have been {{an increase in the number}} of processing cores found in individual computer hardware platforms and an ubiquity of distributed, heterogeneous systems. Together, these changes can improve not only the performance of a range of applications, but the types of applications that can be created. Despite the advances in hardware technology, advances in programming of such systems has not kept pace. Traditional concurrent programming has always been challenging, and is only set to be come more so as the level of hardware concurrency increases. The different hardware platforms which make up heterogeneous systems come with domain-specific programming models, which are not designed to interact, or take into account the different resource-constraints present across different hardware devices, motivating a need for runtime reconfiguration or adaptation. This dissertation investigates the actor model of computation as an appropriate abstraction to address the issues present in programming concurrent, distributed, and adaptive applications across different scales and types of computing hardware. Given the limitations of other approaches, this dissertation describes a new <b>actor-based</b> <b>programming</b> language (Ensemble) and its runtime to address these challenges. The goal of this language is to enable non-specialist programmers to take advantage of parallel, distributed, and adaptive programming without the programmer requiring in-depth knowledge of hardware architectures or software frameworks. There is also a description of the design and implementation of the runtime system which executes Ensemble applications across a range of heterogeneous platforms. To show the suitability of the actor-based abstraction in creating applications for such systems, the language and runtime were evaluated in terms of linguistic complexity and performance. These evaluations covered programming embedded, concurrent, distributed, and adaptable applications, as well as combinations thereof. The results show that the actor provides an objectively simple way to program such systems without sacrificing performance...|$|E
40|$|This paper {{introduces}} a novel mechanism to perform intercession (a form of reflection) in an objectoriented programming language {{with the goal}} of making the language extensible from within itself. The proposed mechanism builds upon a mirror-based architecture, leading to a reusable reflective API that cleanly separates interface from implementation details. However, support for intercession has been limited in contemporary mirror-based architectures. This {{is due to the fact}} that mirror-based architectures only support reflection explicitly triggered by metaprograms, while intercession requires reflection implicitly triggered by the language interpreter. This work reconciles mirrors with intercession in the context of an <b>actor-based,</b> object-oriented <b>programming</b> language named AmbientTalk. We describe this language’s full reflective architecture, highlighting its novel mirror-based approach to reflect upon both objects and concurrently executing actors. Subsequently, we apply AmbientTalk’s mirror-based reflection to implement two language features which crucially depend on intercession, to wit future-type message passing and leased object references. KEY WORDS...|$|R
40|$|This paper {{demonstrates}} {{the feasibility of}} modeling concurrent diagnostic reasoning (CDR) {{by means of the}} computational model of actors. Actors have a value added on top of objects, because they include the properties of abstraction, modularity and reuse of objects but allow really concurrent and distributed architectures, in the sense that memory (the environment) is assumed not to be shared among actors. Whether concurrency really implies efficiency is still debated. We are more concerned here with the actor-based design of the diagnostic reasoning model. As a testimony of the feasibility of our proposal, a concrete, <b>actor-based</b> diagnostic <b>program</b> is presented as a module for an Intelligent Tutoring System in the domain of school algebra. CDR is obtained from the coordinated behaviour of actors which possess limited local knowledge and accomplish the global goal of diagnostic reasoning by interacting with each other. We examine how the ’traditional‘ approaches to student modeling, such as overlay and bug models, can be re-visited in a distributed perspective of computational actors and how the latter view outperforms the previous ones...|$|R
40|$|Abstract. An {{important}} {{application of}} unique object references {{is safe and}} efficient message passing in concurrent object-oriented programming. However, to prevent the ill effects of aliasing, practical systems often severely restrict the shape of messages passed by reference. Moreover, the problematic interplay between destructive reads–often used to implement unique references–and temporary aliasing through “borrowed ” references is exacerbated in a concurrent setting, increasing the potential for unpredictable run-time errors. This paper introduces {{a new approach to}} uniqueness. The idea is to use capabilities for enforcing both at-most-once consumption of unique references, and a flexible notion of uniqueness. The main novelty of our approach is a model of uniqueness and borrowing based on simple, unstructured capabilities. The advantages are: first, it provides simple foundations for uniqueness and borrowing. Second, it can be formalized using a relatively simple type system, for which we provide a complete soundness proof. Third, it avoids common problems involving borrowing and destructive reads, since unique references subsume borrowed references. We have implemented our type system as an extension to Scala. Practical experience suggests that our system allows type checking real-world <b>actor-based</b> concurrent <b>programs</b> with {{only a small number of}} additional type annotations. ...|$|R
40|$|The {{focus of}} this {{tutorial}} is white-box test case generation (TCG) based on symbolic execution. Symbolic execution consists in executing a program with the contents of its input arguments being symbolic variables rather than concrete values. A symbolic execution tree characterizes the set of execution paths explored during the symbolic execution of a program. Test cases can be then obtained from the successful branches of the tree. The tutorial is split into three parts: (1) The first part overviews the basic techniques used in TCG to ensure termination, handling heap-manipulating programs, achieving compositionality {{in the process and}} guiding TCG towards interesting test cases. (2) In the second part, we focus on a particular implementation of the TCG framework in constraint logic programming (CLP). In essense, the imperative object-oriented program under test is automatically transformed into an equivalent executable CLP-translated program. The main advantage of CLP-based TCG is that the standard mechanism of CLP performs symbolic execution for free. The PET system is an open-source software that implements this approach. (3) Finally, in the last part, we study the extension of TCG to <b>actor-based</b> concurrent <b>programs...</b>|$|R
40|$|International audienceThe {{advent of}} {{portable}} software-defined radio (SDR) technology is tightly {{linked to the}} resolution of a difficult problem: efficient compilation of signal processing applications on embedded computing devices. Modern wireless communication protocols use packet processing rather than infinite stream processing and also introduce dependencies between data value and computation behavior leading to dynamic dataflow behavior. Recently, parametric dataflow has been proposed to support dynamicity while maintaining {{the high level of}} analyzability needed for efficient real-life implementations of signal processing computations. This article presents a new compilation flow that is able to compile parametric dataflow graphs. Built on the LLVM compiler infrastructure, the compiler offers an <b>actor-based</b> C++ <b>programming</b> model to describe parametric graphs, a compilation front end for graph analysis, and a back end that currently matches the Magali platform: a prototype heterogeneous MPSoC dedicated to LTE-Advanced. We also introduce an innovative scheduling technique, called microscheduling, allowing one to adapt the mapping of parametric dataflow programs to the specificities of the different possible MPSoCs targeted. A specific focus on FIFO sizing on the target architecture is presented. The experimental results show compilation of 3 GPP LTE-Advanced demodulation on Magali with tight memory size constraints. The compiled programs achieve performance similar to handwritten code. This work was sponsored by Région Rhône Alpes ADR 11 01302401. Part of this work was published as M. Dardaillon, K. Marquet, T. Risset, J. Martin, and H. -P. Charles. 2014. A compilation flow for parametric dataflow: Programming model, scheduling, and application to heterogeneous MPSoC. " In Proceedings of the International Conference on Compilers, Architecture, and Synthesis for Embedded Systems (CASES' 14). This work extends the previous publication by providing a thorough presentation of a new front end technique, introducing a new Promela model for buffer size verification, and updated results reflecting the subtantial improvements provided by the new Promela model...|$|R

