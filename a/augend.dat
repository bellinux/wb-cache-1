12|1|Public
500|$|Some authors {{call the}} first addend the <b>augend.</b> In fact, during the Renaissance, many authors did not {{consider}} the first addend an [...] "addend" [...] at all. Today, due to the commutative property of addition, [...] "augend" [...] is rarely used, and both terms are generally called addends.|$|E
500|$|The sum a + b can be {{interpreted}} as a binary operation that combines a and b, in an algebraic sense, or it can {{be interpreted}} as the addition of b more units to a. Under the latter interpretation, the parts of a sum [...] play asymmetric roles, and the operation [...] is viewed as applying the unary operation +b to a. Instead of calling both a and b addends, it is more appropriate to call a the <b>augend</b> in this case, since a plays a passive role. The unary view is also useful when discussing subtraction, because each unary addition operation has an inverse unary subtraction operation, and vice versa.|$|E
500|$|In practice, {{computational}} addition may {{be achieved}} via XOR and AND bitwise logical operations {{in conjunction with}} bitshift operations {{as shown in the}} pseudocode below. Both XOR and AND gates are straightforward to realize in digital logic allowing the realization of full adder circuits which in turn may be combined into more complex logical operations. In modern digital computers, integer addition is typically the fastest arithmetic instruction, yet it has the largest impact on performance, since it underlies all floating-point operations as well as such basic tasks as address generation during memory access and fetching instructions during branching. To increase speed, modern designs calculate digits in parallel; these schemes go by such names as carry select, carry lookahead, and the Ling pseudocarry. Many implementations are, in fact, hybrids of these last three designs. Unlike addition on paper, addition on a computer often changes the addends. On the ancient abacus and adding board, both addends are destroyed, leaving only the sum. The influence of the abacus on mathematical thinking was strong enough that early Latin texts often claimed that in the process of adding [...] "a number to a number", both numbers vanish. In modern times, the ADD instruction of a microprocessor often replaces the <b>augend</b> with the sum but preserves the addend. In a high-level programming language, evaluating [...] does not change either a or b; if the goal is to replace a with the sum this must be explicitly requested, typically with the statement [...] Some languages such as C or C++ allow this to be abbreviated as [...]|$|E
40|$|Abstract—In this paper, a {{methodology}} {{for the development}} of fault-tolerant adders based on the Radix 2 Signed Digit (SD) representation is presented. The use of a number representation characterized by a carry propagation confined to neighbor digits implies interesting advantages in terms of error detection, fault localization, and repair. Errors caused by faults belonging to a considered stuck-at fault set can be detected by a parity-based technique. In fact, a carry-free adder preserving the parity of the <b>augends</b> can be implemented allowing fault detection by using a parity checker. Regarding fault localization, the “carry-free ” property of the adder ensures the confinement of the error due to a permanent fault to only few digits. The detection of the faulty digit has been obtained by using a recomputation with shifted operands method. Finally, after the fault localization, graceful degradation of the system intended as the reduction of the performances versus a correct output computation can be obtained by using two different procedures. The first one allows obtaining the correct output by recomputing the result performing two different shift operations and using the intersection of the obtained results to recover the correct output, while the second one is based on a reduced dynamic range approach, which allows us to obtain the result in only one step, but with fewer output digits. Index Terms—Fault tolerance, high-speed arithmetic, error checking. æ...|$|R
50|$|Place the <b>augend</b> 3748 in {{the first}} row, and the addend 289 in the second.|$|E
5000|$|The rods in the <b>augend</b> change {{throughout}} the addition, while the rods in the addend {{at the bottom}} [...] "disappear".|$|E
5000|$|The {{result of}} the {{operation}} is 9. (The number '9' is also called {{the sum of the}} <b>augend</b> 3 and the addend 6.) ...|$|E
5000|$|The {{numbers or}} the objects {{to be added}} in general {{addition}} are collectively {{referred to as the}} terms, the addends or the summands;this terminology carries over to the summation of multiple terms.This is to be distinguished from factors, which are multiplied.Some authors call the first addend the <b>augend.</b> In fact, during the Renaissance, many authors did not consider the first addend an [...] "addend" [...] at all. Today, due to the commutative property of addition, [...] "augend" [...] is rarely used, and both terms are generally called addends.|$|E
50|$|The sum a + b can be {{interpreted}} as a binary operation that combines a and b, in an algebraic sense, or it can {{be interpreted}} as the addition of b more units to a. Under the latter interpretation, the parts of a sum a + b play asymmetric roles, and the operation a + b is viewed as applying the unary operation +b to a. Instead of calling both a and b addends, it is more appropriate to call a the <b>augend</b> in this case, since a plays a passive role. The unary view is also useful when discussing subtraction, because each unary addition operation has an inverse unary subtraction operation, and vice versa.|$|E
5000|$|The {{half adder}} adds two single binary digits A and B. It has two outputs, sum (S) and carry (C). The carry signal {{represents}} an overflow {{into the next}} digit of a multi-digit addition. The value of the sum in decimal system is [...] The simplest half-adder design, pictured on the right, incorporates an XOR gate for S and an AND gate for C. The Boolean logic for the sum (in this case S) will be AB+AB whereas for carry (C) will be AB. With the addition of an OR gate to combine their carry outputs, two half adders can be combined to make a full adder.The half adder adds two input bits and generates a carry and sum, which are the two outputs of a half adder. The input variables of a half adder are called the <b>augend</b> and addend bits. The output variables are the sum and carry. The truth table for the half adder is: ...|$|E
5000|$|In practice, comutational {{addition}} may achieved via XOR and AND bitwise logical {{operations in}} conjunction with bitshift operations {{as shown in the}} pseudocode below. Both XOR and AND gates are straightforward to realize in digital logic allowing the realization of full adder circuits which in turn may be combined into more complex logical operations. In modern digital computers, integer addition is typically the fastest arithmetic instruction, yet it has the largest impact on performance, since it underlies all floating-point operations as well as such basic tasks as address generation during memory access and fetching instructions during branching. To increase speed, modern designs calculate digits in parallel; these schemes go by such names as carry select, carry lookahead, and the Ling pseudocarry. Many implementations are, in fact, hybrids of these last three designs. Unlike addition on paper, addition on a computer often changes the addends. On the ancient abacus and adding board, both addends are destroyed, leaving only the sum. The influence of the abacus on mathematical thinking was strong enough that early Latin texts often claimed that in the process of adding [...] "a number to a number", both numbers vanish. In modern times, the ADD instruction of a microprocessor often replaces the <b>augend</b> with the sum but preserves the addend. In a high-level programming language, evaluating a + b does not change either a or b; if the goal is to replace a with the sum this must be explicitly requested, typically with the statement a = a + b. Some languages such as C or C++ allow this to be abbreviated as a += b.|$|E
40|$|Solution of {{arithmetic}} word problem {{requires a}} mental model of task structure that represents variables and relations between them. In arithmetic addition, three variables (<b>augend,</b> addend, sum) are related {{by the addition}} operation (English & Halford, 1995). Flexible access to {{the components of the}} relation is required especially in non-canonical word problems, in which the <b>augend</b> or addend is missing. Relational processing allows all components of a relation to be accessed, but it is effortful, and is slow to develop during childhood. Therefore, the difference in accuracy between noncanonical problems (<b>augend</b> or addend missing) and canonical problem (sum missing) should be greater in younger than older children. Furthermore, relational processing capacity should predict accuracy on non-canonical problems. In the current research, 132 children aged 6 -, 7 - and 8 - years completed arithmetic word problems in which either the <b>augend,</b> addend or sum was missing and two measures of relational processing ability. Mixed ANOVAs showed significant position effects. Accuracy was lower for problems where the missing sets were in <b>augend</b> and addend positions than in sum position. Hierarchical regression analyses showed that after controlling for accuracy on sum problems, relational processing capacity accounted {{for more than half of}} the agerelated variance in accuracy on augend/addend problems and also for significant unique age-independent variance. Findings demonstrate the importance of relational processing in development of children's arithmetic addition, and have implications for designing word problem teaching strategies. Full Tex...|$|E
40|$|In Japanese primary schools, {{children}} {{are required to}} learn the kuku (“nine nines”) method of multiplication during the formal course of mathematics. When learning, they are taught to recite it as though reciting a Chinese poem or chanting. In the present study, we undertook an experiment designed to examine the role of learing the Japanese kuku multiplication chant in arithmetic operations by requiring the participants to solve {{the three types of}} simple arithmetic problems. In each problem presentation, an equation of simple addition (e. g., 3 (three) added to 4 (four) makes 7 (seven)), of simple multiplication (e. g., 3 (three) multiplied by 4 (four) is 12 (twelve)), or of kuku (e. g., 3 (three) 4 (four) 12 (twelve)) was auditorily presented with either the addend or <b>augend</b> in the addition, or the multiplicand or multiplier in the multiplication or kuku always being acoustically masked by peep sounds so that the participants did not hear the numbers masked. Comparison of the latency to their answer across the three types of problems revealed that as a consequence of learning kuku, a learner could produce the answers for the arithmetic multiplication problems as well as the answers for the kuku problems relatively more easily as compared to the arithmetic addition problems. Implications of the results are argued with reference to the cognitive load theory, a theory of learning and education which underwent substantial development and ex-pansion during last two decades...|$|E

