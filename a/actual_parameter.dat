127|691|Public
25|$|In {{computer}} programming, two {{notions of}} parameter are commonly used, and {{are referred to}} as parameters and arguments—or more formally as a formal parameter and an <b>actual</b> <b>parameter.</b>|$|E
2500|$|... two {{different}} types, namely the function's formal and <b>actual</b> <b>parameter</b> type have ...|$|E
2500|$|... 3 is the <b>actual</b> <b>parameter</b> (the argument) for {{evaluation}} by the defined function; it {{is a given}} value (actual value) that is substituted for the formal parameter of the defined function. (In casual usage the terms parameter and argument might inadvertently be interchanged, and thereby used incorrectly.) ...|$|E
5000|$|Use the {{information}} obtained by Build parameter lists to drop <b>actual</b> <b>parameters</b> {{that are no}} longer required. drop-params has the parameters, ...|$|R
30|$|Significant {{research}} studies focused on improving the BFO algorithm’s performance. These improvements were achieved either by combining BFO with another optimization approach [9, 10] or by modifying the algorithm’s <b>actual</b> <b>parameters</b> [11].|$|R
3000|$|... 2], respectively, in this paper. By using Table 1, the {{comparisons}} of overall computation complexities between the conventional FDE and proposed TDE methods when assuming the <b>actual</b> <b>parameters</b> are evaluated in Section 4.|$|R
5000|$|Locate {{the name}} and start {{building}} the parameter list for the name, filling in the formal parameter names. Also receive any <b>actual</b> <b>parameter</b> list {{from the body of}} the expression, and return it as the <b>actual</b> <b>parameter</b> list from this expression ...|$|E
50|$|In {{this example}} the <b>actual</b> <b>{{parameter}}</b> for the formal parameter o is always p. As p {{is a free}} variable in the whole expression, the parameter may be dropped. The <b>actual</b> <b>parameter</b> for the formal parameter y is always n. However n is bound in a lambda abstraction. So this parameter may not be dropped.|$|E
50|$|Application - An {{application}} (function call) {{is processed}} to extract <b>actual</b> <b>parameter</b> details.|$|E
5000|$|If all the <b>actual</b> <b>parameters</b> {{have the}} same value, and all the free {{variables}} of that value are available for definition of the function then drop the parameter, and replace the old parameter with its value.|$|R
50|$|To {{instantiate}} {{a generic}} unit, the programmer passes <b>actual</b> <b>parameters</b> for each formal. The generic instance then behaves {{just like any}} other unit. It is possible to instantiate generic units at run-time, for example inside a loop.|$|R
5000|$|For {{the list}} class shown above, an <b>actual</b> generic <b>parameter</b> substituting for [...] {{can be any}} other {{available}} class. To constrain the set of classes from which valid <b>actual</b> generic <b>parameters</b> can be chosen, a generic constraint can be specified. In the declaration of class [...] below, the generic constraint dictates that any valid <b>actual</b> generic <b>parameter</b> will be a class that inherits from class [...] The generic constraint ensures that elements of a [...] can in fact be sorted.|$|R
50|$|For a {{function}} name or parameter start populating <b>actual</b> <b>parameter</b> list by outputting the parameter list for this name.|$|E
5000|$|It is also {{possible}} to have 'constrained' formal parameters, for which the <b>actual</b> <b>parameter</b> must inherit from a given class, the [...] "constraint". For example in ...|$|E
50|$|If no {{variable}} {{names are}} {{free in the}} <b>actual</b> <b>parameter</b> and bound in the body, beta reduction may be performed on the lambda abstraction without canonical renaming.|$|E
40|$|Parameterized {{programming}} is extended to higher order modules, by extending views, which fit <b>actual</b> <b>parameters</b> to formal parameters in a flexible way, to morphisms, with higher order module expressions to compose modules into systems. A category theoretic semantics is outlined, and examples in BOBJ show {{the power of}} morphisms...|$|R
40|$|Programs can be {{classified}} according to their construction methodologies, such as di-vide-and-conquer, top-down decomposition, global search, and so on, or any composi-tion thereof. Informally, a program schema [2] is a template program with a fixed control and data flow, but without specific indications about the <b>actual</b> <b>parameters</b> or th...|$|R
40|$|Abstract. Parameterized {{programming}} is extended to higher order modules, by extending views, which fit <b>actual</b> <b>parameters</b> to formal parameters in a flexible way, to morphisms, with higher order module expressions to compose modules into systems. A category theoretic semantics is outlined, and examples in BOBJ show {{the power of}} morphisms...|$|R
50|$|In {{computer}} programming, two {{notions of}} parameter are commonly used, and {{are referred to}} as parameters and arguments—or more formally as a formal parameter and an <b>actual</b> <b>parameter.</b>|$|E
5000|$|The naive beta-redex {{changed the}} meaning of the {{expression}} because x and y from the <b>actual</b> <b>parameter</b> became captured when the expressions were substituted in the inner abstractions.|$|E
50|$|ALGOL {{introduced}} {{the use of}} block structure and lexical scope. It was also notorious for its difficult call by name default parameter passing mechanism, which was defined so as to require textual substitution of the expression representing the <b>actual</b> <b>parameter</b> {{in place of the}} formal parameter during execution of a procedure or function, causing it to be re-evaluated each time it is referenced during execution. ALGOL implementors developed a mechanism they called a thunk, which captured the context of the <b>actual</b> <b>parameter,</b> enabling it to be evaluated during execution of the procedure or function.|$|E
5000|$|The {{parameters}} {{can be used}} by {{the drawing}} functions, and also by the production rules. The production rules can use the parameters in two ways: first, in a conditional statement determining whether the rule will apply, and second, the production rule can modify the <b>actual</b> <b>parameters.</b> For example, look at: ...|$|R
30|$|The {{platform}} used in {{this work}} is explained in details in our previous work [27]. The setup of the experimental system was divided into two configurations. The first configuration collected {{the data for the}} calibration process to find the <b>actual</b> <b>parameters</b> of the platform. The second configuration evaluated the new calibration algorithm.|$|R
30|$|According to the <b>actual</b> <b>parameters,</b> the {{three-dimensional}} transient FE model of wheel/rail rolling contact {{is created by}} ANSYS/LS-DYNA, and the single-layer track dynamic model is taken into account. Based on analysis {{of the features of}} implicit and explicit algorithm, the explicit–explicit order solution method is proposed to improve the solving speed and efficiency.|$|R
50|$|The lambda {{abstraction}} operator, λ, takes {{a formal}} parameter variable {{and a body}} expression. When evaluated the formal parameter variable is identified with {{the value of the}} <b>actual</b> <b>parameter.</b>|$|E
5000|$|... #Caption: MSE (R) {{of least}} squares {{estimator}} (ML) vs. James-Stein estimator (JS). The James-Stein estimator gives its best estimate when {{the norm of}} the <b>actual</b> <b>parameter</b> vector θ is near zero.|$|E
50|$|Beta-reduction {{captures the}} idea of {{function}} application (also called a function call), and implements the substitution of the <b>actual</b> <b>parameter</b> expression for the formal parameter variable. Beta-reduction is {{defined in terms of}} substitution.|$|E
40|$|This paper {{describes}} a language called Nimble that allows designers to declare how the <b>actual</b> <b>parameters</b> in a procedure call {{are to be}} transformed at run time. Normally, programmers must edit an application's source in order to adapt it for reuse in some new context where the interfaces fail to match exactly (e. ...|$|R
5000|$|When a class {{becomes a}} client to , the formal generic {{parameters}} are substituted with <b>actual</b> generic <b>parameters</b> in a generic derivation. In the following attribute declaration, [...] {{is to be}} used as a character string based dictionary. As such, both data and key formal generic parameters are substituted with <b>actual</b> generic <b>parameters</b> of type [...]|$|R
50|$|Dynamic {{dispatch}} {{contrasts with}} static dispatch, {{in which the}} implementation of a polymorphic operation is selected at compile-time. The purpose of dynamic dispatch is to support cases where the appropriate implementation of a polymorphic operation cannot be determined at compile time because it depends on the runtime type of one or more <b>actual</b> <b>parameters</b> to the operation.|$|R
5000|$|The alpha {{renaming}} {{removed the}} problem by changing the names of x and y in the inner abstraction {{so that they are}} distinct from the names of x and y in the <b>actual</b> <b>parameter.</b>|$|E
5000|$|In {{addition}} to the bind-class , ECL has bind-classes , , , and [...] Bind-class [...] indicates that a parameter is to be passed by reference. Bind-class [...] causes a parameter to be passed by reference if possible and by value if not (e.g., if the <b>actual</b> <b>parameter</b> is a pure value, or a variable to which a type conversion must be applied). Bind-class [...] specifies that an abstract syntax tree for the <b>actual</b> <b>parameter</b> is to be passed to the formal parameter; this provides extraordinary flexibility for programmers to invent their own notations, with their own evaluation semantics, for certain procedure parameters. Bind-class [...] is similar to , but provides a capability {{similar to that of}} varargs in C: the [...] bind-class can only appear in the last formal parameter of the procedure, and that formal parameter is bound to a list of abstract syntax tree representations, one for each remaining <b>actual</b> <b>parameter.</b> ECL has an [...] built-in function for evaluating an abstract syntax tree; alternatively, there are functions by which programmers can explore the nodes of the abstract syntax tree and process them according to their own logic.|$|E
5000|$|... 3 is the <b>actual</b> <b>parameter</b> (the argument) for {{evaluation}} by the defined function; it {{is a given}} value (actual value) that is substituted for the formal parameter of the defined function. (In casual usage the terms parameter and argument might inadvertently be interchanged, and thereby used incorrectly.) ...|$|E
40|$|AbstractIn {{this paper}} we study the {{semantics}} of the parameter passing mechanism in algebraic specification languages. More precisely, {{this problem is}} studied for parameterized data types and parameterized specifications. The given results include {{the extension of the}} model functor (which is useful for correctness proofs) and the semantic properties of the result of inserting <b>actual</b> <b>parameters</b> into parameterized specifications. In particular, <b>actual</b> <b>parameters</b> can be parameterized and the result is nested parameterized specification. Correctness of an applied (matrix(int)) or a nested (bintree(string())) parameterized specification is shown given correctness of the parts. The formal theory in this paper is restricted to the basic algebraic case where only equations are allowed in the parameter declaration and parameter passing is given by specification morphisms. But we also give the main ideas of a corresponding theory with requirements where we allow different kinds of restrictions in the parameter declaration...|$|R
50|$|A passive {{programmable}} resistance device uses {{a closed}} loop feedback for controlling resistance to rotational or translational motion of an object. One or more <b>actual</b> <b>parameters,</b> such as force or position, are measured and compared with desired parameters. The differences are used to provide a control signal which controls the resistance to {{the movement of the}} object. Patent US 4544154 A, 1985.|$|R
50|$|For each visual type, the {{acceptance}} packet contains both its identifier and the <b>actual</b> <b>parameters</b> it contains (visual class, etc.) The client stores this information, as it cannot request it afterwards. Moreover, clients cannot change or create new visual types. Requests for {{creation of a}} new window include the depth and the identifier of the visual type to use for representing colors of this window.|$|R
