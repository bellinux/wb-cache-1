29|93|Public
25|$|Buffer overflow, {{in which}} a program tries to store data past the end of {{allocated}} storage. This {{may or may not}} lead to an <b>access</b> <b>violation</b> or storage violation. These are known as security bugs.|$|E
25|$|Typed lambda calculi are {{foundational}} programming {{languages and}} are the base of typed functional programming languages such as ML and Haskell and, more indirectly, typed imperative programming languages. Typed lambda calculi {{play an important role}} in the design of type systems for programming languages; here typability usually captures desirable properties of the program, e.g. the program will not cause a memory <b>access</b> <b>violation.</b>|$|E
25|$|Using a call gate. A call gate is {{a special}} address stored by the kernel in a list in kernel memory at a {{location}} known to the processor. When the processor detects a call to that address, it instead redirects to the target location without causing an <b>access</b> <b>violation.</b> This requires hardware support, but the hardware for it is quite common.|$|E
5000|$|Abort (ABORTB) {{input and}} {{associated}} vector supports processor repairs of bus error conditions, such as page faults and memory <b>access</b> <b>violations.</b>|$|R
40|$|<b>Access</b> policy <b>violations</b> by {{organizational}} insiders {{are a major}} security {{concern for}} organizations because these violations commonly result in fraud, unauthorized disclosure, theft of intellectual property, and other abuses. Given the operational demands of dynamic organizations, current approaches to curbing <b>access</b> policy <b>violations</b> are insufficient. This study presents a new approach for reducing <b>access</b> policy <b>violations,</b> introducing both the theory of accountability and the factorial survey to the information systems field. We identify four system mechanisms that heighten an individual's perception of accountability: identifiability, awareness of logging, awareness of audit, and electronic presence. These accountability mechanisms substantially reduce intentions to commit <b>access</b> policy <b>violations.</b> These results not only point to several avenues for future research on <b>access</b> policy <b>violations</b> but also suggest highly practical design-artifact solutions {{that can be easily}} implemented with minimal impact on organizational insiders. © 2013 M. E. Sharpe, Inc. All rights reserved. Link_to_subscribed_fulltex...|$|R
50|$|Traditionally, the {{mechanisms}} {{used to control}} the correct behavior of software are implemented at the operating system level. The operating system handles several possible security violations such as memory <b>access</b> <b>violations,</b> stack overflow <b>violations,</b> <b>access</b> control <b>violations,</b> and many others. This is {{a crucial part of}} security in computer systems, however by securing the behavior of software on a more specific level, even stronger security can be achieved. Since a lot of properties and behavior of the software is lost in compilation, it is significantly more difficult to detect vulnerabilities in machine code. By evaluating the source code, before the compilation, the theory and implementation of the programming language can also be considered, and more vulnerabilities can be uncovered.|$|R
5000|$|... #Caption: A {{display at}} Frankfurt Airport running a program under Windows XP that has crashed {{due to a}} memory read <b>access</b> <b>violation</b> ...|$|E
5000|$|Despite its {{treatment}} as a pointer, not all pointer style constructs {{could be used}} to array. For example, this code would compile fine but would cause <b>access</b> <b>violation</b> when executed: ...|$|E
5000|$|Buffer overflow, {{in which}} a program tries to store data past the end of {{allocated}} storage. This {{may or may not}} lead to an <b>access</b> <b>violation</b> or storage violation. These are known as security bugs.|$|E
50|$|In {{terms of}} the x86 architecture, general {{protection}} faults are specific to segmentation-based protection {{when it comes to}} memory accesses. However, general protection faults are still used to report other protection violations (aside from memory <b>access</b> <b>violations)</b> when paging is used, {{such as the use of}} instructions not accessible from the current privilege level (CPL).|$|R
50|$|Many processors, {{such as the}} Motorola 680x0, {{feature a}} {{hardware}} trap upon encountering an illegal instruction. A correct instruction, defined in the trap vector, is executed, rather than the random one. Traps can handle a larger range errors than function tokens and NOP slides. Supplementary to illegal instructions, hardware traps securely handle memory <b>access</b> <b>violations,</b> overflows, or a division by zero.|$|R
50|$|CHESS is a {{software}} model checker for finding errors/heisenbugs in multithreaded software by systematic exploration of thread schedules. It finds errors, such as data-races, deadlocks, livelocks, and data-corruption induced <b>access</b> <b>violations,</b> that are extremely {{hard to find}} with current testing tools. Once CHESS locates an error, it provides a fully repeatable execution of the program leading to the error, thus greatly aiding the debugging process.|$|R
50|$|In computing, a {{segmentation}} fault (often shortened to segfault) or <b>access</b> <b>violation</b> is a fault, or failure condition, raised by hardware with memory protection, notifying an operating system (OS) the software {{has attempted to}} access a restricted area of memory (a memory <b>access</b> <b>violation).</b> On standard x86 computers (which includes most personal computers) this {{is a form of}} general protection fault. The OS kernel will, in response, usually perform some corrective action, generally passing the fault on to the offending process by sending the process a signal. Processes can in some cases install a custom signal handler, allowing them to recover on their own, but otherwise the OS default signal handler is used, generally causing abnormal termination of the process (a program crash), and sometimes a core dump.|$|E
50|$|Operating {{systems such}} as Windows and UNIX (and other UNIX-like systems) provide differing {{mechanisms}} for reporting errors caused by page faults. Windows uses structured exception handling to report page fault-based invalid accesses as <b>access</b> <b>violation</b> exceptions, and UNIX (and UNIX-like) systems typically use signals, such as SIGSEGV, to report these error conditions to programs.|$|E
50|$|Typed lambda calculi are {{foundational}} programming {{languages and}} are the base of typed functional programming languages such as ML and Haskell and, more indirectly, typed imperative programming languages. Typed lambda calculi {{play an important role}} in the design of type systems for programming languages; here typability usually captures desirable properties of the program, e.g. the program will not cause a memory <b>access</b> <b>violation.</b>|$|E
40|$|Abstract. Opacity of Transactional Memory is {{proposed}} to be estab-lished by incremental validation. Quiescence {{in terms of}} epoch-based memory reclamation is applied to deal with doomed transactions caus-ing memory <b>access</b> <b>violations.</b> This method unfortunately involves in-creased memory consumption and does not cover reclamations outside of transactions. This paper introduces a different method which com-bines incremental validation with elements of sandboxing to solve these issues...|$|R
40|$|Opacity of Transactional Memory is {{proposed}} {{to be established}} by incremental validation. Quiescence in terms of epoch-based memory reclamation is applied to deal with doomed transactions causing memory <b>access</b> <b>violations.</b> This method unfortunately involves increased memory consumption and does not cover reclamations outside of transactions. This paper introduces a different method which combines incremental validation with elements of sandboxing to solve these issues. Comment: Keywords: transactional memory, opacity, privatization, memory reclamatio...|$|R
40|$|Abstract. Recent work on {{transactional}} memory (TM) bears {{promise to}} exploit multicore capabilities. TM extensions for thread-level speculative parallelism (TLS) have predominantly focused on integer benchmarks with short critical sections and exploit limited on-chip buffering space to store shadow values needed to potentially abort transactions. In contrast, scientific codes generally provide coarse-grained parallel regions with potentially shared memory accesses, {{which do not}} fit into size-limited shadow buffers. Hence, such codes represent a mismatch for TM-TLS. This work contributes mechanisms to speculatively parallelize scientific codes with dense, non-scalar data references exploiting compilation techniques and runtime enhancements coupled with minor hardware enhancements to transparently support TLS. A method to efficiently detect <b>access</b> <b>violations</b> to shared memory in speculatively parallelized regions is developed, much alike TM, yet with data footprints of arbitrarily large size. The mechanism for violation detection is based on runtime software and optional hardware support to efficiently capture regular access traces. Experimental evaluations assess the speculation overhead in presence and absence of <b>access</b> <b>violations</b> considering an environment with and without hardware support. The results show that this method is competitive to explicit parallelization or auto-parallelization, yet can be applied even when data dependency checks remain inconclusive at compilation time. ...|$|R
5000|$|Using a call gate. A call gate is {{a special}} address stored by the kernel in a list in kernel memory at a {{location}} known to the processor. When the processor detects a call to that address, it instead redirects to the target location without causing an <b>access</b> <b>violation.</b> This requires hardware support, but the hardware for it is quite common.|$|E
50|$|In general, {{programs}} can exit {{at any time}} in an unstructured way, by returning to the operating system or crashing. Scripting languages typically end by reaching the end of the program, but for binaries the control must return to the operating system or it will simply run off the end of the process's memory, either executing whatever code is there or (in modern operating systems) resulting in a memory <b>access</b> <b>violation</b> and termination by the operating system.|$|E
5000|$|The 65C816's [...] {{interrupt}} input {{is intended}} to provide the means to redirect program execution when a hardware exception is detected, such as a page fault or a memory <b>access</b> <b>violation.</b> Hence the processor's response when the [...] input is asserted (negated) is different from when [...] and/or [...] are asserted. Also, achieving correct operation in response to [...] requires that the interrupt occur at the proper time during the machine cycle, whereas no such requirement exists for [...] or [...]|$|E
40|$|This work {{describes}} the {{access control system}} being implemented in INGRES (l__N_Nteractive Graphics and REtrieval S~stem). The scheme {{can be applied to}} any relational data base management system and has several advantages over other suggested schemes. These include: a) implementation ease b) small execution time overhead c) powerful and flexible controls d) conceptual simplicity The basic idea utilized is that a user interaction with the data base is modified to an alternate form which is guaranteed to have no <b>access</b> <b>violations.</b> This modification takes place in a high leve...|$|R
50|$|A more {{complicated}} but more effective {{solution is to}} implement safe memory reclamation (SMR). This is in effect lock-free garbage collection. The advantage of using SMR is the assurance a given pointer will exist only once {{at any one time}} in the data structure, thus the ABA problem is completely solved. (Without SMR, something like a freelist will be in use, to ensure that all data elements can be accessed safely (no memory <b>access</b> <b>violations)</b> even when they are no longer present in the data structure. With SMR, only elements actually currently in the data structure will be accessed).|$|R
50|$|On Linux and Solaris platforms, if {{the native}} code {{registers}} {{itself as a}} signal handler, it could intercept signals intended for the JVM. A chain of responsibility {{can be used to}} allow native code to better inter-operate with the JVM. On Windows platforms, Structured Exception Handling (SEH) may be employed to wrap native code in SEH try/catch blocks so as to capture machine (CPU/FPU) generated software interrupts (such as NULL pointer <b>access</b> <b>violations</b> and divide-by-zero operations), and to handle these situations before the interrupt is propagated back up into the JVM (i.e. Java side code), in all likelihood resulting in an unhandled exception.|$|R
5000|$|In general, {{memory access}} {{management}} is a {{responsibility of the}} operating system kernel, in combination with hardware mechanisms that provide supporting functionalities, such as a memory management unit (MMU). If a process attempts to access a memory location outside of its memory space, the MMU denies the request and signals the kernel to take appropriate actions; this usually results in forcibly terminating the offending process. Depending on the software and kernel design and the specific error in question, the user may receive an <b>access</b> <b>violation</b> error message such as [...] "segmentation fault".|$|E
50|$|The {{conditions}} under which segmentation violations occur and how they manifest themselves are specific to hardware and the operating system: different hardware raises different faults for given conditions, and different operating systems convert these to different signals that are passed on to processes. The proximate cause is a memory <b>access</b> <b>violation,</b> while the underlying cause is generally a software bug of some sort. Determining the root cause - debugging the bug - can be simple in some cases, where the program will consistently cause a segmentation fault (e.g., dereferencing a null pointer), while in other cases the bug {{can be difficult to}} reproduce and depend on memory allocation on each run (e.g., dereferencing a dangling pointer).|$|E
5000|$|In {{order for}} the {{processor}} to correctly respond to an abort, system logic must assert (negate) the [...] input {{as soon as a}} valid address has been placed on the bus and it has been determined that the address constitutes a page fault, memory <b>access</b> <b>violation</b> or other anomaly (e.g., attempted execution of a privileged instruction). Hence the logic must not assert [...] until the processor has asserted the [...] or [...] signals. Also, [...] must remain asserted until the fall of the phase-two clock and then be immediately released. If these timing constraints are not observed, the abort interrupt handler itself may be aborted, causing registers and/or memory to be changed in a possibly-undefined manner.|$|E
40|$|A {{compiler}} for multi-threaded object-oriented programs needs {{information about}} the sharing of objects {{for a variety of}} reasons: to implement optimizations, to issue warnings, to add instrumentation to detect <b>access</b> <b>violations</b> that occur at runtime. An Object Use Graph (OUG) statically captures accesses from different threads to objects. An OUG extends the Heap Shape Graph (HSG), which is a compile-time abstraction for runtime objects (nodes) and their reference relations (edges). An OUG specifies for a specific node in the HSG a partial order of events relevant to the corresponding runtime object(s). Relevant events include read and write access, object escape, thread start and join. OUGs have been implemented [...] ...|$|R
40|$|Object {{identification}} and tracking have become critical for automated on-site construction safety assessment. The primary {{objective of this}} paper is to present the development of a testbed to analyze the impact of object {{identification and}} tracking errors caused by data collection devices and algorithms used for safety assessment. The testbed models workspaces for earthmoving operations and simulates safety-related violations, including speed limit <b>violations,</b> <b>access</b> <b>violations</b> to dangerous areas, and close proximity violations between heavy machinery. Three different cases were analyzed based on actual earthmoving operations conducted at a limestone quarry. Using the testbed, the impacts of device and algorithm errors were investigated for safety planning purposes...|$|R
50|$|In {{principle}} this shuffling method {{can even}} result in program failures like endless loops or <b>access</b> <b>violations,</b> because the correctness of a sorting algorithm {{may depend on}} properties of the order relation (like transitivity) that a comparison producing random values will certainly not have.While this kind of behaviour should not occur with sorting routines that never perform a comparison whose outcome can be predicted with certainty (based on previous comparisons), there can be valid reasons for deliberately making such comparisons. For instance the fact that any element should compare equal to itself allows using them as sentinel value for efficiency reasons, {{and if this is}} the case, a random comparison function would break the sorting algorithm.|$|R
5000|$|The No-Execute bit or NX bit (bit 63 of {{the page}} table entry) allows the {{operating}} system to specify which pages of virtual address space can contain executable code and which cannot. An attempt to execute code from a page tagged [...] "no execute" [...] {{will result in a}} memory <b>access</b> <b>violation,</b> similar to an attempt to write to a read-only page. This should {{make it more difficult for}} malicious code to take control of the system via [...] "buffer overrun" [...] or [...] "unchecked buffer" [...] attacks. A similar feature has been available on x86 processors since the 80286 as an attribute of segment descriptors; however, this works only on an entire segment at a time.|$|E
5000|$|Loading {{a library}} causes memory to be allocated; the library must be deallocated {{in order to}} avoid a memory leak. Additionally, failure to unload a library can prevent {{filesystem}} operations on the file which contains the library. Unloading the library is accomplished with [...] on Windows and with [...] on UNIX-like operating systems. However, unloading a DLL can lead to program crashes if objects in the main application refer to memory allocated within the DLL. For example, if a DLL introduces a new class and the DLL is closed, further operations on instances of that class from the main application will likely cause a memory <b>access</b> <b>violation.</b> Likewise, if the DLL introduces a factory function for instantiating dynamically loaded classes, calling or dereferencing that function after the DLL is closed leads to undefined behaviour.|$|E
50|$|A general {{protection}} fault (GPF) in the Intel x86 and AMD x86-64 instruction set architectures (ISAs), {{as well as}} other ISAs, is a fault (a type of interrupt) initiated by ISA-defined protection mechanisms in response to an <b>access</b> <b>violation</b> caused by some running code, either in the kernel or a user program. The mechanism is first described in Intel manuals and datasheets for the 80286 CPU, which was introduced in 1983; it is also described in section 9.8.13 in the Intel 80386 programmer's reference manual from 1986. A {{general protection}} fault is implemented as an interrupt (vector number 13 in decimal) in both the x86 and the AMD64 architectures. Some operating systems may also classify some exceptions not related to access violations, such as illegal opcode exceptions, as general protection faults, even though they {{have nothing to do with}} memory protection.|$|E
5000|$|An {{infinite}} loop (or endless loop) is {{a sequence of}} instructions in a computer program which loops endlessly, either due to the loop having no terminating condition, having one {{that can never be}} met, or one that causes the loop to start over. In older operating systems with cooperative multitasking, {{infinite loop}}s normally caused the entire system to become unresponsive. With the now-prevalent preemptive multitasking model, infinite loops usually cause the program to consume all available processor time, but can usually be terminated by the user. Busy wait loops are also sometimes called [...] "infinite loops". One possible cause of a computer [...] "freezing" [...] is an infinite loop; others include thrashing, deadlock, and <b>access</b> <b>violations.</b>|$|R
30|$|Revoke {{certificate}} It {{has to be}} {{ensured that}} certificates once handed out by the π-Box can be revoked to exclude devices from the π-Cloud if {{they are responsible for}} <b>access</b> <b>violations</b> or other harmful behaviour. The revoking has to be initiated by a component of the π-Box which sends the ID of the device that has to be excluded from the π-Cloud. After the Device Directory added the certificate of the corresponding device to the revoke certification list, a list of the connected devices is requested which leads the Device Directory to return a list of them. A request should then be send to all devices of the list in order to cause each of them to add the undesired device to the own revoke certification list.|$|R
40|$|Program-synchronous exceptions, for example, breakpoints, watchpoints, illegal opcodes, {{and memory}} <b>access</b> <b>violations,</b> provide {{information}} about exceptional conditions, interrupting the program and vectoring to an operating system handler. Over the last decade, however, programs and run-time systems have increasingly employed these mechanisms as a performance optimization to detect normal and expected conditions. Unfortunately, current architecture and operating system structures are designed for exceptional or erroneous conditions, where performance is of secondary importance, rather than normal conditions. Consequently, this has limited the practicality of such hardware-based detection mechanisms. We propose both hardware and software structures that permit efficient handling of synchronous exceptions by user-level code. We demonstrate a software implementation that reduces exceptiondelivery cost by an order-of-magnitude on current RISC processors, and show the performance benefits o [...] ...|$|R
