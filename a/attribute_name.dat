73|1131|Public
50|$|The <b>attribute</b> <b>name</b> is {{considered}} case-insensitive.|$|E
5000|$|A tuple is {{basically}} {{the same thing as}} a row, except in an SQL DBMS, where the column values in a row are ordered. (Tuples are not ordered; instead, each attribute value is identified solely by the <b>attribute</b> <b>name</b> and never by its ordinal position within the tuple.) An <b>attribute</b> <b>name</b> might be [...] "name" [...] or [...] "age".|$|E
5000|$|Delete_Attribute: Unbind an <b>attribute</b> <b>name</b> from a {{value and}} remove the name from the u-form ...|$|E
5000|$|The {{natural join}} can be {{simulated}} with Codds primitives as follows. Let c1, …, cm be the <b>attribute</b> <b>names</b> common to R and S, r1, …, rn be the <b>attribute</b> <b>names</b> unique to R and let s1, …, sk be the attributes unique to S. Furthermore, {{assume that the}} <b>attribute</b> <b>names</b> x1, …, xm are neither in R nor in S. In a first step the common <b>attribute</b> <b>names</b> in S can now be renamed: ...|$|R
5000|$|The {{simulation}} {{of the division}} with the basic operations is as follows. We assume that a1,...,an are the <b>attribute</b> <b>names</b> unique to R and b1,...,bm are the <b>attribute</b> <b>names</b> of S. In the first step we project R on its unique <b>attribute</b> <b>names</b> and construct all combinations with tuples in S: ...|$|R
5000|$|The {{natural join}} can be {{simulated}} with Codd's primitives as follows. Assume that c1,...,cm are the <b>attribute</b> <b>names</b> common to R and S, r1,...,rn are theattribute names unique to R and s1,...,sk are theattribute unique to S. Furthermore, {{assume that the}} <b>attribute</b> <b>names</b> x1,...,xm are neither in R nor in S. In a first step we can now rename the common <b>attribute</b> <b>names</b> in S: ...|$|R
5000|$|Set_Attribute: Bind an <b>attribute</b> <b>name</b> to a value (replacing any {{existing}} binding to that name) ...|$|E
5000|$|Leading and {{trailing}} whitespace (spaces and tabs) in the <b>attribute</b> <b>name</b> {{are ignored}} {{unless they are}} quoted (with a [...] "`").|$|E
50|$|For the Cartesian {{product to}} be defined, the two {{relations}} involved must have disjoint headers—that is, {{they must not}} have a common <b>attribute</b> <b>name.</b>|$|E
50|$|In the {{resulting}} relation, tuples in R which have no common values in common <b>attribute</b> <b>names</b> with tuples in S take a null value, ω. Tuples in S which have no common values in common <b>attribute</b> <b>names</b> with tuples in R {{also take a}} null value, ω.|$|R
40|$|Overview of Data Contains 3 {{tables in}} SQL format: **Table 1 (apache_datasources) :** List of Apache Data sources <b>Attributes</b> (<b>Name,</b> Type) : `datasource_id` Integer `item_description` Character `date_posted` Date `date_collected` Date `method` Character `item_url` Character `last_updated` Date **Table 2 (apache_people_projects) :** List of people {{committing}} various projects <b>Attributes</b> (<b>Name,</b> Type) : `svn_id` Character `real_name` Character `web_site` Character `datasource_id` Integer `project_name` Character `role_on_project` Character `details` Character `email` Character `organization` Character `last_updated` Date **Table 3 (apache_unlisted_cla) :** List {{of people with}} signed CLAs but are not committers <b>Attributes</b> (<b>Name,</b> Type) : `real_name` Character `datasource_id` Integer `last_updated` Dat...|$|R
25|$|Our own <b>attributes</b> (<b>name</b> and sign) live on today.|$|R
50|$|The Compare {{operation}} takes a DN, an <b>attribute</b> <b>name</b> and {{an attribute}} value, and checks if the named entry contains that attribute with that value.|$|E
5000|$|For each file in the MFT, the {{attributes}} identified by attribute type, <b>attribute</b> <b>name</b> must be unique. Additionally, NTFS has some ordering constraints for these attributes.|$|E
50|$|Some {{attribute}} types function differently {{when used}} to modify different element types. For example, the <b>attribute</b> <b>name</b> {{is used by}} several element types, but has slightly different functions in each.|$|E
5000|$|<b>Attribute</b> <b>names</b> are case-folded and {{normalized}} {{strings of}} Unicode characters ...|$|R
25|$|XML is case-sensitive for element and <b>attribute</b> <b>names,</b> while HTML is not.|$|R
50|$|The Unified Modeling Language (UML) {{supports}} {{a kind of}} <b>attribute</b> <b>named</b> Stereotypes.|$|R
5000|$|On the opposite, {{the default}} data stream of {{directories}} {{has a distinct}} type, but are not anonymous: they have an <b>attribute</b> <b>name</b> ("$I30" [...] in NTFS 3+) that reflects its indexing format.|$|E
50|$|Whereby the Prefix {{is used as}} {{placeholder}} for the namespace and the LocalPart as {{the local}} part of the qualified name. A local part can be an <b>attribute</b> <b>name</b> or an element name.|$|E
50|$|Attributes may be {{specified}} {{anywhere in}} a normal line. In addition to the '@' symbol, attributes always use a pair of braces ('{' and '}') to enclose the <b>attribute</b> <b>name</b> and possibly additional arguments.|$|E
5000|$|A tuple is {{a partial}} {{function}} from <b>attribute</b> <b>names</b> to atomic values.|$|R
50|$|More {{formally}} the semantics of {{the division}} is defined as follows:where {a1,...,an} is the set of <b>attribute</b> <b>names</b> unique to R and ta1,...,an is the restriction of t to this set. It is usually required that the <b>attribute</b> <b>names</b> in the header of S are a subset of those of R because otherwise {{the result of the}} operation will always be empty.|$|R
5000|$|Directory schemas are object classes, <b>attributes,</b> <b>name</b> {{bindings}} {{and knowledge}} (namespaces) where an object class has: ...|$|R
5000|$|During lookups, TXT {{records that}} do not contain an unquoted [...] "=" [...] are ignored. TXT records that seem to contain a null <b>attribute</b> <b>name,</b> that is, the TXT-DATA starts with the {{character}} [...] "=", are also ignored.|$|E
50|$|To store {{new types}} of information, the {{experimental}} RFC 1464 suggests a structured format in TXT data fields. The format consists of the <b>attribute</b> <b>name</b> followed by {{the value of the}} attribute. The name and value are separated by an equals sign (=).|$|E
5000|$|Legacy HTML {{and early}} SVG {{versions}} bind events to presentation elements by encoding the event name in an <b>attribute</b> <b>name,</b> {{such that the}} value of the attribute is the action for that event at that element. For example, (with Javascript’s onclick attribute): ...|$|E
25|$|Bodily <b>attribute</b> <b>names</b> {{are family}} {{names such as}} Krause (curly), Schwarzkopf (black head), Klein (small), Groß (big).|$|R
5000|$|A {{functional}} dependency (FD for short) is written as [...] for [...] finite sets of <b>attribute</b> <b>names.</b>|$|R
5000|$|Bodily <b>attribute</b> <b>names</b> {{are family}} {{names such as}} Krause (curly), Schwarzkopf (black head), Klein (small), Groß (big).|$|R
5000|$|Attribute declarations, which define {{properties}} of attributes. Again the properties include the <b>attribute</b> <b>name</b> and target namespace. The attribute type constrains {{the values that}} the attribute may take. An attribute declaration may also include a default value or a fixed value (which is then the only value the attribute may take.) ...|$|E
5000|$|... xupl doesn't require closing tags {{at the end}} of the document. This {{facilitates}} limited streaming {{of content}} into a document. To facilitate terse documents and demonstrated by the HTML example above, one <b>attribute</b> <b>name</b> per tag (and per namespace) is optional for which the xupl parser will provide the default name.|$|E
5000|$|The {{attribute}} or parameter: typically implemented as {{a foreign}} key into a table of attribute definitions. The attribute definitions table might contain the following columns: an attribute ID, <b>attribute</b> <b>name,</b> description, data type, and columns assisting input validation, e.g., maximum string length and regular expression, set of permissible values, etc.|$|E
5000|$|Attributes are {{additional}} values {{associated with each}} document {{that can be used}} to perform additional filtering and sorting during search. <b>Attributes</b> are <b>named.</b> <b>Attribute</b> <b>names</b> are case insensitive. Attributes are not full-text indexed; they are stored in the index as is. Currently supported attribute types are: ...|$|R
50|$|The full {{outer join}} is written as R ⟗ S where R and S are relations. The {{result of the}} full outer join is the set of all {{combinations}} of tuples in R and S that are equal on their common <b>attribute</b> <b>names,</b> in addition to tuples in S that have no matching tuples in R and tuples in R that have no matching tuples in S in their common <b>attribute</b> <b>names.</b>|$|R
5000|$|So {{what remains}} to be done is take the {{projection}} of R on itsunique <b>attribute</b> <b>names</b> and subtract those in V: ...|$|R
