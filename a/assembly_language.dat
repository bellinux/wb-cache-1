2220|221|Public
5|$|An Introduction to Computer Programming and Data Structures using MACRO-11 (1981). MACRO-11 was an <b>assembly</b> <b>language</b> for PDP-11 computers.|$|E
5|$|Although C# {{applications}} {{are intended to}} be economical with regard to memory and processing power requirements, the language {{was not intended to}} compete directly on performance and size with C or <b>assembly</b> <b>language.</b>|$|E
5|$|Harvard had a DEC PDP-10 {{that was}} {{available}} for student use. They would use it to develop BASIC. While Allen modified their development software for the new 8080 microprocessor, Gates began writing 8080 <b>assembly</b> <b>language</b> by hand on yellow legal pads. They enlisted another Harvard student, Monte Davidoff, to write the math routines.|$|E
5000|$|Some <b>assembly</b> <b>languages</b> (Microchip) use the {{notation}} [...] (for ABCD16).|$|R
50|$|<b>Assembly</b> <b>languages</b> are {{categorized}} as second-generation programming languages, and are machine-dependent.|$|R
50|$|Second-generation {{programming}} language (2GL) is a generational way to categorize <b>assembly</b> <b>languages.</b>|$|R
5|$|In August 2003, {{the game}} was {{released}} as freeware with its <b>assembly</b> <b>language</b> source code by Revolution Software. The source code availability {{made it possible for}} the ScummVM project to support the game, which allows the game to be played on Windows, OS X, Linux, Windows CE and other compatible operating systems and platforms.|$|E
5|$|MacPaint {{was written}} by Bill Atkinson, a member of Apple's {{original}} Macintosh development team. The original MacPaint consisted of 5,804 lines of Pascal computer code, augmented by another 2,738 lines of 68000 <b>assembly</b> <b>language.</b> MacPaint's user interface was designed by Susan Kare, {{also a member of}} the Macintosh team. Kare also beta-tested MacPaint before release.|$|E
5|$|SAS version 4 {{had limited}} features, but made SAS more accessible. Version 5 {{introduced}} a complete macro language, array subscripts, and a full-screen interactive user interface called Display Manager. In 1985, SAS was rewritten in the C programming language. This {{allowed for the}} SAS' Multivendor Architecture that allows the software to run on UNIX, MS-DOS, and Windows. It was previously written in PL/I, Fortran, and <b>assembly</b> <b>language.</b>|$|E
25|$|In some <b>assembly</b> <b>languages</b> like MIPS, the $ sign {{is used to}} {{represent}} registers.|$|R
50|$|<b>Assembly</b> <b>languages</b> and {{low-level}} languages like BCPL {{generally have}} no syntactic support for arrays.|$|R
50|$|Typed <b>assembly</b> <b>languages</b> usually {{include a}} {{high-level}} memory management {{system based on}} garbage collection.|$|R
5|$|Software was {{distributed}} through print media; magazines and books. The reader would type the BASIC program listing {{into the computer}} by hand, run it, and could save it to tape for later use. Software distributed in this way was in general simpler and slower than its <b>assembly</b> <b>language</b> counterparts. Magazines printed long lists of checksummed hexadecimal digits with machine code games or tools.|$|E
5|$|There was no <b>assembly</b> <b>language</b> defined for the Mark 1. Programs had to {{be written}} and {{submitted}} in binary form, encoded as eight 5-bit characters for each 40-bit word; programmers were encouraged to memorize the modified ITA2 coding scheme to make their job easier. Data was read and written from the papertape punch under program control. The Mark 1 had no system of hardware interrupts; the program continued after a read or write operation had been initiated until another input/output instruction was encountered, {{at which point the}} machine waited for the first to complete.|$|E
5|$|As Thompson began porting {{the game}} to the new system, {{he decided not to}} base the code on any of the {{existing}} software for the computer, and instead write his own. As a result, he implemented his own base code libraries for programs to use, including arithmetic packages and graphics subsystems. These initial subsystems were coded in <b>assembly</b> <b>language</b> on the GECOS system and assembled, then the output physically put on punched tapes to be carried over and inserted into the PDP-7. Thompson then wrote an assembler for the PDP-7 to avoid this laborious process. The game ran very slowly on the new machine, causing Thompson to branch out from there to design his own file system based on some ideas by Dennis Ritchie and Rudd Canaday, rooted in their experience with the Multics file system, with which he then ran Space Travel.|$|E
5000|$|In some <b>assembly</b> <b>languages</b> like MIPS, the $ sign {{is used to}} {{represent}} registers.|$|R
50|$|In {{computer}} programming, {{addressing modes}} are primarily {{of interest to}} compiler writers and to those who write in <b>assembly</b> <b>languages.</b>|$|R
50|$|Other {{languages}} (for instance, some <b>assembly</b> <b>languages</b> and LISP dialects, CONFIG.SYS and INI files) use semicolons to {{mark the}} beginning of comments.|$|R
5|$|Byte {{magazine}} {{published an}} <b>assembly</b> <b>language</b> version of Spacewar in 1977 that {{ran on the}} Altair 8800 and other Intel 8080-based microcomputers using an oscilloscope as the graphical display and a lookup table for orbits, {{as well as a}} three-dimensional variant in 1979 written in Tiny BASIC. More modern recreations of the game for computers have been made as well. An emulated version of the original game, based on the original source code made publicly available by Martin Graetz and running in a JavaScript PDP-1 emulator, was made available to play on the internet in 2012. The only working PDP-1s that are known to exist are kept in the Computer History Museum in Mountain View, California, where demonstrations of the machine are held, which include playing Spacewar.|$|E
5|$|Development {{started by}} {{focusing}} on the game's hardware. The staff first debated what type of monitor to use: black and white or color. They reasoned that using advanced technology would better establish them as good designers and chose a color monitor. The developers estimated that the game would require 4colors, but instead chose hardware that could display each pixel in 16colors. At the time, the designers believed that was more than they would ever need for a game. The monitor's resolution is 320×256, an expansion from the then industry standard of 256×256. The staff believed that the wider screen provided a better aspect ratio and would improve the game's presentation. Video games at the time relied on hardware to animate graphics, but the developers decided to use software to handle animation and programmed the game in <b>assembly</b> <b>language.</b> The switch allowed them to display more on-screen objects at a lower cost.|$|E
5|$|Joust was {{developed}} by Williams Electronics, with John Newcomer as the lead designer. Programmer Bill Pfutzenrueter and artists Jan Hendricks and Python Anghelo assisted him. Tim Murphy and John Kotlarik handled the audio design. The game features amplified monaural sound and raster graphics on a 19-inch color CRT monitor. Like other Williams arcade games, Joust was programmed in <b>assembly</b> <b>language.</b> A pack of three AA batteries provide power to save the game's settings and high scores when the machine is unplugged from an electrical outlet. The cabinet artwork, by Anghelo, is stenciled on a wooden frame. Anghelo also designed artwork for promotional materials; one such flyer featured archaic English, which was also incorporated into the game's onscreen instructions and game-over message.|$|E
5000|$|In some <b>assembly</b> <b>languages,</b> {{for example}} {{that for the}} MOS Technology 6502, the {{mnemonic}} [...] "RTS" [...] (ReTurn from Subroutine) is used.|$|R
50|$|Most <b>assembly</b> <b>languages</b> {{and some}} {{low-level}} languages, such as BCPL (Basic Combined Programming Language), lack built-in support for data structures. On the other hand, many high-level programming languages and some higher-level <b>assembly</b> <b>languages,</b> such as MASM, have special syntax or other built-in support for certain data structures, such as records and arrays. For example, the C (a direct descendant of BCPL) and Pascal languages support structs and records, respectively, {{in addition to}} vectors (one-dimensional arrays) and multi-dimensional arrays.|$|R
50|$|SASM (SimpleASM) — {{a simple}} Open Source crossplatform {{integrated}} development environment for NASM, MASM, GAS and FASM <b>assembly</b> <b>languages</b> with syntax highlighting and debugger.|$|R
5|$|The Radar System Improvement Program (RSIP) was a joint US/NATO {{development}} program. RSIP {{enhances the}} operational {{capability of the}} E-3 radars' electronic countermeasures, and dramatically improve the system's reliability, maintainability, and availability. Essentially, this program replaced the older transistor-transistor logic (TTL) and emitter-coupled logic (MECL) electronic components, long-since out of production, with off-the-shelf digital computers that utilised a High-level programming language instead of <b>assembly</b> <b>language.</b> Significant improvement came from adding pulse compression to the pulse-Doppler mode, replacing the old 8-bit FFT with 24-bit FFTs, and the 12-bit A/D (Sign + 12-bits) with a 15-bit A/D (Sign + 15-bits). These hardware and software modifications improve the E-3 radars' performance, providing enhanced detection with an emphasis towards low radar cross-section (RCS) targets.|$|E
5|$|Mainframe {{computers}} are computers used primarily by businesses and academic institutions for large-scale processes. Before personal computers, first termed microcomputers, became widely {{available to the}} general public in the 1970s, the computing industry was composed of mainframe computers and the relatively smaller and cheaper minicomputer variant. During the mid to late 1960s, many early video games were programmed on these computers. Developed prior to the rise of the commercial video game industry in the early 1970s, these early mainframe games were generally written by students or employees at large corporations in a machine or <b>assembly</b> <b>language</b> that could only be understood by the specific machine or computer type they were developed on. While many of these games were lost as older computers were discontinued, some of them were ported to high-level computer languages like BASIC, had expanded versions later released for personal computers, or were recreated for bulletin board systems years later, thus influencing future games and developers.|$|E
5|$|The {{development}} toolkit for the Motorola CPU {{included a}} compiler for the C programming language, {{which the two}} programmers were familiar with. After Atari had conducted performance evaluations, it approved usage of the language. Cerny and Flanagan's decision to program Marble Madness in the C language had positive and negative consequences. Atari games had previously been programmed in <b>assembly</b> <b>language.</b> The C language was easier to program, but was less efficient, so the game operates at the slower speed of 30Hz instead of the normal 60Hz frequency of arcade games at the time. Cerny decided to use a trackball system (marketed by Atari as Trak-Ball) to give the game a unique control system, and he chose a motorized trackball for faster spinning and braking when the in-game ball traveled downhill and uphill, respectively. As it was building the prototypes, Atari's design department informed Cerny that the motorized trackball's design had an inherent flaw—one of the four supports had poor contact with the ball—and {{the use of a}} regular trackball was more feasible. Additionally, Cerny had anticipated the use of powerful custom chips that would allow RAM-based sprites to be animated by the CPU, but the available hardware was a less-advanced system using ROM-based, static sprites.|$|E
5000|$|Simply calling {{back the}} routine whose address {{is on the}} top of the stack, does not, of course, exhaust the {{possibilities}} in <b>assembly</b> <b>language(s)!</b> ...|$|R
5000|$|Other <b>assembly</b> <b>languages</b> (6502, Motorola), Pascal, Delphi, some {{versions}} of BASIC (Commodore), Game Maker Language, Godot and Forth use [...] as a prefix: [...]|$|R
50|$|Some {{languages}} can statically link data inline with instructions. These can {{be considered}} data-structured, in the most primitive way. Some <b>Assembly</b> <b>languages</b> can do this.|$|R
25|$|<b>Assembly</b> <b>language</b> {{is still}} taught in most {{computer}} science and electronic engineering programs. Although few programmers today regularly work with <b>assembly</b> <b>language</b> as a tool, the underlying concepts remain very important. Such fundamental topics as binary arithmetic, memory allocation, stack processing, character set encoding, interrupt processing, and compiler design {{would be hard}} to study in detail without a grasp of how a computer operates at the hardware level. Since a computer's behavior is fundamentally defined by its instruction set, the logical way to learn such concepts is to study an <b>assembly</b> <b>language.</b> Most modern computers have similar instruction sets. Therefore, studying a single <b>assembly</b> <b>language</b> is sufficient to learn: I) the basic concepts; II) to recognize situations where the use of <b>assembly</b> <b>language</b> might be appropriate; and III) to see how efficient executable code can be created from high-level languages. This is analogous to children needing to learn the basic arithmetic operations (e.g., long division), although calculators are widely used for all except the most trivial calculations.|$|E
25|$|Historically, {{numerous}} {{programs have}} been written entirely in <b>assembly</b> <b>language.</b> Operating systems were entirely written in <b>assembly</b> <b>language</b> until {{the introduction of the}} Burroughs MCP (1961), which was written in Executive Systems Problem Oriented Language (ESPOL), an Algol dialect. Many commercial applications were written in <b>assembly</b> <b>language</b> as well, including a large amount of the IBM mainframe software written by large corporations. COBOL, FORTRAN and some PL/I eventually displaced much of this work, although a number of large organizations retained assembly-language application infrastructures well into the 1990s.|$|E
25|$|Paul Carter: PC <b>Assembly</b> <b>Language.</b> Free ebook, 2001.|$|E
25|$|Labels in X# {{are mostly}} {{equivalent}} to labels in other <b>assembly</b> <b>languages.</b> The instruction {{to jump to}} a label uses the goto mnemonic, {{as opposed to the}} conventional jump or jmp mnemonic.|$|R
50|$|Tombstones are a {{mechanism}} to detect dangling pointers that can appear in certain computer programming languages, e. g. C, C++ and <b>assembly</b> <b>languages,</b> and {{to act as a}} containment to their dangerous effects.|$|R
50|$|There {{are both}} high- and {{low-level}} programming languages that use non-structured programming. Some languages commonly cited as being non-structured include JOSS, FOCAL, TELCOMP, <b>assembly</b> <b>languages,</b> MS-DOS batch files, and early versions of BASIC, Fortran, COBOL, and MUMPS.|$|R
