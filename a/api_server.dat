19|86|Public
50|$|The <b>API</b> <b>server</b> {{is a key}} {{component}} and serves the Kubernetes API using JSON over HTTP, which provides both {{the internal and external}} interface to Kubernetes. The <b>API</b> <b>server</b> processes and validates REST requests and updates state of the API objects in etcd, thereby allowing clients to configure workloads and containers across Worker nodes.|$|E
50|$|RESTHeart is a Java {{open source}} Web <b>API</b> <b>server</b> built {{on top of}} the MongoDB database.|$|E
50|$|In February 2013, Opscode {{released}} version 11 of Chef. Changes in this release {{included a}} complete rewrite {{of the core}} <b>API</b> <b>server</b> in Erlang.|$|E
5000|$|Computer data logging: logging <b>APIs,</b> <b>server</b> logs & syslog, web logging & web {{counters}} ...|$|R
50|$|Searchlight {{provides}} {{advanced and}} consistent search capabilities across various OpenStack cloud services. It accomplishes this by offloading user search queries from other OpenStack <b>API</b> <b>servers</b> by indexing their data into ElasticSearch. Searchlight is being integrated into Horizon and {{also provides a}} Command-line interface.|$|R
5000|$|... 2015-06-04 - version 0.8.0 released, {{client to}} <b>server</b> <b>API</b> {{improved}} ...|$|R
5000|$|OpenSocial {{acknowledged}} that the [...] "one-size-fits-all" [...] approach it was taking {{was not going to}} work for the diverse type of websites that had adopted the platform. To address this issue, OpenSocial modularized into four compliance modules: Core <b>API</b> <b>Server,</b> Core Gadget Server, Social <b>API</b> <b>Server,</b> and Social Gadget Server. This allowed a developer to pick and choose the modules they wanted to use while using other services that aren't part of OpenSocial. Extensions were introduced to allow developers to extend OpenSocial containers.|$|E
5000|$|The {{controller}} {{manager is}} the process that the core Kubernetes controllers like DaemonSet Controller and Replication Controller run in. The controllers communicate with the <b>API</b> <b>server</b> to create, update and delete the resources they manage (pods, service endpoints, etc.) ...|$|E
5000|$|SensorUp Inc. is an Internet of Things {{company based}} in Calgary, Alberta, Canada. SensorUp led the {{development}} of the Open Geospatial Consortium SensorThings API standard specification, an open and unified geospatial framework to interconnect IoT sensing devices, data, and applications over the Web. In 2014, SensorUp received funding supports from Natural Resources Canada's GeoConnections and TecTerra. In 2016, as part of the OGC Internet of Things pilot project SensorUp demonstrated its interoperable OGC SensorThings API platform solution at the Department of Homeland Security. Dr. Reginald Brothers, the Undersecretary of the Homeland Security Science and Technology, was [...] "impressed with the ‘state of the practical’ where these various industry sensors can be integrated today using open standards that remove the stovepipe limitations of one-off technologies. [...] " [...] In March 2016 SensorUp submitted a new open source software project proposal, titled Whiskers, to the Eclipse Foundation. Whiskers will be an open source Javascript client library for the OGC SensorThings API and a light-weight OGC SensorThings <b>API</b> <b>server</b> for IoT gateways (e.g., Raspberry Pi).|$|E
5000|$|Support common {{existing}} {{use cases of}} HTTP, such as desktop web browsers, mobile web browsers, web <b>APIs,</b> web <b>servers</b> at various scales, proxy servers, reverse proxy servers, firewalls, and content delivery networks.|$|R
5000|$|Rich client UI {{development}} with <b>API</b> access to <b>server</b> state and automatic high speed DOM-based page refresh ...|$|R
5000|$|Version 5.1: {{production}} release 27 November 2008 (event scheduler, partitioning, plugin <b>API,</b> row-based replication, <b>server</b> log tables) ...|$|R
30|$|In {{order to}} avoid this kind of delays and to {{minimize}} the time to scale, we implemented a faster scaling method in the <b>API</b> <b>Server</b> calling a specific entry of the load balancing plugin each 10 seconds. The encrypted call transmits collective cluster information consisting of all edge server heartbeats including a timestamp. A history of the last minute of heartbeats is kept in memory to determine the actual progression of load. Depending on the load history the necessary measures like cluster resizing are initiated by the <b>API</b> <b>Server.</b>|$|E
30|$|This {{component}} builds {{an abstract}} layer of all components below and provides functionalities to control, launch and terminate clusters. First {{of all the}} control component performs validity and integrity checks of parameters supplied to instantiate a cluster component instance. After the instantiation the cluster is passed to the analysis component taking over responsibility of cluster operations. The current implementation of the web interface uses an RMI Interface to connect to the <b>API</b> <b>server.</b>|$|E
40|$|We {{introduce}} an open-source {{implementation of}} a machine translation <b>API</b> <b>server.</b> The aim of this software package is to enable anyone to run their own multi-engine translation server with neural machine translation engines, supporting an open API for client applications. Besides the hub {{with the implementation of}} the client API and the translation service providers running in the background we also describe an open-source demo web application that uses our software package and implements an online translation tool that supports collecting translation quality comparisons from users...|$|E
5000|$|WSAPI - a web <b>server</b> <b>API</b> that abstracts the {{web server}} from Lua web {{applications}} a la Rack and WSGI ...|$|R
50|$|Qore's {{standard}} runtime library supports data mapping, APIs {{for communicating}} with databases (including high-level APIs for SQL operations, schema management, and DBA actions), client <b>APIs</b> and <b>server</b> infrastructure implementations for many protocols including HTTP, REST, WebSocket, RPC protocols, and many file format and file- and data-exchange protocols.|$|R
50|$|Swagger-Codegen {{contains}} a template-driven engine to generate documentation, <b>API</b> clients and <b>server</b> stubs {{in different languages}} by parsing the OpenAPI definition.|$|R
40|$|The thesis {{deals with}} an Annotation server module design and its {{implementation}} in the Decipher project. The {{purpose of the}} module is to suggest annotations for document that the user works with. One will find the Annotation server and the SEC Store <b>API</b> <b>server</b> description {{in the beginning of}} the thesis. A major part of the document presents a design and an implementation of the solution. Standalone part of the thesis deals with a module functionalities testing in the system environment. The communication protocol between both servers definition and description is also included in this document...|$|E
40|$|This work {{deals with}} {{traveling}} salesman problem (TSP) and examines it’s {{possibilities to use}} in business. It is about the optimization of the travel cost, saving time and unnecessary mileage. Part {{of the work is}} a program with a GUI written in program MATLAB. Program uses neural networks to calculate the most effective path between places, where the trader has to reach. It’s possible to use the algorithm for many purposes, e. g. distribution of goods, store management, planning of PCBs or rescue services. Program communicates with the Google Maps <b>API</b> <b>server,</b> which provides the actual information of the path...|$|E
30|$|In detail, Figure  5 {{shows the}} {{physical}} and virtual servers and the modules in each server. For example, in the OpenStack <b>API</b> <b>server</b> case, this server is a virtual server, it is in both the Internet segment and the Control segment, and its modules are a Cinder scheduler, Cinder API, nova-api, keystone, glance-registry, and nova-scheduler. Two servers are used for redundancy. Other servers are the proposed automatic verification server, a user terminal and an operator terminal, Glance application servers for image upload, NFS storage for images, template servers for tenant replication, a DB for OpenStack and test cases, OpenStack servers for virtual resources, iSCSI storage for the data of these servers, and load balancers for load balancing.|$|E
5000|$|This {{dashboard}} provides easy-to-use client-side visualisation of Internet-of-Things {{sensor data}} from OGC SensorThings <b>API</b> compatible <b>servers.</b> Various types of widgets {{can be arranged}} and configured on the dashboard. It is a web application and can be embedded into any website. A live demo {{is available on the}} project page.https://github.com/SensorThings-Dashboard/SensorThings-Dashboard ...|$|R
30|$|Figure  5 is a {{performance}} measurement environment. It shows physical and virtual servers and modules in each server. For example in TM server case, a TM server {{is a virtual}} server, is in both Internet segment and Control segment and has modules of API, Web GUI, OpenStack communicate process, tomcat and apache. Two servers are for redundancy. Other servers are a user terminal and an operator terminal, Glance application servers for image upload, a NFS storage for image, OpenStack <b>API</b> <b>servers,</b> a DB for OpenStack and TM, OpenStack servers for virtual resources such as network, volume or VM and iSCSI storages and load balancers for load balancing. Figure  5 omits maintenance servers such as syslog or backup servers and redundant modules such as heartbeat. These servers are connected with Gigabit Ethernet.|$|R
5000|$|Windows XP SP2 {{and later}} include http.sys and the HTTP <b>Server</b> <b>API,</b> the kernel-mode HTTP server for applications, backported from Windows Server 2003.|$|R
40|$|Full Coverage Displays (FCDs) {{cover the}} {{interior}} surface {{of an entire}} room with pixels. FCDs make possible many new kinds of immersive display experiences - but current technology for building FCDs is expensive and complex, and software support for developing full-coverage applications is limited. To address these problems, we introduce ASPECTA, a hardware configuration and software toolkit that provide a low-cost and easy-to-use solution for creating full coverage systems. We outline ASPECTA’s (minimal) hardware requirements and describe the toolkit’s architecture, development <b>API,</b> <b>server</b> implementation, and configuration tool; we also provide a full {{example of how the}} toolkit can be used. We performed two evaluations of the toolkit: a case study of a research system built with ASPECTA, and a laboratory study that tested the effectiveness of the API. Our evaluations, as well as multiple examples of ASPECTA in use, show how ASPECTA can simplify configuration and development while still dramatically reducing the cost for creators of applications that take advantage of full-coverage displays. Postprin...|$|E
30|$|One {{possible}} {{action is}} resizing a cluster: If a cluster overload condition occurs, {{the number of}} virtual machines is dynamically increased by an upsizing process. On the other hand, if idle machines exist a downsizing process takes care to decrease the number of virtual machines by sending a termination or stop signal to underutilized machines. As a boundary condition the <b>API</b> <b>server</b> ensures the cost effectiveness of the operation as the resource usage accounting model may vary for different IaaS cloud providers. For example, the Amazon Web Services (AWS) compute service EC 2 [11] charges any started hour of instance usage independent of the actual utilization profile (wallclock time). Thus {{it would be interesting}} to stop machines right before the end of the hour in order to take full advantage of an already billed resource. Another accounting model applied by Google [12] or Profitbricks [13] continuously charges the actually consumed resources (CPU time). The current implementation is utilizing AWS services and instances are therefore terminated on an hourly basis.|$|E
40|$|Radio {{planning}} is designing of network structure and elements under various design requirements. With the increasing shortage of frequencies, radio planning {{has become more}} and more complex. Hence, to maintain accuracy and optimization computerized planning tools are needed. This thesis focuses on developing a simplified and economical solution on web for radio planning tool using WRAP- the software for spectrum management and radio planning developed by WRAP International AB, Linköping, Sweden. In order to make WRAP calculations available for remote users it had developed APIs. The web-based WRAP needs to communicate with WRAP <b>API</b> <b>server,</b> for exchanging API messages in order to perform calculation. To make the system user friendly and interactive, latest web technologies are implemented. In this thesis, we started development process right from requirements gathering to find out required components that need to be analyzed to find suitable web-based conversion. Further, we designed and implemented a software solution. The final part is evaluation to discover if requirements are fully implemented or not as well as to gather the performance result of the new system. It is found, the performance of web based WRAP is equally fast as desktop version for smaller coverage areas whereas, for larger coverage areas, web-based WRAP is slower than desktop versio...|$|E
5000|$|The word [...] "application", {{once used}} as an adjective, is not {{restricted}} to the [...] "of or pertaining to application software" [...] meaning. For example, concepts such as application programming interface (<b>API),</b> application <b>server,</b> application virtualization, application lifecycle management and portable application apply to all computer programs alike, not just application software.|$|R
50|$|For the {{database}} application developer and systems integrator, Virtuoso implements {{a variety of}} industry standard data access <b>APIs</b> (client and <b>server)</b> that includes: ODBC, JDBC, OLE DB, ADO.NET, ADO.NET Entity Framework, XMLA.|$|R
50|$|Between {{the server}} and the application, {{there may be}} a WSGI middleware, which {{implements}} both sides of the <b>API.</b> The <b>server</b> receives a request from a client and forwards it to the middleware. After processing, it sends a request to the application. The application's response is forwarded by the middleware to the server and ultimately to the client. There may be multiple middlewares forming a stack of WSGI-compliant applications.|$|R
40|$|Muslim {{sometimes}} {{has trouble}} {{when they travel}} to a new place for find where {{the location of the}} halal food and mosque near their location is. Other things that Muslim will have difficulty when they travel in to a new place are find the Qibla direction, pray time in local time and the mosque location near their location. From that problem MLH (Muslim Little Helper) want to help them to solve their problem. The process is carried out as follows: The app get the user location, send the location to the YELP <b>API</b> <b>server</b> and muslimshalat. com API to get the location of halal food, and mosque (using YELP) and for find the direction of Qibla and the prayer schedule (by using muslimshalat. com API). After the system get the data, then it will show on the Map (using apple map inside the app) and put the data as marker. For the Qibla direction and prayer time, it will show in arrow image and listview. This app will be use Swift for the development language. The test result shows that the YELP API can be use only in USA, and internet play as the main rule in this app, because to create connection to the server to pull the data, the system need internet to pass all the data to server...|$|E
40|$|Our {{client is}} a growing business, which leads to less {{flexibility}} and more problems in development. Also, {{there is a need}} to be able to easily test out functionality on a small group of customers, without breaking other parts of the product. Therefore our client would like to modularize their application. As the client wants to develop a new modular platform next to their current platforms, the choice of frameworks and techniques was still open. We split up the backend and frontend, because they wanted to have a static frontend communicating with an <b>API</b> <b>server.</b> We used Ruby on Rails for the backend and Ember. js as a frontend framework. The modular structure has been implemented by building plugins for these frameworks, being a Rails Gem and an Ember Addon. Also, we built a command line tool to generate new modules to make it easier to work with the new structure. The resulting plugins allow for the generation of both frontend and backend modules, being able to communicate with each other. They can be executed both standalone, and integrated into the new platform. During this process we wanted to keep high software standards in mind. We continuously tested the product and measured code coverage, quality and other analytics. We have used the Scrum methodology for our agile workflow. During the development it became clear that the core application of the client wouldn’t be ready in time. Therefore we adapted our plugins to be completely standalone. Bachelor Computer ScienceComputer ScienceElectrical Engineering, Mathematics and Computer Scienc...|$|E
40|$|ElateMe je nová crowdfundingová platforma s elementy sociálni sitě. Na rozdil od jiných podobných projektů, jako jsou Kickstarter nebo Patreon, které podporuji vývoj kreativnich a komerčnich projektů prostřednictvim zájemců, ElateMe je zaměřen na naplněni osobnich přáni s pomoci přátel uživatelů. V aplikaci ElateMe může uživatel sdilet své přáni a jeho přátelé mu mohou pomoci tim, že finančně přispěji. Vývoj této platformy je týmovým projektem. Práce je rozdělena do vývoje Android a iOS aplikaci, backend REST API a reklamniho serveru. Tato bakalářská práce se zaměřuje na vývoj backend REST API pro výše uvedený projekt. Cilem této práce bylo definovat a zdokumentovat funkčni a nefunkčni požadavky pro systém ve vývoji, analyzovat připady užiti a celkovou strukturu projektu. Autor také analyzuje externi systémy použivané touto aplikaci, jmenovitě Facebook Graph API, rozhrani online platebnich systémů, jako jsou FIO-banka a Bitcoin, služby push notifikace Apple(APNs) a Google(GCM). V rámci této práce byla navržena struktura databáze a architektura serverové aplikace a bylo realizováno backend rozhrani pro komunikaci s mobilnimi a webovými aplikacemi pomoci populárnich nástrojů pro vývoj web serverů, jako jsou programovaci jazyk Python, Django web {{framework}} a PostgreSQL DBMS. Nakonec aplikace byla podrobena jednotkovým (unit) a výkonovým testům. ElateMe {{is a new}} crowdfunding {{platform with}} elements of the social network. Unlike other similar projects like Kickstarter or Patreon that help bring creative, commercial projects to life by means of interested people, ElateMe focuses on the fulfillment of personal wishes {{with the help of}} user's friends. In ElateMe application, the user can share his wish, and his friends can help him by contributing financially. The development of this platform is a team project. The work is divided into the development of Android and iOS applications, REST <b>API</b> <b>server</b> and an advertising server. This thesis focuses {{on the development of the}} backend REST API for the project mentioned above. The aim of this work was to define and document the functional and non-functional requirements for the system under development, to analyze use cases and the overall structure of the project. The author also explains the external systems used by this application, such as the Facebook Graph API, the interfaces of the online payment systems like FIO-banka and Bitcoin, the operating system push notification services of Apple(APNs) and Google(GCM). In the framework of this work, the database structure and server-side application architecture were designed, and the backend interface for communication with mobile and web applications was implemented using modern web development tools such as Python programming language, Django web framework, and PostgreSQL DBMS. After that, the application has undergone unit and performance testing...|$|E
50|$|Rack {{provides}} a modular and adaptable interface for developing web applications in Ruby. By wrapping HTTP requests and responses it unifies the <b>API</b> for web <b>servers,</b> web frameworks, and software in between (called middleware) {{into a single}} method call.|$|R
5000|$|It {{can be used}} as such as a {{web server}} {{scripting}} language when combined with the Corel Web Server Control OCX, which implements a <b>server</b> <b>API</b> similar to the [...] CGI, and its standalone console, the Corel Web Server.|$|R
50|$|Google Cloud Messaging {{functions}} using <b>server</b> <b>APIs</b> and SDKs, both {{maintained by}} Google. The GCM {{has the ability}} to send push notifications, deep-linking commands, and application data. Larger messages can be sent with up to 4 KB of payload data.|$|R
