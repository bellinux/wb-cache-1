1|23|Public
40|$|We {{introduce}} the extended modal logic EML with regularity constraints and full Presburger {{constraints on the}} number of children that generalize graded modalities, also known as number restrictions in description logics. We show that EML satisfiability is only pspace-complete by designing a Ladner-like algorithm. This extends a well-known and non-trivial pspace upper bound for graded modal logic. Furthermore, we provide a detailed comparison with logics that contain Presburger constraints and that are dedicated to query XML documents. As an application, we provide a logarithmic space reduction from a variant of Sheaves logic SL into EML that allows us to establish that its satisfiability problem is also pspace-complete, significantly improving the best known upper bound. Key words: modal logic, Ladner-like algorithm, <b>arithmetical</b> <b>constraint,</b> regularity constraint, computational complexity...|$|E
40|$|Abstract. In this paper, {{we present}} recent results about the verifica-tion of counter {{machines}} by using decision procedures for Presburger arithmetic. We recall several known classes of counter machines {{for which the}} reachability sets are Presburger-definable as well as temporal logics with <b>arithmetical</b> <b>constraints.</b> We discuss issues related to flat counter machines, path schema enumeration, {{and the use of}} SMT solvers. ...|$|R
40|$|The {{notion of}} unranked trees has {{attracted}} {{much interest in}} current research, especially due to their application as formal models of XML documents. In particular, several automata and logic formalisms on unranked trees have been considered (again) in the literature, and many results {{that had previously been}} shown for the ranked-tree setting have turned out to hold for the unranked-tree setting as well. In this thesis, we study two kinds of extensions of finite automata on unranked trees, namely, the extension by <b>arithmetical</b> <b>constraints</b> and the extension by subtree-equality constraints. In {{the first part of the}} thesis we introduce a framework of automata on unranked trees that unifies two different approaches to incorporating <b>arithmetical</b> <b>constraints</b> known from the literature, namely the global-constraint approach of Klaedtke and Rueß (2003) and the local-constraint approach of Seidl et al. (2003). We investigate the relationship between the two types of <b>arithmetical</b> <b>constraints</b> with respect to language recognition, and we show that the emptiness problem for this automaton model is decidable. In the second part of this thesis, we introduce automata on unranked trees that are equipped with equality and disequality constraints between direct subtrees, thereby extending the corresponding automaton model in the ranked-tree setting, which was introduced by Bogaert and Tison (1982). In the definition of the automaton model, we propose using formulas of monadic second-order logic to capture the possibility of comparing unboundedly many direct subtrees for equality, a feature that arises naturally in light of the unrankedness. Our main result is that the emptiness problem for this automaton model is decidable. Based upon this result, furthermore, we introduce a logic over data words (that is, words over an infinite alphabet) for which the satisfiability problem is decidable...|$|R
40|$|Abstract. We {{show that}} model-checking flat counter systems over CTL* (with <b>arithmetical</b> <b>constraints</b> on counter values) {{has the same}} complex-ity as the satisfiability problem for Presburger arithmetic. The lower bound already holds with the {{temporal}} operator EF only, no arithmeti-cal constraints in the logical language and with guards on transitions made of simple linear constraints. This complements our understanding of model-checking flat counter systems with linear-time temporal log-ics, such as LTL for which the problem is already known to be (only) NP-complete with guards restricted to the linear fragment. ...|$|R
40|$|Abstract. We study model-checking {{problems}} on counter systems when guards are quantifier-free Presburger formulae, the specification languages are LTL-like dialects with <b>arithmetical</b> <b>constraints</b> and the runs {{are restricted to}} reversal-bounded ones. We introduce a generalization of reversal-boundedness and we show the NExpTime-completeness of the reversal-bounded model-checking problem {{as well as for}} related reversalbounded reachability problems. As a by-product, we show the effective Presburger definability for sets of configurations for which there is a reversal-bounded run verifying a given temporal formula. Our results generalize existing results about reversal-bounded counter automata and provides a uniform and more general framework. ...|$|R
40|$|International audienceThis paper {{considers}} {{the problem of}} rewriting queries using views {{by means of a}} tolerant method. The approach proposed is based on an approximate matching between the constraints from the query and those from the views, in the case where both the query and the views contain <b>arithmetical</b> <b>constraints</b> expressed as intervals. In such a context, the answers obtained are not certain anymore but only more or less probable. An algorithm which retrieves the top-k rewritings of a given query is described. Experimentations are reported, which show that the extra cost induced by the approximate nature of the rewriting process is perfectly acceptable...|$|R
40|$|International audienceUsing a glass-box {{theory of}} ﬁnite domain constraints, FD, we {{show how the}} {{entailment}} of user-deﬁned constraints can be expressed by antimonotone FD constraints. We also provide an algorithm for checking the entailment and consistency of FD constraints. FD is shown to be expressive enough to allow the deﬁnition of <b>arithmetical</b> <b>constraints,</b> as well as nontrivial symbolic constraints, that are normally built in to CLP systems. In particular, we use conditional FD constraints, which exploit entailment checking, to deﬁne symbolic constraints. Thus, we claim that a glass-box system such as FD is expressive enough to {{capture the essence of}} ﬁnite domain constraint programmin...|$|R
40|$|Reachability and LTL model-checking {{problems}} for flat counter systems {{are known to}} be decidable but whereas the reachability problem can be shown in NP, the best known complexity upper bound for the latter problem is made of a tower of several exponentials. Herein, we show that the problem is only NP-complete even if LTL admits past-time operators and <b>arithmetical</b> <b>constraints</b> on counters. Actually, the NP upper bound is shown by adequately combining a new stuttering theorem for Past LTL and the property of small integer solutions for quantifier-free Presburger formulae. Other complexity results are proved, for instance for restricted classes of flat counter systems...|$|R
40|$|Abstract Using a glass-box {{theory of}} finite domain constraints, FD, we {{show how the}} {{entailment}} of user-defined constraints can be expressed by anti-monotone FD constraints. We also provide an algorithm for checking the entailment and consistency of FD constraints. FD is shown to be expressive enough to allow the definition of <b>arithmetical</b> <b>constraints,</b> as well as non-trivial symbolic constraints, that are normally built in to CLP systems. In particular, we use conditional FD constraints, which exploit entailment checking, to define symbolic constraints. Thus, we claim that a glass-box system such as FD is expressive enough to {{capture the essence of}} finite domain constraint programming...|$|R
40|$|Abstract. Among the {{approximation}} {{methods for}} the verification of counter systems, {{one of them}} consists in model-checking their flat unfoldings. Unfortunately, the complexity characterization of model-checking problems for such operational models is not always well studied except for reachability queries or for Past LTL. In this paper, we characterize the complexity of model-checking problems on flat counter systems for the specification languages including first-order logic, linear mu-calculus, infinite automata, and related formalisms. Our results span different complexity classes (mainly from PTime to PSpace) and they apply to languages in which <b>arithmetical</b> <b>constraints</b> on counter values are systematically allowed. As far as the proof techniques are concerned, we provide a uniform approach {{that focuses on the}} main issues. ...|$|R
40|$|Modelling {{problems}} {{containing a}} mixture of Boolean and numerical variables is a long-standing interest of Artificial Intelligence. However, performing in-ference and learning in hybrid domains is a particularly daunting task. The ability to model these kind of domains is crucial in “learning to design” tasks, that is, learning applications where {{the goal is to}} learn from examples how to perform automatic de novo design of novel objects. In this paper we present Structured Learning Modulo Theories, a max-margin approach for learning in hybrid domains based on Satisfiability Modulo Theories, which allows to combine Boolean reasoning and optimization over continuous linear <b>arithmetical</b> <b>constraints.</b> The main idea is to leverage a state-of-the-art gen-eralized Satisfiability Modulo Theory solver for implementing the inference and separation oracles of Structured Output SVMs. We validate our method on artificial and real world scenarios...|$|R
40|$|We {{present a}} method for characterizing the least fixed-points of a certain class of Datalog {{programs}} in Presburger arithmetic. The method consists in applying {{a set of rules}} that transform general computation paths into "canonical" ones. We use the method for treating the problem of reachability in the field of Petri nets, thus relating some unconnected results and extending them in several directions. Keywords: decomposition, linear arithmetic, least fixed-point, Petri nets, reachability set 1. Introduction The problem of computing fixpoints for arithmetical programs has been investigated from the seventies in an imperative framework. A typical application was to check whether or not array bounds were violated. A pionneering work in this field is the work by Cousot-Halbwachs (Cousot, 78). The subject has known a renewal of interest with the development of logic programming and deductive databases with <b>arithmetical</b> <b>constraints.</b> Several new applications were then possible in these f [...] ...|$|R
40|$|We {{present a}} {{declarative}} language [...] CFLP (R) [...] which enhances functional logic programming with constraint solving capabilities. CFLP (R) features: polymorphic types, nondeterministic functions, lazy evaluation, higher order (even logic) computations, <b>arithmetical</b> <b>constraints</b> over real numbers and disequality constraints over syntactic terms. The {{features of the}} language are shown by means of examples, attempting to demonstrate the interest of CFLP (R). The execution mechanism of the language results of a simple combination of lazy narrowing (with a sophisticated strategy, as realized in up to date functional logic languages) and constraint solving. The language has been implemented by means of translation of source programs into a Prolog system supporting real constraint solving. This shows the practicability of the proposal. 1 Introduction Constraints {{play a central role}} in present days research, development and application of logic programming (LP) languages (see [15] for a sur [...] ...|$|R
40|$|Using a glass-box {{theory of}} finite domain constraints, FD, we {{show how the}} {{entailment}} of user-defined constraints can be expressed by anti-monotone FD constraints. We also provide an algorithm for checking the entailment and consistency of FD constraints. FD is shown to be expressive enough to allow the definition of <b>arithmetical</b> <b>constraints,</b> as well as non-trivial symbolic constraints, that are normally built in to CLP systems. In particular, we use conditional FD constraints, which exploit entailment checking, to define symbolic constraints. Thus, we claim that a glass-box system such as FD is expressive enough to {{capture the essence of}} finite domain constraint programming. This work was sponsored by ESPRIT Project 7195 (ACCLAIM), and has been performed in close cooperation with the Programming Systems group at SICS and Philippe Codognet at INRIA-Rocquencourt. Also published in Proceedings of the Eleventh International Conference on Logic Programming, MIT Press, 1994. [...] ...|$|R
40|$|Vasilis Aggelis University of Patras aggelisv@otenet. gr Stavros Cosmadakis University of Patras scosmada@cti. gr Phone: 30 - 61 - 997867 Fax: 30 - 61 - 991650 Abstract We {{present a}} new {{optimization}} method for nested SQL query blocks with aggregation operators. The method {{is derived from}} the theory of dependency implication. It unifies and generalizes previously proposed (seemingly unrelated) algorithms, and can incorporate general database dependencies given in the database schema. We apply our method to query blocks with max, min aggregation operators. We obtain an algorithm which does not infer <b>arithmetical</b> <b>constraints,</b> and reduces optimization of such query blocks to the well-studied problem of tableau equivalence. We prove a completeness result for this algorithm: if two max, min blocks can be merged, the algorithm will detect this fact. 1 Introduction The practical importance of optimizing queries in relational database systems has been recognized. Traditional systems [...] ...|$|R
40|$|<b>Arithmetical</b> <b>constraints</b> {{are widely}} used in formal {{languages}} like regular expressions, tree grammars and paths. In XML {{they are used to}} impose bounds on the number of occurrences described by content models of schema languages (XML Schema, RelaxNG). In query languages (XPath, XQuery), they allow selecting nodes that have a bounded number of nodes reachable by a given path expression. Counting types and paths are thus natural extensions of their countless counterparts already regarded as the core constructs in XML languages and type systems. One of the biggest challenges in XML is to develop automated procedures for ensuring static-type safety and optimization techniques. To this end, {{there is a need to}} solve some basic reasoning tasks that involve constructions such as counting XML schemas and XPath expressions. Every compiler of XML programs will have to routinely solve problems such as type and path typechecking, for ensuring at compile time that invalid documents can never arise as the output of XML processing code...|$|R
40|$|AbstractWe {{address the}} {{verification}} problem of FIFO-channel systems. We apply the symbolic analysis principle to these systems. We represent their sets of configurations using structures called constrained queue-content decision diagrams (CQDDs) combining finite-state automata with linear <b>arithmetical</b> <b>constraints</b> on {{number of occurrences}} of symbols. We show that CQDDs allow forward and backward reachability analysis of systems with nonregular sets of configurations. Moreover, we prove that CQDDs allow to compute the exact effect of the repeated execution of any fixed cycle in the transition graph of a system. We use this fact to define a generic reachability analysis semi-algorithm parametrized {{by a set of}} cycles Θ. Given a set of configurations, this semi-algorithm performs a least fixpoint calculation to construct the set of its successors (or predecessors). At each step, this calculation is accelerated by considering the cycles in Θ as additional “meta-transitions” in the transition graph, generalizing the approach of Boigelot and Godefroid (CAV' 96, Lecture Notes in Computer Science, Vol. 1102, Springer, Berlin, 1996) ...|$|R
40|$|Abstract. We {{define a}} method to statically bound the size of values {{computed}} during the execution of a program {{as a function of}} the size of its parameters. More precisely, we consider bytecode programs that should be executed on a simple stack machine with support for algebraic data types, pattern-matching and tail-recursion. Our size verification method is expressed as a static analysis, performed at the level of the bytecode, that relies on machine-checkable certificates. We follow here the usual assumption that code and certificates may be forged and should be checked before execution. Our approach extends a system of static analyses based on the notion of quasi-interpretations that has already been used to enforce resource bounds on first-order functional programs. This paper makes two additional contributions. First, we are able to check optimized programs, containing instructions for unconditional jumps and tail-recursive calls, and remove restrictions on the structure of the bytecode that was imposed in previous works. Second, we propose a direct algorithm that depends only on solving a set of <b>arithmetical</b> <b>constraints.</b> ...|$|R
40|$|We {{consider}} {{in this report}} Datalog programs with <b>arithmetical</b> <b>constraints</b> of the following form: p(x 0; y 0; z 0) : p(x + e; y +; z + fl) / x 0; p(x; y; z) : p(x + ¯; y + f; z + ffi) / y 0; p(x; y; z) : p(x + ff; y + fi; z + g) / z 0; p(x; y; z) : where x 0; y 0; z 0; e;; fl; ¯; f; ffi; ff; fi; g denote integer constants. The problem is to find an arithmetic formula f(x; y; z) equivalent to the relation p(x; y; z) defined by the above program. This characterization problem has useful applications in several fields, like the generation of lemmas for proving the termination of Prolog programs, the compilation of queries in Temporal Deductive Databases, or the verification of safety properties in parametric concurrent systems. We show here that programs of the above form are divided into three classes: the hierarchic, periodic and spiralling classes. More than 99 % of the programs fall into the hierarchic and periodic classes and can be characterized by a linear arithmetic formula, un [...] ...|$|R
40|$|In {{this paper}} several results {{concerning}} the periodic points of 1 -norm nonexpansive maps will be presented. In particular, we {{will examine the}} set R(n), which consists of integers p ?? 1 such that there exist a 1 -norm nonexpansive map f: Rn ¿ Rn and a periodic point of f of minimal period p. The principal problem {{is to find a}} characterization of the set R(n) in terms of <b>arithmetical</b> and combinatorial <b>constraints.</b> This problem was posed in [12, section 4]. We shall present here a significant step towards such a characterization. In fact, we shall introduce for each n ¿ N a set T(n) that is determined by <b>arithmetical</b> and combinatorial <b>constraints</b> only, and prove that R(n) ¿ T(n) for all n ¿ N. Moreover, we will see that R(n) = T(n) for n = 1, 2, 3, 4, 6, 7, and 10, but it remains an open problem whether the sets R(n) and T(n) are equal for all n ¿ N...|$|R
40|$|Let K n = fx 2 R n j x i 0; 1 i ng and {{suppose that}} f : K n ! K n is nonexpansive {{with respect to}} the l 1 -norm, kxk 1 = P n i= 1 x i, and f(0) = 0. It is known (see [1]) that for every x 2 K n there exists a {{periodic}} point = x 2 K n (so f p () = for some minimal positive integer p = p) and f k (x) approaches ff j () j 0 j ! pg as k tends to infinity. In a previous paper [13] the set P 2 (n) of positive integers p for which there exists a map f as above and a periodic point 2 K n of minimal period p was related to the idea of "admissible arrays" and a set Q(n) determined by certain <b>arithmetical</b> and combinatorial <b>constraints.</b> In a sequel to this paper [14] it is proved that P 2 (n) = Q(n) for all n, but the computation of Q(n) is highly nontrivial. Here we derive a variety of theorems about admissible arrays and use these theorems to compute Q(n) explicitly for n 50 and prove that P (n) = P 2 (n) = Q(n) for n 50, where P (n) is a naturally occurring [...] ...|$|R

