81|343|Public
2500|$|Note {{that in this}} format, {{the first}} value of [...] is always zero and the last is always , so they are in some sense {{redundant}} (although in programming languages where the <b>array</b> <b>length</b> needs to be explicitly stored, [...] would not be redundant). [...] Nonetheless, this does avoid the need to handle an exceptional case when computing the length of each row, as it guarantees the formula [...] works for any row [...] [...] Moreover, the memory cost of this redundant storage is likely insignificant for a sufficiently large matrix.|$|E
50|$|Arrays in Java {{are created}} at runtime, just like class instances. <b>Array</b> <b>length</b> is defined at {{creation}} and cannot be changed.|$|E
50|$|The C++ Standard Library {{offers no}} real support for Unicode. std::basic_string::length will only return the {{underlying}} <b>array</b> <b>length</b> which is acceptable when using ASCII or UTF-32 {{but not when}} using variable length encodings like UTF-8 or UTF-16. In these encodings, <b>array</b> <b>length</b> is neither a correct measure {{of the number of}} code points, number of characters or width. There is no support for advanced Unicode concepts like normalization, surrogate pairs, bidi or conversion between encodings, although unicode libraries exist, such as iconv and ICU.|$|E
3000|$|... 1) First, a genie {{expands the}} {{transmit}} scattering intervals Ψ _T_ 22 and Ψ _T_ 12 until the two intervals are fully overlapped, and likewise expands expands Ψ _R_ 11 and Ψ _R_ 12 {{until they are}} fully overlapped, as shown in Fig. 6. To ensure that the net manipulation of the genie can only enlarge D_FD, the genie also increases the <b>array</b> <b>lengths</b> L_T_ 2 and L_R_ 1 sufficiently for any added interference due {{to the expansion of}} Ψ _T_ 12 and Ψ _R_ 12 to be compensated by the increased <b>array</b> <b>lengths.</b>|$|R
5000|$|The term super-{{integron}} {{was first}} applied in 1998 (but without definition) to the integron {{with a long}} cassette array on the small chromosome of Vibrio cholerae. The term has since been used for integrons of various cassette <b>array</b> <b>lengths</b> or for integrons on bacterial chromosomes (versus, for example, plasmids). Use of [...] "super-integron" [...] is now discouraged since its meaning is unclear.|$|R
40|$|A {{permutation}} <b>array</b> of <b>length</b> n {{is a set}} of permutations of n {{elements such}} that any two permutations coincide in at most one position. A general construction of permutation arrays is given. All permutation <b>arrays</b> of <b>length</b> 6 and maximal size 18 are determined. Bounds on cyclic arrays are given. An appendix describes the application to data transmission (due to A. J. Han Vinck) ...|$|R
50|$|A common {{solution}} to the problem above is to always pass the <b>array</b> <b>length</b> as a function argument, and functions that expect an array argument should also provide a placeholder for its length.|$|E
5000|$|Arrays {{know their}} {{upper and lower}} bounds (and implicitly their length), and the bounds are passed along when a {{function}} expects an array as argument. The functions , [...] and [...] retrieve the lower bound, upper bound and <b>array</b> <b>length,</b> respectively, in any context.|$|E
5000|$|... {{function}} read_and_process(n) result(o) integer,intent(in)::n real::o real,dimension(n)::vals integer::i do i = 1,n vals(i) = read_val (...) end do o = process(vals)end function read_and_processwhen {{utilizing the}} Fortran 90 feature of checking procedure interfaces at compile-time; {{on the other}} hand, if the functions use pre-Fortran 90 call interface the (external) functions must first be declared, and the <b>array</b> <b>length</b> must be explicitly passed as an argument (as in C):function read_and_process(n) result(o) integer,intent(in)::n real::o real,dimension(n)::vals real::read_val, process integer::i do i = 1,n vals(i) = read_val (...) end do o = process(vals,n)end function read_and_process ...|$|E
5000|$|... /* 'a' {{is now an}} <b>array</b> of <b>length</b> 42 and can be {{manipulated}} and freed here */ ...|$|R
40|$|International audienceImaging systems {{based on}} linear arrays with delay-and-sum {{beamforming}} require estimating the path differences between each pixel and the array elements. Considering the quadratic approximation, the linear part {{is related to}} the steering direction whereas the quadratic term refers to the curvature of the wavefront. The several ways for handling this approximation are presented, e. g., closest second order development for each pixel, paraxial development, Fresnel approximation, down to the Fraunhofer (linear) approximation. The domains of validity of these developments are scarcely described in the literature. They are estimated here by considering the largest error encountered on the array in the path differences. The quadratic approximation is usually considered as not enough efficient in terms of either the computation savings, or the extent of the domains of validity. It is shown that settings of practical interest can be found by optimizing the quadratic coefficient as a function of range. This procedure yields the computation saving of the paraxial approximation, still keeping quite large angular domains of validity. The solutions are conveniently displayed with general graphs where ranges are counted in <b>array</b> <b>lengths,</b> and <b>array</b> <b>lengths</b> are given in wavelength units...|$|R
5000|$|In the {{following}} example code used for swapping the values of two <b>array</b> of <b>length</b> n, there is a loop-independent dependence of [...]|$|R
50|$|In MIMO {{communication}} systems, array gain means a {{power gain}} of transmitted signals that {{is achieved by}} using multiple-antennas at transmitter and/or receiver, with respect to single-input single-output case. It can be simply called power gain. In a broadside array, the array gain is almost exactly proportional {{to the length of}} the array. This is the case provided that the elements of the antenna are not spaced to a point at which large radiation side lobes form in other directions and that the <b>array</b> <b>length</b> exceeds one or two wavelengths. The power gain of a broadside array is nearly independent of the number of broadside elements as long as both of these conditions are met.|$|E
5000|$|Object Pascal {{provides}} language-level {{support for}} dynamic arrays. It's declared with lower and upper bound omitted. One then must call [...] function to allocate the storage. Dynamic arrays in Object Pascal are reference counted, so one doesn't {{have to worry}} about freeing the storage. Dynamic arrays are always zero-based. The three functions , [...] and [...] would still retrieve lower bound, upper bound and <b>array</b> <b>length</b> correctly. Example:type TIntArray = array of Integer; T2DimIntArray = array of array of Integer;var a : TIntArray; a2 : T2DimIntArray; i,j: Integer;begin SetLength(a,10); // allocate 10 storage for i := Low(a) to High(a) do ... // do something with ai SetLength(a2,10,10); // allocate 10 x 10 storage for i := Low(a2) to High(a2) do for j := Low(a2i) to High(a2i) do ... // do something with ai,jend; ...|$|E
50|$|The passive, or listening, part of {{the system}} is SURTASS, which detects {{returning}} echoes from submerged objects, such as submarines, through the use of hydrophones. These devices transform mechanical energy (received acoustic sound wave) to an electrical signal that can be analyzed by the signal processing system of the sonar. The SURTASS hydrophones are mounted on a horizontal receive array that is towed behind the vessel. The <b>array</b> <b>length</b> is 1,500 m (4,900 ft) with an operational depth of 150 to 460 m (500 to 1,500 ft). The SURTASS LFA ship must maintain a minimum speed of approximately 6 km/h through the water in order to tow the hydrophone array in the horizontal plane. The return signals or echoes, which are usually below background or ambient noise level, are then processed and evaluated to identify and classify potential underwater targets.|$|E
40|$|AbstractThe {{parameterized}} {{pattern matching}} {{problem is to}} check if there exists a renaming bijection on the alphabet with which a given pattern can {{be transformed into a}} substring of a given text. A parameterized border array (p-border array) is a parameterized version of a standard border array, and we can efficiently solve the parameterized pattern matching problem using p-border arrays. In this paper, we present a linear time algorithm to verify if a given integer array is a valid p-border array for a binary alphabet. We also show a linear time algorithm to compute all binary parameterized strings sharing a given p-border array. In addition, we give an algorithm which computes all p-border <b>arrays</b> of <b>length</b> at most n, where n is a given threshold. This algorithm runs in O(B 2 n) time, where B 2 n is the number of all p-border <b>arrays</b> of <b>length</b> n for a binary parameter alphabet. The problems with a larger alphabet are much more difficult. Still, we present an O(n 1. 5) –time O(n) –space algorithm to verify if a given integer <b>array</b> of <b>length</b> n is a valid p-border array for an unbounded alphabet. The best previously known solution to this task takes time proportional to the n-th Bell number 1 e∑k= 0 ∞knk!, and hence our algorithm is much more efficient. Also, we show {{that it is possible to}} enumerate all p-border <b>arrays</b> of <b>length</b> at most n for an unbounded alphabet in O(Bnn 2. 5) time, where Bn denotes the number of p-border <b>arrays</b> of <b>length</b> n...|$|R
40|$|Abstract—The {{synthesis}} of optimal narrow beam low sidelobe linear array is addressed. Only the <b>length</b> of the <b>array</b> is constrained. The number, the positions and the weightings {{of the elements}} are left free. It is proven, that the optimal design is always an array with {{a small number of}} elements. One first demonstrates that among equally spaced linear <b>arrays</b> of given <b>length,</b> the sparsest Dolph-Chebyshev design, i. e., the one with the largest admissible inter-element distance, is the optimal one. Then, the restriction to equally spaced elements is removed, and the general problem is solved and discussed. It is shown that the sparsest Dolph-Chebyshev designs are optimal for <b>array</b> <b>lengths</b> in given specified intervals and close to optimal for all other lengths. 1...|$|R
40|$|We {{study the}} {{influence}} of optical near-field interactions on the dipole surface plasmon resonance of Au nanoparticles in closely spaced particle arrays using finite-difference timedomain simulations. In particular, the resonance energies of the collective plasmon-polariton modes are determined for longitudinal and transverse polarization for different particle <b>array</b> <b>lengths</b> and inter-particle spacings of 50 nm Au spheres in air. The obtained results are set in context with recent publications suggesting the possibility to use ordered arrays of closely spaced noble metal nanoparticles as plasmon waveguides for electromagnetic energy below the diffraction limit of light...|$|R
50|$|Any {{priority}} queue {{that can handle}} non-monotone extraction operations can also handle monotone extractions, but some {{priority queue}}s are specialized to work only for monotone extractions or work better when the extractions are monotone.For instance, the bucket queue is a simple priority queue data structure consisting of an array indexed by priority, where each array cell contains a bucket of items with that priority. An extract-min operation performs a sequential search for the first non-empty bucket and chooses an arbitrary item in that bucket. For non-monotone extractions, each extract-min operation takes time (in the worst case) proportional to the <b>array</b> <b>length</b> (the number of distinct priorities).However, when used as a monotone priority queue, {{the search for the}} next non-empty bucket can begin at the priority of the most recent previous extract-min operation rather than {{at the start of the}} array. This optimization causes the total time for a sequence of operations to be proportional to the sum of the number of operations and the length of the array, rather than (as in the non-monotonic case) the product of these two quantities.|$|E
3000|$|... [...]. This large spacing {{is chosen}} {{to make the}} mutual {{coupling}} effect negligible at the transmitting terminal. For the receiver terminal, we fix the <b>array</b> <b>length</b> [...]...|$|E
30|$|It {{is known}} that this gain cannot exceed the minimum between the numbers of {{spatially}} orthogonal 1 beams that can be implemented {{by means of the}} transmitting and receiving arrays. Specifically, for a uniform linear array 2 (ULA) with isotropic elements, the maximum achievable number of approximately orthogonal beams is equal to twice the <b>array</b> <b>length</b> normalized to the wavelength, since the angular resolution allowed by the array, in the directional cosine domain (− 1, 1) is roughly equal to the inverse of the normalized <b>array</b> <b>length</b> [3, Chap. 7].|$|E
5000|$|... // {{create a}} new byte <b>array</b> with <b>length</b> sizeof(T) and store it in local 0 sizeof !!T newarr uint8 dup // keep a copy on the stack for later (1) stloc.0 ...|$|R
5000|$|Variable <b>length</b> <b>arrays.</b> This feature {{leads to}} {{possibly}} non-compile time [...] operator.|$|R
5000|$|The algorithm, then, {{proceeds}} as follows: [...] P = <b>array</b> of <b>length</b> N M = <b>array</b> of <b>length</b> N + 1 [...] L = 0 for i {{in range}} 0 to N-1: // Binary {{search for the}} largest positive j ≤ L // such that XMj < Xi lo = 1 hi = L while lo ≤ hi: mid = ceil((lo+hi)/2) if XMmid < Xi: lo = mid+1 else: hi = mid-1 [...] // After searching, lo is 1 greater than the // length of the longest prefix of Xi newL = lo [...] // The predecessor of Xi is the last index of [...] // the subsequence of length newL-1 Pi = MnewL-1 MnewL = i [...] if newL > L: // If we found a subsequence longer than any we've // found yet, update L L = newL [...] // Reconstruct the longest increasing subsequence S = <b>array</b> of <b>length</b> L k = ML for i in range L-1 to 0: Si = Xk k = Pk [...] return S ...|$|R
3000|$|In {{an attempt}} to further boost the array directivity, we may select smaller values for Δ without {{changing}} the <b>array</b> <b>length.</b> Letting M[*]=[*] 5, Δ[*]=[*] 1 / 8, we find N [...]...|$|E
40|$|Adaptive Arrays {{have been}} used {{extensively}} in wireless communications applications to reduce interference between desired users and interfering signals. In particular a large concentration of research has been directed to the Uniform Linear Array (ULA). However in most situations presented the authors utilise a fixed <b>array</b> <b>length.</b> In a mobile environment this has the disadvantage of producing a fixed beamwidth due to the fixed <b>array</b> <b>length.</b> This paper proposes an algorithm {{which can be used}} to determine the required beamwidth for a number of incoming signals by altering the length a specified number of elements present in an antenna array. This is achieved by the difference in the arrival angle of the desired user and a range incoming interferers known having a varied angle spread. The Least Mean Square (LMS) algorithm is incorporated into the algorithm for optimisation of the radiation pattern...|$|E
40|$|Abstract: Microsatellites are {{currently}} {{one of the}} most commonly used genetic markers. The application of bioinformatic tools has become common practice in the study of these short tandem repeats (STR). However, in silico studies can suffer from study bias. Using a meta-analysis on microsatellite distribution in yeast we show that estimates of numbers of repeats reported by different studies can differ in the order of several magnitudes, even within a single genome. These differences arise because varying definitions of microsatellites, spanning repeat size, <b>array</b> <b>length</b> and array composition, are used in different search paradigms, with minimum <b>array</b> <b>length</b> being the main influencing factor. Structural differences in the implemented search algorithm additionally contribute to variation in the number of repeats detected. We suggest that for future studies a consistent approach to STR searches is adopted in order to improve the power of intra- and interspecific comparison...|$|E
40|$|Our goal in {{this paper}} is to make secure {{information}} flow typing more practical. We propose simple and permissive typing rules for array operations in a simple sequential imperative language. Arrays are given types of the form 1 arr 2, where 1 is the security class of the array's contents and 2 is the security class of the <b>array's</b> <b>length.</b> To keep the typing rules permissive, we propose a novel, lenient semantics for out-of-bounds array indices. We show that our type system ensures a noninterference property, and we present an example that suggests that it will not be too difficult in practice to write programs that satisfy the typing rules...|$|R
40|$|Experiments with {{one-dimensional}} {{arrays of}} Josephson junctions in {{the regime of}} dominating charging energy show that the Coulomb blockade is lifted at the threshold voltage, which {{is proportional to the}} <b>array's</b> <b>length</b> and depends strongly on the Josephson energy. We explain this behavior as de-pinning of the Cooper-pair-charge-density by the applied voltage. We assume strong charge disorder and argue that physics around the de-pinning point is governed by a disordered sine-Gordon-like model. This allows us to employ the well-known theory of charge density wave de-pinning. Our model is in good agreement with the experimental data. Comment: Main: 4 pages, 2 figures, Appendix: 3 pages, 4 figure...|$|R
5000|$|Let P and c be <b>arrays</b> of <b>length</b> n with 1-based {{indexing}} (i.e. {{the first}} entry of an array has index 1). The algorithm for generating all n! permutations {{of the set}} {1,2,...,n} is given by the following pseudocode: ...|$|R
40|$|Abstract Background Birds have smaller average genome sizes {{than other}} {{tetrapod}} classes, {{and it has}} been proposed that a relatively low frequency of repeating DNA is one factor in reduction of avian genome sizes. Results DNA repeat arrays in the sequenced portion of the chicken (Gallus gallus) autosomes were quantified and compared with those in human autosomes. In the chicken 10. 3 % of the genome was occupied by DNA repeats, in contrast to 44. 9 % in human. In the chicken, the percentage of a chromosome occupied by repeats was positively correlated with chromosome length, but even the largest chicken chromosomes had repeat densities much lower than those in human, indicating that avoidance of repeats in the chicken is not confined to minichromosomes. When 294 simple sequence repeat types shared between chicken and human genomes were compared, mean repeat <b>array</b> <b>length</b> and maximum repeat <b>array</b> <b>length</b> were significantly lower in the chicken than in human. Conclusions The fact that the chicken simple sequence repeat arrays were consistently smaller than arrays of the same type in human is evidence that the reduction in repeat <b>array</b> <b>length</b> in the chicken has involved numerous independent evolutionary events. This implies that reduction of DNA repeats in birds is the result of adaptive evolution. Reduction of DNA repeats on minichromosomes may be an adaptation to permit chiasma formation and alignment of small chromosomes. However, the fact that repeat array lengths are consistently reduced on the largest chicken chromosomes supports the hypothesis that other selective factors are at work, presumably related to the reduction of cell size and consequent advantages for the energetic demands of flight. </p...|$|E
40|$|OBJECTIVE: To {{describe}} the genetic diversity of Plasmodium vivax isolates from different {{areas in the}} Brazilian Amazon using 11 polymorphic microsatellites and to evaluate the correlation between microsatellite variation and repeat <b>array</b> <b>length.</b> METHODS: Microsatellites with variable repeat units and array lengths were selected using in silico search of the P. vivax genome. We designed primers and amplified the selected loci in DNA obtained from patients with P. vivax acute infections. RESULTS: Positive correlation between repeat <b>array</b> <b>length</b> and microsatellite variation was detected independently {{of the size of}} repeat unit (di, tri, or tetranucleotide). We used these markers to {{describe the}} genetic variability of P. vivax isolates from four geographic regions of the Brazilian Amazon. Substantial variability was observed among P. vivax isolates within populations, concurrent with high levels of multiple-clone infections and high linkage disequilibrium. Overall, structured populations were observed with moderate to high genetic differentiation. CONCLUSION: The markers studied are useful tools for assessing population structure of P. vivax, as demonstrated for Brazilian populations and for searching for evidence of recent selection events associated with different phenotypes, such as drug resistance...|$|E
40|$|This paper {{presents}} some of {{the preliminary}} work aimed at estimating the ocean bottom morphological structure in coastal waters using a towed array. In order to obtain {{an idea of the}} expected performance of the system and draw some conclusions on its operation this study presents the sensitivity of three processors to variations of: <b>array</b> <b>length,</b> source and receiver positions, sensor noise, source frequency and frequency band. Conclusions tend to demonstrate that cost function sensitivity to sound speed variations is higher on the bottom top layers and it increases with <b>array</b> <b>length.</b> An increased sensitivity is generally acompanied by a cost function non-monotonic behavior creating local minima and making it more di cult to reach the global minimum. Attenuations have in general small in uence on the acoustic eld structure and are therefore di cult to estimate. Increasing the signal frequency band by incoherent module averaging has no signi cant in uence on sensitivity. A cost function relaying on the conventional matched lter has shown low sensitivity to sensor noise and is being extended to matching directional data from bottom arrivals at several frequencies. Mismatch cases, mainly those related to array/source relative position, will be also presented...|$|E
40|$|Several theorems {{exist that}} allow the {{identification}} of undetectable faults in synchronous sequential circuits by applying combinational ATPG to an iterative logic <b>array</b> of limited <b>length.</b> In this paper, we consider the theorem that resulted {{in one of the}} most effective procedures for identifying undetectable faults. We show conditions on fault free sequential circuits under which the only undetectable faults that can be identified by this theorem using an iterative logic <b>array</b> of any <b>length</b> are combinationally redundant faults. Such faults can be identified using an iterative logic <b>array</b> of <b>length</b> one, or techniques specifically developed for combinationally redundant faults. Whereas for a general circuit, increasing the length of the iterative logic array may help identify additional undetectable faults, this is not the case for circuits with the properties identified here. We demonstrate the existence of benchmark circuits that satisfy these conditions. ...|$|R
5000|$|In pseudocode, the {{pairwise}} summation algorithm for an <b>array</b> x of <b>length</b> n > 0 can be written: ...|$|R
5000|$|... size_t flexsize(int n){ char bn+3; /* Variable <b>length</b> <b>array</b> */ return sizeof b; /* Execution time sizeof */} ...|$|R
