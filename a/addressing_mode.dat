183|613|Public
25|$|MIPS IV is {{the fourth}} version of the architecture. It is a superset of MIPS III and is {{compatible}} with all existing versions of MIPS. MIPS IV was designed to mainly improve floating-point (FP) performance. To improve access to operands, an indexed <b>addressing</b> <b>mode</b> (base + index, both sourced from GPRs) for FP loads and stores was added, as were prefetch instructions for performing memory prefetching and specifying cache hints (these supported both the base + offset and base + index addressing modes).|$|E
25|$|In {{the early}} days of the {{computer}} industry, programming was done in assembly language or machine code, which encouraged powerful and easy-to-use instructions. CPU designers therefore tried to make instructions that would do as much work as feasible. With the advent of higher level languages, computer architects also started to create dedicated instructions to directly implement certain central mechanisms of such languages. Another general goal was to provide every possible <b>addressing</b> <b>mode</b> for every instruction, known as orthogonality, to ease compiler implementation. Arithmetic operations could therefore often have results as well as operands directly in memory (in addition to register or immediate).|$|E
2500|$|An {{instruction}} set {{is said to}} be orthogonal if it lacks redundancy (i.e., there is only a single instruction {{that can be used to}} accomplish a given task) and is designed such that instructions can use any register in any <b>addressing</b> <b>mode.</b> This terminology results from considering an instruction as a vector whose components are the instruction fields. [...] One field identifies the registers to be operated upon and another specifies the <b>addressing</b> <b>mode.</b> An orthogonal {{instruction set}} uniquely encodes all combinations of registers and addressing modes.|$|E
5000|$|<b>Address</b> <b>mode</b> {{operations}} - Use <b>address</b> <b>modes</b> {{to simplify}} code.|$|R
5000|$|Different {{computer}} architectures vary greatly {{as to the}} number of <b>addressing</b> <b>modes</b> they provide in hardware. There are some benefits to eliminating complex <b>addressing</b> <b>modes</b> and using only one or a few simpler <b>addressing</b> <b>modes,</b> even though it requires a few extra instructions, and perhaps an extra register. [...] It has proven much easier to design pipelined CPUs if the only <b>addressing</b> <b>modes</b> available are simple ones.|$|R
50|$|Since the PDP-11 was an octal-oriented (3-bit sub-byte) machine (<b>addressing</b> <b>modes</b> 0-7, {{registers}} R0-R7), {{there were}} (electronically) 8 <b>addressing</b> <b>modes.</b> Through {{the use of}} the Stack Pointer (R6) and Program Counter (R7) as referenceable registers, there were 10 conceptual <b>addressing</b> <b>modes</b> available.|$|R
2500|$|MIPS I has {{instructions}} that load and store 8-bit bytes, 16-bit halfwords, and 32-bit words. Only one <b>addressing</b> <b>mode</b> is supported: base + displacement. Since MIPS I is a 32-bit architecture, loading quantities fewer than 32 bits requires the datum {{to be either}} signed- or zero-extended to 32 bits. The load instructions suffixed by [...] "unsigned" [...] perform zero extension; otherwise sign extension is performed. Load instructions source the base from {{the contents of a}} GPR (rs) and write the result to another GPR (rt). Store instructions source the base from the contents of a GPR (rs) and the store data from another GPR (rt). All load and store instructions compute the memory address by summing the base with the sign-extended 16-bit immediate. MIPS I requires all memory accesses to be aligned to their natural word boundaries, otherwise an exception is signaled. To support efficient unaligned memory accesses, there are load/store word instructions suffixed by [...] "left" [...] or [...] "right". All load instructions are followed by a load delay slot. The instruction in the load delay slot cannot use the data loaded by the load instruction. The load delay slot can be filled with an instruction that is not dependent on the load; a nop is substituted if such an instruction cannot be found.|$|E
50|$|This <b>addressing</b> <b>mode</b> {{is closely}} related to the indexed {{absolute}} <b>addressing</b> <b>mode.</b>|$|E
50|$|As a result, {{a greater}} number of {{programs}} were able to utilize the enhanced direct page <b>addressing</b> <b>mode</b> versus legacy processors that only included the zero page <b>addressing</b> <b>mode.</b>|$|E
25|$|The {{designers}} {{attempted to}} make the assembly language orthogonal. That is, instructions are divided into operations and <b>address</b> <b>modes,</b> and almost all <b>address</b> <b>modes</b> are available for almost all instructions. There are 56 instructions and a minimum instruction size of 16 bits. Many instructions and <b>addressing</b> <b>modes</b> are longer to include additional <b>address</b> or <b>mode</b> bits.|$|R
50|$|Even on a {{computer}} with many <b>addressing</b> <b>modes,</b> measurements of actual programs indicate that the simple <b>addressing</b> <b>modes</b> listed below account for some 90% or more of all <b>addressing</b> <b>modes</b> used. Since most such measurements are based on code generated from high-level languages by compilers, this reflects to some extent {{the limitations of the}} compilers being used.|$|R
50|$|A Change <b>Address</b> <b>Mode</b> (CAM) {{instruction}} switched between 2-, 3- and 4-character <b>address</b> modes.The <b>address</b> <b>mode</b> specified {{the number}} of characters needed for each operand address in instructions.|$|R
50|$|Additionally, a third index {{register}} (Z) was included, the stack pointer was widened to 16 bits, and the zero page <b>addressing</b> <b>mode</b> was superseded {{by the more}} flexible direct page <b>addressing</b> <b>mode.</b>|$|E
50|$|When {{there are}} only a few {{addressing}} modes, the particular <b>addressing</b> <b>mode</b> required is usually encoded within the instruction code(e.g. IBM System/360 and successors, most RISC). But when there are lots of addressing modes, a specific field is often set aside in the instruction to specify the <b>addressing</b> <b>mode.</b> The DEC VAX allowed multiple memory operands for almost all instructions, and so reserved the first few bits of each operand specifier to indicate the <b>addressing</b> <b>mode</b> for that particular operand.Keeping the <b>addressing</b> <b>mode</b> specifier bits separate from the opcode operation bits produces an orthogonal instruction set.|$|E
50|$|A {{cylinder}} is {{a division}} of data in a disk drive, as used in the CHS <b>addressing</b> <b>mode</b> of a Fixed Block Architecture disk or the cylinder-head-record (CCHHR) <b>addressing</b> <b>mode</b> of a CKD disk.|$|E
5000|$|Support {{of several}} <b>addressing</b> <b>modes.</b> In {{addition}} to the 6-byte MAC address (including multicast and unicast), it supports a MAC address-less mode, and an optional 3-byte <b>address</b> <b>mode.</b>|$|R
50|$|Besides instructions, the ISA defines {{items in}} the {{computer}} {{that are available to}} a program - e.g. data types, registers, <b>addressing</b> <b>modes,</b> and memory. Instructions locate these available items with register indexes (or names) and memory <b>addressing</b> <b>modes.</b>|$|R
5000|$|With four <b>address</b> <b>mode</b> {{selection}} bits (P, R, I and N - indexed, relative, indirect and immediate), NAR 2 instructions can specify 16 different <b>addressing</b> <b>modes</b> but not {{all make}} sense in all instructions. In the following table: ...|$|R
50|$|Within a loop, this <b>addressing</b> <b>mode</b> {{can be used}} to step {{backwards}} {{through all}} the elements of an array or vector. A stack can be implemented by using this mode in conjunction with the previous <b>addressing</b> <b>mode</b> (autoincrement).|$|E
5000|$|... +-----------------+ | clear {{carry bit}} | +-----------------+ [...] +-------------------+ | clear Accumulator | +-------------------+The implied <b>addressing</b> <b>mode,</b> {{also called the}} {{implicit}} <b>addressing</b> <b>mode</b> (X86 assembly language), does not explicitly specify an effective address for either the source or the destination (or sometimes both).|$|E
50|$|In {{the early}} {{instances}} {{of the architecture}} (System/360 and early System/370), the instruction address was 24 bits; in later instances (XA/370), the instruction address was 31 bits plus a mode bit (24 bit <b>addressing</b> <b>mode</b> if zero; 31 bit <b>addressing</b> <b>mode</b> if one) {{for a total of}} 32 bits.|$|E
50|$|The <b>{{addressing}}</b> <b>modes</b> {{listed below}} {{are divided into}} code addressing and data addressing. Most computer architectures maintain this distinction, but there are, or have been, some architectures which allow (almost) all <b>addressing</b> <b>modes</b> {{to be used in}} any context.|$|R
25|$|Has {{powerful}} indexed <b>addressing</b> <b>modes.</b>|$|R
5000|$|The {{first four}} {{general-purpose}} RAM locations are {{also known as}} the X, Y, V and W registers, and some instructions can access them using special short <b>addressing</b> <b>modes.</b> The X and Y registers serve as index registers, and can use indirect <b>addressing</b> <b>modes</b> [...] and [...]|$|R
50|$|See the {{discussion}} of side-effects under the autoincrement <b>addressing</b> <b>mode.</b>|$|E
5000|$|The {{first drive}} {{interface}} used 22-bit <b>addressing</b> <b>mode</b> {{which resulted in}} a maximum drive capacity of two gigabytes. Later, the first formalized ATA specification used a 28-bit <b>addressing</b> <b>mode</b> through LBA28, allowing for the addressing of 228 (...) sectors (blocks) of 512 bytes each, resulting in a maximum capacity of 128 GiB (137 GB).|$|E
5000|$|The PC-relative <b>addressing</b> <b>mode</b> {{can be used}} to load a {{register}} with a value stored in program memory a short distance away from the current instruction. It {{can be seen as a}} special case of the [...] "base plus offset" [...] <b>addressing</b> <b>mode,</b> one that selects the program counter (PC) as the [...] "base register".|$|E
50|$|The <b>addressing</b> <b>modes</b> {{listed here}} {{were used in}} the 1950-1980 period, but are no longer {{available}} on most current computers.This list is by no means complete; there have been many other interesting and peculiar <b>addressing</b> <b>modes</b> used from time to time, e.g. absolute-minus-logical-OR of two or three index registers.|$|R
50|$|Most RISC {{architectures}} {{have only}} about five simple <b>addressing</b> <b>modes,</b> while CISC architectures {{such as the}} DEC VAX have over a dozen <b>addressing</b> <b>modes,</b> {{some of which are}} quite complicated. The IBM System/360 architecture had only three addressing modes; a few more have been added for the System/390.|$|R
2500|$|Simple <b>addressing</b> <b>modes</b> {{with complex}} <b>addressing</b> {{performed}} by instruction sequences ...|$|R
5000|$|RISC OS version 5 in {{hardware}} ROM module, using 32-bit <b>addressing</b> <b>mode.</b>|$|E
50|$|Sequential {{execution}} is {{not considered}} to be an <b>addressing</b> <b>mode</b> on some computers.|$|E
5000|$|Note {{that there}} is no {{generally}} accepted way of naming the various addressing modes. In particular, different authors and computer manufacturers may give different names to the same <b>addressing</b> <b>mode,</b> or the same names to different addressing modes. Furthermore, an <b>addressing</b> <b>mode</b> which, in one given architecture, is treated as a single <b>addressing</b> <b>mode</b> may represent functionality that, in another architecture, is covered by two or more addressing modes. For example, some complex instruction set computer (CISC) architectures, such as the Digital Equipment Corporation (DEC) VAX, treat registers and literal or immediate constants as just another <b>addressing</b> <b>mode.</b> Others, such as the IBM System/360 and its successors, and most reduced instruction set computer (RISC) designs, encode this information within the instruction. Thus, the latter machines have three distinct instruction codes for copying one register to another, copying a literal constant into a register, and copying the contents of a memory location into a register, while the VAX has only a single [...] "MOV" [...] instruction.|$|E
5000|$|<b>Addressing</b> <b>modes</b> added scaled {{indexing}} {{and another}} level of indirection ...|$|R
5000|$|Simple <b>addressing</b> <b>modes</b> {{with complex}} <b>addressing</b> {{performed}} by instruction sequences ...|$|R
50|$|Most operands {{can apply}} any of eight <b>addressing</b> <b>modes</b> to eight registers. The <b>addressing</b> <b>modes</b> provide register, immediate, absolute, relative, {{deferred}} (indirect), and indexed addressing, and can specify autoincrementation and autodecrementation of a register by one (byte instructions) or two (word instructions). Use of relative addressing lets a machine-language program be position-independent.|$|R
