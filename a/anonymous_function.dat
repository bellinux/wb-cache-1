97|150|Public
25|$|Anonymous delegates are {{functions}} pointers {{that hold}} anonymous methods. The {{purpose is to}} make it simpler to use delegates by simplifying the process of assigning the function. Instead of declaring a separate method in code the programmer can use the syntax to write the code inline and the compiler will then generate an <b>anonymous</b> <b>function</b> for it.|$|E
25|$|Note {{also that}} the <b>anonymous</b> <b>function</b> is named Smaller in the {{parameter}} list of the second definition of qsort {{so that it can}} be referenced by that name within that function. It is not named in the first definition of qsort, which deals with the base case of an empty list and thus has no need of this function, let alone a name for it.|$|E
500|$|Until PHP 5.3, {{support for}} {{anonymous}} functions and closures {{did not exist}} in PHP. While create_function (...) exists since PHP 4.0.1, it is merely a thin wrapper around eval (...) that allows normal PHP functions to be created during program execution. PHP 5.3 added syntax to define an <b>anonymous</b> <b>function</b> or [...] "closure" [...] which can capture variables from the surrounding scope: ...|$|E
50|$|<b>Anonymous</b> <b>functions</b> {{originate}} {{in the work of}} Alonzo Church in his invention of the lambda calculus in 1936, before electronic computers, in which all <b>functions</b> are <b>anonymous.</b> In several programming languages, <b>anonymous</b> <b>functions</b> are introduced using the keyword lambda, and <b>anonymous</b> <b>functions</b> are often referred to as lambdas or lambda abstractions. <b>Anonymous</b> <b>functions</b> have been a feature of programming languages since Lisp in 1958, {{and a growing number of}} modern programming languages support <b>anonymous</b> <b>functions.</b>|$|R
50|$|Since <b>anonymous</b> <b>functions</b> don't have names, {{it is not}} {{possible}} to define recursive <b>anonymous</b> <b>functions.</b>|$|R
5000|$|In C#, {{support for}} <b>anonymous</b> <b>functions</b> has deepened {{through the various}} {{versions}} of the language compiler. The language v3.0, released in November 2007 with [...]NET Framework v3.5, has full support of <b>anonymous</b> <b>functions.</b> C# names them lambda expressions, following the original version of <b>anonymous</b> <b>functions,</b> the lambda calculus. See the C# 4.0 Language Specification, section 5.3.3.29, for more information.|$|R
2500|$|... evaluates to [...] Here, we're doing a {{function}} application: we execute the <b>anonymous</b> <b>function</b> by passing to it the value 5.|$|E
2500|$|A lambda {{abstraction}} [...] is {{a definition}} of an <b>anonymous</b> <b>function</b> {{that is capable of}} taking a single input [...] and substituting it into the expression [...]|$|E
2500|$|The {{abstraction}} [...] {{represents an}} <b>anonymous</b> <b>function</b> that maps the input [...] to the output [...] [...] This is also called function literal, common in most contemporary programming languages, and sometimes written as [...]|$|E
5000|$|In this example, [...] is an {{instance}} of [...] and [...] is equivalent to [...]PHP 5.3 mimics <b>anonymous</b> <b>functions</b> {{but it does not}} support true <b>anonymous</b> <b>functions</b> because PHP functions are still not first-class objects.|$|R
5000|$|<b>Anonymous</b> <b>{{function}}s</b> (function literals) {{are defined}} using [...] expressions, e.g. [...] for a function that squares its argument. Lisp programming style frequently uses higher-order functions {{for which it}} is useful to provide <b>anonymous</b> <b>functions</b> as arguments.|$|R
5000|$|Lisp and Scheme support <b>anonymous</b> <b>functions</b> {{using the}} [...] "lambda" [...] construct, {{which is a}} {{reference}} to lambda calculus. Clojure supports <b>anonymous</b> <b>functions</b> with the [...] "fn" [...] special form and # (...) reader syntax.(lambda (arg) (* arg arg)) ...|$|R
2500|$|The above {{example is}} an {{expression}} that evaluates to a first-class function. The symbol lambda creates an <b>anonymous</b> <b>function,</b> given a list of parameter names, (x) [...] just a single argument in this case, and an expression that is evaluated as {{the body of the}} function, (* x x). Anonymous functions are sometimes called lambda expressions.|$|E
2500|$|It thus defines an <b>anonymous</b> <b>function</b> {{that takes}} [...] and returns [...] For example, [...] is a lambda {{abstraction}} for the function [...] {{using the term}} [...] for [...] The definition of a function with a lambda abstraction merely [...] "sets up" [...] the function but does not invoke it. [...] The abstraction binds the variable [...] in the term [...]|$|E
2500|$|The authors {{state that}} the use of {{equality}} operator (=) to denote set membership rather than the set membership operator (âˆˆ) is an abuse of notation, but that doing so has advantages. Inside an equation or inequality, the use of asymptotic notation stands for an <b>anonymous</b> <b>function</b> in the set O(g), which eliminates lower-order terms, and helps to reduce inessential clutter in equations, for example: ...|$|E
50|$|Go {{supports}} <b>anonymous</b> <b>functions.</b>|$|R
50|$|<b>Anonymous</b> <b>functions</b> {{including}} lexical closures.|$|R
5000|$|<b>Anonymous</b> <b>functions</b> with {{capturing}} semantics (i.e., closures) ...|$|R
2500|$|A typed lambda {{calculus}} is a typed formalism {{that uses the}} lambda-symbol (...) to denote <b>anonymous</b> <b>function</b> abstraction. In this context, types are usually objects of a syntactic nature that are assigned to lambda terms; {{the exact nature of}} a type depends on the calculus considered (see kinds below). From a certain point of view, typed lambda calculi can be seen as refinements of the untyped {{lambda calculus}} but from another point of view, they can also be considered the more fundamental theory and [...] untyped lambda calculus a special case with only one type.|$|E
5000|$|In certain contexts, {{like when}} an <b>anonymous</b> <b>function</b> is a {{parameter}} being passed to another function, the compiler can infer {{the types of}} {{the parameters of the}} <b>anonymous</b> <b>function</b> and they can be omitted in the syntax. In such contexts, it is also possible to use a shorthand for anonymous functions using the underscore character to introduce unnamed parameters. val list = List(1, 2, 3, 4) list.reduceLeft( [...] (x, y) => x + y [...] ) // Here, the compiler can infer that the types of x and y are both Int. // Thus, it needs no type annotations on the parameters of the <b>anonymous</b> <b>function.</b> list.reduceLeft( [...] _ + _ [...] ) // Each underscore stands for a new unnamed parameter in the <b>anonymous</b> <b>function.</b> // This results in an even shorter equivalent to the <b>anonymous</b> <b>function</b> above.|$|E
50|$|In PHP {{and other}} {{languages}} the <b>anonymous</b> <b>function</b> {{is the only}} alternative: the nested function is declared not as usual function, but by reference, as a local variable. To use local variables in the <b>anonymous</b> <b>function,</b> use closure.|$|E
50|$|Numerous {{languages}} support <b>anonymous</b> <b>functions,</b> {{or something}} similar.|$|R
50|$|The various dialects of ML support <b>anonymous</b> <b>functions.</b>|$|R
50|$|Alternatively, we {{can also}} compose using pure <b>anonymous</b> <b>functions.</b>|$|R
50|$|Before 4.0.1, PHP had no <b>anonymous</b> <b>function</b> support.|$|E
50|$|Tcl uses apply {{command to}} apply an <b>anonymous</b> <b>function</b> (since 8.6).|$|E
50|$|The <b>anonymous</b> <b>function</b> {{here is the}} {{multiplication}} of the two arguments.|$|E
5000|$|... #Subtitle level 5: Choosing <b>anonymous</b> <b>functions</b> {{only for}} lifting ...|$|R
50|$|Haskell uses a concise syntax for <b>anonymous</b> <b>functions</b> (lambda expressions).|$|R
5000|$|Clang {{supports}} <b>anonymous</b> <b>functions,</b> called blocks, {{which have}} the form: ...|$|R
5000|$|The <b>anonymous</b> <b>function</b> in {{this example}} is the lambda expression:lambda x,y: cmp(...) ...|$|E
5000|$|Note the {{implications}} of the <b>anonymous</b> <b>function</b> in the JavaScript fragments that follow: ...|$|E
5000|$|Instead, an <b>anonymous</b> <b>function,</b> {{that does}} not return a value, can be used:javascript:(function (...) {document.title=location.href;}) (...) ...|$|E
5000|$|In Elixir, you can mix module {{definitions}} and <b>anonymous</b> <b>functions</b> ...|$|R
5000|$|... #Subtitle level 5: Choosing named and <b>anonymous</b> <b>functions</b> for lifting ...|$|R
50|$|Java {{supports}} <b>anonymous</b> <b>functions,</b> named Lambda Expressions, {{starting with}} JDK 8.|$|R
