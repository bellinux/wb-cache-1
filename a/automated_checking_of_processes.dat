0|10000|Public
40|$|Abstract. Compliance rules {{describe}} regulations, {{policies and}} quality constraints business processes must adhere to. Given {{the large number}} of rules and their frequency of change, manual compliance checking can be-come a time-consuming task. <b>Automated</b> compliance <b>checking</b> <b>of</b> <b>process</b> activities and their ordering is an alternative whenever business pro-cesses and compliance rules are described in a formal way. This paper introduces an approach for <b>automated</b> compliance <b>checking.</b> Compliance rules are translated into temporal logic formulae that serve as input to model checkers which in turn verify whether a process model satisfies the requested compliance rule. To address the problem of state-space explo-sion we employ a set of reduction rules. The approach is prototypically realized and evaluated. ...|$|R
40|$|In {{order to}} improve the {{flexibility}} of information systems, an increasing amount <b>of</b> business <b>processes</b> is being automated by implementing tasks as modular services in service compositions. As organizations are required to adhere to laws and regulations, with this increased flexibility there is a demand for <b>automated</b> compliance <b>checking</b> <b>of</b> business <b>processes.</b> Model <b>checking</b> is a technique which exhaustively and automatically verifies system models against specifications of interest, e. g. a finite state machine against a set of logic formulas. When model checking business processes, existing approaches either cause large amounts of overhead, linearize models {{to such an extent}} that activity parallelization is lost, offer only <b>checking</b> <b>of</b> runtime execution traces, or introduce new and unknown logics. In order to fully benefit from existing model checking techniques, we propose a mapping from workflow patterns to a class of labeled transition systems known as Kripke structures. With this mapping, we provide pre-runtime compliance checking using well-known branching time temporal logics. The approach is validated on a complex abstract process which includes a deferred choice, parallel branching, and a loop. The process is modeled using the Business Process Model and Notation (BPMN) standard, converted into a colored Petri net using the workflow patterns, and subsequently translated into a Kripke structure, which is then used for verification...|$|R
50|$|Verification {{will involve}} {{such things as}} human review of the models, {{performed}} by experts in the relevant domain, and <b>automated</b> <b>checking</b> <b>of</b> the Executable UML semantics. i.e., checking that the Executable UML model complies with the Executable UML metamodel.|$|R
50|$|The <b>process</b> <b>of</b> editing in DRAKON Editor {{is based}} on free drawing. The user inserts and manipulates {{primitive}} shapes such as rectangles, vertical and horizontal lines. The user experience {{is similar to that}} of business drawing tools. DRAKON Editor does not prevent the user from violating the rules of DRAKON language. It is possible, however, to perform an <b>automated</b> <b>check</b> <b>of</b> the visual syntax at any time.|$|R
40|$|We address two {{necessary}} issues {{needed for}} developing {{safe and reliable}} MD PnP systems: robust wireless networking and <b>automated</b> <b>checking</b> for component interoperability and reliability. First, the robustness of a wireless network can be improved {{by the use of}} DSSS-CDMA, which tradeoff throughput to achieve higher reliability and persistence of connections as needed. Second, <b>automated</b> <b>checking</b> <b>of</b> components interoperability and reliability can be partially addressed by the use of the Integrated Framework for Assumptions and Dependencies (IFAD) by specifying a machine-checkable encoding <b>of</b> component information, <b>checking</b> interface assumptions, and finding how various environmental changes can impact the system...|$|R
40|$|The {{development}} of parallel programs is {{primarily concerned with}} application speed. This {{has led to the}} {{development of}} parallel applications in which software engineering aspects play only subordinate roles. In order to increase software quality in parallel applications, we motivate the construction of parallel programs by composing active objects which interact by means of an object [...] oriented coordination model. This paper presents a formalism for specifying the behaviour of parallel active objects and a corresponding notion of behavioural types which can be used for verifying whether certain active objects conform to a specified behaviour. Our approach is based on high [...] level Petri nets which enable (besides other benefits) automated analysis, in particular for <b>automated</b> type <b>checking</b> <b>of</b> active objects. We illustrate the usefulness of our approach by presenting reusable active objects for a manager/worker architecture. Their correct interaction is shown by <b>automated</b> <b>checking</b> <b>of</b> behav [...] ...|$|R
40|$|Research {{operating}} systems are often written in type-safe, highlevel languages. These languages perform automatic static and dynamic checks to give basic assurances about run-time behavior. Yet such {{operating systems}} still rely on unsafe, low-level code {{to communicate with}} hardware, {{with little or no}} <b>automated</b> <b>checking</b> <b>of</b> the correctness of the hardware-software interaction. This paper describes experience using the Spec # language and Boogie verifier to statically specify and statically verify the safety of a driver's interaction with a network interface, including the safety of DMA. 1...|$|R
40|$|Abstract. Traditional IDLs {{present some}} limitations, {{since they were}} defined for {{describing}} the services that objects offer, but not those ser-vices they require from other objects, nor the partial ordering in which their services {{are expected to be}} used. In this paper we propose an IDL extension that uses a subset of pi-calculus for describing objects service protocols. Our approach can be also used in a component-oriented en-vironment for <b>automated</b> <b>checking</b> <b>of</b> protocol interoperability between objects. This is supported by a platform that controls the dynamic com-position of components. ...|$|R
40|$|Abstract. We {{describe}} an automata-theoretic {{approach to the}} <b>automated</b> <b>checking</b> <b>of</b> truth and validity for temporal logics. The basic idea underlying {{this approach is that}} for any formula we can construct an alternating automaton that accepts precisely the models of the formula. For linear temporal logics the automaton runs on infinite words while for branching temporal logics the automaton runs on infinite trees. The simple combinatorial structures that emerge from the automata-theoretic approach decouple the logical and algorithmic components of truth and validity checking and yield clean and essentially optimal algorithms for both problems. ...|$|R
40|$|International audienceTERMOS is an UML-based formal {{language}} for specifying scenarios in mobile computing systems. TERMOS scenarios {{are used for}} the verification of test traces: they represent mandatory or forbidden interactions that are searched for in the trace. Building upon previous work on the semantics of TERMOS, this paper presents the complete integration of the language into UML support technology. A TERMOS profile has been developed for the editing of scenarios, {{as well as an}} Eclipse plugin for the <b>automated</b> <b>checking</b> <b>of</b> traces. We demonstrate the approach on a case study, a group membership protocol in ad hoc networks...|$|R
40|$|The Unified Modelling Language (UML) is {{becoming}} a global standard diagrammatic notation for expressing and describing object-oriented models. Recently, the Object Constraint Language (OCL) has been proposed as a standard expression language for expressing additional constraints on UML models, which are not conveniently expressible in a diagrammatic form. In this paper we provide an approach for formalising some aspects of UML diagrams and OCL, {{which could be used}} for <b>automated</b> <b>checking</b> <b>of</b> the integrity of UML/OCL models, and help building case tools for the notation. We also highlight some features of OCL which makes it difficult to give full mathematical semantics...|$|R
40|$|Abstract. Software {{development}} {{processes are}} typically {{supported by a}} set of different tools that assist the designer in various phases of de-velopment like modeling, verification, source code generation, testing. Tool-chains can be formed by the integration of tools that are related to the subsequent steps <b>of</b> the <b>process.</b> In this paper, we present a tool inte-gration framework which applies metamodel-driven and process-centric design patterns. Motivated by our research activities in various projects, our framework is based on standard process models, which allows the re-use of tool integration patterns as well as <b>automated</b> <b>checking</b> <b>of</b> the conformance of tool-chains to development standards. We make use of the state-of-the-art Rational Jazz platform as a technological basis. ...|$|R
40|$|Traditional IDLs {{were defined}} for {{describing}} the ser-vices that objects offer, but not those services they require from other objects, nor the partial ordering {{in which they}} expect their methods to be used. In this paper we propose {{an extension of the}} CORBA IDL that uses a sugared subset of the polyadic pi-calculus for describing object service protocols, aimed towards the <b>automated</b> <b>checking</b> <b>of</b> protocol interoperability between CORBA objects in open component-based environments. Furthermore, some advantages and disadvantages of our proposal are discussed, {{as well as some of}} the practical limitations encountered when trying to implement and use this sort of IDL exten-sions in open systems. ...|$|R
30|$|Duplicate {{data entry}} {{was used for}} quality control with the paper-based surveys (Kawado et al. 2003; Neaton et al. 1990). <b>Automated</b> logic <b>checking</b> <b>of</b> numeric fields was {{implemented}} as appropriate. More details about the survey methodology and validation were published previously (Bauer et al. 2016).|$|R
40|$|The {{size of a}} {{software}} system provides {{a basis for the}} estimation of software cost during software development. Hence, it is important to measure the system size reliably as early as possible. Two best known specification level metrics are Albrecht's Function Points and DeMarco's Function Bang which, however, lack automated estimation support. We demonstrate how the calculation of these metrics can be automated and describe a prototype assistant tool, which calculates these metrics from Structured Analysis (SA) descriptions. To assure the reliability of estimation, the SA descriptions must be verified before applying the automated metrics. In our prototype system, we have implemented a set <b>of</b> rules for <b>automated</b> <b>checking</b> <b>of</b> completeness and consistency of a structured specification...|$|R
40|$|The {{mechanization}} of business-to-business contract enforcement {{requires a}} clear architecture {{and a clear}} and unambiguous underpinning model of the way permissions and obligations are managed within organizations. Policies {{will need to be}} expressed in terms of the basic model, and the expressive power available will depend, in part, on the ability to compose sets of policies derived from different sources. The models used must reflect the structure of the organizations concerned and how the behaviour of organizations is constrained by broader shared rules. This paper considers a contract monitoring system intended to provide <b>automated</b> <b>checking</b> <b>of</b> business to business contracts, sets out a suitable model and explains how {{it can be used to}} guide the representatio...|$|R
40|$|We {{present a}} method for {{translating}} the synchronisation behaviour <b>of</b> a <b>process</b> oriented discrete event simulation language into a process algebra. Such translations serve two purposes. The first exploits the formal structure <b>of</b> the target <b>process</b> algebraic representations to enable proofs of such properties of the source system as deadlock freedom, safety, fairness and liveness which can {{be very difficult to}} establish by simulation experiment. The second exploits the denotational semantics to better understand the language constructs as abstract entities and to facilitate reasoning about simulation models. Here we give the intuition and the basic translation mechanisms using a variety of the Demos simulation language and the CCS and SCCS process algebras. The translations have been automated as SML programs and produce CWB compatible input allowing the <b>automated</b> <b>checking</b> <b>of</b> formal system properties. Keywords: process algebras; simulation; verification. 1 Introduction Many complex pr [...] ...|$|R
50|$|In 2009 {{the company}} {{introduced}} a new DNS security capability that functions as a spam blacklist, providing <b>automated,</b> real-time <b>checking</b> <b>of</b> DNS queries against a list of known malicious sites. This was based on Nominum’s Trusted Response and Universal Enforcement (TRUE) technology, which protects broadband users and devices against a range of Internet threats and malicious content.|$|R
40|$|Academic {{institutions}} typically publish annual calendars {{that describe}} {{the rules and}} regulations for their degree programs. Using Extensible Markup Language (XML), this thesis investigates the development of a lightweight markup scheme for degree requirements that both structures the text of the regulations and formally encodes its logic. This formal encoding is shown to have immediate benefit in identifying crossreference errors and other inconsistencies that otherwise may go undetected. In addition, the formal encoding captures the logic of the requirements in a way that allows a number of useful secondary products to be derived by transformation. These include hypertext (webbased) versions of a traditional printed calendar, requirements checklists so that students and advisors can track progress through particular programs, and computer software that implement degree audit: the <b>automated</b> <b>checking</b> <b>of</b> degree requirements. Furthermore, a multi-yea...|$|R
5000|$|... cryptlib {{provides}} other capabilities including full X.509/PKIX certificate handling (all X.509 versions from X.509v1 to X.509v4) {{with support}} for SET, Microsoft AuthentiCode, Identrus, SigG, S/MIME, SSL, and Qualified certificates, PKCS #7 certificate chains, handling of certification requests and CRLs (certificate revocation lists) including <b>automated</b> <b>checking</b> <b>of</b> certificates against CRLs and online checking using RTCS and OCSP, and issuing and revoking certificates using CMP and SCEP. It also implements {{a full range}} of certification authority (CA) functions provides complete CMP, SCEP, RTCS, and OCSP server implementations to handle online certificate enrolment/issue/revocation and certificate status checking. Alongside the certificate handling, it provides a sophisticated key storage interface that allows the use {{of a wide range of}} key database types ranging from PKCS #11 devices, PKCS #15 key files, and PGP/OpenPGP key rings through to commercial-grade RDBMS' and LDAP directories with optional SSL protection.|$|R
40|$|Modern {{software}} systems, {{which often}} are concurrent and manipulate complex data structures must be extremely reliable. We present a novel framework based on symbolic execution, for <b>automated</b> <b>checking</b> <b>of</b> such systems. We provide a two-fold generalization of traditional symbolic execution based approaches. First, we de ne a source to source translation to instrument a program, which enables standard model checkers to perform symbolic {{execution of the}} program. Second, we give a novel symbolic execution algorithm that handles dynamically allocated structures (e. g., lists and trees), method preconditions (e. g., acyclicity), data (e. g., integers and strings) and concurrency. The program instrumentation enables a model checker to automatically explore dierent program heap con gurations and manipulate logical formulae on program data (using a decision procedure). We illustrate two applications <b>of</b> our framework: <b>checking</b> correctness <b>of</b> multi-threaded programs that take inputs from unbounded domains with complex structure and generation of non-isomorphic test inputs that satisfy a testing criterion...|$|R
40|$|In this {{companion}} {{paper to}} [BT 93 a] we present semantic translations for the compound {{actions of a}} Demos-like discrete event simulation language. These translations allow direct construction of CCS and SCCS processes to represent the behaviour of a simulation system. The translations have been automated as SML programs and produce CWB compatible input, allowing the <b>automated</b> <b>checking</b> <b>of</b> formal system properties. As simulation methodologies increasingly are used to evaluate cost and correctness of systems the ability to perform such proofs becomes important. We present a normal form for the syntactic construction of Demos, permitting {{the identification of the}} languages basic construction. 1 Introduction Simulation is widely used for studying the behaviour and performance of complex systems. One of the underlying problems of the simulation methodology is that of ensuring the correctness of the representation of the system under study. In general, simulation systems do not admit formal pr [...] ...|$|R
40|$|While {{designing}} an architecture, architects {{often make}} assumptions about different factors like execution environment, structural {{properties of the}} artifacts, properties of input/output data etc. Implicit and invalid assumptions {{have been identified as}} a primary reason for architectural mismatches. Such mismatches cause nightmares to the people working at the system integration phase. Today’s complex systems operate in dynamic and rapidly changing environments. Implicit assumptions in the reusable components often make it challenging to adopt the components in a changed operational domain. If not documented, assumptions are often forgotten and it is both difficult and expensive to find them out from previously built software. This paper aims to formally capture assumptions at the architecture level {{so that they can be}} checked automatically throughout the system development. <b>Automated</b> <b>checking</b> <b>of</b> assumptions would facilitate a practicable assumption management system for complex and large-scale software system development with smooth integration and evolution...|$|R
40|$|Analysis of {{accidents}} and incidents in aviation is a nontrivial task: even if detailed data on an air traffic accident are available, it is usually difficult {{to come up with}} a clear analysis, because the causes of incidents cannot be attributed to a point of failure of one individual entity. Instead, most incidents in aviation are caused by a complex interplay <b>of</b> <b>processes</b> at various levels of the socio-technical system. The current paper presents an approach for analysis of aviation incidents that takes a multi-agent perspective, and is based on formal methods. A multi-agent simulation framework is presented that addresses both the behaviour of individual agents (operators, pilots) as well as their mutual communication, and interaction with technical systems. By manipulating various parameters in the model, different scenarios can be explored. Moreover, by means <b>of</b> <b>automated</b> <b>checks</b> <b>of</b> dynamic properties, these scenarios can be assessed with respect to their likelihood of the occurrence {{of accidents}}. The approach is illustrated by a case study on a runway incursion incident at a large European airport in 1995...|$|R
5000|$|Recently, some formalist mathematicians have {{proposed}} that all formal mathematical knowledge should be systematically encoded in computer-readable formats, {{in order to facilitate}} <b>automated</b> proof <b>checking</b> <b>of</b> mathematical proofs and the use of interactive theorem proving in the development of mathematical theories and computer software. Because of their close connection with computer science, this idea is also advocated by mathematical intuitionists and constructivists in the [...] "computability" [...] tradition (see below).|$|R
40|$|We present CurryCheck, {{a tool to}} {{automate}} the testing of programs written in the functional logic programming language Curry. CurryCheck executes unit tests as well as property tests which are parameterized over one or more arguments. In the latter case, CurryCheck tests these properties by systematically enumerating test cases so that, for smaller finite domains, CurryCheck can actually prove properties. Unit tests and properties can be defined in a Curry module without being exported. Thus, they are also useful to document the intended semantics of the source code. Furthermore, CurryCheck also supports the <b>automated</b> <b>checking</b> <b>of</b> specifications and contracts occurring in source programs. Hence, CurryCheck is a useful tool {{that contributes to the}} property- and specification-based development of reliable and well tested declarative programs. Comment: Pre-proceedings paper presented at the 26 th International Symposium on Logic-Based Program Synthesis and Transformation (LOPSTR 2016), Edinburgh, Scotland UK, 6 - 8 September 2016 (arXiv: 1608. 02534...|$|R
40|$|Traditional IDLs {{were defined}} for {{describing}} {{the services that}} objects offer, but not those services they require from other objects, nor the relative {{order in which they}} expect their methods to be called. Some of the existing proposals try to add protocol information to object interfaces, but most of them fail to do so in a modular way. In this paper we propose an extension of the CORBA IDL that uses a sugared subset of the polyadic π-calculus for describing object service protocols, based on the concept of roles. Roles allow the modular specification of the observable behavior of CORBA objects, reducing the complexity of the compatibility tests. Our main aim is the <b>automated</b> <b>checking</b> <b>of</b> protocol interoperability between CORBA objects in open component-based environments, using similar techniques to those used in software architecture description and analysis. In addition, our proposal permits the study of substitutability between CORBA objets, as well as the realization of dynamic compatibility tests during their run-time execution...|$|R
40|$|Part 6 : Research in Progress and PracticeInternational audienceGovernance and {{compliance}} {{of health care}} networks gain more and more attention in the IS research. The configuration of medical care workflow systems and the compliance <b>check</b> <b>of</b> care <b>processes</b> according to national and international guidelines is the motivation for this paper. We are following a process model based approach {{for the management of}} health care networks. We present a service-based method for the compliance <b>check</b> <b>of</b> <b>process</b> models and enable a configuration of information systems with process models. The application of the method as well as the discussion of the practical benefits is illustrated by a real world case...|$|R
40|$|For a region-wide teleradiology {{network in}} Germany a vendor-independent Uptime-server concept was defined. The Uptime-server was {{realized}} for the availability check and prospective error-detection {{of the emergency}} teleradiology servers and clients based on encrypted digital imaging and communication in medicine (DICOM) -e-mail transfers. The concept and the experiences of 2  years of use with more than 30 clients and servers in 15 hospitals and in nine other regional partners are shown. The Uptime-server does provide <b>automated</b> availability <b>checks</b> for all servers and clients, <b>automated</b> <b>checks</b> <b>of</b> the download speed of the Internet lines, and a graphical user interface for the clinical user and the system administrator. A clinical user can display the availability information from all clients and servers in the network (see [URL] In case of malfunctions during an emergency transfer, immediate reactions are possible, often {{without the need for}} help of a hotline or a system administrator. The chosen Uptime-server concept proofed to be reliable; it worked with products from nine different manufacturers without problems. Its statistical output can be used to fulfill the legal requirements <b>of</b> regular availability <b>checks</b> for teleradiology lines...|$|R
2500|$|Recently, some formalist mathematicians have {{proposed}} {{that all of our}} formal mathematical knowledge should be systematically encoded in computer-readable formats, so as to facilitate <b>automated</b> proof <b>checking</b> <b>of</b> mathematical proofs and the use of interactive theorem proving in the development of mathematical theories and computer software. Because of their close connection with computer science, this idea is also advocated by mathematical intuitionists and constructivists in the [...] "computability" [...] tradition (see below). See QED project for a general overview.|$|R
40|$|This note {{describes}} a resistor network that enables <b>automated</b> linearity <b>checks</b> <b>of</b> resistance-thermometry measurements. The network {{is made in}} such a manner that the voltages across any number of resistors in a resistor series are read to get separate four-terminal values interrelated by the formula for the series connection. Linearity tests of resistance bridges show that the network can resolve deviations from linearity down to +/- 20 mu ohm for resistance measurements from 32 to 284 ohm...|$|R
5000|$|Recently, some formalist mathematicians have {{proposed}} {{that all of our}} formal mathematical knowledge should be systematically encoded in computer-readable formats, so as to facilitate <b>automated</b> proof <b>checking</b> <b>of</b> mathematical proofs and the use of interactive theorem proving in the development of mathematical theories and computer software. Because of their close connection with computer science, this idea is also advocated by mathematical intuitionists and constructivists in the [...] "computability" [...] tradition (see below). See QED project for a general overview.|$|R
40|$|As new {{and complex}} multi-party edge {{services}} are deployed on the Internet, application-layer protocols with complex communication models and event dependencies {{are increasingly being}} specified and adopted. To ensure that such protocols (and compositions thereof with existing protocols) do not result in undesirable behaviors (e. g., deadlocks), a methodology is desirable for the <b>automated</b> <b>checking</b> <b>of</b> the "safety" of these protocols. In this paper, we present ingredients of such a methodology. Specifically, we show how SPIN, a tool from the formal systems verification community, {{can be used to}} quickly identify problematic behaviors of application-layer protocols with non-trivial communication models [...] -such as HTTP with the addition of the " 100 Continue" mechanism. As a case study, we examine several versions of the specification for the Continue mechanism; our experiments mechanically uncover multi-version interoperability problems, including some which motivated revisions of HTTP/ 1. 1 and some which persist even in the current version of the protocol. We develop relations for describing arbitrarily large compositions of HTTP proxies using finite models, and also discuss the broader applicability of these techniques to open internet protocol development...|$|R
40|$|Abstract—Traditional IDLs {{were defined}} for {{describing}} {{the services that}} objects offer, but not those services they require from other objects, nor the relative {{order in which they}} expect their methods to be called. Some of the existing proposals try to add protocol information to object interfaces, but most of them fail to do so in a modular way. In this paper we propose an extension of the CORBA IDL that uses a sugared subset of the polyadic-calculus for describing object service protocols, based on the concept of roles. Roles allow the modular specification of the observable behavior of CORBA objects, reducing the complexity of the compatibility tests. Our main aim is the <b>automated</b> <b>checking</b> <b>of</b> protocol interoperability between CORBA objects in open component-based environments, using similar techniques to those used in software architecture description and analysis. In addition, our proposal permits the study of substitutability between CORBA objects, as well as the realization of dynamic compatibility tests during their runtime execution. Index Terms—Interface definition languages, software components, component-based software development, protocols, compatibility and substitutability of components...|$|R
40|$|Computer-based {{systems are}} {{increasingly}} being exposed to evolving security threats, which often reveal new vulnerabilities. A formal analysis of the evolving threats is difficult due {{to a number of}} practical considerations such as incomplete knowledge about the design, limited information about attacks, and constraints on organisational resources. In our earlier work on RISA (Risk assessment in Security Argumentation), we showed that informal risk assessment can complement the formal analysis of security requirements. In this paper, we integrate the formal and informal assessment of security by proposing a unified meta-model and an automated tool for supporting security argumentation called OpenRISA. Using a uniform representation of risks and arguments, our <b>automated</b> <b>checking</b> <b>of</b> formal arguments can identify relevant risks as rebuttals to those arguments, and identify mitigations from publicly available security catalogues when possible. As a result, security engineers are able to make informed and traceable decisions about the security of their computer-based systems. The application of OpenRISA is illustrated with examples from a PIN Entry Device case study. (C) 2015 Elsevier Inc. All rights reserved. SUBMITTEDpeer-reviewe...|$|R
40|$|Web Services {{provide a}} {{powerful}} access channel to business capabilities. Inside the company, resources {{can be shared}} and costs reduced. Outside the company, the interaction with customers and suppliers can be streamlined and business opportunities extended. A major issue with the current Web Service model {{is the problem of}} composition and the difficulties that arise as Web Services are assembled, typically in a bottom-up manner. We briefly discuss this issue, and propose a lightweight solution based on <b>automated</b> consistency <b>checking</b> <b>of</b> Web Service interfaces...|$|R
