38|80|Public
40|$|Data {{refinements}} are refinement {{steps in}} which a program’s local data structures are changed. Data refinement proof obligations require the software designer to find an <b>abstraction</b> <b>relation</b> that relates {{the states of the}} original and new program. In this paper we describe an algorithm that helps a designer find an <b>abstraction</b> <b>relation</b> for a proposed refinement. Given sufficient time and space, the algorithm can find a minimal <b>abstraction</b> <b>relation,</b> and thus show that the refinement holds. As it executes, the algorithm displays mappings that cannot be in any <b>abstraction</b> <b>relation.</b> When the algorithm is not given sufficient resources to terminate, these mappings can help the designer find a suitable <b>abstraction</b> <b>relation.</b> The same algorithm can be used to test an <b>abstraction</b> <b>relation</b> supplied by the designer...|$|E
40|$|We {{present the}} {{complete}} lattice of demonic languages and its interpretation in refinement proofs. In {{contrast to the}} conventional approach of refinement with an <b>abstraction</b> <b>relation</b> on the underlying state spaces, we introduce a notion of refinement with an <b>abstraction</b> <b>relation</b> on the power sets of the state spaces. This allows us to derive a single complete refinement rule for demonic specifications...|$|E
40|$|Specification {{animation}} {{has become}} a popular technique in industry, particularly for validation in model-based design processes. Animation tools provide the ability to explore and visualise the behaviour of a model without needing to study its internal workings. Formal refinement techniques should also {{be of interest to}} industry since they support verifiably correct transformations of system models towards implementation. So far, however, refinement techniques are not widely used. Their application requires a high degree of mathematical skill, even with the currently available tool support. Better tool support is needed to make refinement techniques accessible to industry. In this thesis we investigate the application of existing specification animation and visualisation tools to problems in refinement theory. We show how animation and visualisation can be used to support verification, by refinement, and validation, by comparing the behaviour of a refined specification against its abstract specification. Such techniques can be used to explain and/or improve the understanding of a refinement and to check for the presence of errors in a refinement, for example, before attempting a proof. In the most challenging cases, data refinements, the designer needs to supply an <b>abstraction</b> <b>relation</b> in order to prove the refinement. We initially assume that an <b>abstraction</b> <b>relation</b> is provided as an input to the verification and validation tasks. However, finding abstraction relations is hard, and is currently a matter of trial and error. We therefore study the problem of finding abstraction relations. We show that, if an <b>abstraction</b> <b>relation</b> exists, there is always a unique weakest <b>abstraction</b> <b>relation</b> and at least one minimal <b>abstraction</b> <b>relation,</b> and we describe algorithms for finding both the weakest <b>abstraction</b> <b>relation</b> and minimal abstraction relations. These algorithms can be applied to small finite-state systems to produce abstraction relations in terms of explicit values of state variables. We then investigate a symbolic algorithm for finding abstraction relations, which can be applied to systems with infinite states, to produce abstraction relations in predicate form. The theory and the algorithms we develop thus make it possible for us to extend our animation-based verification and validation techniques {{so that they can be}} used without providing a complete <b>abstraction</b> <b>relation.</b> Additionally our extended techniques can help a designer construct an <b>abstraction</b> <b>relation</b> or check a proposed one...|$|E
40|$|International audienceThe paper {{proposes a}} formal {{semantics}} for traceability relations in enterprise architecture. The proposed semantics requires that traceability relations should be simulation preorders, a requirement on <b>abstraction</b> <b>relations</b> {{widely used in}} program verification. The effectiveness of the proposed semantics is illustrated on a well-known enterprise architecture model from the military domain...|$|R
40|$|Multi-agent {{systems for}} a certain {{application}} area can be modeled at multiple levels of <b>abstraction.</b> Interlevel <b>relations</b> are a means to relate models from different abstraction levels. Three dimensions of abstraction often occurring are the process abstraction, temporal abstraction, and agent cluster abstraction dimension. In this paper a unifying formalization is presented {{that can be used}} as a framework to specify interlevel relations for any of such dimensions. The approach is illustrated by showing how a variety of different types of <b>abstraction</b> <b>relations</b> between multi-agent system models can be formally specified in a unified manner. © 2013 World Scientific Publishing Company...|$|R
40|$|Abstraction” is {{used both}} for {{denoting}} {{relations in the}} problem domain of an information system, and for denoting relations inside software and hardware of a computer. This calls for a clarification of the concept, such that frameworks of information system concepts and techniques for analysis and design can distinguish and compare different types of abstractions. Abstraction is specialized in the paper as follows: representation, classification, generalization, aggregation, and role-realization. The latter relation occurs often when modelling reality, but it is presented with erroneous direction of abstraction in the literature, {{and it is not}} supported by techniques for analysis. It is also shown that separating abstraction in analysis of problem domains from abstraction when designing information systems clarifies the direction of <b>abstraction.</b> <b>Abstraction</b> <b>relations</b> in a taxonomy of concepts for information systems science and the FRISCO framework are discussed, and improvements suggested. Jackson System Development, object-oriented analysis and design, and dataflow diagrams can be improved through extensions with the <b>abstraction</b> <b>relations</b> specified in this paper...|$|R
40|$|This paper {{gives an}} {{overview}} of the real-time specification of a commercial RISC processor. The specification is at two related levels, with an <b>abstraction</b> <b>relation</b> defined between them. The lower level specification models separate stages of execution of up to five overlapped instructions. The higher level specification abstracts from the lower level to recapture an atomic, instruction level view of code execution. The load word instruction is used as an example to illustrate the specification at both levels...|$|E
40|$|Abstractions are {{important}} in specifying and proving properties of complex systems. To prove that a given automaton implements an abstract specification automaton, one must first find the correct <b>abstraction</b> <b>relation</b> between {{the states of the}} automata, and then show that this relation is preserved by all corresponding action sequences of the two automata. This paper describes tool support based on the PVS theorem prover that can help users accomplish the second task, in other words, in proving a candidate <b>abstraction</b> <b>relation</b> correct. This tool support relies on a clean and uniform technique for defining abstraction properties relating automata that uses library theories for defining abstraction relations and templates for specifying automata and abstraction theorems. The paper then describes how the templates and theories allow development of generic, high level PVS strategies that aid in the mechanization of abstraction proofs. These strategies first set up the standard subgoals for the abstraction proofs and then execute the standard initial proof steps for these subgoals, thus making the process of proving abstraction properties in PVS more automated. With suitable supplementary strategies to implement the “natural ” proof steps needed to complete the proofs of any of the standard subgoals remaining to be proved, the abstractio...|$|E
40|$|What {{does it mean}} to {{say that}} one program is "more {{abstract}}" than another? What is "abstract" about an abstract data type? What is the difference between a "high-level" program and a "low-level" program? In this paper we attempt to answer these questions by formally defining an <b>abstraction</b> <b>relation</b> between programs which matches our intuitive ideas about abstraction. The relation is based on examining the operational semantics of the programs, expressed as a set of traces (sequences of states) from a given initial state to a possible final state...|$|E
40|$|This paper {{introduces}} {{the use of}} abstraction relationships for timed automata. <b>Abstraction</b> <b>relations</b> {{make it possible to}} determine when one specification implements another, i. e. when they have the same set of computations. The approach taken here permits the hiding of internal events and takes into account the timed behavior of the specification. A new representation of the semantics of a specification is introduced. This representation, min-max automata is more compact than other types of finite state automata typically used torepresent real-time systems, and can be used to define a variety of abstraction relationships...|$|R
30|$|Today most of {{cognitive}} science scholars converge on conceiving creativity an ordinary specific cognition function. It is patrimony of all living agents, casually or intentionally activated in certain situations, challenging the old conception of creativity as exceptional endowment of talented cognitive agents (Bink and Marsh 2000; Ward et al. 1997; Weisberg 1993). But the idea {{remains of a}} largely unexplored set {{of cognitive}} mechanisms and abilities, hardly repeatable by computer programs. That occurs because of the evident human (biotic) features of divergence from routine reasoning and calculus, use of intuition and other intriguing biotic generic cognitive behaviours (introducing analogies, <b>abstractions,</b> <b>relations,</b> boundaries, equalities, consistencies, and beauties into the expert and domain-dependent reasoning) (Hofstadter 1995).|$|R
40|$|Abstract. The paper {{presents}} {{the method of}} network invariants for verifying {{a wide spectrum of}} ltl properties, including liveness, of parameterized systems. This method can be applied to establish the validity of the property over a system S(n) for every value of the parameter n. The application of the method requires checking <b>abstraction</b> <b>relations</b> between two finite-state systems. We present a proof rule, based on the method of Abstraction Mapping by Abadi and Lamport, which has been implemented on the tlv model checker and incorporates both history and prophecy variables. The effectiveness of the network invariant method is illustrated on several examples, including a deterministic and probabilistic versions of the dining-philosophers problem...|$|R
40|$|It {{is widely}} {{recognized}} that abstraction and modularization are indispensable for specification of real-world programs. In source-code level program specification languages, {{such as the}} Java Modeling Language (JML) [3], model fields [4] are a common means for achieving abstraction and information hiding. However, there is yet no well-defined formal semantics for the general {{case in which the}} <b>abstraction</b> <b>relation</b> defining a model field is non-functional and may contain references to other model fields. In this contribution, we discuss and compare several possibilities for defining model field semantics, and we give a complete formal semantics for the general case. Our analysis and the proposed semantics is inspired by a generalization of Hilbert’s ε terms. Model fields. Model fields are abstractions of the program’s memory state given in a syntactically convenient form (as fields in a class). For example, one may define a model field of type Set containing all elements of some linked list, thus abstracting from and hiding implementation detail. Introducing such a model field in the specification is possible even if the type Set is not defined in the programming language but only in the specification language. The relation between the concrete state and model fields, i. e., the <b>abstraction</b> <b>relation,</b> is specified by so-called represents clauses. In general, abstraction relations may be non-functional, and they may refer to entities which are not present in the concrete program (e. g. ...|$|E
40|$|Abstraction and {{composition}} are the fundamental issues in making model checking viable for software. This paper proposes new techniques for automating abstraction and decomposition using source level type {{information provided by}} the programmer. Our system includes two novel components to achieve this end: (1) a behavioral type-and-eect system for the -calculus, which extracts sound models as types, and (2) an assume-guarantee proof rule for carrying out compositional model checking on the types. Open simulation between CCS processes is used as both the subtyping relation in the type system and the <b>abstraction</b> <b>relation</b> for compositional model checking...|$|E
40|$|Abstract. In {{this paper}} we de ne a precise notion of <b>abstraction</b> <b>relation</b> between {{continuous}} dynamical systems and discrete state-transition systems. Our main result states that every Turing Machine {{can be realized}} by a dynamical system with piecewise-constant derivatives in a 3 -dimensional space and thus the reachability problem for such systems is undecidable for 3 dimensions. A decision procedure for 2 -dimensional systems has been recently reported by Maler and Pnueli. On the other hand we show that some non-deterministic nite automata cannot be realized by any continuous dynamical system with less than 3 dimensions. ...|$|E
50|$|In mathematics, an {{algebraic}} matroid is a matroid, a combinatorial structure, which expresses an <b>abstraction</b> of the <b>relation</b> of algebraic independence.|$|R
40|$|As Web sites {{begin to}} realise the {{advantages}} of engaging users in more extended interactions involving a semi-structured combination of information and communication behaviour, the log les recording Web usage become more complex. While Web usage mining provides for the syntactic speci cation of structured patterns like association rules or (generalised) sequences, it is less clear how to analyse and visualise usage data involving longer patterns with little expected structure, without losing {{an overview of the}} whole of all paths. The method proposed in this paper employs two ways of analysing complex Web usage data. Concept hierarchies are used as a basic method of aggregating Web pages. Interval-based coarsening is then proposed as a method for representing sequences at coarser levels of <b>abstraction.</b> <b>Relations</b> to the measures support, con dence, and ways of analysing generalised sequences are shown...|$|R
40|$|A regular {{relation}} R, is one {{for which}} R = R R ^ R, where “ ” is relational composition and “^ ” is relational transpose. By examining realistic case studies, and other examples, it is shown that when expressed using a rigorous specification notation, {{the majority of}} specifications {{turn out to be}} regular relations. This is certainly so for deterministic problems, and when <b>abstraction</b> <b>relations</b> are functions, reification preserves regularity. Nondeterministic specifications can appear to exhibit non-regularity, but at least in the most commonly occuring cases, it is argued that this is caused as much by a failure to separate concerns, as by any intrinsic lack of regularity in the specification. Such specifications can be recast into a regular form, and the process is analogous to a “transformation to orthogonal coordinates ” of the original problem. A design philosophy is proposed, that places the search for regularity at the heart of specification construction, with implications for requirements capture...|$|R
40|$|Abstract. It {{is widely}} {{recognized}} that abstraction and modularization are indispensable for specification of real-world programs. In source-code level program specification and verification, model fields {{are a common}} means for those goals. However, it remains a challenge to provide a wellfounded formal semantics for the general {{case in which the}} <b>abstraction</b> <b>relation</b> defining a model field is non-functional. In this paper, we discuss and compare several possibilities for defining model field semantics, and we give a complete formal semantics for the general case. Our analysis and the proposed semantics is based on a generalization of Hilbert’s ε terms. ...|$|E
40|$|The {{present study}} gives a {{mathematical}} framework for self-evolution within autonomous problem solving systems. Special attention {{is set on}} universal abstraction, thereof generation by net block homomorphism, consequently multiple order solving systems and the overall decidability of {{the set of the}} solutions. By overlapping presentation of nets new <b>abstraction</b> <b>relation</b> among nets is formulated alongside with consequent alphabetical net block renetting system proportional to normal forms of renetting systems regarding the operational power. A new structure in self-evolving problem solving is established via saturation by groups of equivalence relations and iterative closures of generated quotient transducer algebras over the whole evolution...|$|E
40|$|Abstract model {{checking}} is {{a method}} to verify properties of a state transition system by system. If the employed <b>abstraction</b> <b>relation</b> satisfies certain conditions that guarantee the correctness of the abstraction, verification results of the abstract system can be shifted to the original one. However, the correctness of abstraction {{is not always easy}} to verify. In our previous work, we applied abstract model checking on concurrent garbage collection algorithms, but the correctness of the abstraction was not formally proven. In this paper, we formalize the abstraction and the underlying model for concurrent garbage collection algorithms, and formally prove the correctness of the abstraction using the proof assistant, HOL. ...|$|E
40|$|We {{propose a}} {{platform}} for the specification and analysis of systems. This platform contain models, their refinement and abstraction, and a temporal logic semantics; rendering a sound framework for property validation and refutation. The platform is parametric in a domain of view, an abstraction of a construction based on the Plotkin power domain. For each domain of view E, the resulting platform P[E] contains partial, incomplete systems and complete systems [...] the actual implementations. Complete systems correspond to the platform that has as parameter a domain D that is, as a set, isomorphic to the maximal elements of E. If one restricts P[E] to implementations, but retains the temporal logic semantics, re nement, and <b>abstraction</b> <b>relations,</b> one recovers the platform P[D]. This foundation recasts existing work on modal transition systems, presents fuzzy systems, and ponders {{on the nature of}} probabilistic platforms. For domains of view E that are determined by a linearly ordered, co [...] ...|$|R
40|$|AbstractA regular {{relation}} R, is one {{for which}} R = R ∘ R ^ ∘ R, where ∘ is relational composition and ^ is relational transpose. By examining realistic case studies, and other examples, it is shown that when expressed using a rigorous specification notation, {{the majority of}} specifications {{turn out to be}} regular relations. This is certainly so for deterministic problems, and when <b>abstraction</b> <b>relations</b> are functions, reification preserves regularity. Nondeterministic specifications can appear to exhibit nonregularity, but at least in the most commonly occurring cases, it is argued that this is caused as much by a failure to separate concerns, as by any intrinsic lack of regularity in the specification. Such specifications can be recast into a regular form, and the process is analogous to a “transformation to orthogonal coordinates” of the original problem. A design philosophy is proposed, that places the search for regularity at the heart of specification construction, with implications for requirements capture...|$|R
40|$|A key {{question}} that arises in rigorous analysis of cyberphysical systems under attack involves establishing {{whether or not}} the attacked system deviates significantly from the ideal allowed behavior. This is the problem of deciding {{whether or not the}} ideal system is an abstraction of the attacked system. A quantitative variation of this question can capture how much the attacked system deviates from the ideal. Thus, algorithms for deciding <b>abstraction</b> <b>relations</b> can help measure the effect of attacks on cyberphysical systems and to develop attack detection strategies. In this paper, we present a decision procedure for proving that one nonlinear dynamical system is a quantitative abstraction of another. Directly computing the reach sets of these nonlinear systems are undecidable in general and reach set over-approximations do not give a direct way for proving abstraction. Our procedure uses (possibly inaccurate) numerical simulations and a model annotation to compute tight approximations of the observable behaviors of the system and then uses these approximations to decide on abstraction. We show that the procedure is sound and that it is guaranteed to terminate under reasonable robustness assumptions...|$|R
40|$|Abstract. Methods for {{abstraction}} {{have been}} proposed to ease comprehension, monitoring, and validation of large processes and their running instances. To date, abstraction mechanisms have focused predominantly on structural aggregation, projection, and ad-hoc transformations. We propose an approach for configuration of process abstractions tailored to a specific abstraction goal expressed as constraints on the <b>abstraction</b> <b>relation</b> and process transformation operators. Our framework goes beyond simple structural aggregation and leverages domain-specific properties, taxonomies, meronymy, and flow criteria. In this paper we outline the constraint-based framework and its underlying inference procedure. We show that our approach can handle most of the common process analysis use cases...|$|E
40|$|Ensuring the {{reliability}} of multithreaded software systems is difficult due to the potential for subtle interactions between threads. We present a new modular verification technique to check concise specifications of large multithreaded programs. Our analysis scales to systems {{with large numbers of}} procedures and threads. We achieve thread-modular analysis by annotating each shared variable by an access predicate that summarizes the condition under which a thread may access that variable. We achieve procedure-modular analysis by annotating each procedure with a specification related to its implementation by an <b>abstraction</b> <b>relation</b> combining the notions of simulation and reduction. We have implemented our analysis in Calvin-R, a static checker for multithreaded Java programs. ...|$|E
40|$|In {{this paper}} we study two {{possible}} semantics for the logic MTL (Metric Temporal Logic). In the first semantics, called dense time semantics, time is modeled by the positive real numbers. In the second one, called fictitious clock semantics, real-time information is delivered by a global fictitious clock. We {{show that the}} fictitious clock semantics {{can be viewed as}} an abstraction of the dense time semantics. This <b>abstraction</b> <b>relation</b> is formalized by a parametric conservative connection, a kind of Galois connection, a favorite structure of abstract interpretation [5, 6]. This formalization can be used to partially decide undecidable problems in the dense time semantics by reasoning on the fictitious clock semantics...|$|E
40|$|Abstract. Semantic Web model {{representation}} and integration can be exploited to provide organizations {{that deal with}} {{a large amount of}} data sources with an integrated view on the overall information managed. In order to support semantic Web model {{representation and}} integration in the large users must be provided with light-weight languages to represent and integrate the models, in particular avoiding the design of complex Tbox axioms. Assuming to adopt at the frontend level graph-based Concept-to-Concept Relationship (CCR) representations, in this paper we question about two semantic issues. First, we inquire whether light-weight semantic Web languages such as RDFS and DL-Lite can be used to provide the semantics of individual CCR models. Second, we inquire whether these languages can be used to provide appropriate semantics for the mappings needed for model integration. Discussing a case study in the eGovernment domain we claim that both the answer are negative. Therefore, we propose a new semantic interpretation for CCR models and we define three main classes of integration and <b>abstraction</b> <b>relations</b> defining their semantics. ...|$|R
50|$|Plastic {{characteristics}} of this painting are: spontaneity of the gesture, automatism, expressive use of material, the nonexistence of preconceived ideas, {{the experience that}} the deed generates the idea, and the work is the place and the privileged moment whereby the artist discovers himself; it {{is the end of}} the reproduction of the object for the representation of the theme that becomes the end of the painting, with a sometime calligraphic aspect, referring to a Calligraphic <b>Abstraction</b> in <b>relation</b> to the works of Georges Mathieu, Hans Hartung, or Pierre Soulages.|$|R
25|$|One socio-historical {{explanation}} {{that has been}} offered for the growing prevalence of the abstract in modern art – an explanation linked to the name of Theodor W. Adorno – is that such abstraction is a response to, and a reflection of, the growing <b>abstraction</b> of social <b>relations</b> in industrial society.|$|R
40|$|AbstractAbstractions are {{important}} in specifying and proving properties of complex systems. To prove that a given automaton implements an abstract specification automaton, one must first find the correct <b>abstraction</b> <b>relation</b> between {{the states of the}} automata, and then show that this relation is preserved by all corresponding action sequences of the two automata. This paper describes tool support based on the PVS theorem prover that can help users accomplish the second task, in other words, in proving a candidate <b>abstraction</b> <b>relation</b> correct. This tool support relies on a clean and uniform technique for defining abstraction properties relating automata that uses library theories for defining abstraction relations and templates for specifying automata and abstraction theorems. The paper then describes how the templates and theories allow development of generic, high level PVS strategies that aid in the mechanization of abstraction proofs. These strategies first set up the standard subgoals for the abstraction proofs and then execute the standard initial proof steps for these subgoals, thus making the process of proving abstraction properties in PVS more automated. With suitable supplementary strategies to implement the “natural” proof steps needed to complete the proofs of any of the standard subgoals remaining to be proved, the abstraction proof strategies can form part of a set of mechanized proof steps that can be used interactively to translate high level proof sketches into PVS proofs. Using timed I/O automata examples taken from the literature, this paper illustrates use of the templates, theories, and strategies described to specify and prove two types of abstraction property: refinement and forward simulation...|$|E
40|$|We {{present a}} number of {{abstraction}} techniques for the validation of trust and security properties of services. Abstraction consists in transforming a concrete model to be analyzed into a abstract model more amenable to analysis. The transformation must be sound w. r. t. a class of properties, i. e. a property proved on the abstract model must also hold in the concrete one. This implies that the original model must be over-approximated, i. e. every reachable state or trace of the concrete system has a counterpart (modulo an <b>abstraction</b> <b>relation)</b> in the abstract system. Thus, in the worst case, a concrete system may be secure, while we {{are not able to}} prove this using its abstraction. Deliverable detail...|$|E
40|$|Abstract. Knowledge {{generation}} {{processes are}} traditionally {{related to the}} DIKW (data-information-knowledge-wisdom) hierarchy, a layered model for the classification of human understanding. Software components can be situated in one or several of these layers, or assist in the interfaces between two of them. Most of the knowledge generation processes {{that occur in the}} archaeology field involve complex mechanisms of <b>abstraction,</b> <b>relation</b> and interpretation. Is it possible to assist the users in performing these processes? We have detected problems in the archaeological knowledge generation process that could be improved through software assistance. We propose a conceptual framework based on the structure of the data that is being managed by the user, and on the cognitive processes that the user wishes to perform on the data. The proposed framework can, arguably, set the foundation for assisted knowledge generation implemented as software systems...|$|E
40|$|This article formalizes an <b>abstraction</b> of input/output <b>relations,</b> {{based on}} {{parameterized}} zonotopes, {{which we call}} affine sets. We describe the abstract transfer functions and prove their correctness, which allows the generation of accurate numerical invariants. Other applications range from compositional reasoning to proofs of user-defined complex invariants and test case generation. Comment: 23 page...|$|R
40|$|We define λseal, an untyped call-by-value λ-calculus with {{primitives}} {{for protecting}} abstract data by sealing, {{and develop a}} bisimulation proof method that is sound and complete with respect to contextual equivalence. This provides a formal basis for reasoning about data abstraction in open, dynamic settings where static techniques such as type <b>abstraction</b> and logical <b>relations</b> are not applicable...|$|R
40|$|Several {{cognitive}} scientists {{attribute the}} effectiveness of tutorial dialogue to its interactive nature. Although this view has empirical support, the notion of ―interactivity‖ is too vague to guide the development of natural-language tutorial dialogue systems. This paper describes our attempts to operationalize particular forms of interactivity: tutor abstraction and specification of student dialogue moves, and tutor prompts for specification. We describe and illustrate {{the process by which}} we specified decision rules for abstraction and specification in automated tutorial dialogues about physics. Correlational analyses suggest that particular types of interactive <b>abstraction</b> and specification <b>relations</b> predict student learning, as measured by pretest to posttest gain score—for example, tutor prompts for the student to specify the individual forces that comprise the net force. Since particular kinds of <b>abstraction</b> and specification <b>relations</b> are associated with particular decision rules, these findings are guiding our selection of rules to implement in a tutorial dialogue system for physic...|$|R
