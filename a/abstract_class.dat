260|1325|Public
25|$|A {{class or}} <b>abstract</b> <b>class</b> can only inherit from one class or <b>abstract</b> <b>class.</b>|$|E
25|$|An <b>abstract</b> <b>class</b> {{may have}} constructors. An {{interface}} cannot.|$|E
25|$|A {{class or}} <b>abstract</b> <b>class</b> may {{implement}} {{one or more}} interfaces.|$|E
5000|$|... #Subtitle level 2: <b>Abstract</b> <b>classes</b> {{and pure}} virtual {{functions}} ...|$|R
5000|$|<b>Abstract</b> <b>classes</b> can be created, signified, or {{simulated}} {{in several}} ways: ...|$|R
2500|$|Interfaces and <b>abstract</b> <b>classes</b> are similar. The {{following}} describes {{some important}} differences: ...|$|R
25|$|An <b>abstract</b> <b>class</b> {{may have}} constants, static methods and static members. An {{interface}} cannot.|$|E
25|$|An <b>abstract</b> <b>class</b> {{may have}} member {{variables}} {{as well as}} non-abstract methods or properties. An interface cannot.|$|E
25|$|An <b>abstract</b> <b>class</b> {{may have}} non-public methods and {{properties}} (also abstract ones). An interface {{can only have}} public members.|$|E
40|$|C++ {{directly}} {{supports a}} variety of programming styles. In this, C++ deliberately differs from languages designed to support a single way of writing programs. This paper briefly presents key programming styles directly supported by C++ and argues that the support for multiple styles {{is one of its}} major strengths. The styles presented include: traditional C-style, concrete <b>classes,</b> <b>abstract</b> <b>classes,</b> traditional <b>class</b> hierarchies, <b>abstract</b> <b>classes</b> and class hierarchies, and generic programming. To provide a context for this overview, I discuss criteria for a reasonable and useful definition of ‘‘object-oriented programming. ’’...|$|R
5000|$|Curl: <b>Abstract</b> <b>classes</b> as mixins permit method {{implementations}} {{and thus}} constitute traits by another name.|$|R
40|$|Frameworks are {{a common}} {{object-oriented}} code-structuring technique that is used design; a framework instance {{is a set of}} concrete <b>classes</b> that subclass <b>abstract</b> <b>classes</b> to provide an executable subsystem. Frameworks are designed for reuse: <b>abstract</b> <b>classes</b> encapsulate common code and concrete classes encapsulate instance-specific code. Unfortunately, this delineation of reusable v. s. instance-specific code is problematic. Concrete classes of different framework instances can have much in common and there can be variations in <b>abstract</b> <b>classes,</b> all of which lead to unnecessary code replication. In this paper, we show how to overcome these limitations by decomposing frameworks and framework instances into primitive and reusable components. Doing so reduces code replication and creates a component-based product-line of frameworks and framework instances. ...|$|R
2500|$|... Specifies that {{a method}} or {{property}} declaration is an override of a virtual member or an {{implementation of a}} member of an <b>abstract</b> <b>class.</b>|$|E
2500|$|A member {{function}} {{can also}} be made [...] "pure virtual" [...] by appending it with = 0 after the closing parenthesis and before the semicolon. A class containing a pure virtual function is called an <b>abstract</b> <b>class.</b> Objects cannot be created from an abstract class; they can only be derived from. Any derived class inherits the virtual function as pure and must provide a non-pure definition of it (and all other pure virtual functions) before objects of the derived class can be created. A program that attempts to create an object of a class with a pure virtual member function or inherited pure virtual member function is ill-formed.|$|E
50|$|A {{class or}} <b>abstract</b> <b>class</b> can only inherit from one class or <b>abstract</b> <b>class.</b>|$|E
5000|$|A {{concrete}} class is a class {{that can be}} instantiated, as opposed to <b>abstract</b> <b>classes,</b> which cannot.|$|R
5000|$|... clients remain {{unaware of}} the classes that {{implement}} these objects; clients only know about the <b>abstract</b> <b>class(es)</b> defining the interface ...|$|R
40|$|Interfaces {{are widely}} used as central design {{elements}} of Java applications. Although interfaces are abstract types similar to <b>abstract</b> <b>classes,</b> the usage of interfaces in Java applications may considerably differ from the usage of <b>abstract</b> <b>classes.</b> Unlike <b>abstract</b> <b>classes,</b> interfaces are meant to enable multiple inheritance in Java programs. Hence, interfaces are meant to encode shared similarities between classes belonging to different class-type hierarchies. Therefore, it is frequent to use interfaces as partial types, where an interface specifies one specific aspect or usage of its implementing classes. In this paper, we investigate interfaces' usage in Java applications from two perspectives. First, we investigate the usage of interfaces as types of classes belonging to different class-type hierarchies (i. e., interface's type variability). Second, we investigate the usage of interfaces as partial types of implementing classes (i. e., interface's type completeness) ...|$|R
50|$|In a {{language}} that supports inheritance, an <b>abstract</b> <b>class,</b> or abstract base class (ABC), is a class that cannot be instantiated because it is either labeled as abstract or it simply specifies abstract methods (or virtual methods). An <b>abstract</b> <b>class</b> may provide implementations of some methods, and may also specify virtual methods via signatures {{that are to be}} implemented by direct or indirect descendants of the <b>abstract</b> <b>class.</b> Before a class derived from an <b>abstract</b> <b>class</b> can be instantiated, all abstract methods of its parent classes must be implemented by some class in the derivation chain.|$|E
5000|$|A {{subclass}} of an <b>abstract</b> <b>class</b> that is {{not itself}} abstract may be instantiated, resulting in the execution of a constructor for the <b>abstract</b> <b>class</b> and, therefore, {{the execution of the}} field initializers for instance variables of that class.|$|E
5000|$|ClassDescription (<b>abstract</b> <b>class)</b> - class/variable naming, {{comments}} ...|$|E
50|$|OWBAL {{abstraction}} {{is based}} on interfaces, which are described through <b>abstract</b> <b>classes,</b> and these classes contain only pure virtual methods. No default implementation is allowed.|$|R
50|$|Sather {{also takes}} {{inspiration}} from other programming languages and paradigms: iterators, design by contract, <b>abstract</b> <b>classes,</b> multiple inheritance, anonymous functions, operator overloading, contravariant type system.|$|R
5000|$|Avoid {{duplication}} in the code: {{the general}} workflow structure is implemented {{once in the}} <b>abstract</b> <b>class's</b> algorithm, and necessary variations are implemented in the subclasses.|$|R
50|$|An <b>abstract</b> <b>class</b> {{may have}} constructors. An {{interface}} cannot.|$|E
50|$|A {{class or}} <b>abstract</b> <b>class</b> may {{implement}} {{one or more}} interfaces.|$|E
5000|$|All {{concrete}} class packages must connect only through interface or <b>abstract</b> <b>class</b> packages.|$|E
5000|$|Number {{of classes}} and interfaces: The number of {{concrete}} and <b>abstract</b> <b>classes</b> (and interfaces) in the package is {{an indicator of the}} extensibility of the package.|$|R
25|$|<b>Abstract</b> <b>classes</b> are {{classes that}} only serve as {{templates}} {{and you can}} not initialize an object of that type. Otherwise it is just like an ordinary class.|$|R
5000|$|... '''''' - Abstract {{methods can}} be present only in <b>abstract</b> <b>classes,</b> such methods have no body {{and must be}} {{overridden}} in a subclass unless it is abstract itself.|$|R
5000|$|The {{following}} Java code {{shows an}} <b>abstract</b> <b>class</b> {{that needs to}} be extended: ...|$|E
50|$|An <b>abstract</b> <b>class</b> {{may have}} constants, static methods and static members. An {{interface}} cannot.|$|E
5000|$|... // [...] "AbstractExpression" [...] <b>{{abstract}}</b> <b>class</b> AbstractExpression { public abstract void Interpret(Context context); } ...|$|E
25|$|There may be {{abstract}} members too. Abstract {{members are}} members of <b>abstract</b> <b>classes</b> {{that do not have}} any implementation. They must be overridden by the class that inherits the member.|$|R
50|$|Dart is an object-oriented, class defined, single {{inheritance}} language using a C-style syntax that transcompiles optionally into JavaScript. It supports interfaces, mixins, <b>abstract</b> <b>classes,</b> reified generics, optional typing, and a sound type system.|$|R
50|$|The EntitySpaces {{binaries}} {{are written}} in C#. Templates are available to generate both C# and VB.NET concrete and <b>abstract</b> <b>classes,</b> so EntitySpaces is fully supported for both languages, but native VB.NET binaries are not provided.|$|R
