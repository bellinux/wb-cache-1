10000|10000|Public
5|$|Instances {{where many}} {{passages}} overlap {{between the two}} books, in some case word for word, also refutes this <b>assertion.</b>|$|E
5|$|Supporters of this <b>assertion</b> {{said that}} Ray's {{confession}} was given under pressure {{and that he}} had been threatened with the death penalty.|$|E
5|$|More recently, June Schlueter {{has found}} {{evidence}} that Martin the Elder was in London when the engraver of the First Folio portrait {{was known to be}} in Madrid. Although she began her archival research hoping to prove Edmond's <b>assertion</b> that the elder Martin was the Shakespeare engraver, Schlueter concludes that the newly discovered evidence actually supports the younger.|$|E
40|$|Abstract. <b>Assertions</b> or {{contracts}} {{are an important}} technique {{to improve the quality}} of software. Thus, <b>assertions</b> are also desirable for functional logic programming. Unfortunately, there is no established meaning of <b>assertions</b> in languages with a demand-driven evaluation strategy. Strict <b>assertions</b> are immediately checked but may influence the behavior of programs. Lazy <b>assertions</b> do not modify the behavior but may not be faithful since some <b>assertions</b> might not be checked at all. In order to avoid the disadvantages of strict and lazy <b>assertions,</b> we propose enforceable <b>assertions</b> that are delayed as lazy <b>assertions</b> but can be explicitly enforced at some point where faith is required, e. g., at the end of the program execution or before irrevocable I/O actions. We describe a prototypical implementation of this idea in the functional logic language Curry where the programmer can choose between lazy and enforceable <b>assertions.</b> ...|$|R
40|$|SystemVerilog <b>Assertions</b> (SVA) {{are getting}} lots of {{attention}} in the verification community, and rightfully so. <b>Assertions</b> Based Verification Methodology is a critical improvement for verifying large, complex designs. But, we design engineers want to play too! Verification engineers add <b>assertions</b> to a design after the HDL models have been written. This means placing the <b>assertions</b> on module boundaries, binding external <b>assertions</b> to signals within the model, or modifying the design models to insert <b>assertions</b> within the code. Design engineers can, and should, add <b>assertions</b> within a design while the HDL models are being coded. There are challenges with doing this, however. A decision {{needs to be made}} before design work begins as to what types of scenarios the design engineer should provide <b>assertions</b> for. The design and verification teams need to coordinate efforts to avoid writing redundant <b>assertions,</b> or worse, to miss adding <b>assertions</b> on key functionality. Design engineers have to learn the SVA (or PSL) <b>assertions</b> language, which is a complex languages in and of itself. The design process will probably take longer, because adding (and debugging) <b>assertions</b> as the design is being coded may not be trivial...|$|R
40|$|Executable <b>assertions</b> {{are used}} to test flight control software. The {{techniques}} used for testing flight software; however, {{are different from the}} techniques used to test other kinds of software. This is because of the redundant nature of flight software. An experimental setup for testing flight software using executable <b>assertions</b> is described. Techniques for writing and using executable <b>assertions</b> to test flight software are presented. The error detection capability of <b>assertions</b> is studied and many examples of <b>assertions</b> are given. The issues of placement and complexity of <b>assertions</b> and the language features to support efficient use of <b>assertions</b> are discussed...|$|R
5|$|Ruth von Phul was {{the first}} to argue that Earwicker was not the dreamer, which {{triggered}} a number of similarly-minded views on the matter, although her <b>assertion</b> that Shem was the dreamer has found less support.|$|E
5|$|Some of Churchill's Native American critics, such as Vernon Bellecourt (White Earth Ojibwe) and Suzan Shown Harjo (Southern Cheyenne-Muscogee Creek), {{argue that}} his <b>assertion</b> of Native American ancestry without {{the ability to}} prove it might {{constitute}} misrepresentation and grounds for termination. The University {{has said that it}} does not hire on the basis of ethnicity.|$|E
5|$|South American giant {{cockroaches}} of {{the genus}} Lucihormetica {{were believed to be}} the first known example of defensive mimicry, emitting light in imitation of bioluminescent, poisonous click beetles. However, doubt has been cast on this <b>assertion,</b> and there is no conclusive evidence that the cockroaches are bioluminescent.|$|E
40|$|Abstract. <b>Assertions</b> test {{expected}} {{properties of}} run-time values without dissrupting the normal working of a program. So in a lazy functional language <b>assertions</b> should be lazy — not forcing evaluation, but only examining what is evaluated by {{other parts of}} the program. We describe two different ways of embedding lazy <b>assertions</b> in Haskell, one sequential and the other concurrent. Examples illustrate the relative merits of the two approaches. We also show that timely failure of lazy <b>assertions</b> may require <b>assertions</b> in <b>assertions!...</b>|$|R
5000|$|Management <b>assertions</b> or {{financial}} statement <b>assertions</b> are the implicit or explicit <b>assertions</b> that the preparer of financial statements (management) is making to its users. Financial statements include <b>assertions</b> {{related to the}} recognition, measurement, presentation, and disclosure of the financial information contained within such statements. [...] The role of the auditor in a financial statement audit is to obtain evidence as to whether management's <b>assertions</b> can be supported.|$|R
40|$|AbstractCall {{a set of}} <b>assertions</b> A {{complete}} (with {{respect to}} a class of programs S) if for any p, q∈A and S∈S, wherever {p}S{q} holds, then all intermediate <b>assertions</b> can be chosen from A. This paper {{is devoted to the}} study of the problem which sets of <b>assertions</b> are complete in the above sense. We prove that any set of recursive <b>assertions</b> containing true and false is not complete. We prove the completeness for while programs of some more powerful <b>assertions,</b> e. g. the set of recursively enumerable <b>assertions.</b> Finally, we show that by allowing the use of an ‘auxilliary’ coordinate, the set of recursive <b>assertions</b> is complete for while programs...|$|R
5|$|The {{concept of}} syadvada allows the Jains {{to accept the}} truth in other philosophies from their perspectives, thus inculcating a {{tolerance}} for other viewpoints. Anekantvada is non-absolutist and stands firmly against all dogmatisms, even including any <b>assertion</b> that only Jainism is the right religious path.|$|E
5|$|Theobald even {{maintained}} the theoretical claim of Canterbury to jurisdiction over Irish sees by consecrating Patrick as Bishop of Limerick in 1140. That, however, {{was the last}} <b>assertion</b> of the claim, as in 1152 the papal legate Giovanni Paparo reorganised the Irish dioceses and settled the issue by appointing the Archbishop of Armagh the primate of Ireland.|$|E
5|$|Truthiness is {{the belief}} or <b>assertion</b> that a {{particular}} statement is true based on the intuition or perceptions of some individual or individuals, without regard to evidence, logic, intellectual examination, or facts. Truthiness can range from ignorant assertions of falsehoods to deliberate duplicity or propaganda intended to sway opinions.|$|E
40|$|<b>Assertions</b> {{can be used}} as test oracles. However, writing {{effective}} <b>assertions</b> {{of right}} abstraction levels is difficult because on the one hand, detailed <b>assertions</b> are preferred for through testing (i. e., to detect as many errors as possible), {{but on the other hand}} abstract <b>assertions</b> are preferred for readability, maintainability, and reusability. As <b>assertions</b> become a practical tool for testing and debugging programs, this is an important and practical problem to solve for the effective use of <b>assertions.</b> We advocate the use of model variables [...] -specification-only variables of which abstract values are given as mappings from concrete program states [...] -to write abstract <b>assertions</b> for test oracles. We performed a mutation testing experiment to evaluate the effectiveness of the use of model variables in assertion-based test oracles. According to our experiment, <b>assertions</b> written in terms of model variables are as effective as <b>assertions</b> written without using model variables in detecting (injected) faults, and the execution time overhead of model variables are negligible. Our findings are applicable to other use of runtime checkable <b>assertions...</b>|$|R
40|$|At&act. Call {{a set of}} <b>assertions</b> J & {{complete}} (with {{respect to}} a class of programs 9) if for any p, q E & and S ‘E 9, whenever {p}S{q} holds, then all intermediate <b>assertions</b> can be chosen from ~ 4. This paper {{is devoted to the}} study of the problem which sets of <b>assertions</b> are complete in the above sense. We prove that any set of recursive <b>assertions</b> containing true and false is not complete. We prove the completeness for while programs of some more powerful <b>assertions,</b> e. g. the set of recursively enumerable <b>assertions.</b> Finally, we show that by allowing the use of an ‘<auxiliary’ coordinate, the set of recursive <b>assertions</b> is compiete for while programs. 1...|$|R
50|$|<b>Assertions</b> {{that are}} checked at compile time are called static <b>assertions.</b>|$|R
5|$|A {{side effect}} of Baldwin's tour of Wales was the implied <b>assertion</b> of royal {{authority}} in a section of Henry's domains that had always been somewhat fractious. Baldwin was also asserting his ecclesiastical authority over the Welsh bishops, especially when he {{made a point of}} celebrating mass at every Welsh cathedral; he was the first Archbishop of Canterbury to celebrate mass at St Asaph's Cathedral. Baldwin excommunicated the only Welsh prince who refused to appear before him and take the cross, Owain Cyfeiliog.|$|E
5|$|Although many {{publications}} have repeated Doyle's unsupported <b>assertion</b> {{that the}} wartime photograph inspired Miller's poster, Westinghouse historian Charles A. Ruch, a Pittsburgh resident {{who had been}} friends with J. Howard Miller, said that Miller {{was not in the}} habit of working from photographs, but rather live models. Penny Coleman, the author of Rosie the Riveter: Women working on the home front in World War II, said that she and Ruch could not determine whether the wartime photo had appeared in any of the periodicals that Miller would have seen.|$|E
5|$|Boggs is {{led to his}} {{execution}} and sees that Scully has not attended. Scully visits Mulder in hospital, where he is recovering from his gunshot wound. She has come to believe Mulder's <b>assertion</b> that Boggs arranged everything. Mulder asks her why she refused the chance to hear from her father again through Boggs. She tells him {{that she did not}} need to hear anything, because she already knew what her father would have said.|$|E
40|$|Lazy {{functional}} programming languages need lazy <b>assertions</b> {{to ensure that}} <b>assertions</b> preserve the meaning of programs. Examples in this paper demonstrate that previously proposed lazy <b>assertions</b> nonetheless break basic semantic equivalences, because they include a non-deterministic disjunction combinator. The objective {{of this paper is}} to determine ”correct ” definitions for lazy <b>assertions.</b> The starting point is our formalisation of basic properties such as laziness, taking them as axioms of our design space. We develop the first denotational semantics for lazy assertions; <b>assertions</b> denote subdomains. We define a weak disjunction combinator and together with a conjunction combinator <b>assertions</b> form a bounded distributive lattice. From the established laws we derive an efficient prototype implementation of lazy <b>assertions</b> for Haskell as a library...|$|R
5000|$|Both United States and International {{auditing}} standards include guidance related to financial statement <b>assertions.</b> The PCAOB and the IFAC address financial statement <b>assertions</b> in AS 15 and ISA 315, respectively. Auditors generally classify <b>assertions</b> into three categories: ...|$|R
50|$|When {{a program}} is {{deployed}} to production, <b>assertions</b> are typically turned off, {{to avoid any}} overhead or side effects they may have. In some cases <b>assertions</b> are completely absent from deployed code, such as in C/C++ <b>assertions</b> via macros. In other cases, such as Java, <b>assertions</b> {{are present in the}} deployed code, and can be turned on in the field for debugging.|$|R
5|$|Chief Justice Melville Fuller {{delivered}} {{the opinion of}} the court on May 21, 1900. This opinion held that there were no federal issues in question in the case, and that the court lacked jurisdiction. The opinion affirmed the state court of appeals' <b>assertion</b> that an elective office was not property. Justices Gray, White, Shiras, and Peckham concurred with the majority opinion.|$|E
5|$|Coghill {{received}} his first drum {{at the age}} of 14, which was a Pearl drum kit given to him by his parents. In 1999, Coghill noted that he began using a 1970 Slingerland drum kit, citing that it had a better sound than a new kit, and was cheaper. Coghill uses Avedis Zildjian cymbals. He says that he has been offered sponsorship, but opted for older drums as a matter of preference. Despite this <b>assertion,</b> as of 2007 Coghill's name is mentioned in the Brady Drums artist roster.|$|E
5|$|Contrary to {{the view}} here popularized by Cassius Dio, however, Nerva had in fact little choice with regard to his successor. Faced with a major crisis, he desperately needed {{the support of a}} man who could restore his damaged reputation. The only {{candidate}} with sufficient military experience, consular ancestry, and connections was Trajan. Likewise, Edward Gibbon's <b>assertion</b> that Nerva hereby established a tradition of succession through adoption among the Five Good Emperors has found little support among modern historians.|$|E
40|$|Abstract 1 —Automated assertion-based {{test data}} {{generation}} {{has been shown}} to be a promising tool for generating test cases that reveal program faults. Because the number of <b>assertions</b> may be very large for complex programs, one of the main concerns to the applicability of assertion-based testing is the amount of search time required to explore a potentially large number of <b>assertions.</b> Since assertion-based test data generation is meant to be used after programs have been tested using regular testing methods, e. g. black-box and white box, it is expected that most faults have been removed previously, therefore, a large number of <b>assertions</b> will not be violated. If the number of unpromising <b>assertions</b> can be reduced, then the efficiency of assertion-based test data generation can be significantly improved. This paper presents an algorithm which uses data-dependency analysis among <b>assertions</b> in order to accumulate historical data about previously explored <b>assertions</b> which can then be utilized during future explorations. The results of a small experimental evaluation of this algorithm show that the algorithm may reduce the number of <b>assertions</b> to be explored, hence making assertion-based test data generation more efficient. This improvement my vary depending on the number and relationship among <b>assertions</b> found in each program. For example, in a program named MinMax 2 with 5 <b>assertions,</b> there was no improvement while in another program named GCD with 24 <b>assertions,</b> there was more than 50 % reduction in number of <b>assertions</b> to be explored. Index Terms—automated software testing, test data generation, software testing, assertion-based testing, program <b>assertions</b> I...|$|R
40|$|<b>Assertions</b> are formal {{constraints}} {{over the}} state variables of a source program which are inserted as annotations in the program text. When some code has been annotated with <b>assertions</b> and is then subjected to refactoring, original <b>assertions</b> {{would no longer be}} consistent with the refactored code. The main focus {{of this paper is to}} specify how <b>assertions</b> could be made consistent across the refactoring process considering design-by-contract. ...|$|R
40|$|Automated assertion-based {{test data}} {{generation}} {{has been shown}} to be a promising tool for generating test cases that reveal program faults. Because the number of <b>assertions</b> may be very large for complex programs, one of the main concerns to the applicability of assertion-based testing is the amount of search time required to explore a potentially large number of <b>assertions.</b> Since assertion-based test data generation is meant to be used after programs have been tested using regular testing methods, e. g. black-box and white box, it is expected that most faults have been removed previously, therefore, a large number of <b>assertions</b> will not be violated. If the number of unpromising <b>assertions</b> can be reduced, then the efficiency of assertion-based test data generation can be significantly improved. This paper presents an algorithm which uses data-dependency analysis among <b>assertions</b> in order to accumulate historical data about previously explored <b>assertions</b> which can then be utilized during future explorations. The results of a small experimental evaluation of this algorithm show that the algorithm may reduce the number of <b>assertions</b> to be explored, hence making assertion-based test data generation more efficient. This improvement my vary depending on the number and relationship among <b>assertions</b> found in each program. For example, in a program named MinMax 2 with 5 <b>assertions,</b> there was no improvement while in another program named GCD with 24 <b>assertions,</b> there was more than 50 % reduction in number of <b>assertions</b> to be explored...|$|R
5|$|Despite initial {{suggestions}} that a petition would be lodged against the result by Sanders, including a strong <b>assertion</b> in the Pall Mall Gazette, such a petition was eventually abandoned. Allsopp entered parliament, becoming the 18th new Member of Parliament {{to be elected}} since the general election in 1886. Allsopp served as the Member for Taunton until the 1895 general election.|$|E
5|$|Despite this trauma, Quatermass {{continues}} with his space programme, {{now called the}} British Rocket Group, and by Quatermass II (1955) is actively planning the establishment of Moon bases. In this serial we see his daughter, Paula Quatermass, who works as an assistant at the Rocket Group, {{but there is no}} sign of a wife or other children. In the fourth episode of the serial he mentions that he never reached his twenty-fifth wedding anniversary, tying in with The Quatermass Memoirs later <b>assertion</b> of his wife's early death.|$|E
5|$|Due to his wartime experiences, Frederick William was {{convinced}} that Brandenburg-Prussia would only prevail with a standing army. Traditionally, raising and financing army reserves was a privilege of the estates, yet Frederick William envisioned a standing army financed independently of the estates. He succeeded in getting the consent and necessary financial contributions of the estates in a landtag decree of 26 July 1653. In turn, he confirmed several privileges of the knights, including tax exemption, <b>assertion</b> of jurisdiction and police powers on their estates (Patrimonialgerichtsbarkeit) and the upholding of serfdom (Leibeigenschaft, Bauernlegen).|$|E
50|$|Inerrancy {{relates to}} the {{absolute}} correctness of the Bible in factual <b>assertions</b> (including historical and scientific <b>assertions).</b>|$|R
40|$|<b>Assertions</b> test {{expected}} {{properties of}} run-time values without disrupting the normal working of a program. So in a lazy functional language <b>assertions</b> should be lazy - not forcing evaluation, but only examining what is evaluated by {{other parts of}} the program. We explore the subtle semantics of lazy <b>assertions</b> and describe sequential and concurrent variants of a method for checking lazy <b>assertions.</b> All variants are implemented in Haskell...|$|R
40|$|This paper {{addresses}} {{the need to}} integrate formal <b>assertions</b> into the modeling, implementation, and testing of statechart based designs. The paper describes an iterative process for the development and verification of statechart prototype models augmented with statechart <b>assertions</b> using the StateRover tool. The novel aspects of the proposed process include (1) writing formal specifications using statechart <b>assertions,</b> (2) JUnit-based simulation and validation of statechart <b>assertions,</b> (3) JUnit-based simulation and testing of statechart prototype models augmented with statechart <b>assertions,</b> (4) automatic, JUnit-based, white-box testing of statechart prototypes augmented with statechart <b>assertions,</b> and (5) spiral adjustment of model and specification using the test results. We demonstrate the proposed process with a prototype of a safety-critical computer assisted resuscitation algorithm (CARA) software for a casualty intravenous fluid infusion pump. ...|$|R
