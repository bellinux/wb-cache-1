44|79|Public
50|$|W.B. Ackerman defines an <b>applicative</b> <b>language</b> as {{one which}} {{does all of}} its {{processing}} by means of operators applied to values. The earliest known <b>applicative</b> <b>language</b> was LISP.|$|E
5000|$|For example, a {{sequence}} of operations in an <b>applicative</b> <b>language</b> like the following: ...|$|E
50|$|OPAL (OPtimized <b>Applicative</b> <b>Language)</b> is a {{functional}} programming language first developed at the Technical University of Berlin.|$|E
40|$|The {{connection}} machine (CM) {{is a highly}} parallel single instruction multiple data (SIMD) computer, which {{has been described as}} 'a huge piece of hardware looking for a programming methodology'[Arv]. <b>Applicative</b> <b>languages,</b> on the other hand, can be described as a programming methodology looking for a parallel computing engine. By simulating archi- tectures that support <b>applicative</b> <b>languages</b> ('appllcative architectures') (e. g., data flow and reduction architectures) on the CM we can achieve the following goals: Quickly and easily experiment with the design and implementation of applicative archi- tectures...|$|R
40|$|Projet FORMELThe {{polymorphic}} type discipline, {{as in the}} ML language, fits {{well within}} purely <b>applicative</b> <b>languages,</b> but does not extend naturally to the main feature of algorithmic languages : in-place update of data structures. Similar typing difficulties arise with other extensions of <b>applicative</b> <b>languages</b> : logical variables, communication channels, continuation handling. This work studies (in the setting of relational semantics) two new approaches to the polymorphic typing of these non-applicative features. The first one relies on a restriction of generalization over types (the notion of dangerous variables), and on a refined typing of functional values (closure typing). The resulting type system {{is compatible with the}} ML core language, and is the most expressive type systems for ML with imperative features proposed so far. The second approach relies on switching to "by-name" semantics for the constructs of polymorphism, instead of the usual "by-value" semantics. The resulting language differs from ML, but lends itself easily to polymorphic typing. Both approaches smoothly integrate non-applicative features and polymorphic typing...|$|R
50|$|Applicatives {{may also}} be the only way of expressing such roles, as in the Bantu Chaga languages, where instrumental, benefactive, malefactive, and locative are formed solely by <b>applicatives.</b> In other <b>languages</b> <b>applicatives</b> coexist with other methods of expressing said roles. In these <b>languages</b> <b>applicatives</b> are often used to bring a {{normally}} oblique argument into special focus, or as in Nez Percé, to keep humans as core arguments.|$|R
5000|$|For example, a {{sequence}} of operations in an <b>applicative</b> <b>language</b> like the following:def example(x): y = foo(x) z = bar(y) w = baz(z) return w...is written in point-free style as the composition of {{a sequence}} of functions, without parameters: ...|$|E
40|$|The “referential transparency” {{principle}} of <b>applicative</b> <b>language</b> expressions stipulates {{that a single}} value exists for all occurrences of an expression in a given context (where a context {{is a set of}} bindings of variables to values). In principle, each such value therefore need to be computed only once. However, in <b>applicative</b> <b>language</b> systems supporting recursive programming or tasking notions, the bindings are not all precomputed and explicit. As a result, textual recognition of all multipleoccurrences is precluded, with the unfortunate consequence that such occurrences are recomputed. We elaborate upon the early notion of “memo function” for solving this problem. We suggest syntactic and semantic constructs providing programmer control for avoiding recomputation, which is incorporated into a “building-block” approach...|$|E
40|$|An <b>applicative</b> <b>language</b> {{based on}} the LAMBDA-Calculus is presented. The language, SLIPS (Small Language for Instruction Purposes), is {{described}} using the LAMBDA-Calculus as a metalanguage. A call-by-need mechanism of function invocation eliminates the drawbacks of both call-by-name and call-by-value. The system has been implemented in PASCAL...|$|E
40|$|This paper {{addresses}} {{the problem of}} designing a parallel reduction architecture for <b>applicative</b> <b>languages.</b> An interconnection network that allows for scheduling of binary trees of arbitrary depth is presented. It is shown that using a static scheduling strategy the architecture achieves optimal performance while scheduling complete binary trees. Some {{issues related to the}} design of a machine based on this network are also discussed...|$|R
40|$|The conc {{representation}} of lists in implementations of <b>applicative</b> <b>languages</b> is introduced. This representation {{is based on}} an operator conc which supplements the usual cons, the representation itself being able to coexist with the conventional nested-pair representation. Advantages of the conc representation are presented which relate to multiprocessing and conventional systems. Qualitative comparison with other compact list representations is made. The conc representation exploits demand-driven evaluation and provides further justification for the “tagged data” approach...|$|R
30|$|Double applicatives {{are rare}} across {{languages}}. Only a few languages {{have been reported}} to exhibit double applicatives so far (Samkoe 1994). These include Huastec, Kinyarwanda, Sierra Popoluca, Lillooet, Shuswap, and Thompson. Along with Shi, Chaokai and Atul Manqoqo (2013), this paper adds Tsou and Bunun to the impoverished list. However, {{it should be noted that}} Tsou and Bunun differ from double <b>applicative</b> <b>languages</b> such as Kinyarwanda in that Tsou and Bunun are asymmetrical object languages which extract only the applied object.|$|R
40|$|In the 1977 Turing award lecture [1] Backus {{introduced}} the <b>applicative</b> <b>language</b> FP and extended {{the language in}} [2]. It is a language driven by the notion of functional composition. Following the standard mathematical approach the method of evaluation was an innermost first composition driven strategy...|$|E
40|$|The use of continuations in the {{definition}} of programming languages has gained considerable currency recently, particularly in conjunction with the lattice-theoretic methods of D. Scott. Although continuations are apparently needed to provide a mathematical semantics for non-applicative control features, they are unnecessary for {{the definition}} of a purely <b>applicative</b> <b>language,</b> even when call-by-value occurs. This raises the question {{of the relationship between the}} direct and the continuation semantic functions for a purely <b>applicative</b> <b>language.</b> We give two theorems which specify this relationship and show that, in a precise sense, direct semantics are included in continuation semantics. The heart of the problem is the construction of a relation which must be a fixed-point of a non-monotonic 2 ̆ 2 relational functor. 2 ̆ 2 A general method is given for the construction of such relations between recursively defined domains...|$|E
40|$|AbstractFunctional {{and logic}} {{programming}} languages {{are combined into}} a new <b>applicative</b> <b>language.</b> The ultimate aim {{is the development of}} more efficient programs than would otherwise be possible. This paper introduces the key idea and gives examples of its use to solve various programming problems. On implementations that support parallel evaluation of expressions, further interesting possibilities arise...|$|E
40|$|We have {{described}} {{several aspects of}} languages and systems for 2 ̆ 2 applicative 2 ̆ 2 multiprocessing, including some solved and some unsolved problems. From a theoretical point of view, the combination of distributed processing and <b>applicative</b> <b>languages</b> seems to provided an extremely interesting and varied array of topics for future investigation. There seems to {{be little doubt that}} this combination will {{have a significant impact on}} future uses of computers, as well as theories relating to these uses...|$|R
40|$|<b>Applicative</b> {{programming}} <b>languages</b> {{and languages}} for data-flow machines are {{often described as}} value-oriented languages. Other languages, such a Smalltalk, are described as object-oriented. LISP {{has been described as}} both value-oriented and object-oriented. What exactly do these terms mean? This paper attempts to identify and clarify the differences between values and objects and, hence, between value-oriented and object-oriented languages. The paper then turns {{to the question of whether}} objects should be included in <b>applicative</b> <b>languages</b> and the role they can fill in those languages. The remainder of the paper is a proposal for one approach to a true object-oriented programming. This includes both an informal description of object-oriented programming constructs and a formal semantics for these constructs. Nondeterminacy, synchronization and recovery from failures are briefly discussed. (Author) Prepared for: Naval Postgraduate School, Monterey, California 93943. [...] Cover. [URL] provided by the Chief of Naval Researc...|$|R
25|$|As {{with other}} <b>applicative</b> {{programming}} <b>languages,</b> a TTM function may be recursive {{and may be}} defined {{as the result of the}} invocation of a sequence of other function calls.|$|R
40|$|The syntax of {{a formal}} {{language}} is effectively given. This is not immediately so for the semantics. This paper deals with the simple but sufficiently powerful <b>applicative</b> <b>language</b> (λ-calculus) and studies effectiveness properties of its semantics. In particular it analyses {{the effectiveness of the}} interpretation of λ-terms as well as different notions of computability over models...|$|E
30|$|While the {{grouping}} of a transported theme/causand {{as an instrument}} and that of a goal as a beneficiary are encoded by prepositions in English and Chinese, they are carried out by applicative morphology in Tsou {{as well as other}} Formosan languages. In this sense, Tsou can be identified as a morphologically <b>applicative</b> <b>language,</b> as opposed to English and Chinese, which are not morphologically applicative languages.|$|E
40|$|In {{an earlier}} paper we {{developed}} an intermediate representation for languages based on composition, and showed how the representation could facilitate generating code for functional languages, such as FP. In this paper {{we follow the}} same philosophical approach, using instead the <b>applicative</b> <b>language</b> APL. Further, we show how this intermediate representation simplifies the task of generating code for highly parallel machines, such as the Connection Machine...|$|E
30|$|These locative construals {{therefore}} {{count as}} instances of low applicatives. As a result, we have secured some reliable tests at hand {{to map out}} the topography of <b>applicatives</b> across <b>languages.</b>|$|R
40|$|OF DISSERTATION THE SPECTRUM OF THREAD IMPLEMENTATIONS ON HYBRID MULTITHREADED ARCHITECTURES The {{proliferation}} of multithreaded architectures indicates {{a desire to}} combine {{the best of the}} dataflow and von Neumann models. These architectures have the capability of masking memory latencies using the dataflow model as well as the capability of exploiting locality, both temporal and spatial, a la von Neumann. This is accomplished by increasing granularity from instruction level to thread level. Increased granularity results in reducing the synchronization required per instruction and introduces locality where none was present. <b>Applicative</b> and functional <b>languages</b> expose parallelism with no intervention by the programmer and without expensive data dependence analysis, apart from array analysis. With the combination of <b>applicative</b> <b>languages,</b> hybrid multithreaded architectures and capable compilers, a possible platform for scalable high performance computing is created. The challenge is to de [...] ...|$|R
40|$|A {{future is}} a {{language}} construct that allows programmers to expose parallelism in <b>applicative</b> <b>languages</b> such as MultiLisp [5] with minimal e ort. In this paper we describe a technique for implementing futures, {{which we call}} leapfrogging, that reduces blocking due to load imbalance. The utility of leapfrogging is enhanced {{by the fact that}} it is completely platform-independent, is free from deadlock, and places a bound on stack sizes that is at most a small constant times the maximum stack size encountered during a sequential execution of the same computation. We demonstrate the performance of leapfrogging using a prototype implementation written in C++. ...|$|R
40|$|This paper {{proposes a}} method for {{organizing}} linguistic knowledge in both systematic and flexible fashion. We introduce a purely <b>applicative</b> <b>language</b> (PAL) as an intermediate representation and an object-oriented computation mechanism for its interpretation. PAL enables {{the establishment of a}} principled and well-constrained method of interaction among lexicon-oriented linguistic modules. The object-oriented computation mechanism provides a flexible means of abstracting modules and sharing common knowledge. 1...|$|E
40|$|We {{introduce}} a tensor sum which {{is useful for}} the design and analysis of digit-index permutations (DIPs) algorithms. Using this operation we obtain a new high-performance algorithm for the family of DIPs. We discuss an implementation in the <b>applicative</b> <b>language</b> Sisal and show how different choices of parameters yield different DIPs. The efficiency of the special case of digit reversal is illustrated with performance results on a Cray C- 90...|$|E
40|$|This is {{the second}} report of a series {{exploring}} {{the use of the}} Q programming notation to prototype a programming environment. This environment includes an interpreter, unparser, syntax directed editor, command interpreter, debugger and code generator, and supports programming in a small <b>applicative</b> <b>language.</b> The present report extends the interpreter, unparser, syntax directed editor, command interpreter and debugger to accomodate block-structured identifier declaration and reference. Chief of Naval Research, Arlington, VA[URL]...|$|E
40|$|In {{the context}} of spoken interfaces, we present a {{practical}} methodology and an implemented workbench called EGAL (Lexicalized Tree Grammar Extraction) dedicated to design and test restricted languages used in specific task-oriented applications. A complementary methodology is proposed to process the extraction of these <b>applicative</b> <b>languages</b> from a general LTAG grammar and a training corpus. Additional results allow us to estimate the representativeness of the training corpus. An application {{of the system is}} presented for the tuning of a LTAG grammar dedicated to a spoken interface {{on the basis of a}} Wizard of Oz corpus. 1...|$|R
50|$|In the {{classification}} of programming <b>languages,</b> an <b>applicative</b> programming <b>language</b> is designed to support the development of programs as giving {{the result of a}} function of the combined variables. Successive functional transformations are applied to data to arrive at the result. Such a language, with program control and total state kept in the background, may also be known as a functional language, in a rather loose sense of the term. Lisp and ML are <b>applicative</b> programming <b>languages.</b> In Haskell, this programming paradigm is developed into the applicative functor, which extends the higher-order functional abstraction beyond monad.|$|R
40|$|The {{problem of}} {{automatic}} storage reclamation for distributed implementations of <b>applicative</b> <b>languages</b> is explored. Highly parallel distributed systems have several unique characteristics that complicate the reclamation process; in this setting, the deficiencies of existing storage reclamation schemes are thus noted. A real-time, effectively distributed, garbage collector of the mark-sweep variety, called the marking-tree collector, {{is shown to}} accomplish reclamation in parallel with the main computation, with no centralized data or control other than a logical rendezvous between phases of the collector. In addition, {{it is capable of}} finding and subsequently deleting active processes which are determined to be no longer relevant to the computation...|$|R
40|$|This is {{the first}} report of a series {{exploring}} {{the use of the}} Q programming notation to prototype a programming environment. This environment includes an interpreter, unparser, syntax directed editor, command interpreter, debugger and code generator, and supports programming in a small <b>applicative</b> <b>language.</b> The present report describes the interpreter, unparser, syntax directed editor, command interpreter and debugger for a subset of the language, namely arithmetic expressions. Prepared for: Chief of Naval Research[URL]...|$|E
40|$|We {{outline the}} {{analysis}} of a distributed evaluator for an <b>applicative</b> <b>language</b> FGL (Function Graph Language). Our goal {{is to show that}} the least fixed point semantics of FGL are faithfully implemented by the hardware evaluator envisioned in the Applicative Multi-Processor System AMPS. Included in the analysis are a formalization of demand-driven computation, the introduction of an intermediate graphic language IGL to aid in our proofs, and discussion of pragmatic issues involved in the AMPS machine language design...|$|E
40|$|This is {{the last}} report of a series {{exploring}} {{the use of the}} Omega programming notation to prototype a programming environment. This environment includes an interpreter, unparser, syntax directed editor, command interpreter, debugger and code -generator, and supports programming in a small <b>applicative</b> <b>language.</b> This report presents a universal (i. e., table-driven) syntax directed editor and unparser, which requires only 53 rules to express. A running implementation of these ideas is listed in the appendices. Office of Naval Research[URL]...|$|E
50|$|Applicative {{universal}} grammar, or AUG, is {{a universal}} semantic metalanguage intended for studying the semantic processes in particular languages.This is a linguistic theory that views the formation of phrase {{in a form that}} is analogous to function application in an <b>applicative</b> programming <b>language.</b>|$|R
50|$|However, {{creating}} verbs {{with new}} meanings {{are not necessarily}} the same as <b>applicative</b> marking in <b>languages</b> like Chamorro.|$|R
40|$|AbstractWe {{investigate}} various equivalence {{relations between}} expressions in a first-order {{functional programming language}} augmented {{with the ability to}} destructively alter the underlying data. To define the semantics we introduce the notion of a memory structure. A computation theory for lexically scoped functional language is then defined over these structures. The equivalence relations are then defined within this model theoretic framework. A distinction is made between intensional relations and extensional relations. The former class turn out to have a much more manageable theory than the latter. The principal intensional relation studied is strong isomorphism, its properties allow for elegant verification proofs in a style similar to that of purely <b>applicative</b> <b>languages.</b> In particular the relation is preserved under many standard syntactic manipulations and transformations...|$|R
