105|83|Public
500|$|Statements {{cannot be}} a part of an expression, so list and other comprehensions or lambda expressions, all being expressions, cannot contain statements. A {{particular}} case of this is that an assignment statement such as a = 1 cannot form part of the conditional expression of a conditional statement. This has the advantage of avoiding a classic C error of mistaking an <b>assignment</b> <b>operator</b> = for an equality operator == in conditions: if (c = 1) { ... } is syntactically valid (but probably unintended) C code but if c = 1: ... causes a syntax error in Python.|$|E
2500|$|Assignment {{operators}} ( [...] etc.) are {{combinations of}} a binary operator and the <b>assignment</b> <b>operator</b> (...) {{and will be}} evaluated using the ordinary operators, which can be overloaded.|$|E
50|$|If {{the move}} <b>assignment</b> <b>operator</b> is not {{explicitly}} defined, the compiler generates an implicit move <b>assignment</b> <b>operator</b> (C++11 and newer). The parameter of a move <b>assignment</b> <b>operator</b> is an rvalue reference (T&&) to type T, where T {{is the object}} that defines the move <b>assignment</b> <b>operator.</b> The move <b>assignment</b> <b>operator</b> is different than a move constructor because a move <b>assignment</b> <b>operator</b> is called on an existing object, while a move constructor is called on an object created by the operation. Thereafter, the other object's data is no longer valid.|$|E
5000|$|JavaScript {{supports}} the following binary <b>assignment</b> <b>operators</b> ...|$|R
5000|$|... #Subtitle level 2: Right-associativity of <b>assignment</b> <b>operators</b> ...|$|R
50|$|The {{procedural}} <b>assignment</b> <b>operator(s)</b> (<=, =) can now operate {{directly on}} arrays.|$|R
5000|$|Copy <b>assignment</b> <b>operator</b> if no move {{constructor}} {{and move}} <b>assignment</b> <b>operator</b> are explicitly declared.|$|E
5000|$|Move <b>assignment</b> <b>operator</b> if no copy {{constructor}}, copy <b>assignment</b> <b>operator,</b> move constructor and destructor are explicitly declared.|$|E
5000|$|In the C++ {{programming}} language, {{the move}} <b>assignment</b> <b>operator</b> [...] {{is used for}} transferring a temporary object to an existing object. The move <b>assignment</b> <b>operator,</b> like most C++ operators, can be overloaded. Like the copy <b>assignment</b> <b>operator</b> it is a special member function.|$|E
5000|$|Has trivial {{copy and}} move <b>assignment</b> <b>operators,</b> which {{may use the}} default syntax.|$|R
5000|$|Compound <b>assignment</b> <b>operators</b> a la C e.g. , , , [...] were added. [...] is {{equivalent}} to [...]|$|R
50|$|The {{following}} list, {{though not}} complete or all-inclusive, lists {{some of the}} major programming languages that support augmented <b>assignment</b> <b>operators.</b>|$|R
5000|$|To {{overload}} {{the move}} <b>assignment</b> <b>operator,</b> {{the signature of}} the function must be:To successfully overload the move <b>assignment</b> <b>operator,</b> the following conditions must be met: ...|$|E
5000|$|The copy <b>assignment</b> <b>operator,</b> {{often just}} called the [...] "assignment operator", {{is a special}} case of <b>assignment</b> <b>operator</b> where the source (right-hand side) and {{destination}} (left-hand side) are of the same class type. It {{is one of the}} special member functions, which means that a default version of it is generated automatically by the compiler if the programmer does not declare one. The default version performs a memberwise copy, where each member is copied by its own copy <b>assignment</b> <b>operator</b> (which may also be programmer-declared or compiler-generated).|$|E
5000|$|... #Subtitle level 2: Return {{value of}} {{overloaded}} <b>assignment</b> <b>operator</b> ...|$|E
5000|$|The {{compiler}} generated functions will be , non-virtual and {{the copy}} constructor and <b>assignment</b> <b>operators</b> will receive [...] parameters (and not {{be of the}} alternative legal forms).|$|R
5000|$|Because implicitly-generated constructors and <b>assignment</b> <b>operators</b> simply copy all class data members ("shallow copy"), {{one should}} define {{explicit}} copy constructors and copy <b>assignment</b> <b>operators</b> for classes that encapsulate complex data structures or have external references such as pointers, {{if you need}} to copy the objects pointed to by the class members. If the default behavior ("shallow copy") is actually the intended one, then an explicit definition, although redundant, will be a [...] "self-documenting code" [...] indicating that it was an intention rather than an oversight.|$|R
5000|$|Similarly, some languages, such as BASIC {{use just}} the [...] symbol for both {{assignment}} and equality, {{as they are}} syntactically separate (as with Pascal, Ada, Python, etc., <b>assignment</b> <b>operators</b> cannot appear in expressions).|$|R
50|$|Each {{of these}} is called a {{compound}} <b>assignment</b> <b>operator</b> in said languages.|$|E
5000|$|Copy {{constructor}} if no move constructor {{and move}} <b>assignment</b> <b>operator</b> are explicitly declared.|$|E
5000|$|If a {{destructor}} is declared {{generation of}} a copy <b>assignment</b> <b>operator</b> is deprecated.|$|E
50|$|The OCPJP 6 exam tests a {{candidate}} on knowledge of declarations, access control, object orientation, <b>assignments,</b> <b>operators,</b> flow control, assertions, string handling, I/O, parsing, formatting, generics, collections, inner classes, threads and the JDK tools. The test {{is available in}} English, Japanese, Chinese, German, Korean, Portuguese, Russian and Spanish.|$|R
5000|$|Compound <b>assignment</b> <b>operators</b> of {{the form}} [...] (such as [...] ) were changed to the form [...] (that is, [...] ) to remove the {{semantic}} ambiguity created by constructs such as , which had been interpreted as [...] (decrement [...] by 10) instead of the possibly intended [...] (let [...] be -10).|$|R
5000|$|A [...] is a {{container}} for a raw pointer, which the [...] {{is said to}} own. A [...] explicitly prevents copying of its contained pointer (as would happen with normal assignment), but the [...] function {{can be used to}} transfer ownership of the contained pointer to another [...] A [...] cannot be copied because its copy constructor and <b>assignment</b> <b>operators</b> are explicitly deleted.|$|R
5000|$|PHP 7.2 {{will add}} the Null Coalescing <b>Assignment</b> <b>Operator</b> with the [...] syntax: ...|$|E
50|$|The symbol = {{functions}} as an <b>assignment</b> <b>operator</b> to store a {{value in a}} variable.|$|E
50|$|The '<-' (or '←') <b>assignment</b> <b>operator</b> {{has played}} an {{influence}} in the S programming language.|$|E
50|$|Situations exist where classes {{may need}} destructors, but cannot sensibly {{implement}} copy and move constructors and copy and move <b>assignment</b> <b>operators.</b> This happens, for example, when the base class {{does not support}} these latter Big Four members, but the derived class's constructor allocates memory for its own use. In C++11, this can be simplified by explicitly specifying the five members as default.|$|R
5000|$|... #Caption: Flowchart {{examples}} of the canonical Böhm-Jacopini structures: the SEQUENCE (rectangles descending the page), the WHILE-DO and the IF-THEN-ELSE. The three structures are made of the primitive conditional GOTO (IF test=true THEN GOTO step xxx) (a diamond), the unconditional GOTO (rectangle), various <b>assignment</b> <b>operators</b> (rectangle), and HALT (rectangle). Nesting of these structures inside assignment-blocks result in complex diagrams (cf Tausworthe 1977:100,114).|$|R
50|$|In {{order to}} reflect normal usage, addition, subtraction, multiplication, and {{division}} operators are usually left-associative while an exponentiation operator (if present) is right-associative; this {{applies to the}} up-arrow operator as well. Any <b>assignment</b> <b>operators</b> are also typically right-associative. To prevent cases where operands {{would be associated with}} two operators, or no operator at all, operators with the same precedence must have the same associativity.|$|R
5000|$|In C, C++, and C#, the <b>assignment</b> <b>operator</b> is =, {{which is}} {{augmented}} as follows: ...|$|E
5000|$|Occurrence of an <b>assignment</b> <b>operator</b> (=, *=, /=, %=, +=, <<=, >>=, &=, !=, ^=).|$|E
5000|$|In R, the <b>assignment</b> <b>operator</b> is {{basically}} , as in , {{but a single}} equals sign {{can be used in}} certain contexts.|$|E
5000|$|Augmented {{assignment}} (or compound assignment) is {{the name}} given to certain <b>assignment</b> <b>operators</b> in certain programming languages (especially those derived from C). An augmented assignment is generally used to replace a statement where an operator takes a variable {{as one of its}} arguments and then assigns the result back to the same variable. A simple example is [...] which is expanded to [...] Similar constructions are often available for various binary operators.|$|R
5000|$|... is {{deprecated}} under C++11 {{and completely}} removed from C++17. The copy constructor and <b>assignment</b> <b>operators</b> of [...] do not actually copy the stored pointer. Instead, they transfer it, leaving the prior [...] object empty. This was {{one way to}} implement strict ownership, so that only one [...] object can own the pointer at any given time. This means that [...] {{should not be used}} where copy semantics are needed. Since [...] already existed with its copy semantics, it could not be upgraded to be a move-only pointer without breaking backward compatibility with existing code.|$|R
5000|$|Thompson invented {{arithmetic}} <b>assignment</b> <b>operators</b> for B, using [...] to add y to x (in C {{the operator}} is written [...] ). B also introduced the {{increment and decrement}} operators ( [...] and [...] ). Their prefix or postfix position determines whether the value is taken before or after alteration of the operand. These innovations {{were not in the}} earliest versions of B. Some guess that they were created for the auto-increment and auto-decrement address modes of the DEC PDP-11. This is historically impossible as there was no PDP-11 at the time that B was developed.|$|R
