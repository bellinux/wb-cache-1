7|611|Public
40|$|The {{need for}} <b>automatic</b> <b>storage</b> <b>allocation</b> arises from desires for program modularity, machine independence, and {{resource}} sharing. Virtual memory is an elegant way of achieving these objectives. In a virtual memory, the addresses a program may use to identify information are {{distinguished from the}} addresses th...|$|E
40|$|Dynamic storage {{allocation}} and automatic garbage collection {{are among the}} most popular features that high-level languages can offer. However, time-critical applications cannot be written in such languages unless the time taken to allocate and deallocate storage can be reasonably bounded. In this paper, we present algorithms for <b>automatic</b> <b>storage</b> <b>allocation</b> that are appropriate for real-time and embedded systems...|$|E
40|$|Abstract. Dynamic storage {{allocation}} and automatic garbage collection {{are among the}} most popular features that high-level languages can offer. However, timecritical applications cannot be written in such languages unless the time taken to allocate and deallocate storage can be reasonably bounded. In this paper, we present algorithms for <b>automatic</b> <b>storage</b> <b>allocation</b> that are appropriate for realtime and embedded systems. We have implemented these algorithms, and results are presented that validate the predictability and efficiency of our approach. ...|$|E
40|$|This paper {{describes}} {{ways that}} <b>storage</b> <b>allocation</b> optimization, though “correct”, can convert a running program into one that fails. A general “safety condition” is proposed {{and applied to}} some existing and proposed <b>storage</b> <b>allocation</b> optimizations. These are shown to be unsafe or not general. Application of the safety condition yields several classes of <b>storage</b> <b>allocations</b> that may safely be optimized to stack allocations. For one useful class of allocations optimization is shown to be NP-complete. Safety considerations for <b>storage</b> <b>allocation</b> optimizations...|$|R
40|$|Dynamic <b>storage</b> <b>allocation</b> is an {{important}} part of a large class of computer programs written in C and C��. High-performance algorithms for dynamic <b>storage</b> <b>allocation</b> have been, and will continue to be, of considerable interest. This paper presents detailed measurements of the cost of dynamic <b>storage</b> <b>allocation</b> in 11 diverse C and C� � programs using five very different dynamic <b>storage</b> <b>allocation</b> implementations, including a conservative garbage collection algorithm. Four of the allocator implementations measured are publicly available on the Internet. A number of the programs used in these measurements are also available on the Internet to facilitate further research in dynamic <b>storage</b> <b>allocation.</b> Finally, the data presented in this paper is an abbreviated version of more extensive statistics that are also publicly available on the Internet. key words: Garbage collection Dynamic <b>storage</b> <b>allocation</b> Performance evaluation Conservative collection Dynamic memory managemen...|$|R
40|$|In {{computer}} information systems, {{some programs}} are used {{more frequently than}} others producing skewed distributions of program usages. We investigate the claim that static views of program usage frequencies are insufficient when they are used for <b>storage</b> <b>allocation</b> decisions making it necessary to study {{the implications of the}} use of dynamic frequencies in <b>storage</b> <b>allocation.</b> The use of dynamic frequencies provides a natural extension to previously presented static cost model literature for hierarchical <b>storage</b> <b>allocation.</b> In our work, we present the value of incorporating dynamic usage frequencies into program usage cost models. Thus, an optimization-based cost modeling methodology using Simon's Model for dynamic hierarchical <b>storage</b> <b>allocation</b> is presented. To illustrate, a simple example of program <b>storage</b> <b>allocation</b> is presented in both static and dynamic form. Cost-saving comparisons are then discussed...|$|R
40|$|Virtual memory, long a {{standard}} feature of nearly every operating system and computer chip, is now invading the Internet through the World Wide Web. Once {{the subject of}} intense controversy, virtual memory is now so ordinary that few people think much about it. That this has happened {{is one of the}} engineering triumphs of the computer age. Virtual memory is the simulation of a storage space so large that programmers do not need to rewrite programs, and authors do not need to rewrite documents, when the content of a program module, the capacity of a local memory, or the configuration of a network changes. The name, borrowed from optics, recalls the virtual images formed in mirrors and lenses [...] images that are not there but behave is if they are. The story of virtual memory, from the Atlas Computer at the University of Manchester in the 1950 s to the multicomputers and World Wide Web on the 1990 s, is not simply a story of <b>automatic</b> <b>storage</b> <b>allocation,</b> it is a story of machines helping programmers with protection of information, reuse and sharing of objects, and linking of program components. In what follows, I will give an account of the history of virtual memory, including personal recollections of the events I witnessed and experienced. These recollections will make up a kind of photo album of technical snapshots of virtual memory from birth, through adolescence, to maturity. From these snapshots you will see that the real driver was the quest for a good programming environment; <b>automatic</b> <b>storage</b> <b>allocation</b> was actually a secondary concern. You will see that virtual memory’s designers had deep insights about modularity, sharing, resuse, and objects a long time ago, a fact that may surprise some younger members of the field. Without those insights, virtual memory would never have passed its adolescence. I was a graduate student at MIT Project MAC during 1964 - 68, a time of intense debate on the principles to be incorporated into Multics, principles that would make a permanent imprint on operating systems. <b>Automatic</b> <b>storage</b> <b>allocation</b> and management of multiprogramming were high on the agenda. I contributed the working set model for program behavior. The working set model generated a practical theory for measuring a program’s dynamic memory demand and building an automatic control system that would schedule processor an...|$|E
40|$|ESPRIT Project 415 {{has taken}} what are {{considered}} to be good programming language styles and is developing parallel architectures to support them. Here we describe the part of the project which is developing a distributed memory architecture for functional languages. Designing parallel architectures for evaluating functional languages presents many challenging problems. Firstly a model for the parallel reduction of such languages must be found. An abstract interpretation has been developed which leads to a parallel reduction model. It can be implemented in a compiler so that programs can automatically be annotated with parallelism information. The original COBWEB, a novel distributed memory architecture, is described, along with the conclusions we have drawn from our simulation work. We also briefly describe some of the architectural features of the architecture we are designing to support the parallel reduction model. Many programming languages including functional ones require <b>automatic</b> <b>storage</b> <b>allocation</b> which has to be garbage collected. We present another piece of work from our project which has resulted in the discovery of a distributed reference counting garbage collection algorithm which has very low overheads. ...|$|E
40|$|We have {{designed}} and implemented a single-chip microcomputer (which we call SCHEME- 79) which directly interprets a typed pointer variant of SCHEME, a dialect {{of the language}} LISP. To support this interpreter the chip implements an <b>automatic</b> <b>storage</b> <b>allocation</b> system for heap-allocated data and an interrupt facility for user interrupt routines implemented in SCHEME. We describe how the machine architecture is tailored to support the language, and the design methodology by which the hardware was synthesized. We develop an interpreter for SCHEME written in LISP which {{may be viewed as}} a microcode specification. This is converted by successive compilation passes into actual hardware structures on the chip. We develop a language embedded in LSIP for describing layout artwork so we can procedurally define generators for generalized macro components. The generators accept parameters to produce the specialized instances used in a particular design. We discuss the performance of the current design and directions for improvement, both in the circuit performance and in the algorithms implemented by the chip. A complete annotated listing of the microcode embodied by the chip is included...|$|E
40|$|In many recent {{computer}} system designs, hardware facilities {{have been provided}} for easing the problems of <b>storage</b> <b>allocation.</b> A method of characterizing dynamic <b>storage</b> <b>allocation</b> systems [...] accordlng to the functional capabilities provided and the underlying techniques used [...] is presented. The basic purpose of the paper {{is to provide a}} useful perspective from which the utility of Various hardware facilities may be assessed. A brief survey of <b>storage</b> <b>allocation</b> facilities in several representative {{computer system}}s is included as an appendix...|$|R
5000|$|Support for {{multiple}} volume groups for optimal <b>storage</b> <b>allocation</b> ...|$|R
40|$|An Inverted file is a {{commonly}} used index for both archival databases and free text where no updates are expected. Applications like information filtering and dynamic environments like the Internet require inverted files to be updated efficiently. Recently, extensible inverted files are proposed {{which can be}} used for fast online indexing. The effective <b>storage</b> <b>allocation</b> scheme for such inverted files uses the arrival rate to preallocate storage. In this article, this <b>storage</b> <b>allocation</b> scheme is improved by using information about both the arrival rates and their variability to predict the storage needed, as well as scaling the <b>storage</b> <b>allocation</b> by a logarithmic factor. The resultant, final storage utilization rate can be as high as 97 - 98 % after indexing about 1. 6 million documents. This compares favorably with the storage utilization rate of the original arrival rate <b>storage</b> <b>allocation</b> scheme. Our evaluation shows that the retrieval time for extensible inverted file on solid state disk is on average similar to the retrieval time for in-memory extensible inverted file. When file seek time is not an issue, our scalable <b>storage</b> <b>allocation</b> enables extensible inverted files to be used as the main index on disk. Our statistical <b>storage</b> <b>allocation</b> may be applicable to novel situations where the arrival of items follows a binomial, Poisson or normal distribution. Department of Computin...|$|R
40|$|Wide {{distribution}} of the computer algebra system Mathematica 1 has encouraged numerous programmers, researchers and educators to produce libraries of programs in its special language, for incorporation as " into Mathematica systems. Although some features of the language are quite interesting, some authors have found that for their purposes the Mathematica proprietary computer program has problematical and di cult-to-alter semantics. Therefore certain kinds of experiments and developments are necessarily inconvenient. An initial step in opening up such user-written libraries to re-use is an independent re-implementation of the language via a non-proprietary parser. In principle, this allows other implementations of semantics, as well as experiments in data representation, while still using the language basically {{as described in the}} Mathematica references. We describe a parser written in Common Lisp, a language which is appropriate for three reasons: (1) It is a standard and has wide distribution � (2) It supports numerous useful features including <b>automatic</b> <b>storage</b> <b>allocation</b> and garbage collection, arbitrary-precision integers, and tools for lexical scanning of languages � and (3) Lisp is the host language for several algebraic manipulation systems whose subroutines may be of some interest for programmers implementing alternative semantics...|$|E
40|$|AbstractWe use {{an on-line}} {{algorithm}} for coloring interval graphs {{to construct a}} polynomial time approximation algorithm WIC for Dynamic <b>Storage</b> <b>Allocation.</b> The performance ratio for WIC is at most six; the best previous upper bound on the performance ratio for a polynomial time approximation algorithm for Dynamic <b>Storage</b> <b>Allocation</b> had been 80...|$|R
5000|$|ASM <b>Automatic</b> <b>Storage</b> Management Oracle's database-oriented {{filesystem}} ...|$|R
50|$|Norton Zone offered 5 GB {{of storage}} {{for free and}} larger <b>storage</b> <b>allocations</b> via subscription.|$|R
40|$|Includes bibliographical {{references}} (pages [65]- 66) An <b>automatic</b> <b>storage</b> and {{retrieval system}} provides {{the ability to}} move material without manual intervention and to bring real time information in line with material movement. Efficient space utilization, accurate inventory tracking, reduced costs, increased capacity and minimal inventory are other benefits associated with an <b>automatic</b> <b>storage</b> and retrieval system. The construction of the <b>automatic</b> <b>storage</b> and retrieval system has been a common industrial practice. However, to date no procedure for sizing an <b>automatic</b> <b>storage</b> and retrieval system is available. This thesis presents a successfully applied methodology for sizing an unit load <b>automatic</b> <b>storage</b> and retrieval system. Economic lot sizing, space requirement, unit load size determination, throughput analysis, software and simulation are explored. Examples include use of the Silver-meal formula in lot sizing calculations, use of the square-root economic lot formula, determining the delivery window factor, application of the expansion factor, rough cut sizing using different height/length speed ratios for cranes, cubic space requirements calculations, total number of containers calculations, crane cycle time calculations and a throughput analysis technique. A SLAMM II with FORTRAN simulation is included in the Appendix. M. S. (Master of Science...|$|R
40|$|Nowadays {{automation}} is a {{trend of}} container terminals all over the world. Although not applied in current automated container terminals, <b>storage</b> <b>allocation</b> is indispensable in conventional container terminals, and promising for automated container terminals in future. This paper seeks into the <b>storage</b> <b>allocation</b> problem in automated container terminals and proposed a two level structure for the problem. A mixed integer programming model is built for the upper level, and a modified Particle Swarm Optimization (PSO) algorithm is applied to solve the model. The applicable conditions of the model is investigated by numerical experiments, so as {{the performance of the}} algorithm in different problem scales. It is left to future research the lower level of the problem and the potential benefit of <b>storage</b> <b>allocation</b> to automated container terminals...|$|R
5000|$|... {{infinite}} store : The programmer is {{not responsible}} for <b>storage</b> <b>allocation</b> and can create as many data objects as needed.|$|R
5000|$|... 2003: Saab {{introduces}} CargoSET; <b>automatic</b> <b>storage</b> well retr{{action for}} the convertible, a two-step tonneau action for quicker soft-top deployment ...|$|R
40|$|Practical and {{theoretical}} {{results have been}} found concerning the use of global <b>storage</b> <b>allocation</b> for the instances of applied occurrences of an attribute. The practical results focus on the necessary and sufficient conditions to decide at evaluator construction time whether an evaluator can allocate the instances of an applied occurrence {{to a number of}} global variables, stackes and queues. Checking these conditions takes polynomial time for a simple multi-visit evaluator and exponential time for an absolutely non-circular evaluator. The theoretical results are concerned with the data structures that are required for the global <b>storage</b> <b>allocation</b> of the instances of applied occurrences in simple multi-X evaluators, where X € {pass, sweep, visit}. For this purpose, the general class of basic linear data structures is introduced. This class of data structures {{can also be used to}} explore the theoretical possibilities and limitations of <b>storage</b> <b>allocation</b> techniques in domains other than attribute grammars...|$|R
40|$|Dynamic <b>storage</b> <b>allocation</b> is used {{heavily in}} many {{application}} areas including interpreters, simulators, optimizers, and translators. We describe research that can improve {{all aspects of the}} performance of dynamic <b>storage</b> <b>allocation</b> by predicting the lifetimes of short-lived objects when they are allocated. Using five significant, allocation-intensive C programs, we show that a great fraction of all bytes allocated are short-lived (? 90 % in all cases). Furthermore, we describe an algorithm for lifetime prediction that accurately predicts the lifetimes of 42 [...] 99 % of all objects allocated. We describe and simulate a storage allocator that takes advantage of lifetime prediction of short-lived objects and show that it can significantly improve a program's memory overhead and reference locality, and even, at times, improve CPU performance as well. 1 Introduction. Dynamic <b>storage</b> <b>allocation</b> (DSA) is used heavily in {{many application areas}} including interpreters, simulators, optimizers, and [...] ...|$|R
40|$|We {{examine the}} problem of {{counting}} interval graphs. We answer the question posed by Hanlon, of whether the formal power series generating function {{of the number of}} interval graphs on n vertices has a positive radius of convergence. We have found that it is zero. We have obtained a lower bound and an upper bound on the number of interval graphs on n vertices. We also study the application of interval graphs to the dynamic <b>storage</b> <b>allocation</b> problem. Dynamic <b>storage</b> <b>allocation</b> {{has been shown to be}} NP-complete by Stockmeyer. Coloring interval graphs on-line has applications to dynamic <b>storage</b> <b>allocation.</b> The most colors used by Kierstead 2 ̆ 7 s algorithm is 3 ω - 2, where ω is the size of the largest clique in the graph. We determine a lower bound on the colors used. One such lower bound is 2 ω - 1...|$|R
5000|$|... sorting systems method: no {{movement}} of the order picker(s), the products are brought to him by an automatic system (conveyor system, <b>automatic</b> <b>storage</b> ...).|$|R
40|$|Dynamic <b>Storage</b> <b>Allocation</b> is {{the problem}} of packing given axis-aligned {{rectangles}} into a horizontal strip of minimum height by sliding the rectangles vertically but not horizontally. Where L = LOAD is the maximum sum of heights of rectangles that intersect any vertical line and OPT is the minimum height of the enclosing strip, it is obvious that OPT LOAD; previous work showed that OPT 3 LOAD. We continue the study of the relationship between OPT and LOAD, proving that OPT = L + O((hmax=L)) L, where hmax is the maximum job height. Conversely, we prove that for any > 0, there exists a c > 0 such that for all suf- ciently large integers hmax, there is a Dynamic <b>Storage</b> <b>Allocation</b> instance with maximum job height hmax, maximum load at most L, and OPT L + c(hmax=L) L, for in nitely many integers L. En route, we construct several new polynomial-time approximation algorithms for Dynamic <b>Storage</b> <b>Allocation...</b>|$|R
40|$|<b>Storage</b> <b>allocation</b> affects {{important}} {{performance measures}} of distributed storage systems. Most previous {{studies on the}} <b>storage</b> <b>allocation</b> consider its effect separately either {{on the success of}} the data recovery or on the service rate (time) where it is assumed that no access failure happens in the system. In this paper, we go one step further and incorporate the access model and the success of data recovery into the service rate analysis. In particular, we focus on quasi-uniform <b>storage</b> <b>allocation</b> and provide a service rate analysis for both fixed-size and probabilistic access models at the nodes. Using this analysis, we then show that for the case of exponential waiting time distribution at individuals storage nodes, minimal spreading allocation results in the highest system service rate for both access models. This means that for a given storage budget, replication provides a better service rate than a coded storage solution. Comment: This paper has been accepted for presentation in IEEE ISIT 201...|$|R
25|$|As in C, C++ {{supports}} {{four types}} of memory management: static storage duration objects, thread <b>storage</b> duration objects, <b>automatic</b> <b>storage</b> duration objects, and dynamic storage duration objects.|$|R
40|$|Estimating {{the fault}} rate {{function}} Paging activity {{can be a}} major factor in determining whether a software workload will run on a given computer system. A program’s paging behavior is difficult to predict because it depends not only on the workload processed by the program, but also on the level of storage contention of the processor. A program’s fault rate function relates <b>storage</b> <b>allocation</b> to the page fault rate experienced while processing a given workload. Thus, with the workload defined, the fault rate function can be used to see how the program’s <b>storage</b> <b>allocation</b> is affected by varying levels of storage contention, represente...|$|R
40|$|Dynamic <b>Storage</b> <b>Allocation</b> is {{a problem}} {{concerned}} with storing items that each have weight and time restrictions. Approximate algorithms have been constructed through online coloring of interval graphs. We present a general-ization that uses online coloring of tolerance graphs. We utilize online-with-representation algorithms on tolerance graphs, which are online algorithms in which the corresponding tolerance representation of a vertex is also presented. We find linear bounds for the online-with-representation chromatic number of various classes of tolerance graphs and apply these results to a generalization of Dynamic <b>Storage</b> <b>Allocation,</b> giving us a polynomial time approximation algorithm with linear performance ratio...|$|R
40|$|This paper {{presents}} virtual allocation, {{a scheme}} for flexible <b>storage</b> <b>allocation.</b> It separates <b>storage</b> <b>allocation</b> from the file system. It employs an allocate-on-write strategy, which lets applications {{fit into the}} actual usage of storage space {{without regard to the}} configured file system size. This improves flexibility by allowing storage space to be shared across different file systems. This paper presents the design of virtual allocation and an evaluation of it through benchmarks. To illustrate our approach, we implemented a prototype system on PCs running Linux. We present the results from the prototype implementation and its evaluation. ...|$|R
40|$|The yard truck {{scheduling}} and the <b>storage</b> <b>allocation</b> are two important decision problems affecting {{the efficiency of}} container terminal operations. This paper proposes a novel approach that integrates these two problems into a whole. The objective is to minimize the weighted sum of total delay of requests and the total travel time of yard trucks. Due to the intractability of the proposed problem, a hybrid insertion algorithm is designed for effective problem solutions. Computational experiments are conducted to examine the key factors {{of the problem and}} the performance of the proposed heuristic algorithm. Container terminal operations Yard truck scheduling <b>Storage</b> <b>allocation</b> Heuristic algorithm...|$|R
40|$|AbstractThis paper {{proposes a}} new <b>storage</b> <b>allocation</b> rule based on target storage curves. Joint {{operating}} rules are also proposed {{to solve the}} operation problems of a multi-reservoir system with joint demands and water transfer-supply projects. The joint operating rules include a water diversion rule to {{determine the amount of}} diverted water in a period, a hedging rule based on an aggregated reservoir to determine the total release from the system, and a <b>storage</b> <b>allocation</b> rule to specify the release from each reservoir. A simulation-optimization model was established to optimize the key points of the water diversion curves, the hedging rule curves, and the target storage curves using the improved particle swarm optimization (IPSO) algorithm. The multi-reservoir water supply system located in Liaoning Province, China, including a water transfer-supply project, was employed as a case study to verify the effectiveness of the proposed join operating rules and target storage curves. The results indicate that the proposed operating rules are suitable for the complex system. The <b>storage</b> <b>allocation</b> rule based on target storage curves shows an improved performance with regard to system storage distribution...|$|R
40|$|Dynamic <b>storage</b> <b>allocation</b> has a {{significant}} impact on computer performance. A dynamic storage allocator manages space for objects whose lifetimes are not known by the system {{at the time of their}} creation. A good dynamic storage allocator should utilize storage efficiently and satisfy requests in as few instructions as possible. A dynamic storage allocator on a multiprocessor should have the ability to satisfy multiple requests concurrently. This paper examines parallel dynamic <b>storage</b> <b>allocation</b> algorithms and how performancescales with increasing numbers of processors. The highest throughputs and lowest instruction counts are achieved with multiple free list fit I. The best memory utilization is achieved using a best fit system...|$|R
50|$|In {{computer}} programming, a variable-length array (VLA), {{also called}} variable-sized, runtime-sized, is an array data structure of <b>automatic</b> <b>storage</b> duration whose length is determined at run time (instead of at compile time).|$|R
30|$|The map of {{the costs}} {{obtained}} with the simulation environment developed can be a decision support system to choose the best model evaluating the condition of production rate, preventive maintenance actions time required, and the buffer <b>storages</b> <b>allocation.</b>|$|R
40|$|<b>Storage</b> <b>allocation</b> of {{outbound}} containers is a {{key factor}} {{of the performance of}} container handling system in automated container terminals. Improper storage plans of outbound containers make QC waiting inevitable; hence, the vessel handling time will be lengthened. A simulation-based optimization method is proposed in this paper for the <b>storage</b> <b>allocation</b> problem of outbound containers in automated container terminals (SAPOBA). A simulation model is built up by Timed-Colored-Petri-Net (TCPN), used to evaluate the QC waiting time of storage plans. Two optimization approaches, based on Particle Swarm Optimization (PSO) and Genetic Algorithm (GA), are proposed to form the complete simulation-based optimization method. Effectiveness of this method is verified by experiment, as the comparison of the two optimization approaches...|$|R
