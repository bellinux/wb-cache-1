13|5|Public
40|$|IPv 6 Addressing of IPv 4 /IPv 6 Translators This {{document}} {{discusses the}} <b>algorithmic</b> <b>translation</b> of an IPv 6 address to a corresponding IPv 4 address, and vice versa, using only statically configured information. It defines a well-known prefix {{for use in}} algorithmic translations, while allowing organizations to also use network-specific prefixes when appropriate. <b>Algorithmic</b> <b>translation</b> is used in IPv 4 /IPv 6 translators, {{as well as other}} types of proxies and gateways (e. g., for DNS) used in IPv 4 /IPv 6 scenarios. Status of This Memo This is an Internet Standards Track document. This document {{is a product of the}} Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by th...|$|E
40|$|Conversion of {{software}} written for one machine or operating system to equivalent software for another machine or operating system {{is shown to}} be economically attractive using source-to-source translation. The features of an automatic converter are described using a Pascal-to-C translater as an example. Solutions {{to the problems of}} denesting procedures, converting data structures and types, converting control structures and operators, and converting semantics in one language into equivalent semantics in another language are proposed and evaluated in terms of an algorithmic translator. The results obtained through experience suggest that <b>algorithmic</b> <b>translation</b> from one language to another can yield 95 to 99 per cent conversion without human intervention, leading to significan...|$|E
40|$|Abstract. The use of {{business}} process models has gone far beyond doc-umentation purposes. In the development {{of business}} applications, they can {{play the role of}} an artifact on which high level properties can be verified and design errors can be revealed in an effort to reduce overhead at later software development and diagnosis stages. This paper demon-strates how formal verification may add value to the specification, de-sign and development of business process models in an industrial setting. The analysis of these models is achieved via an <b>algorithmic</b> <b>translation</b> from the de-facto standard business process modeling language BPMN to Event-B, a widely used formal language supported by the Rodin plat-form which offers a range of simulation and verification technologies. ...|$|E
40|$|We {{provide a}} general <b>algorithmic</b> schema for <b>translation</b> rule {{extraction}} {{and show that}} several popular extraction methods (including phrase pair extraction, hierarchical phrase pair extraction, and GHKM extraction) {{can be viewed as}} specific instances of this schema. This work is primarily intended as a survey of the dominant extraction paradigms, in which we make explicit the close relationship between these approaches, and establish a language for future hybridizations. This facilitates a generic and extensible implementation of alignment-based extraction methods. ...|$|R
40|$|The present project fits in {{the context}} of devising theoretical-computational {{strategies}} aimed to simplify the description of chemical kinetics when many species are involved in the reaction of interest. Here we focus on well-stirred reacting systems in isothermal conditions, so that the dynamical variables are the volumetric concentrations of the species. It is assumed that the complex reaction owns a kinetic scheme made of known elementary steps (or, similarly, a reaction network is formed by elementary reactions) to which the Mass-Action Law is applicable to construct the system of differential equations governing the time evolution. The main goal of this work is to achieve the simplification of the kinetics description via the construction of hypersurfaces called Slow Manifolds (SMs) in the Literature. Since a SM has lower dimension than the number of chemical species involved in the reaction, and since the slow part of the evolution is found to take place in the neighborhood of the SM (after an initial transient), the identification of these surfaces may allow an efficient simplification in terms of reduction of the number of relevant dynamical variables. In {{the first part of the}} thesis we review the state of the art of the methods available in Literature to construct the SMs. Then we stand on a formal and objective mathematical definition of the SM recently proposed [P. Nicolini and D. Frezzato, J. Chem. Phys. 138, 234101 (2013); ibid., J. Chem. Phys. 138, 234102 (2013) ], and develop computational strategies to “translate” it in the numerical practice. Codes in programming language FORTRAN 77 have been created to implement these strategies and to test their efficiency both on low-dimensional model kinetic schemes, and on a simplified scheme for hydrogen combustion widely taken as benchmark in the Literature. Although the methods developed by us are based on a rigorous definition of Slow Manifold, and the results for the model-schemes are satisfactory, the tests on the hydrogen combustion scheme reveal that the choice of some work-parameters (required to perform the calculations) may largely affect the outcomes. In this respect, the <b>algorithmic</b> <b>translations</b> of the formal definition of Slow Manifold is not yet fully satisfactory. In the final chapter we argue some possible improvements of the methods, namely the exploitation of data clustering algorithms to exclude spurious solutions, the inclusion of the temperature amongst the dynamical variables, and the consideration of non-elementary reactions. ...|$|R
40|$|AbstractFor a {{language}} Lalg of many-sorted <b>algorithmic</b> logic a <b>translation</b> Tr into a suitable first-order language L′ is considered. L′ contains additional sorts of variables for natural numbers and objects coding computations. Thus, in L′ statements about properties of programs of Lalg can be expressed. The main {{problem of the}} paper is to investigate what properties of a given theory T in Lalg (e. g., decidability, completeness, etc.) transfer to the first-order theory Tr(T). In other words, is the first-order theory Tr(T) a good approximation of the algorithmic theory T?It is also investigated whether, for a given algorithmic theory T in Lalg, every model M′ of T′ = Tr(T) has a submodel such that its reduct M to the language Lalg {{is a model of}} the theory T. This problem can be treated as the question of removing nonstandard computations...|$|R
40|$|It {{has become}} {{increasingly}} cost-effective to produce primary medical records as electronic documents. However, access to these documents by disease-concept {{is limited by the}} user's knowledge of the classification system (ICD, SNOMED, MeSH). We have developed a system of <b>algorithmic</b> <b>translation</b> between medical natural language and MeSH titles, by respelling common word roots. Using the list of 17, 494 words harvested from all autopsies performed at The Johns Hopkins Hospital between May 28, 1889, and June 30, 1987, a set of 2, 310 respelling formulas converted 10, 200 words into 659 distinct MeSH titles. Results show that respelling formulas can be used to translate medical natural language into MeSH titles, and thus improve the access to the database...|$|E
40|$|The use of {{business}} process models has gone far beyond documentation purposes. In the development {{of business}} applications, they can {{play the role of}} an artifact on which high level properties can be verified and design errors can be revealed in an effort to reduce overhead at later software development and diagnosis stages. This paper demonstrates how formal verification may add value to the specification, design and development of business processes models in an industrial setting. The analysis of these models is achieved via an <b>algorithmic</b> <b>translation</b> from the de-facto standard business process modelling language BPMN to Event-B, a widely used formal language supported by the Rodin platform which offers a range of simulation and verification technologies...|$|E
40|$|Data {{reduction}} in Multidimensional Data Warehouses (MDWs) allows increasing {{the efficiency of}} analysis and facilitating decision-makers' tasks. In this paper, we model a MDW containing reduced data {{through a set of}} states. Each state is valid for a certain period of time; it contains only useful information according to decision-makers' needs. In order to carry out analyses in a MDW composed of multiple states, an extension of traditional OLAP analysis operators is required. In this paper, we define a set of OLAP operators compatible with reduced MDWs. For each operator, we propose a user-oriented definition along with an <b>algorithmic</b> <b>translation.</b> To show the feasibility and the efficiency of the proposed concepts, we implement the analysis operators in an R-OLAP framework...|$|E
40|$|A {{number of}} storage {{elements}} now offer standard protocol interfaces like NFS 4. 1 /pNFS and WebDAV, {{for access to}} their data repositories, {{in line with the}} standardization effort of the European Middleware Initiative (EMI). Also the LCG FileCatalogue (LFC) can offer such features. Here we report on work that seeks to exploit the federation potential of these protocols and build a system that offers a unique view of the storage and metadata ensemble and the possibility of integration of other compatible resources such as those from cloud providers. The challenge, here undertaken by the providers of dCache and DPM, and pragmatically open to other Grid and Cloud storage solutions, is to build such a system while being able to accommodate name translations from existing catalogues (e. g. LFCs), experiment- based metadata catalogues, or stateless <b>algorithmic</b> name <b>translations,</b> also known as ”trivial file catalogues”. Such so-called storage federations of standard protocols-based storage elements give a unique view of their content, thus promoting simplicity in accessing the data they contain and offering new possibilities for resilience and data placement strategies. The goal is to consider HTTP and NFS 4. 1 -based storage elements and metadata catalogues and make them able to cooperate through an architecture that properly feeds the redirection mechanisms that they are based upon, thus giving the functionalities of a ”loosely coupled” storage federation. One of the key requirements is to use standard clients (provided by OS’es or open source distributions, e. g. Web browsers) to access an already aggregated system; this approach is quite different from aggregating the repositories at the client side through some wrapper API, like for instance GFAL, or by developing new custom clients. Other technical challenges that will determine the success of this initiative include performance, latency and scalability, and the ability to create worldwide storage federations that are able to redirect clients to repositories that they can efficiently access, for instance trying to choose the endpoints that are closer or applying other criteria. We believe that the features of a loosely coupled federation of open-protocols-based storage elements will open many possibilities of evolving the current computing models without disrupting them, and, at the same time, will be able to operate with the existing infrastructures, follow their evolution path and add storage centers that can be acquired as a third-party service...|$|R
40|$|Ciclo 2012 di seminari interni CRS 4, Number 20120229. We motivate and {{describe}} the design and implementation of a web-based system for the alignment of parallel texts. It builds on the interactive color-highlight interface now deployed at Google Translate. By a series of simple point and click operations translators can mark up equivalent text-ranges in their own translation and in the original. When successful, the visual cues created by this activity should benefit the understanding of readers of limited degrees of bilingualism [...] and may also capture aspects of semantic context not readily available to <b>algorithmic</b> statistical machine <b>translation.</b> We provide a working demonstration that treats poetic texts. Statistical machine translation (SMT) delivers texts unacceptable for literary or academic purposes since generally, it cannot assimilate adequate context: Yet how might one ever articulate such context? Here rather than taking a theoretical perspective we adopt an spatio-visual approach made possible by recent advances in the electronic presentation of multilingual texts:– we allow the translator supply the colour higlights [...] . But how? Semantic units don't respect lexical boundaries and they occur at different scales. Any translator, committed to provide a definitive version of a text, eventually arrives at irreversible order of words – and may actually wish to justify their choices by documenting the correspondence between their version and the original. We focus on verse – an extreme challenge for SMT – with the eventual aim of expressing elusive aspects of semantic communication in order to differentiate those that can be articulated via spatio-visual cues. In verse a deviation from a literal correspondence is essential to reestablish in the translation a "decorum" appropriate to the original so that readers are encouraged to achieve an equivalent respect for its author also from the translated works. We use jQuery to provide an interface that lets the human translator mark up what they consider a correct alignment between words, or groups of words, in the original and their own translation – {{with a view to}} articulating context that may not be readily available to SMT. We detail below how the interface runs off a web-page and allows the alignment of equivalent ranges in parallel texts via a simple point-and-click action. Alignments created by the user are instantaneously made visible using a variant of the interactive color-highlight system mentioned above. Key to reducing the complexity of the implementation of the interface is our systematic deployment of open-standard, non-proprietary, web technologies. 2011 - 09 - 15 AlgheroCHItaly 2011, 13 - 16 settembre 2011, Algher...|$|R
40|$|Graduation date: 1985 Conversion of {{software}} written for one machine or operating system to equivalent software for another machine or operating system {{is shown to}} be economically attractive using source-to-source translation. The features of an automatic converter are described using a Pascal-to-C translater as an example. Solutions {{to the problems of}} denesting procedures, converting data structures and types, converting control structures and operators, and converting semantics in one language into equivalent semantics in another language are proposed and evaluated in terms of an algorithmic translator. The results obtained through experience suggest that <b>algorithmic</b> <b>translation</b> from one language to another can yield 95 to 99 per cent conversion without human intervention, leading to significant improvements over other methods {{of software}} conversion...|$|E
40|$|Design Patterns are {{informal}} {{descriptions of}} tested solutions to recurring problems. Most design tools {{have little or}} no support for documenting the presence and usage of patterns in code. Reverse engineering is therefore often required to recover Design Patterns from code in existing projects. Knowledge of what Design Patterns have been used can aid in code comprehension, as well as support research. Since pattern descriptions are abstract and informal, they offer no <b>algorithmic</b> <b>translation</b> into concrete code. Some patterns prescribe class structures that are easy to recognize, while others lead to structures that are difficult or impossible to recognize. This work presents a tool that can recover five different design patterns from C++ code with high precision and at a speed of 3 × 10 6 LOC/hr. This makes it suitable for analysis of large (multi-millon LOC) systems. ...|$|E
40|$|International audienceFormal {{methods in}} {{software}} and hardware design often generate formulas {{that need to be}} validated, either interactively or automatically. Among the automatic tools, SMT (Satisfiability Modulo Theories) solvers are particularly suitable to discharge such proof obligations, since their input language is equational logic with symbols from various useful decidable fragments such as uninterpreted symbols, linear arithmetic, and usual data-structures like arrays or lists. In this paper, we present an approach to combine decision procedures and propositional solvers into an SMT-solver. This approach is based not only on the exchange of deducible equalities between decision procedures, but also on the generation of model equalities by decision procedures. This extends nicely the classical Nelson-Oppen combination procedure in a simple platform to smoothly combine convex and non-convex theories. We show the soundness and completeness of this approach using an original abstract framework to represent and reason about SMT-solvers. We then describe an <b>algorithmic</b> <b>translation</b> of this method, implemented in the kernel of the veriT solver...|$|E
40|$|In {{this paper}} we apply the methods {{proposed}} in [5], [7] for detecting anomalies in existing executable INMOS C [1] code for a parallel program using static and dynamic analyses of Petri nets. Our target architecture {{on which the}} application program is running is a transputer network. The <b>algorithmic</b> <b>translation</b> of the INMOS C program into hierarchical place/transition nets which preserves both control and message flow is performed by a Petri net generator. Every implemented process is converted into an equivalent net. After this, the net parts generated are visualized and linked, and supplements are added, using a powerful graphical Petri net editor. Hierarchical methods are furnished, e. g. function calls are levelled down to subnets, and communication interface objects are highlighted. Every net object in the graphical representation is referenced with its counterpart in the source code so that error localization is possible. In the next processing step, the output capabilities of the [...] ...|$|E
40|$|Currently, many machine vision, {{signal and}} image {{processing}} problems are solved on personal computers {{due to the}} low cost involved in these computers and the many excellent software tools that exist, such as MATLAB. However, computationally expensive tasks {{require the use of}} multi-processor computers that are expensive and difficult to use efficiently due to communications between the processors. In these cases, FPGAs (Field Programmable Gate Arrays) are the best choice but they are not as widely used because of lack of experience in using these devices, difficulties with <b>algorithmic</b> <b>translation</b> and immaturity of the design and implementation tools for FPGAs. Programming languages are always evolving and the programming languages for microprocessors have evolved significantly, from functional and procedural languages to object-oriented languages. Nowadays, a new paradigm called aspect-oriented software development (AOSD) is becoming more widespread. However, hardware programming languages have not evolved to the same extent as the software programming languages for microprocessors. They are still dominated by the technologies developed in 1980 s, which have significant deficiencies described in this thesis. Recent advances in HDLs (Hardware Description Languages) have taken a conservative approach based on well-proven software techniques...|$|E

