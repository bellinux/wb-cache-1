14|502|Public
5000|$|<b>Attribute</b> <b>Nodes</b> {{immediately}} {{follow the}} Namespace Nodes of the element {{with which they}} are associated. If there are no Namespace Nodes associated with a given element, then the <b>Attribute</b> <b>Nodes</b> associated with that element immediately follow the element. The relative order of <b>Attribute</b> <b>Nodes</b> is stable but implementation-dependent.|$|E
5000|$|AttributeNode.{{specified}} [...] - [...] Does {{not create}} <b>Attribute</b> <b>Nodes</b> for default values {{specified in the}} DTD.|$|E
5000|$|As <b>attribute</b> <b>nodes</b> named [...] "xmlns" [...] or [...] "xmlns:xxx", {{exactly as}} the namespaces {{are written in}} the source XML document. This is the model {{presented}} by DOM.|$|E
5000|$|As {{connection}} tables / adjacency matrices / lists {{with additional}} information on bond (edges) and atom <b>attributes</b> (<b>nodes),</b> such as: ...|$|R
30|$|Typically, <b>attributes</b> of a <b>node</b> include {{processing}} capacity (i.e., CPU), storage, {{and location of}} the <b>node.</b> <b>Attributes</b> of a link include the bandwidth and delay. Similar to most of previous studies [2, 3, 7, 26, 30], in this paper, we consider the CPU <b>attribute</b> for <b>nodes</b> and the bandwidth attribute for links as our main focus.|$|R
30|$|A classification/regression tree {{is based}} on a {{supervised}} learning algorithm which provides visual representation for the classification or regression of a dataset (Russell and Norvig 2009). It provides an effective way to generalize and predict output variables for a given dataset. In such trees, nodes represent the input attributes, and edges represent their values. One way to construct such a decision tree, is by using a divide-and-conquer approach to reach the desired output by performing a sequence of tests on each <b>attribute</b> <b>node</b> and splitting the node on each of its possible value. The process is repeated recursively, each time selecting a different <b>attribute</b> <b>node</b> to split on until there are no more nodes left to split and a single output value is obtained.|$|R
5000|$|AttributeNode.{{specified}} [...] - [...] Prior to 1.9.1 {{does not}} set [...] to [...] if ownerElement is null. Does not create <b>Attribute</b> <b>Nodes</b> for default values {{specified in the}} DTD.|$|E
50|$|In the {{decision}} trees induced by gene expression programming, the attributes behave as function nodes {{in the basic}} gene expression algorithm, whereas the class labels behave as terminals. This means that <b>attribute</b> <b>nodes</b> have also associated with them a specific arity or number of branches that will determine their growth and, ultimately, {{the growth of the}} tree. Class labels behave like terminals, which means that for a k-class classification task, a terminal set with k terminals is used, representing the k different classes.|$|E
30|$|The {{decision}} tree is generated based on splitting <b>attribute</b> <b>nodes.</b> The commonly used splitting criteria includes Information Gain and Gini Index. They select the splitting attribute by making each splitting subset as “pure” as possible, {{so that a}} splitting subgroup is classified into the same category.|$|E
40|$|To {{integrate}} CA*-systems {{with other}} {{applications in the}} CIM world, one principal approach currently under development is the feature recognition process based on graph grammars. It enables any CIM component to recognize the higher-level entities - the so-called features - used in this component out of a lower-data exchange format, which might be the internal representation of a CAD system {{as well as some}} standard data exchange format. In this paper we present a 2 ̆ 7 made-to-measure 2 ̆ 7 parsing algorithm for feature recognition. The heuristic driven chart based bottom up parser analyzes <b>attributed</b> <b>node</b> labeled graphs (representing workpieces) with a (feature-) specific <b>attributed</b> <b>node</b> labeled graph grammar (representing the feature definitions) yielding a high level (qualitative) description of the workpiece in terms of features...|$|R
3000|$|Dyad-attributed {{networks}} As {{an alternative}} to <b>attributed</b> <b>nodes,</b> we also consider multigraphs, in which each dyad (pair of nodes) {{is associated with a}} set of features F̂ = (f̂_ 11, [...]..., f̂_nn). Each feature vector f̂_ij = (f̂_ij[1],..., f̂_ij[c])^T maps the pair of node (v [...]...|$|R
5000|$|A node {{object is}} {{represented}} by a single node in a tree. It can be an element <b>node,</b> <b>attribute</b> <b>node,</b> text node, or any type that is described in section [...] "node type". All objects can inherit properties and methods for dealing with parent and child nodes, {{but not all of}} the objects have parent or child nodes. For example, text nodes that cannot have child nodes, similar nodes to add child nodes results in a DOM error.|$|R
3000|$|The {{analysis}} of the conventional and scrambled diagonal 4 -dot experiments presented here is related to, but definitely different from, {{the one that we}} gave in [13]. In [13], we followed Wilson [7] by assuming that all excitatory couplings between <b>attribute</b> <b>nodes</b> in the learned patterns were the same. This is a reasonable hypothesis but it leads {{to the conclusion that the}} symmetry groups of both 4 -dot experiments are [...]...|$|E
30|$|Ji-DeSAG [28] is a de-anonymization {{algorithm}} combing graph {{structure and}} attribute information of {{users in the}} social network based on the structure-attribute graph (SAG) model. In the SAG model, the attributes are represented by nodes and links between <b>attribute</b> <b>nodes</b> and user nodes represent the belonging of attributes to corresponding users. It combines user-based structural de-anonymization and set-based structural de-anonymization techniques. Due to the dependency to the structure-based DA approach, its accuracy {{is influenced by the}} factors related to structure-based de-anonymization, e.g., similarity rate Sa and weighting parameter c.|$|E
40|$|Most {{current network}} {{resources}} recommendation systems {{are used in}} a decision-making environment with low user participation, which can not effectively meet user expectations. The main {{reason is that the}} collection of user preferences is extremely difficult, which leads to the lack of information acquisition, and the lack of effective semantic similarity metric. Accordingly, this paper uses ontology for resource description to build a multiple inheritance hierarchical ontology model, and uses user preference model to generate <b>attribute</b> <b>nodes,</b> and construct a multiple inheritance graph model on account of the user personalization. Simultaneously, it construct preference transfer vector by user preference model, and then uses single-step transfer and multi-step transfer of SSTA to effectively extend evaluation from evaluated resources to the unevaluated resources. Experiment proves that SSTA has excellent recommendation effect compared with mature recommendation systems. </p...|$|E
40|$|Many graphs used in {{real-world}} applications consists of nodes belonging {{to one or}} more categories, or associated with feature vectors (called “attributed node” in this paper). Graph clustering and layout are key techniques for effective visualization of such graphs. This paper briefly surveys these techniques and then introduces author’s own techniques on visualization graphs with <b>attributed</b> <b>nodes...</b>|$|R
50|$|Nearly all {{programming}} models {{allow the}} name of an element or <b>attribute</b> <b>node</b> to be retrieved as a three-part name: the local name, the namespace prefix, and the namespace URI. Applications should avoid attaching any significance to the choice of prefix, but the information is provided because it can be helpful to human readers. Names are considered equal if the namespace URI and local name match.|$|R
3000|$|Attributed graphs, e. g. {{networks}} enclosing (vectors of) generic <b>attributes</b> on <b>nodes</b> and edges (“Attributed graphs” section); [...]...|$|R
40|$|Abstract—The Object Summary (OS) is a {{recently}} proposed tree structure, which summarizes all data {{held in a}} relational database about a data subject. An OS can potentially be very large in size and therefore unfriendly for users who wish to view synoptic information about the data subject. In this paper, we investigate the effective and efficient retrieval of concise and informative OS snippets (denoted as size-l OSs). We propose and investigate the effectiveness of two types of size-l OSs, namely size-l OS(t) s and size-l OS(a) s that consist of l tuple nodes and l <b>attribute</b> <b>nodes</b> respectively. For computing size-l OSs, we propose an optimal dynamic programming algorithm, two greedy algorithms and preprocessing heuristics. By collecting feedback from real users (e. g. from DBLP authors), we assess the relative usability of the {{two different types of}} snippets, the choice of the size-l parameter, as well as the effectiveness of the snippets with respect to the user expectations. In addition, via thorough evaluation on real databases, we test the speed and effectiveness of our techniques...|$|E
30|$|Ji-DeSAG [28] {{is based}} on both user-based {{structural}} de-anonymization and set-based structural de-anonymization. In the SAG model, the attributes are represented by nodes and links between <b>attribute</b> <b>nodes</b> and user nodes represent the belonging of attributes to corresponding users. The Ji-DeSAG algorithm {{is based on}} the previous structure-based DA algorithms but the attribute similarity is added to the similarity score computed between nodes. Both user-based structural DA and set-based structural DA can be extended to the Ji-DeSAG algorithms. In this paper, we take the user-based structural DA promotion as an example to analyze. It takes two directed graphs G 1 =(V 1,E 1) and G 2 =(V 2,E 2) and seed mappings Ms as input. It outputs a mapping μ. In the propagation stage, for each iteration, it calculates a similarity score S for each unmapped (v,v′), v∈V 1 and v′∈V 2. S is determined by the attribute similarity Sa and the structure similarity Ss. Sa is equal to one minus the attribute difference between two nodes divided by the max attribute difference, and Ss {{is the same as the}} previous DA algorithm. The similarity rate S is calclulated as S=c∗Ss+(1 −c)∗Sa, where c is a weighing parameter that balances the weight between attribute similarity and structure similarity.|$|E
40|$|The various {{open-source}} {{data processing}} workflows that were {{integrated into the}} msCompare framework all use their own internal data formats to transfer information between modules. To allow communication between feature detection/quantification, and alignment/matching modules of the different tools, two generic XML formats for the FeatureList and the FeatureMatrix were developed to store feature lists along with matched quantitative feature matrices (Figure 1 a, b). The main aim of the developed formats is to store all {{information provided by the}} integrated programs, making conversion between the different formats possible and allowing easy integration of new modules from other programs. The FeatureList XML format (Figure S 7 in supplementary material) starts with a Data element, which has a data file attribute containing the link to the original mzXML file that was used to generate the feature list. The Data node has one FeatureList child node, which contains one or more Feature nodes. Each feature node represents a detected and quantified feature in the raw LC-MS data and has an AttributeList and a HullPointList child node. The HullPointList node may have zero or more HullPoint child nodes. The HullPoint element has one or more <b>Attribute</b> <b>nodes,</b> which have two attributes, value and name. The following names are used within msCompare to define the properties of a HullPoint: retentionTime to store the retention time in minutes, mass to store the mass to charge rati...|$|E
40|$|Abstract—Community {{detection}} algorithms {{are fundamental}} tools {{that allow us}} to uncover organizational principles in networks. When detecting communities, there are two possible sources of information one can use: the network structure, and the features and <b>attributes</b> of <b>nodes.</b> Even though communities form around nodes that have common edges and common attributes, typically, algorithms have only focused on one of these two data modalities: community detection algorithms traditionally focus only on the network structure, while clustering algorithms mostly consider only <b>node</b> <b>attributes.</b> In this paper, we develop Com-munities from Edge Structure and <b>Node</b> <b>Attributes</b> (CESNA), an accurate and scalable algorithm for detecting overlapping communities in networks with <b>node</b> <b>attributes.</b> CESNA statis-tically models the interaction between the network structure and the <b>node</b> <b>attributes,</b> which leads to more accurate community detection as well as improved robustness in the presence of noise in the network structure. CESNA has a linear runtime in the network size and is able to process networks an order of magnitude larger than comparable approaches. Last, CESNA also helps with the interpretation of detected communities by finding relevant <b>node</b> <b>attributes</b> for each community. I...|$|R
40|$|Abstract. Community {{detection}} in networks {{is a broad}} {{problem with}} many proposed solutions. Existing methods frequently make use of edge density and node attributes; however, the methods ultimately have dif-ferent denitions of community and build strong assumptions about com-munity features into their models. We propose a new method for commu-nity detection, which estimates both per-community feature distributions (topics) and per-node community membership. Communities are mod-eled as connected subgraphs with <b>nodes</b> sharing similar <b>attributes.</b> <b>Nodes</b> may join multiple communities and share common attributes with each. Communities have an associated probability distribution over <b>attributes</b> and <b>node</b> <b>attributes</b> are modeled as draws from a mixture distribution. We make two basic assumptions about community structure: commu-nities are densely connected and have a small network diameter. These assumptions inform the estimation of community topics and member-ship assignments without being too prescriptive. We present competi-tive results against state-of-the-art methods for nding communities in networks constructed from NSF awards, the DBLP repository, and the Scratch online community. ...|$|R
50|$|In Neo4j, {{everything}} {{is stored in}} the form of either an edge, a <b>node,</b> or an <b>attribute.</b> Each <b>node</b> and edge can have any number of <b>attributes.</b> Both the <b>nodes</b> and edges can be labelled. Labels can be used to narrow searches. As of version 2.0, indexing was added to Cypher with the introduction of schemas. Previously, indexes were supported separately from Cypher.|$|R
40|$|Abstract. We present Architectural Design Rewriting (ADR), a graphbased {{approach}} {{to deal with}} the design of reconfigurable software architectures. The key features we promote are: (i) hierarchical design; (ii) soft constraints for modeling QoS attributes; (iii) style-preserving reconfigurations; (iv) rule-based approach; and (v) algebraic presentation. Roughly, actual architectures are modeled by graphs with port and <b>attribute</b> <b>nodes</b> through which component edges are connected. Uniformly, QoS constraints on attributes are also modeled as edges. Architectures are designed hierarchically by a set of edge replacement rules that fix the architectural style. Depending on their reading, productions allow: (i) top-down design by refinement, (ii) bottom-up typing, and (iii) algebraic composition of typed architectures, with terms corresponding to style proofs. Moreover, productions exploit constraint primitives {{that can be used in}} the refinement phase, e. g., to reserve a certain amount of resources or to postpone architectural decisions. Similarly, reconfigurations are modeled as graph transformations triggered by constraints primitives to guarantee that certain levels of QoS are mantained. The main contribution is showing that we can take advantage by exploiting styles when specifying reconfigurations: (i) by giving hierarchical specifications that exploit the classes introduced by the style, (ii) by guaranteeing that all reconfigurations are style-preserving, (iii) by expressing reconfigurations as ordinary term rewrite rules on the algebra of style proofs. Overall, this results in a simple and formal mechanism for designing architectures according to a style, for checking that an architecture is an instance of a style and for ensuring style preservation during reconfigurations. ...|$|E
40|$|Abstract. We {{present a}} new method for {{explicit}} graph embedding. Our algorithm extracts a feature vector for an undirected attributed graph. The proposed feature vector encodes {{details about the}} number of nodes, number of edges, <b>node</b> degrees, the <b>attributes</b> of <b>nodes</b> and the <b>attributes</b> of edges in the graph. The first two features are for the number of nodes and the number of edges. These are followed by w features for node degrees, m features for k <b>node</b> <b>attributes</b> and n features for l edge attributes — which represent the distribution of <b>node</b> degrees, <b>node</b> <b>attribute</b> values and edge attribute values, and are obtained by defining (in an unsupervised fashion), fuzzy-intervals over the list of <b>node</b> degrees, <b>node</b> <b>attributes</b> and edge attributes. Experimental results are provided for sample data of ICPR 2010 1 contest GEPR 2. ...|$|R
40|$|The {{effects of}} social {{influence}} and network autocorrelation suggest that both network structure and <b>node</b> <b>attribute</b> information should inform {{the tasks of}} link prediction and <b>node</b> <b>attribute</b> inference. However, the algorithmic {{question of how to}} efficiently incorporate these two sources of information remains largely unanswered. We propose a Social-Attribute Network (SAN) model that gracefully integrates <b>node</b> <b>attributes</b> with network structure to predict network links and infer <b>node</b> <b>attributes.</b> We adapt leading supervised and unsupervised link prediction algorithms to the SAN model and demonstrate performance improvement for each algorithm. We then show that link prediction accuracy is further improved by first inferring missing attributes. We evaluate these algorithms on a novel Google+ network dataset and achieve state-of-the-art link prediction and attribute inference performance...|$|R
40|$|Abstract [...] Security {{is one of}} the {{important}} problem in wireless sensor networks. With limited energy resources and processing resources, this paper focus on <b>node</b> <b>attribute</b> behavior based anomaly detection system and deals only with attributes of layered sensor node. It introduces <b>node</b> <b>attribute</b> behavioral index. The detection uses genetic algorithm which evaluates the behavior of sensor <b>node</b> with <b>node</b> <b>attributes</b> and threshold technique have been used to detect abnormal behavior of sensor node based on behavioral index. The performance has been evaluated for MAC and network layer feature set of wireless nodes...|$|R
40|$|Community {{detection}} algorithms {{are fundamental}} tools to understand organizational principles in social networks. With the increasing power of social media platforms, when detecting communities {{there are two}} possi- ble sources of information one can use: the structure of social network and <b>node</b> <b>attributes.</b> However structure of social networks and <b>node</b> <b>attributes</b> are often interpreted separately in the research of community detection. When these two sources are interpreted simultaneously, one common as- sumption shared by previous studies is that <b>nodes</b> <b>attributes</b> are correlated with communities. In this paper, we present a model {{that is capable of}} combining topology information and <b>nodes</b> <b>attributes</b> information with- out assuming correlation. This new model can recover communities with higher accuracy even when <b>node</b> <b>attributes</b> and communities are uncorre- lated. We derive the detectability threshold for this model and use Belief Propagation (BP) to make inference. This algorithm is optimal {{in the sense that it}} can recover community all the way down to the threshold. This new model is also with the potential to handle edge content and dynamic settings...|$|R
25|$|Load {{and save}} {{arbitrary}} <b>attributes</b> on <b>nodes</b> and edges. For example, input {{a set of}} custom annotation terms for your proteins, create a set of confidence values for your protein–protein interactions.|$|R
40|$|This is {{the first}} release of hetio for hetnets in Python. Currently, the {{following}} features are supported: 	creating a hetnet consisting of a metagraph (types) and a graph (nodes and edges) 	metanode and metaedge abbreviations 	node and edge properties using the data <b>attribute</b> 	<b>node</b> and edge masking 	writing and reading hetnets 	summary statistics 	summary visualizations 	metapath extraction from the metagraph 	graph traversal to extract paths 	feature computation, specifically DWPCs The following features are not currently supported: 	node or edge deletion 	network permutation (edge swaps) Documentation is lacking, but see these examples of network creation and feature extraction...|$|R
30|$|Identification of {{the trust}} <b>attributes</b> for a <b>node’s</b> trust {{building}} process.|$|R
3000|$|... a {{shows an}} example {{unweighted}} <b>attributed</b> multigraph: <b>nodes</b> represent authors, and undirected edges represent co-authorship in scientific articles. The adjacency matrix of this graph—counting for multiplicity of edges—is shown in Fig. 1 [...]...|$|R
40|$|International audienceWe {{present a}} new method for {{explicit}} graph embedding. Our algorithm extracts a feature vector for an undirected attributed graph. The proposed feature vector encodes {{details about the}} number of nodes, number of edges, <b>node</b> degrees, the <b>attributes</b> of <b>nodes</b> and the <b>attributes</b> of edges in the graph. The first two features are for the number of nodes and the number of edges. These are followed by w features for <b>node</b> degrees, m features for k node <b>attributes</b> and n features for l edge attributes [...] which represent the distribution of <b>node</b> degrees, <b>node</b> <b>attribute</b> values and edge attribute values, and are obtained by defining (in an unsupervised fashion), fuzzy-intervals over the list of <b>node</b> degrees, <b>node</b> <b>attributes</b> and edge attributes. Experimental results are provided for sample data of ICPR 2010 contest GEPR...|$|R
40|$|Abstract. In {{the pattern}} {{recognition}} context, objects {{can be represented}} as graphs with <b>attributed</b> <b>nodes</b> and edges involving their relations. Consequently, matching attributed graphs {{plays an important role}} in objects recognition. In this paper, a node signatures extraction is combined with an optimal assignment method for matching attributed graphs. In particular, we show how local descriptions are used to define a node-to-node cost in an assignment problem using the Hungarian method. Moreover, we propose a distance formula to compute the distance between attributed graphs. The experiments demonstrate that the newly presented algorithm is well-suited to pattern recognition applications. Compared with well-known methods, our algorithm gives good results for retrieving images. ...|$|R
50|$|The {{language}} {{is based on}} the XQuery and XPath Data Model (XDM) which uses a tree-structured model of the information content of an XML document, containing seven kinds of nodes: document <b>nodes,</b> elements, <b>attributes,</b> text <b>nodes,</b> comments, processing instructions, and namespaces.|$|R
