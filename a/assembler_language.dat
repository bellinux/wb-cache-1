126|51|Public
25|$|Michael Singer, PDP-11. <b>Assembler</b> <b>Language</b> Programming and Machine Organization, John Wiley & Sons, NY: 1980.|$|E
2500|$|An {{assembly}} (or <b>assembler)</b> <b>language,</b> often abbreviated asm, is {{a low-level}} programming language for a computer, or other programmable device, {{in which there}} is a very strong (but often not one-to-one) correspondence between the language and the architecture's machine code instructions. [...] Each assembly language is specific to a particular computer architecture. In contrast, most high-level programming languages are generally portable across multiple architectures but require interpreting or compiling. Assembly language may also be called symbolic machine code.|$|E
50|$|The {{scores of}} these chiptunes {{were written in}} Motorola 68000 <b>Assembler</b> <b>language,</b> not {{with the help of}} a {{graphical}} music editor. The program routines used to play the Yamaha YM2149 (soundchip in the Atari 1040STF) were all coded and optimized in Motorola 68000 <b>Assembler</b> <b>language</b> by Benjamin Gerard, born 1973, his brother.|$|E
2500|$|More {{sophisticated}} high-level <b>assemblers</b> provide <b>language</b> abstractions such as: ...|$|R
50|$|The typical {{operating}} {{system for the}} Model 25 was DOS/360, which was loaded from disk.Less common was TOS/360, which was loaded from tape, and, rarely, BOS/360, which was loaded from punched cards. Programming was mostly in the COBOL, RPG and <b>Assembler</b> <b>languages</b> for the commercial applications that were the predominant uses of this computer, but Fortran {{could also be used}} for the scientific and engineering applications.|$|R
40|$|Foundations of Microprogramming: Architecture, Software, and Applications {{discusses}} the foundations and trends in microprogramming, {{focusing on the}} architectural, software, and application aspects of microprogramming. The book reviews microprocessors, microprogramming concepts, and characteristics, {{as well as the}} architectural features in microprogrammed computers. The text explains support software and the different hierarchies or levels of <b>languages.</b> These include <b>assembler</b> <b>languages</b> which are mnemonic or symbolic representation of machine commands; the procedure oriented machine-dependent...|$|R
50|$|Software {{developed}} by Psion {{as part of}} the Organiser I project and application software after its launch was written in 6301 <b>assembler</b> <b>language,</b> in POPL, and in other custom-designed languages. <b>Assembler</b> <b>language</b> development at Psion itself was carried out using cross-development tools, including a cross assembler and linker, all of which ran on a DEC VAX.|$|E
50|$|The {{principal}} high-level programming languages were GEORGE, ALPHACODE, STEVE, TIP, GIP, and Algol. <b>Assembler</b> <b>language</b> translators included ZP43 and STAC.|$|E
50|$|The {{format of}} <b>assembler</b> <b>language</b> {{statements}} reflects {{the layout of}} an 80-column punched card, though successive versions have relaxed most of the restrictions.|$|E
50|$|As the 1400 series matured {{additional}} <b>assemblers,</b> programming <b>languages</b> {{and report}} generators became available, replacing SPS in most sites.|$|R
40|$|Most {{computer}} programmers use {{a high-level}} language (HLL) to code their solutions to stated problems. Such languages (FORTRAN, COBOL, Algol, Pascal, C) enable the programmer to code {{in a more}} efficient, cost-effective manner than in lower-level (<b>assembler)</b> <b>languages.</b> Further, such programs are 2 ̆ 2 cleaner 2 ̆ 2, less likely to contain 2 ̆ 2 bugs 2 ̆ 2, and provide a degree of readability difficult to achieve in assembly languages...|$|R
50|$|Programming {{was mostly}} in the COBOL, RPG and <b>Assembler</b> <b>languages</b> for the {{commercial}} applications that were the predominant uses of this computer, but Fortran {{could also be used}} for the scientific and engineering applications, and a PL/I subset compiler PL/I(D) was available. COBOL programs for other computers could be run after recompiling on the System/360, except the input/output sections had to be re-written to relate to the System/360 devices through the DOS/360 DTF (Define the File) macros.|$|R
50|$|In older {{operating}} {{systems such as}} those used on IBM mainframes, full operating system functionality was only available to <b>assembler</b> <b>language</b> programs, not to high level language programs (unless assembly language subroutines were used, of course), as the standard macro instructions did not always have counterparts in routines available to high-level languages. In modern {{operating systems}} such as Unix and its derivatives, operating system access is provided through subroutines, usually provided by dynamic libraries. High-level languages such as C offer comprehensive access to operating system functions, obviating the need for <b>assembler</b> <b>language</b> programs for such functionality.|$|E
50|$|The {{efficiency}} of compiled high-level COBOL and PL/I language programs left {{much to be}} desired. Many CICS application programs continued to be written in <b>assembler</b> <b>language,</b> even after COBOL and PL/I support became available.|$|E
50|$|For maximum {{efficiency}} all calculations were programmed {{using the}} <b>assembler</b> <b>language</b> supplied with the hardware. A high-level language resembling Fortran was provided for coordinating tasks and controlling data transfers {{to and from}} the host computer.|$|E
40|$|Abstract. Model-driven {{architecture}} {{envisions a}} paradigm shift as dramatic as the one from low-level <b>assembler</b> <b>languages</b> to high-level programming languages. In order for this vision to become reality, algorithms are needed that compile models of software systems into deployable and executable implementations. This paper discusses two algorithms that provide such transformations for process graph models in a business process or workflow environment and produce executable programs based on Web services and orchestration languages. The reverse transformations back from executable programs to process graphs are also described...|$|R
40|$|This paper {{focuses on}} the {{usability}} of the PINPAS tool. The PINPAS tool is an instruction-level interpreter for smartcard <b>assembler</b> <b>languages,</b> augmented with facilities to study side-channel vulnerabilities. The tool can simulate side-channel leakage and has a suite of utilities to analyze this. The usage of the tool, {{for the analysis of}} a cryptographic algorithm is illustrated using the standard AES and RSA. Vulnerabilities of the implementations are identied and protective measures added. It is argued, that the tool can be instrumental for the design and realization of secure smartcard implementations in a systematic way...|$|R
50|$|There {{was also}} an <b>assembler</b> type <b>language</b> known as Cesil (Computer Education in Schools Instructional Language) used in the late-1970s {{developed}} by ICL. It was quite similar to the later language MASM.|$|R
50|$|The team first {{built an}} OOPS {{environment}} {{using a combination}} of procedural Rexx and <b>assembler</b> <b>language.</b> Valour may {{have been one of the}} first commercial products that looked to object-oriented programming to underpin its development platform.|$|E
50|$|Schönhage {{designed}} and implemented together with Andreas F. W. Grotefeld and Ekkehart Vetter a multitape Turing machine, called TP, in software. The machine is programmed in TPAL, an <b>assembler</b> <b>language.</b> They implemented numerous numerical algorithms including the Schönhage-Strassen algorithm on this machine.|$|E
50|$|IBM offered <b>assembler</b> <b>language</b> macros {{to provide}} {{programming}} support. During the System/360 era, these access methods were BTAM (Basic Telecommunications Access Method) and QTAM (Queued Telecommunications Access Method) - which was later replaced by Telecommunications Access Method (TCAM). IBM introduced VTAM (Virtual Telecommunications Access Method) with the System/370.|$|E
40|$|Abstract. This paper {{focuses on}} the {{usability}} of the PINPAS tool. The PINPAS tool is an instruction-level interpreter for smartcard <b>assembler</b> <b>languages,</b> augmented with facilities to study side-channel vulnerabili-ties. The tool can simulate side-channel leakage and has a suite of utilities to analyze this. The usage of the tool, {{for the analysis of}} a cryptographic algorithm is illustrated using the standard AES and RSA. Vulnerabilities of the implementations are identied and protective measures added. It is argued, that the tool can be instrumental for the design and realization of secure smartcard implementations in a systematic way...|$|R
50|$|With the {{so-called}} ’’Basic Assembler Tool for MikroSim’’ MikroBAT, simple {{programs can be}} developed in <b>assembler</b> programming <b>language.</b> Here, all supported mnemonics of the <b>assembler</b> programming <b>language</b> {{are determined by the}} user’s self-created machine’s instruction set on micro instruction level. The add-on tool is able to translate the assembly language program into machine code and data and transferring the binary code into the external RAM for subsequent simulations. Together with MikroBAT the microcode simulator MikroSim supports the didactical introduction of teaching aspects in technical computer science from a switch-controlled calculating machine to an assembler programmable application.|$|R
5000|$|The MALPAS toolset {{comprises}} five {{specific analysis}} tools that address various properties of a program. The input to the analysers {{needs to be}} written in MALPAS Intermediate Language (IL); this can be hand-written or produced by an automated translation tool from the original source code. Automatic translators exist for common high-level programming languages such as Ada, C and Pascal, as well as <b>assembler</b> <b>languages</b> such as Intel 80*86, PowerPC and 68000. The IL text is input into MALPAS via the [...] "IL Reader", which constructs a directed graph and associated semantics for the program under analysis. The graph is reduced using a series of graph reduction techniques.|$|R
50|$|PRTV {{was written}} {{in a mixture of}} languages. The higher layers were written in MP/3 and PL/I, whereas the lower layers were written in PL/I and System/370 <b>assembler</b> <b>language.</b> MP/3 was a macro {{processing}} language developed at Peterlee from 1973 onwards, similar to ML/I or TRAC. PRTV ran on System/370 IBM mainframes.|$|E
50|$|For {{performance}} reasons, in 1992 and 1993 SK8 was re-implemented {{from the}} ground up. Working at Apple's Cambridge Research Center, the Macintosh Common Lisp object store was isolated and directly hooked into SK8's store. The SK8Script debugger was re-implemented at the <b>assembler</b> <b>language</b> level (previously in Lisp) and the compiler and runtime performance improved.|$|E
50|$|When a {{piece of}} {{computer}} hardware can interpret a programming language directly, that language is called machine code. A so-called native code compiler is one that compiles a program into machine code. Actual compilation is often separated into multiple passes, like code generation (often for <b>assembler</b> <b>language),</b> translator (generating native code), linking, loading and execution.|$|E
5000|$|System {{software}} {{including a}} {{disk operating system}} and FORTRAN, BASIC and <b>assembler</b> for assembly <b>language.</b>|$|R
40|$|CLiP (Code from Literate Program) {{is a tool}} {{which allows}} writing literate {{programs}} in virtually any programming language (Pascal, Fortran, C, C++, <b>Assembler</b> <b>languages,</b> etc) and in combination with almost any formatter (Runoff, Troff, TeX, LaTeX, etc.) or word-processor (Winword, Lotus Manuscript, Ami Pro, Word Perfect, Wordstar, etc). This posting explains the CLiP philosophy and compares it to the WEB approach. CLiP turns out much more general. In spite of this generality its disadvantages {{as compared to the}} WEB-family are few indeed. Currently we have two versions of CLiP, for VAX/VMS and for MS-DOS platform. Although only limited user documentation is available, this is not felt as a big problem since CLiP works fairly intuitivel...|$|R
40|$|This work {{contains}} {{collection of}} problems with the microcontrollers PIC. The work first shortly acquaint with used hardware, whereby is microprocessor PIC 16 F 84 A. This microcontroller is very good for education of programming for students on secondary school. This work have to help with study in programming microcontrollers on the secondary school. Next chapters contains manuals for programming in low-level <b>language</b> <b>assembler</b> and for <b>language</b> higher level - C language plus manuals for development systems MPLab and MikroC. The output of this work is many problems solution, that are ranged from simpler to complicated. Whole collection of problems is in apendix. Exercise are writing how in <b>assembler,</b> so in <b>language</b> C...|$|R
5000|$|As {{explained}} {{further in}} [...] "Usage" [...] below, the name [...] "BR14" [...] {{comes from the}} IBM assembler-language instruction [...] "Branch (to the address in) Register 14", which by convention is used to [...] "return from a subroutine". Most early users of OS/360 were familiar with IBM <b>Assembler</b> <b>Language</b> and would have recognized this at once.|$|E
50|$|William Daly Jr. {{wrote and}} {{described}} a Qubic-playing program {{as part of}} his Master's program at the Massachusetts Institute of Technology. The program was written in <b>assembler</b> <b>language</b> for the TX-0 computer. It included lookahead to 12 moves and kept a history of previous games with each opponent, modifying its strategy according to their past behavior.|$|E
50|$|GEC 4000 series {{computers}} {{were capable of}} running a number of operating systems but in practice Prestel machines exclusively ran OS4000 which itself was developed by GEC. This in turn supported BABBAGE, the so-called high level <b>assembler</b> <b>language</b> {{in which all the}} Prestel software for both IRC and UDC machines (and later the messaging machine) was written.|$|E
50|$|High-level {{assemblers}} in computing are <b>assemblers</b> for assembly <b>language</b> {{that incorporate}} features found in high-level programming languages.|$|R
5000|$|IL (instruction list) is an <b>assembler</b> like {{programming}} <b>language</b> (Is now deprecated but {{available for}} backward compatibilty [...] ) ...|$|R
5000|$|Many early {{programming}} languages, including Fortran, Cobol and {{the various}} IBM <b>assembler</b> <b>languages,</b> used only the first 72 columns of a card — a tradition that traces back to the IBM 711 card reader used on the IBM 704/709/7090/7094 series (especially the IBM 704, the first mass-produced computer with floating point arithmetic hardware), which could only read 72 of the 80 columns in one pass. Columns 73-80 were ignored by the compilers and {{could be used for}} identification or a sequence number so that if the card deck was dropped it could be restored to its proper order using a card sorter. (An alternative, imperfect but commonly employed technique to maintain proper card order was to draw one or more diagonal stripes across the top edge of all the cards in a deck.) ...|$|R
