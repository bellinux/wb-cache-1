2|148|Public
40|$|Digital Flight Control System (DFCS) {{software}} {{was used as}} a test case for <b>assertion</b> <b>testing.</b> The assertions were written and embedded in the code, then errors were inserted (seeded) one at a time and the code executed. Results indicate that <b>assertion</b> <b>testing</b> is an effective and efficient method of detecting errors in flight software. Most errors are eliminate at an earlier stage in the development than before...|$|E
40|$|Assertions {{can be used}} to {{automate}} the process of testing software. Two methods for automating the generation of input test data are described in this paper. One method selects the input values of variables at regular intervals in a 'grid'. The other, adaptive testing, uses assertion violations as a measure of errors detected and generates new test cases based on test results. The important features of <b>assertion</b> <b>testing</b> are that: it can be used throughout the entire testing cycle; it provides automatic notification of error conditions; and it can be used with automatic input generation techniques which eliminate the subjectivity in choosing test data...|$|E
5000|$|Conformance testing {{methodology}} standards: specify methods and procedures, <b>assertion</b> language definitions, <b>test</b> <b>assertions,</b> <b>testing</b> and reporting requirements, {{and other aspects}} of conformance testing methodologies.|$|R
40|$|An {{experiment}} in using <b>assertions</b> to dynamically <b>test</b> fault tolerant flight software is described. The experiment showed that 87 % of typical errors {{introduced into the}} program would be detected by assertions. Detailed analysis of the test data showed {{that the number of}} assertions needed to detect those errors could be reduced to a minimal set. The analysis also revealed that the most effective <b>assertions</b> <b>tested</b> program parameters that provided greater indirect (collateral) testing of other parameters...|$|R
50|$|In {{computer}} software <b>testing,</b> a <b>test</b> <b>assertion</b> {{is an expression}} which encapsulates some testable logic specified about a target under test.The expression is formally presented as an assertion, along with some form of identifier, to help testers and engineers ensure that tests of the target relate properly and clearly to the corresponding specified statements about the target. Usually the logic for each <b>test</b> <b>assertion</b> is limited to one single aspect specified.Assertion testing = Type of testing consisting in verifying if the conditions confirm the product requirements.A <b>test</b> <b>assertion</b> may include prerequisites which must be true for the <b>test</b> <b>assertion</b> to be valid.|$|R
40|$|<b>Assertions</b> <b>test</b> {{expected}} {{properties of}} run-time values without disrupting the normal working of a program. So in a lazy functional language assertions should be lazy - not forcing evaluation, but only examining what is evaluated by {{other parts of}} the program. We explore the subtle semantics of lazy assertions and describe sequential and concurrent variants of a method for checking lazy assertions. All variants are implemented in Haskell...|$|R
40|$|Assertions {{are used}} to {{dynamically}} test fault tolerant flight software. The experiment showed that 87 % of typical errors introduced into the program would be detected by assertions. Detailed analysis of the test data showed {{that the number of}} assertions needed to detect those errors could be reduced to a minimal set. The analysis also revealed that the most effective <b>assertions</b> <b>tested</b> program parameters that provided greater indirect (collateral) testing of other parameters...|$|R
40|$|<b>Assertions</b> <b>test</b> {{expected}} {{properties of}} run-time values without disrupting the normal computation of a program. We present a library for enriching Haskell programs with assertions. Expected properties {{can be specified}} in a parser-combinator like language. The assertions are lazy: they do not force evaluation but only examine what is evaluated by the program. They are also prompt: assertion failure is reported as early as possible. The implementation is based on lazy observations and continuation-based coroutines...|$|R
40|$|Abstract. <b>Assertions</b> <b>test</b> {{expected}} {{properties of}} run-time values without dissrupting the normal working of a program. So in a lazy functional language assertions should be lazy — not forcing evaluation, but only examining what is evaluated by {{other parts of}} the program. We describe two different ways of embedding lazy assertions in Haskell, one sequential and the other concurrent. Examples illustrate the relative merits of the two approaches. We also show that timely failure of lazy assertions may require assertions in assertions!...|$|R
40|$|<b>Assertions</b> <b>test</b> {{expected}} {{properties of}} run-time values without disrupting the normal computation of a program. Here {{we present a}} library for enriching programs in the lazy language Haskell with assertions. Expected properties are written in an expressive pattern logic that combines pattern matching with logical operations and predicates. The presented assertions are lazy: they do not force evaluation but only examine what is evaluated by {{other parts of the}} program. They are also prompt: assertion failure is reported as early as possible, before a faulty value is used by the main computation...|$|R
5000|$|Automatic {{inference}} and static/dynamic checking of such <b>assertions</b> (including unit <b>testing).</b>|$|R
40|$|This {{document}} provides {{guidelines and}} best practices for writing <b>test</b> <b>assertions</b> alongaligned with mandatory and optional {{components of a}} <b>test</b> <b>assertion</b> modelthe Test Assertions Model. Status: This document was last revised or approved by the OASIS Test Assertions Guidelines (TAG) TC on the above date. The level of approval is also listed above. Check the "“Latest Vversion"...|$|R
40|$|Abstract: This paper {{proposes a}} {{methodology}} {{to measure the}} semantic confor-mance rate of standardized biometric minutia interchange records. The paper pro-poses a fingerprint modality specific <b>assertion</b> <b>test.</b> A conformance test based on this methodology can attest for a given algorithm or software under test that the generated minutiae templates are a faithful representation of the input signal (i. e. fingerprint image). The test methodology is based on ground truth data that has been composed by dactyloscopic experts. As individual experts assessment yields slightly diverging coordinates a clustering algorithm is proposed that merges a set of manually placed minutia into one ground truth data set. The methodology is evaluated on ten-print fingerprint images and the NIST baseline minutia extraction algorithm. ...|$|R
40|$|Abstract: The use of both mineral {{fertilizer}} and organic manure {{has been found}} to be a sustainable technology for crop production and integration of mineral fertilizer with crop residue compost could further increase crop yield. This <b>assertion</b> was <b>tested</b> in Nigeria by nourishing Telfairia occidentalis with cassava peel compos...|$|R
5000|$|The new utility {{introduces}} {{a new way}} to <b>test</b> <b>assertions</b> at compile-time, using the new keyword [...]The declaration assumes this form: static_assert (constant-expression, error-message); ...|$|R
5000|$|The {{interface}} {{should be}} implemented in two ways, one of which really accesses the external process, and the other {{of which is a}} fake or mock. Fake objects need do little more than add a message such as “Person object saved” to a trace log, against which a <b>test</b> <b>assertion</b> can be run to verify correct behaviour. Mock objects differ in that they themselves contain <b>test</b> <b>assertions</b> that can make the test fail, for example, if the person's name and other data are not as expected.|$|R
5000|$|NUnit {{provides}} a {{rich set of}} assertions as static methods of the [...] class. If an assertion fails, the method call does not return and an error is reported. If a <b>test</b> contains multiple <b>assertions,</b> any that follow the one that failed will not be executed. For this reason, it's usually best to try for one <b>assertion</b> per <b>test.</b>|$|R
40|$|This {{document}} provides {{guidelines and}} best practices for writing <b>test</b> <b>assertions</b> along with mandatory and optional {{components of a}} <b>test</b> <b>assertion</b> model. Status: This document was last revised or approved by the Test Assertions Guidelines TC on the above date. The level of approval is also listed above. Check the "Latest Version " location noted above for possible later revisions of this document. Technical Committee members should send comments on this specification to the Technical Committee’s email list. Others should send comments to the Technical Committee by using the “Send A Comment ” button on the Technical Committee’s web page a...|$|R
40|$|An {{executable}} assertion is {{a logical}} statement about the variables or a block of code. If there is no error during execution, the assertion statement results in a true value. Executable assertions {{can be used for}} dynamic testing of software. They can be employed for validation during the design phase, and exception and error detection during the operation phase. The present investigation is concerned with the problem of writing executable assertions, taking into account the use of <b>assertions</b> for <b>testing</b> flight software. They can be employed for validation during the design phase, and for exception handling and error detection during the operation phase The digital flight control system and the flight control software are discussed. The considered system provides autopilot and flight director modes of operation for automatic and manual control of the aircraft during all phases of flight. Attention is given to techniques for writing and using <b>assertions</b> to <b>test</b> flight software, an experimental setup to test flight software, and language features to support efficient use of assertions...|$|R
40|$|This paper {{discusses}} {{an approach}} to avoid incorrect results in the execution of automatic tests of multi-threaded systems. We argue that such incorrect results have two main sources. First, it is typically difficult to determine when all threads have finished processing and thus when {{it is safe to}} perform the <b>test</b> <b>assertions.</b> Second, background threads can change the system state while assertions are being performed, thus producing non-deterministic results. The main contributions of this work are: (i) a generic approach that ensures that <b>test</b> <b>assertions</b> are performed in a safe moment; (ii) implementation details of such an approach using Aspect-Oriented Programming (AOP); and (iii) an evaluation of the proposed approach. 1...|$|R
5000|$|Albert was {{the first}} of Robby Garner's {{multifaceted}} bots. The Albert One system was composed of several subsystems. Among those were a version of Eliza, the therapist, Elivs, another Eliza-like bot, and several other helper applications working together in a hierarchical arrangement. As a continuation of the stimulus-response library, various other database queries and <b>assertions</b> were <b>tested</b> to arrive at each of Albert's responses. Robby went on to develop networked examples of this kind of hierarchical [...] "glue" [...] at The Turing Hub.|$|R
25|$|These <b>assertions</b> are <b>tested</b> {{on a large}} set of {{randomized}} input images, {{to handle}} the worst cases. The former IEEE 1180–1990 standard contained some similar precision requirements. The precision has a consequence on the implementation of decoders, and it is critical because some encoding processes (notably used for encoding sequences of images like MPEG) {{need to be able}} to construct, on the encoder side, a reference decoded image. In order to support 8-bit precision per pixel component output, dequantization and inverse DCT transforms are typically implemented with at least 14-bit precision in optimized decoders.|$|R
30|$|Following Erickson’s (1986) {{guidelines}} for reporting fieldwork research, analysis ended by testing inductively generated empirical assertions. Proposed <b>assertions</b> were <b>tested</b> against the data corpus, while searching for confirming and disconfirming evidence. General assertions were constructed using the computer-generated, three-way contingency table (Fienberg, 1977). High frequency counts from the contingency table aided in identifying and examining potential assertions. For example, {{in order to}} reveal what TDTs did when they encountered a challenge without a simple or known solution, a particular cell of the contingency table could be identified and investigated to reveal how teachers responded to these scenarios (e.g., no known solution path and design problem structuring). Upon reading and re-reading these incidents and while exploring related pieces of data (e.g., curriculum design artifacts), initial <b>assertions</b> were <b>tested</b> against the data corpus. Assertions best supported by the evidence were considered representative of the data set as a whole. This synoptic reporting provided the study with a form of general description (Erickson, 1986). For ease of reading, specific description (i.e., representative transcriptions and interpretive commentary) will follow a single team. Again, {{the aim of this}} reporting is not one of proof; but rather as Erickson (1986) states to, “persuade the audience that an adequate evidentiary warrant exists for the assertions made, (and) that patterns of generalization within the data set are indeed as the researcher claims they are,” (p. 149).|$|R
40|$|Executable assertions {{are used}} to test flight control software. The {{techniques}} used for testing flight software; however, {{are different from the}} techniques used to test other kinds of software. This is because of the redundant nature of flight software. An experimental setup for testing flight software using executable assertions is described. Techniques for writing and using executable <b>assertions</b> to <b>test</b> flight software are presented. The error detection capability of assertions is studied and many examples of assertions are given. The issues of placement and complexity of assertions and the language features to support efficient use of assertions are discussed...|$|R
40|$|Abstract: The {{buckling}} of hexagonal layers in {{bulk and}} nanostructures of AlN is analyzed {{in the framework}} of atomistic and first principles techniques. At ambient conditions, the wurtzite structure (B 4) of AlN consists of buckled hexagons. On the other hand, a non-buckled Bk structure is found to be metastable at zero pressure, being favored at higher pressures. It is suggested that the energy ordering of B 4 and Bk may change in finite systems; an <b>assertion</b> <b>tested</b> in this study by considering finite slabs, nanobelts, and nanorings, and comparing the results with the previous studies on small clusters, and periodic nanostructures. We find that the buckling in fi-nite systems is much smaller than that in the bulk ma-terial, with N atoms sticking out in the first layer, fol-lowed by an even smaller opposite buckling of the next layer, and negligible buckling of the inner layers. All the structures considered present some degree of symmetry, usually a σz symmetry plane, so that buckling is oppo-site {{on both sides of the}} finite system and thus the dipole moment is quenched. Periodic nanostructures display no buckling, a fact that is related with their ability to model the inner part of the system, neglecting geometric surface effects. It is suggested that the zero-dipole and negligi-ble buckling present in the small size regime will lead to buckled hexagons in larger finite systems, similar to the bulk behavior, thus introducing a change in the size dependence of their structural and electronic properties...|$|R
40|$|The {{acceptability}} {{of evidence in}} court is dependent upon stringent criteria for its admissibility. One of the leading guidelines is the Daubert criteria which asserts five requirements for admissibility. These criteria assert scientific principles that must be complied. The focus on the scientific testing of Digital Forensics tools is often glossed over by accepting commonly used proprietary tools without delving into their performance. In particular, Daubert states that the known error rates of a scientific procedure must be published, and that the scientific procedures must be independently tested. In this thesis, I am concerned about the satisfaction of Daubert’s key points when collecting digital forensic information that is evidentially sound: •	The scientific procedure must be independently tested. •	The scientific procedure should be published and subjected to peer review. •	Are there standards and protocols for {{the execution of the}} methodology of the scientific procedure? •	Is the scientific procedure generally accepted by the relevant scientific communities •	Is there a known error rate or potential to know the error rate {{associated with the use of}} the scientific procedure (Daubert v. Merrell Dow Pharmaceuticals, 1993) Without known error rates and falsifiability criterion, digital evidence should not be in courtrooms. In this thesis the relevant literature and conceptual scope of the problem is explored theoretically, and then network tools tested empirically. The thesis is an initial investigation into whether there are error rates above zero when a network tool is used for evidence collection. The contribution is to both the digital forensic investigation community as well as to the law practitioners and judicial profession by demonstrating a potential problem with network forensic data. The performance of two tools was tested by subjecting them to increasing packet loads and measuring their performance. The results were then measured against the baseline of expected outputs and the differences noted. These differences were then used to generate an error rate in the form of a percentage. As part of the methodology the assertion was that, the tools would perform without error. Therefore, the research question is: Research Question: Can the Network Management System and the Network Packet Capture tool, achieve zero errors for digital forensic purposes? Thus, the research goal of this thesis is to determine whether a computer system can capture relevant information systematically and comprehensively for post incident forensic presentation that complies with legal requirements of completeness. The findings demonstrated that the popular network tools selected had significant error rates that are not published. The error margins indicate that a large number of packets that are potentially evidential are lost as the work rate increases. This will in turn affect the validity of data presented as evidential. I recommend that the concepts developed within this thesis be expanded and codified through future research. That a professionally accepted <b>assertion</b> <b>test</b> bench be developed and test case methodology procedures formulated. Thus, transference can be assured, where tools tested under many scenarios through many <b>assertion</b> <b>tests</b> can provide an acceptable level of assurance. Therefore, the desired outcome is that error rates can be determined by the forensic examiner as a standard part of digital network forensic readiness and provided along with evidential data...|$|R
40|$|Abstract—Assertion-Based {{software}} testing {{has been shown}} to be a promising tool for generating test cases that reveal program faults. Because the number of assertions may be very large for industry-size programs, one of the main concerns to the applicability of assertion-based testing is the amount of search time required to explore a large number of assertions. This paper presents a new approach for assertions exploration during the process of Assertion-Based {{software testing}}. Our initial exterminations with the proposed approach show that the performance of Assertion-Based testing may be improved, therefore, making this approach more efficient when applied on programs with large number of <b>assertions.</b> Keywords—Software <b>testing,</b> assertion-based <b>testing,</b> program <b>assertions.</b> I...|$|R
40|$|We {{describe}} {{our present}} on-going research {{work on a}} software tool called the Dynamic Instrumentation Engine (DIE). The main goal for designing and developing the DIE is to aid in dynamic program analysis and instrumentation without modifying the source code and thus ease the process of information gathering activities associated with instrumentation and testing of software applications. This form of instrumentation is on-the-fly and noninvasive since it has no computational side-effects. The DIE should prove to be an excellent software tool to gather valuable information about a program under analysis, for areas such as dynamic program analysis and data collection, temporal <b>assertion</b> monitoring, <b>test</b> coverage measurement, etc...|$|R
40|$|This article {{explains}} how foreign assistance {{to one or}} both sides {{in a civil war}} influences the dynamics of the conflict. It submits that external assistance has the potential of affecting the military capabilities available to the belligerents. It then argues that the balance of those capabilities impacts significantly on whether the warfare in a civil war assumes a conventional, guerrilla or irregular form. These theoretical <b>assertions</b> are <b>tested</b> against the case of the Angolan Civil War. It is shown that during that war, variations in the form of warfare correlated closely to the type, degree, and direction of foreign intervention given to each of the belligerents. 28 page(s...|$|R
5000|$|In the Microsoft {{document}} [...] "Output Content Protection and Windows Vista", it {{is claimed}} that: [...] "The security level achieved for typical video data {{is estimated to}} be approaching that of regular AES. This <b>assertion</b> is being <b>tested</b> by Intel putting its Cascaded Cipher out to the cryptography community to get their security assessment — that is, {{to see if they can}} break it." ...|$|R
40|$|It {{is pointed}} out that {{executable}} assertions {{can be used for}} dynamic testing of software. An executable assertion is a logical statement about the variables or a block of code. If there is no error during execution then the assertion statement results in a true value. Assertions are useful for testing purposes throughout the lifecycle of software. They can be used for validation during the design phase, and for exception handling and error detection during the operation phase. The present investigation has the objective to study the use of executable <b>assertions</b> for <b>testing</b> flight software. Attention is given to details regarding executable assertions, the digital flight control system, testing flight software, and preliminary experimental results...|$|R
5000|$|EiffelStudio {{includes}} an integrated testing facility called EiffelStudio AutoTest http://docs.eiffel.com/book/eiffelstudio/autotest, whereby developers may build simple to sophisticated unit and integration testing suites. The EiffelStudio AutoTest facilities enable the developer to execute and test Eiffel class code from the feature level (e.g. unit testing) to entire class systems (e.g. integration). As such, execution of this code also executes the contracts {{of the features}} and attributes executed. As such, EiffelStudio AutoTest is a means to exercising the [...] "tests" [...] or assumptions of the Design by Contract conditions. Therefore, unit and integration testing need not re-test through means of <b>assertions</b> or <b>test</b> oracles what has already been coded as specification in the contracts of the class text.|$|R
40|$|These {{theoretical}} <b>assertions</b> are <b>tested</b> {{through the}} case study of Philadelphia, Pennsylvania. This constitutional city has been a citadel of violence towards Blacks throughout its history. The limited efforts to thwart such has lent tacit approval to police violence. Philadelphia {{was the target of}} two unprecedented federal suits involving police brutality and the forerunner of innovative techniques to address that concern. However, negligible results of such litigation and the absence of clear guidelines governing police actions led to the unscrupulous manner in which MOVE was forced from their homes in 1978 and again in 1985. It was concluded that the reluctance of the courts to prosecute violators, coupled with the expansion of police discretion, is that lawful repression has taken precedence over human justice...|$|R
40|$|In {{this paper}} we {{consider}} the relationship between financial development and economic activity from 1960 to 2006 in 71 economies. A number of contributions in the literature suggest that deeper financial markets promote economic growth. We put this <b>assertion</b> to the <b>test</b> conducting regression analysis at both the levels and growth rates of the relevant variables. We do not find substantial evidence of a causal effect of the rate of financial development on economic growth...|$|R
40|$|Social {{interaction}} {{is an essential}} part of human communication, however the participants are often miles apart. Technological advances strive to bridge the physical distances between people, but generally lack the social potential offered through activities such as sports and games. An Exertion Interface combines the strength of both: the ability of sports to connect people socially, and the ability of telecommunications to connect people over a distance. By requiring intense physical effort from the participants, an Exertion Interface creates a better social bonding experience than traditional computer interfaces. This <b>assertion</b> is <b>tested</b> through the creation of a system in which two remotely-located participants play a physically demanding ball game against each other while communicating through an overlaid life-size video-conference. A study with 56 participants showed that players who used the Exertion Interfac...|$|R
40|$|In the {{development}} of automated tests, there {{is an increase in}} complexity when the initialization or assertion are related to an external resource. This occurs when the behavior of a class causes a change in the environment where it is running, not only in the application state. Usually these issues are addressed and implemented in the test classes, which make it difficult for their reusage across projects and even into other test classes, generating code duplication and causing loss of productivity when coding tests. This paper presents a pattern that suggests a solution to simplify the initialization and <b>assertion</b> through <b>tests</b> metadata classes. This solution allows each method to has specific assertions and initializations, isolation the solutions out of the test classes, allowing the reusage by other test classes...|$|R
