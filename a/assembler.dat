2735|891|Public
5|$|Early PDP-1 users wrote {{programming}} software {{including an}} <b>assembler</b> {{translated from the}} TX-0 over one weekend in 1961. Kotok later wrote an interpreter for the Lisp programming language in TECO macros.|$|E
5|$|There {{was also}} {{significant}} condescension towards COBOL {{in the business}} community from users of other languages, for example FORTRAN or <b>assembler,</b> implying that COBOL could be used only for non-challenging problems.|$|E
5|$|As Thompson began porting {{the game}} to the new system, {{he decided not to}} base the code on any of the {{existing}} software for the computer, and instead write his own. As a result, he implemented his own base code libraries for programs to use, including arithmetic packages and graphics subsystems. These initial subsystems were coded in assembly language on the GECOS system and assembled, then the output physically put on punched tapes to be carried over and inserted into the PDP-7. Thompson then wrote an <b>assembler</b> for the PDP-7 to avoid this laborious process. The game ran very slowly on the new machine, causing Thompson to branch out from there to design his own file system based on some ideas by Dennis Ritchie and Rudd Canaday, rooted in their experience with the Multics file system, with which he then ran Space Travel.|$|E
50|$|High-level <b>assemblers</b> in {{computing}} are <b>assemblers</b> for {{assembly language}} that incorporate features found in high-level programming languages.|$|R
500|$|Drexler {{reiterated that}} these {{molecular}} <b>assemblers</b> would require no impossible fingers, and would augment solution-phase chemistry to produce macroscopic products with precise arrangements of chemical building blocks, using solution-phase molecular <b>assemblers</b> to bootstrap {{the construction of}} more sophisticated <b>assemblers.</b> He concluded by writing: ...|$|R
50|$|With the {{exception}} of the <b>assemblers</b> for the IBM System/360 Model 20 the IBM <b>assemblers</b> were largely upward-compatible. The differences were mainly in the complexity of expressions allowed and in macro processing. OS/360 <b>assemblers</b> were originally designated according to their memory requirements.|$|R
5|$|In December 1974 Bill Gates was {{a student}} at Harvard University and Paul Allen worked for Honeywell in Boston. They saw the Altair 8800 {{computer}} in the January 1975 issue of Popular Electronics and knew it was powerful enough to support a BASIC interpreter. They wanted {{to be the first to}} offer BASIC for the Altair computer, and the software development tools they had previously created for their Intel 8008 microprocessor based Traf-O-Data computer would give them a head start. While their friend, Paul Gilbert, was building the computer, Allen wrote a program that ran on a DEC PDP-10 time-sharing computer that simulated the 8008 system. He also modified DEC's macro <b>assembler</b> to produce the machine code for the 8008 microprocessor. The Traf-O-Data software could be written and debugged before the computer hardware was complete.|$|E
25|$|The Cosmos Project {{team have}} also created an <b>assembler</b> that is {{designed}} to eventually become the main <b>assembler</b> for the Cosmos system. However, the <b>assembler</b> is still inefficient and slow, and so the Netwide <b>Assembler</b> (NASM) is used instead.|$|E
25|$|Assembly {{language}} is converted into executable machine code by a utility program {{referred to as}} an <b>assembler.</b> The conversion process {{is referred to as}} assembly, or assembling the source code. Assembly time is the computational step where an <b>assembler</b> is run.|$|E
50|$|De novo {{sequence}} <b>assemblers</b> are a type {{of program}} that assembles short nucleotide sequences into longer ones {{without the use of}} a reference. These are most commonly used in bioinformatic studies to assemble genomes or transcriptomes. Two common types of de novo <b>assemblers</b> are greedy algorithm <b>assemblers</b> and De Bruijn graph <b>assemblers.</b> There are numerous programs for de novo sequence assembly and many have been compared in the Assemblathons, a recurring genome assembling event designed to test the many available de novo assembly program.|$|R
50|$|High-level <b>assemblers</b> {{also provide}} data abstractions {{normally}} found in high-level languages. Examples include structures, unions, classes, and sets. Some high-level <b>assemblers</b> (e.g., TASM and HLA) support object-oriented programming.|$|R
50|$|Autocoder was {{the name}} given to certain <b>assemblers</b> {{for a number of}} IBM {{computers}} of the 1950s and 1960s.The first Autocoders appear to have been the earliest <b>assemblers</b> to provide a macro facility.|$|R
25|$|Michael Singer, PDP-11. <b>Assembler</b> Language Programming and Machine Organization, John Wiley & Sons, NY: 1980.|$|E
25|$|The initial {{orders were}} {{hard-wired}} {{on a set}} of uniselector switches and loaded into the low words of memory at startup. By May 1949, the initial orders provided a primitive relocating <b>assembler</b> taking advantage of the mnemonic design described above, all in 31 words. This was the world's first <b>assembler,</b> and arguably the start of the global software industry. There is a simulation of EDSAC available and a full description of the initial orders and first programs.|$|E
25|$|In Honeywell 6000 series <b>assembler,</b> the $ sign, {{when used}} as an address, meant {{the address of the}} {{instruction}} in which it appeared.|$|E
5000|$|Some {{projects}} provide Java <b>assemblers</b> {{to enable}} writing Java bytecode by hand. Assembly code may be also generated by machine, for example by a compiler targeting a Java virtual machine. Notable Java <b>assemblers</b> include: ...|$|R
2500|$|Some <b>assemblers</b> {{also support}} simple {{built-in}} macro-instructions that generate {{two or more}} machine instructions. For instance, with some Z80 <b>assemblers</b> the instruction [...] is recognized to generate [...] followed by [...] These are sometimes known as pseudo-opcodes.|$|R
50|$|In {{the very}} early <b>assemblers,</b> {{subroutine}} support was limited. Subroutines were not explicitly separated from each other or from the main program, and indeed the source code of a subroutine could be interspersed with that of other subprograms. Some <b>assemblers</b> would offer predefined macros to generate the call and return sequences. By the 1960s, <b>assemblers</b> usually had much more sophisticated support for both inline and separately assembled subroutines that could be linked together.|$|R
25|$|The 6809 was <b>assembler</b> source-compatible {{with the}} 6800, though the 6800 had 78 {{instructions}} to the 6809's 59. Some instructions were replaced by more general ones which the <b>assembler</b> translated into equivalent operations and some were even replaced by addressing modes. The instruction set and register complement were highly orthogonal, making the 6809 easier to program than the 6800 or 6502. Like the 6800, the 6809 included an undocumented address bus test instruction which came to be nicknamed Halt and Catch Fire (HCF).|$|E
25|$|By 2004 / 2005, {{pyrosequencing}} {{had been}} brought to commercial viability by 454 Life Sciences. This new sequencing method generated reads much shorter than those of Sanger sequencing: initially about 100 bases, now 400-500 bases. Its much higher throughput and lower cost (compared to Sanger sequencing) pushed the adoption of this technology by genome centers, which in turn pushed development of sequence assemblers that could efficiently handle the read sets. The sheer amount of data coupled with technology-specific error patterns in the reads delayed development of assemblers; at the beginning in 2004 only the Newbler <b>assembler</b> from 454 was available. Released in mid-2007, the hybrid version of the MIRA <b>assembler</b> by Chevreux et al. was the first freely available <b>assembler</b> that could assemble 454 reads as well as mixtures of 454 reads and Sanger reads. Assembling sequences from different sequencing technologies was subsequently coined hybrid assembly.|$|E
25|$|In MASM 80x86 Assembly Language, & is the Substitution Operator, {{which tells}} the <b>assembler</b> {{to replace a}} macro {{parameter}} or text macro name with its actual value.|$|E
50|$|Oriental <b>Assemblers</b> Sdn. Bhd.|$|R
40|$|Turing <b>assemblers</b> are Turing {{machines}} which {{operate on}} n-dimensional tapes under restrictions which characterize a procedure of assembly rather than computation, {{and which are}} intended as an abstraction of certain algorithmic processes of molecular biology. It has been previously shown that Turing <b>assemblers</b> with n-dimensional tapes can simulate arbitrary Turing machines for all n> 1. Here it is shown that for n= 1 even nondeterministic Turing <b>assemblers</b> have a sharply restricted computational capability, being able to successfully assemble only regular sets. The halting problem for linear Turing <b>assemblers</b> is therefore algorithmically solvable, and a characterization of the set of achievable final assemblies will be given as a subclass of the context-free languages...|$|R
50|$|Manufacturing team - Manufacturers and <b>assemblers.</b>|$|R
25|$|The {{original}} {{reason for}} the use of one-pass assemblers was speed of assembly – often a second pass would require rewinding and rereading the program source on tape or rereading a deck of cards or punched paper tape. Later computers with much larger memories (especially disc storage), had the space to perform all necessary processing without such re-reading. The advantage of the multi-pass <b>assembler</b> is that the absence of errata makes the linking process (or the program load if the <b>assembler</b> directly produces executable code) faster.|$|E
25|$|The {{built-in}} ROM-resident BBC BASIC {{programming language}} interpreter realised the system's educational emphasis and was key to its success; {{not only was}} it the most comprehensive BASIC compared to other contemporary implementations but it ran very efficiently and was therefore fast. Advanced programs could be written without resorting to non-structured programming or machine code (necessary with many competing computers). Should one want or need to do some assembly programming, BBC BASIC featured a built-in <b>assembler</b> that allowed a very easy mixture of BBC BASIC and <b>assembler</b> for whatever processor BBC BASIC was operating on.|$|E
25|$|The 68000 <b>assembler</b> code {{below is}} for a {{subroutine}} named , which copies a source null-terminated ASCIZ character string to another destination string, converting all alphabetic characters to lower case.|$|E
25|$|Some <b>assemblers</b> {{may also}} be able to perform some simple types of {{instruction}} set-specific optimizations. One concrete example of this may be the ubiquitous x86 <b>assemblers</b> from various vendors. Most of them are able to perform jump-instruction replacements (long jumps replaced by short or relative jumps) in any number of passes, on request. Others may even do simple rearrangement or insertion of instructions, such as some <b>assemblers</b> for RISC architectures that can help optimize a sensible instruction scheduling to exploit the CPU pipeline as efficiently as possible.|$|R
50|$|GenomeABC: A server for Benchmarking of Genome <b>Assemblers.</b>|$|R
50|$|Other <b>assemblers,</b> such as MASM, {{also support}} macros.|$|R
25|$|A macro <b>assembler</b> {{includes}} a macroinstruction facility so that (parameterized) assembly language text {{can be represented}} by a name, and that name {{can be used to}} insert the expanded text into other code.|$|E
25|$|An <b>assembler</b> program creates {{object code}} by {{translating}} combinations of mnemonics and syntax for operations and addressing modes into their numerical equivalents. This representation typically includes an operation code ("opcode") {{as well as}} other control bits and data. The <b>assembler</b> also calculates constant expressions and resolves symbolic names for memory locations and other entities. The use of symbolic references is a key feature of assemblers, saving tedious calculations and manual address updates after program modifications. Most assemblers also include macro facilities for performing textual substitution – e.g., to generate common short sequences of instructions as inline, instead of called subroutines.|$|E
25|$|During the {{development}} of TTM, {{it became apparent that}} applications other than <b>assembler</b> macro processing were possible. These include data editing, text manipulation, expression compiling, and macro processing for language processors other than assemblers.|$|E
5000|$|Most <b>assemblers</b> {{provide some}} sort of macro ability: the {{advantage}} that HLA offers over other <b>assemblers</b> {{is that it can}} process macro arguments like [...] using HLA's extensive compile-time string functions, and HLA's macro facilities can infer the types of variables and use that information to direct macro expansion.|$|R
5000|$|He was {{an outspoken}} skeptic {{of the idea}} of {{molecular}} <b>assemblers,</b> as advocated by K. Eric Drexler. His main scientific objections, which he termed the “fat fingers problem" [...] and the [...] "sticky fingers problem”, argued against the feasibility of molecular <b>assemblers</b> being able to precisely select and place individual atoms. He also believed that Drexler’s speculations about apocalyptic dangers of molecular <b>assemblers</b> threatened the public support for development of nanotechnology. [...] He debated Drexler in an exchange of letters which were published in Chemical & Engineering News as a point-counterpoint feature.|$|R
2500|$|More {{sophisticated}} high-level <b>assemblers</b> provide language abstractions such as: ...|$|R
