107|640|Public
50|$|The DASL Programming Language (Distributed <b>Application</b> <b>Specification</b> Language) is a high-level, {{strongly}} typed {{programming language}} originally developed at Sun Microsystems Laboratories between 1999 and 2003 {{as part of}} the Ace Project. The goals of the project were to enable rapid development of web-based applications based on Sun's J2EE architecture, and to eliminate the steep learning curve of platform-specific details.|$|E
5000|$|Quack secured several patents that {{underlie}} the technical challenges of delivering interactive voice services. Constructing a voice portal required integrations and innovations not only in speech recognition and speech generation, but also in databases, <b>application</b> <b>specification,</b> constraint-based reasoning and artificial intelligence and computational linguistics. [...] "Quack"'s name derived from the company goal of providing not only voice-based services, but more broadly [...] "Quick Ubiquitous Access to Consumer Knowledge".|$|E
50|$|The DASL {{programmer}} models the graphical {{user interface}} of the application by annotating the logical AUS forms and actions with properties that describe the basic layout of the data on the page. Rather than user interface considerations dominating the <b>application</b> <b>specification,</b> in DASL the logical interaction between the user and domain model is central, and the user interface {{is derived from the}} logical interaction. It is believed that DASL is unique among other languages in this respect.|$|E
5000|$|Sea PROTECTOR is {{developed}} for naval <b>applications.</b> <b>Specifications</b> (excluding weapons and ammo): ...|$|R
2500|$|Accessible Rich Internet <b>Applications</b> (...) <b>specification</b> for {{enhanced}} accessibility in Ajax-based rich Internet applications.|$|R
50|$|Long-GOP MPEG-2 {{material}} interchange between video servers is possible, as broadcasters develop <b>application</b> <b>specifications</b> {{they expect}} their vendors to implement.|$|R
50|$|Originally, JAD was {{designed}} to bring system developers and users of varying backgrounds and opinions together in a productive as well as creative environment. The meetings were a way of obtaining quality requirements and specifications. The structured approach provides a good alternative to traditional serial interviews by system analysts. JAD has since expanded to cover broader IT {{work as well as}} non-IT work (read about Facilitated <b>Application</b> <b>Specification</b> Techniques - FAST - created by Gary Rush in 1985 to expand JAD applicability.|$|E
50|$|ISO/IEC 20248 can {{be viewed}} as an X.509 <b>application</b> <b>specification</b> similar to S/MIME. Classic digital {{signatures}} are typically too big (the digital signature size is typically more than 2k bits) to fit in barcodes and RFID tags while maintaining the desired read performance. ISO/IEC 20248 digital signatures, including the data, are typically smaller than 512 bits. X.509 digital certificates within a public key infrastructure (PKI) is used for key and data description distribution. This method ensures the open verifiable decoding of data stored in a barcode and/or RFID tag into a tagged data structure; for example JSON and XML.|$|E
50|$|The JAD {{process was}} formalized by Tony Crawford and Chuck Morris of IBM {{in the late}} 1970s. It was then {{deployed}} at Canadian International Paper. JAD was used in IBM Canada {{for a while before}} being brought back to the US. Initially, IBM used JAD to help sell and implement a software program they sold, called COPICS. It was widely adapted to many uses (system requirements, grain elevator design, problem-solving, etc.). Tony Crawford later developed JAD-Plan and then JAR (joint application requirements). In 1985, Gary Rush wrote about JAD and its derivations - Facilitated <b>Application</b> <b>Specification</b> Techniques (FAST) - in Computerworld.|$|E
40|$|The Work Manager for <b>Application</b> Servers <b>Specification</b> {{is being}} {{provided}} by the copyright holders under the following license. By using and/or copying this work, you agree that you have read, understood and will comply with the following terms and conditions: Permission to copy and display the Work Manager for <b>Application</b> Servers <b>Specification</b> and/or portions thereof, without modification, in any medium without fee or royalty is hereby granted, provided that you include the following on ALL copies of the Work Manager for <b>Application</b> Servers <b>Specification,</b> or portions thereof, that you make: 1. A link or URL to the Work Manager for <b>Application</b> Servers <b>Specification</b> at this location...|$|R
40|$|We outline Ensemble, {{a design}} and {{implementation}} methodology for composing Message Passing (MP) applications from program components directed by scripts. We present a specification composition, which is directly associated with Ensemble composition of <b>applications.</b> We define <b>specification</b> components corresponding to program components and we compose them, directed by the same scripts, obtaining formal <b>specifications</b> of <b>applications.</b> We use the Petri net (PN) formalism to express component and <b>application</b> <b>specifications.</b> In this paper, PN composition is modeled by appropriate inscriptions on input and output arcs of a unified environment place. Associating composition of <b>applications</b> and <b>specifications</b> is a means for developing reliable and cost-effective applications. Keywords: Message Passing <b>Application</b> Composition, <b>Specification</b> Composition, Reuse, Petri Nets 1 Introduction Parallel Processing {{has emerged as a}} means to cope with the computational power needed by the everincreasing [...] ...|$|R
50|$|Technical {{work of the}} AMWA {{is through}} {{projects}} that strive for compatibility between AAF (Advanced Authoring Format), BXF, MXF (Material Exchange Format) and XML. The current projects fall into three categories: data models, interface <b>specifications,</b> and <b>application</b> <b>specifications.</b>|$|R
5000|$|TPEG RTM was {{intended}} as the [...] "one size fits all" [...] application. However, early implementations soon showed that the RTM structure was too broad {{to be used in}} navigation systems as a replacement for TMC. This first generation TPEG applications (TPEG generation 1, or TPEG1) also provided only a binary encoding, having in some cases a separate specification for the mapping to an XML encoding. Consequently, a revision of both the general information modelling style and the design approach was done, moving TPEG towards more clearly defined and separated applications for specific use cases and a top-down data modelling approach. This second generation TPEG applications (TPEG generation 2, or TPEG2) is now specified with an UML model, from which automatically both a binary encoding and XML encoding are derived. A TPEG2 <b>application</b> <b>specification</b> includes both the binary and XML encodings as integral part of the specification.|$|E
50|$|Several popular {{approaches}} exist {{which are}} employed {{in the creation of}} reactive programming languages. Specification of dedicated languages which are specific to various domain constraints. Such constraints usually are characterized by real-time, embedded computing or hardware description. Another approach involves the specification of general-purpose languages which include support for reactivity. Other approaches are articulated in the definement, and use of programming libraries, or embedded domain-specific languages, that enable reactivity alongside or on top of, the employed general-purpose programming language used to specify an <b>application.</b> <b>Specification,</b> and use of these different approaches results in language capability trade-offs. In general, the more restricted a language is characterized as having to be, the more its associated compilers and analysis tools are then able to inform its using developers (e.g., in performing analysis for whether programs are able to execute in actual real time). Functional trades-offs involving specificity, then result in deterioration of a language's general applicability.|$|E
40|$|Abstract. Standard {{programming}} tools use {{a system}} of error messages and warnings to help programmers in finding syntax and logical errors in their programs. Generative programming differentiates the level of generator from the level of generated application. The source code is synthesized {{at the level of}} generator from a set of code templates according to <b>application</b> <b>specification</b> and rules defined by generator configuration. Code templates, <b>application</b> <b>specification</b> and generator configuration are mutually dependent and error in any part may result in incorrect source code. This paper deals with possibilities of introducing error messages that are specific at the level of generator. An example of generator is developed and discussed...|$|E
30|$|An SDF graph is used {{to simplify}} the <b>application</b> <b>specifications.</b> It allows the {{representation}} of the application behavior at a coarse grain level. This data flow representation models the application operations and specifies the data dependencies between these operations.|$|R
50|$|On November 3, 2010, WiGig Alliance {{announced}} the WiGig version 1.0 A/V and I/O protocol adaptation layer (PAL) <b>specifications.</b> The <b>application</b> <b>specifications</b> {{have been developed}} to support specific system interfaces including extensions for PC peripherals and display interfaces for HDTVs, monitors and projectors.|$|R
50|$|In {{contrast}} to the COM-based specifications, the UA specifications are not pure <b>application</b> <b>specifications.</b> They describe typically UA internal mechanisms, which get handled through the communication stack and are normally only of interest for those that port a stack to a specific target or those that want to implement their own UA stack.|$|R
40|$|We {{present a}} {{run-time}} security monitor that detects both known and unknown cyber attacks by checking that the run-time {{behavior of the}} application {{is consistent with the}} expected behavior modeled by an <b>application</b> <b>specification.</b> This is crucial because, even if the implementation is consistent with its specification, the application may still be vulnerable due to flaws in the supporting infrastructure. This run-time security monitor is sound and complete, eliminating false alarms, as well as efficient, so that it does not limit run-time application performance and so that it supports real-time systems. Importantly, this monitor is readily applicable to both legacy and new system platforms. The security monitor takes as input the <b>application</b> <b>specification</b> and the application implementation, which may be expressed in different languages. The security monitor detects attacks by systematically comparing the application execution and specification behaviors at run-time, even though they operate at two different levels of abstraction. We define the denotational semantics of the specification language and prove that the monitor is sound and complete, i. e. if the application is consistent with its specification, the security monitor will produce no false alarms (soundness) and that it will detect any deviation of the application from the behavior sanctioned by the specification language (completeness). Importantly, the <b>application</b> <b>specification</b> language enables the description of known or potential attack plans, enabling not only attack detection but attack characterization as well...|$|E
40|$|In {{this paper}} we present SALSART, a web-based {{cooperative}} {{environment for the}} design of real-time schedules. It comprises a set of stand alone tools interacting via an internet based central supervisor. It envisions a set of experts working as a geographically separated team on <b>application</b> <b>specification,</b> scheduling, editing, simulation and analysis of real-time schedules...|$|E
30|$|Current {{emerging}} embedded System-on-Chip platforms {{are increasingly}} becoming multiprocessor architectures. System designers experience significant difficulties in programming these platforms. The applications are typically specified as sequential programs {{that do not}} reveal the available parallelism in an application, thereby hindering the efficient mapping of an application onto a parallel multiprocessor platform. In this paper, we present our compiler techniques for facilitating the migration from a sequential <b>application</b> <b>specification</b> to a parallel <b>application</b> <b>specification</b> using the process network model of computation. Our work is inspired by a previous research project called Compaan. With our techniques we address optimization {{issues such as the}} generation of process networks with simplified topology and communication without sacrificing the process networks' performance. Moreover, we describe a technique for compile-time memory requirement estimation which we consider as an important contribution of this paper. We demonstrate the usefulness of our techniques on several examples.|$|E
5000|$|... 3GPP TS 31.121 - Universal Subscriber Identity Module (USIM) <b>application</b> test <b>specification</b> ...|$|R
30|$|Unlike SMIL Timesheets, {{which allow}} for {{embedding}} temporal aspects in documents written in some timeless specification languages, the TAL language allows for specifying temporal semantics {{to be applied}} to compositions outside of them, and as first-class entities. The aim is to incorporate the defined semantics in hypermedia <b>application</b> <b>specifications</b> that are defined using languages that allow temporal behavior specifications.|$|R
50|$|Each {{product is}} {{customized}} {{to suit the}} <b>applications</b> and <b>specifications</b> of the customer.|$|R
40|$|The {{emergence}} of XML has {{lead to a}} change in the development style for Web sites. XML's advantages, such as the separation of content and presentation, or the possibility to develop <b>application</b> <b>specification</b> markup languages, have changed the creation, management and presentation of Web sites. We will investigate the suitability of XML technologies for authoring and delivering virtual, i. e. Web-based, courses...|$|E
40|$|The Æ�-{{calculus}}, a new calculus {{based on}} the �-calculus, is a model for mobile distributed computation. The Æ�-calculus {{can be used to}} specify applications, in order to reason about their security and correctness properties. The Æ � primitives have been been implemented as a Java API. The implementation in Java provides a means of bridging the gap between <b>application</b> <b>specification</b> and implementation. ...|$|E
40|$|Conventional {{approaches}} for ensuring {{the security of}} application software at run-time, through monitoring, either produce (high rates of) false alarms (e. g. intrusion detection systems) or limit application performance (e. g. run-time verification). We present a runtime security monitor that detects both known and unknown cyber attacks by checking that the run-time behavior of the application {{is consistent with the}} expected behavior modeled in <b>application</b> <b>specification.</b> This is crucial because, even if the implementation is consistent with its specification, the application may still be vulnerable due to flaws in the supporting infrastructure (e. g. the language runtime system, libraries and operating system). This runtime security monitor is sound and complete, eliminating false alarms, as well as efficient, so that it does not limit runtime application performance and so that it supports real-time systems. The security monitor takes as input the <b>application</b> <b>specification</b> and the application implementation, which may be expressed in different languages. The specification language of the application software is formalized based on monadic second order logic and event calculus interpreted over algebraic data structures. This language allows us to express behavior of an application at any desired (and practical) level of abstraction as well as with high degree of modularity. The security monitor detects every attack by systematically comparing the application execution and specification behaviors at runtime, even though they operate at two different levels of abstraction. We define the denotational semantics of the specification language and prove that the monitor is sound and complete. Furthermore, the monitor is efficient because of the modular <b>application</b> <b>specification</b> at appropriate level(s) of abstraction...|$|E
50|$|DoJa {{profile is}} a Java <b>application</b> {{environment}} <b>specification</b> for DoCoMo's i-mode mobile phone.|$|R
5000|$|Accessible Rich Internet <b>Applications</b> (ARIA) <b>specification</b> for {{enhanced}} accessibility in Ajax-based rich Internet applications.|$|R
50|$|Together with Intel, DCA had {{designed}} the DCA/Intel Communicating <b>Applications</b> <b>Specification</b> (CAS). It defines a standard, high-level programming interface for data communications applications. The DCX format {{is the standard}} file format for storing FAX images in CAS. DCA was in the market of producing T-1 multiplexers. In 1994, DCA of Alpharetta, Georgia, was acquired in 1994 by Attachmate Corporation of Bellevue, Washington.|$|R
40|$|International audienceEmbedded {{applications}} are usually coming with stringent constraints {{in term of}} cost, energy consumption and real-time. Consequently, fixed-point arithmetic is mainstream for their implementation into embedded systems. Hence, the main objective of the french ANR project DEFIS {{is to provide a}} complete design flow for fixed-point refinement of complex applications. This tool flow is like the missing link between high-level <b>application</b> <b>specification</b> tools and low-level implementation...|$|E
40|$|Ever {{since the}} {{introduction}} of the J 2 EE Enterprise <b>Application</b> <b>specification</b> from SUN Microsystems, this new technology has experienced tremendous growth. This paper will discuss tuning approaches for J 2 EE application servers. After covering tuning options at the architectural level of a J 2 EE application, we discuss the impact of garbage collection and the JVM on application server performance, talk about benchmarking, load-testing and monitoring of applications servers...|$|E
40|$|We {{describe}} {{a proposal for}} an extensible, component-based software architecture for natural language engineering applications. Our model leverages existing linguistic resource description and discovery mechanisms based on extended Dublin Core metadata. In addition, the application design is flexible, allowing disparate components to be combined to suit the overall application functionality. An <b>application</b> <b>specification</b> language provides abstraction from the programming environment and allows ease of interface with computational grids via a broker. May 2003 Open Acces...|$|E
40|$|A QoS {{middleware}} {{provides the}} Quality of Service support required by many QoS sensitive applications. The QoS middleware is between a host and a QoS-enabled infrastructure and hides {{the complexity of}} the extra functionality behind a set of APIs. This article presents the AQUILA QoS middleware, a QoS API to implement QoS-aware applications, a QoS Portal based on <b>application</b> <b>specifications</b> and Proxies to provide legacy non QoS-aware applications with QoS...|$|R
40|$|This thesis {{describes}} {{the development of}} mobile application for Windows Phone. Application is focused on choice of meals and identification of meals. The work contains description the different stages of development, starting with analysis of existing <b>applications,</b> <b>specification</b> of the customer requirements and design prototype inteface and finally to its implementation and testing. The work {{describes the}} choice of technology for the implementation. Result of my work is an elegant, fast and intuitive application...|$|R
40|$|The {{selection}} of GIS software applications {{vary with the}} purposes and requirements of using it. The two major applications for GIS software are for management/information and design analysis. The surveyors Land Information Management PACkage (SLIM) is basically developed for management or monitoring purposes and some design applications. Studies on areas of <b>applications.</b> <b>specifications,</b> operations. data sources, data organisations and information presentation shows the potentials of SLIMPAC as a Management Information System Package...|$|R
