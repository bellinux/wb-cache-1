158|162|Public
25|$|IIS 7 also {{features}} a completely rewritten administration interface that takes advantage of modern MMC features such as task panes and <b>asynchronous</b> <b>operation.</b> Configuration of ASP.NET is more fully integrated into the administrative interface.|$|E
5000|$|The <b>Asynchronous</b> <b>Operation</b> Processor {{controls}} the whole <b>asynchronous</b> <b>operation</b> ...|$|E
5000|$|The Proactive Initiator {{starts the}} <b>asynchronous</b> <b>operation</b> via the <b>Asynchronous</b> <b>Operation</b> Processor and defines the Completion Handler ...|$|E
5000|$|... cofence, which forces local {{completion}} of <b>asynchronous</b> <b>operations,</b> ...|$|R
5000|$|<b>Asynchronous</b> <b>operations</b> return an AsyncResult, {{which is}} like promise objects ...|$|R
5000|$|The Promises tab {{allows for}} tracing of code through <b>asynchronous</b> <b>operations.</b>|$|R
50|$|HMPP {{provides}} synchronous and asynchronous RPC. Implementation of <b>asynchronous</b> <b>operation</b> is hardware dependent.|$|E
5000|$|Parallel, <b>asynchronous</b> <b>operation.</b> Approximately 13,000 adds, 1400 multiplies or 1200 divides {{per second}} ...|$|E
5000|$|Completion Handler {{is a call}} {{at the end of}} the {{operation}} from the <b>Asynchronous</b> <b>Operation</b> Processor ...|$|E
5000|$|... finish, a barrier-like SPMD {{construct}} {{that forces}} completion of <b>asynchronous</b> <b>operations</b> across a team, ...|$|R
30|$|<b>Asynchronous</b> <b>operations</b> {{have higher}} priority: they {{interrupt}} the current execution (even tasks), and they are related to interrupts.|$|R
40|$|Asynchronous Completion Token pattern allows {{applications}} to efficiently associate {{state with the}} completion of <b>asynchronous</b> <b>operations.</b> Contemporary applications must respond to many types of events, ranging from user interface notifications to network messages. Delay-sensitive applications, such as network management systems, often perform long-running operations asynchronously to avoid blocking the processing of other pending events. When these <b>asynchronous</b> <b>operations</b> complete, applications may need more information thansimply the notification itself to properly handle the event. This paper describes how such applications can benefit {{from the use of}} the Asynchronous Completion Token pattern. 1 Intent To efficiently associate state with the completion of <b>asynchronous</b> <b>operations.</b> 2 Also Known As "Magic Cookie" 3 Motivation 3. 1 Context To illustrate the Asynchronous Completion Token pattern, consider the structure of a network Management Application that monitors the performance an [...] ...|$|R
5000|$|... cancel - The cancel {{operation}} {{enables a}} requestor {{to stop the}} execution of an <b>asynchronous</b> <b>operation.</b>|$|E
5000|$|... status - The status {{operation}} {{enables a}} requestor {{to determine whether}} an <b>asynchronous</b> <b>operation</b> has completed successfully or has failed or is still executing.|$|E
50|$|IIS 7 also {{features}} a completely rewritten administration interface that takes advantage of modern MMC features such as task panes and <b>asynchronous</b> <b>operation.</b> Configuration of ASP.NET is more fully integrated into the administrative interface.|$|E
50|$|New {{asynchronous}} {{features were}} added to the C# and Visual Basic languages. These features add a task-based model for performing <b>asynchronous</b> <b>operations,</b> implementing futures and promises.|$|R
50|$|CIAO also {{provides}} an {{implementation of the}} AMI4CCM standard which provides the ability to perform <b>asynchronous</b> <b>operations</b> using a callback model. AMI4CCM is a separate OMG standard.|$|R
5000|$|Version 1.0 (June 1992) {{defined the}} basic {{operation}} of Winsock. It was kept {{very close to}} the existing interface of Berkeley sockets to simplify porting of existing applications. A few Windows-specific extensions were added, mainly for <b>asynchronous</b> <b>operations</b> with message-based notifications.|$|R
5000|$|Geo{{location}} is {{an object}} {{which is part}} of Navigator object. It uses the getCurrentPosition (...) method. Finding location is an <b>asynchronous</b> <b>operation</b> as it requires the user’s permission for access. Hence callback functions for success and failure are required.|$|E
5000|$|The <b>asynchronous</b> <b>operation</b> of the {{communications}} and the computational allowed {{the development of}} asynchronous algorithms, such as Bane's [...] "Asychronous Polynomial Zero Finding" [...] algorithm. The field of asynchronous algorithms, {{as well as the}} asynchronous implementation of current algorithms, is likely to {{play a key role in}} the move to Exascale computing.|$|E
5000|$|In “overlap mode”, {{input and}} output data are {{buffered}} between the client and server {{and a series of}} independent queries can be sent by a client without having to wait for each to complete before sending the next. The responses are sent back in the order in which the queries were sent. This <b>asynchronous</b> <b>operation</b> helps applications to fully utilize Ethernet performance.|$|E
40|$|Asynchronous {{interactions}} {{are becoming more}} important in the implementation of complex B 2 B Web applications. This paper addresses correlation and coordination issues involved with asynchronous Web services, by studying different mechanisms and metadata structures for supporting them; in addition, several interaction patterns for building asynchronous computations are discussed, and the trade-offs between the various patterns are shown. In conclusion, we illustrate the use of asynchronous Web services in the context of some concrete B 2 B applications. This paper discusses how to build a web services architecture that handles requests and responses as separate transactions. Not all web services work synchronously; in some situations, responses to web service requests are not provided immediately, but rather sometime after the initial request transactions complete. Such <b>asynchronous</b> <b>operations</b> aren't explicitly supported by web services specifications and standards. In some situations, responses to web service requests are not provided immediately, but rather sometime after the initial request transactions complete. Such <b>asynchronous</b> <b>operations</b> aren't explicitly supported by web services specifications and standards; however, those standards do include the infrastructure and mechanisms on which <b>asynchronous</b> <b>operations</b> can be based. In this paper, several design patterns for asynchronous web services are discussed...|$|R
5000|$|IBM CKD {{subsystems}} initially operated synchronously {{with the}} system channel and can process information in the gaps between the various fields, thereby achieving higher performance by avoiding the redundant transfer of information to the host. [...] Both synchronous and <b>asynchronous</b> <b>operations</b> are supported on later subsystems.|$|R
40|$|Event-driven {{applications}} {{must respond}} to {{different types of}} events, ranging from user interface notifications to network messages. Delay-sensitive applications, such as network management systems, often perform operations asynchronously to avoid blocking the processing of other pending events. When these <b>asynchronous</b> <b>operations</b> complete, client applications may need more information than simply the completion event itself to perform the appropriate operation completion processing. This paper describes how such applications can benefit {{from the use of}} the Asynchronous Completion Token pattern, which allows applications to efficiently associate actions and state with the completion of <b>asynchronous</b> <b>operations.</b> 1 Intent The Asynchronous Completion Token design pattern efficiently associates the designated client actions and state with the completion of operations invoked asynchronously on services. 2 Also Known As "Magic Cookie" 3 Example To illustrate the Asynchronous Completion Toke [...] ...|$|R
50|$|In telecommunications, <b>{{asynchronous}}</b> <b>operation</b> or {{asynchronous working}} {{is where a}} sequence of operations is executed such that the operations are executed out of time coincidence with any event. It can also be an operation that occurs without a regular or predictable time relationship to a specified event; e.g., the calling of an error diagnostic routine that may receive control {{at any time during}} the execution of a computer program.|$|E
50|$|Among various fixes and {{refinements}} {{compared to}} the original nForce, nForce2 featured a fixed PCI/AGP clock, i.e. PCI and AGP frequencies will not change when changing the FSB. As a result, the nForce2 platform was known for its ease in overclocking AMD processors, and was a favorite for years with the overclocking community. It was also known that the chipset gave best performance with FSB and memory running synchronized, <b>asynchronous</b> <b>operation</b> delivered an unusual high performance loss.|$|E
50|$|The {{pipelining}} {{of requests}} {{results in a}} dramatic improvement in the loading times of HTML pages, especially over high latency connections such as satellite Internet connections. The speedup is less apparent on broadband connections, as the limitation of HTTP 1.1 still applies: the server must send its responses {{in the same order}} that the requests were received — so the entire connection remains first-in-first-out and HOL blocking can occur. The <b>asynchronous</b> <b>operation</b> of the upcoming HTTP/2 or SPDY could be a solution for this.|$|E
40|$|If {{you are a}} JavaScript {{developer}} {{working with}} <b>asynchronous</b> <b>operations</b> and {{want to know more}} about promises, then this book is ideal for you. Having a detailed explanation of JavaScript promises will be perfect as your next step towards adopting this new standard and using the API in your web and JavaScript applications...|$|R
50|$|PLASMA: The Parallel Linear Algebra for Scalable Multi-core Architectures (PLASMA) {{project is}} a modern {{replacement}} of LAPACK for multi-core architectures. PLASMA is a software framework for development of <b>asynchronous</b> <b>operations</b> and features out of order scheduling with a runtime scheduler called QUARK {{that may be used}} for any code that expresses its dependencies with a directed acyclic graph.|$|R
40|$|This paper gives {{practical}} {{solutions for}} implementing Ajax, JavaScript, and Representational State Transfer (REST) – based Web services and functionality. We {{need to develop}} applications that are decoupled that is client code is separate from the server code. Using this approach applications can be easily tested and maintained. In some situations, responses to web service requests are not provided immediately, but rather sometime after the initial request transactions complete. Such <b>asynchronous</b> <b>operations</b> aren't explicitly supported by web services specifications and standards; however, those standards do include the infrastructure and mechanisms on which <b>asynchronous</b> <b>operations</b> can be based. Calling a web service asynchronously instead of performing a complete post back has several advantages, including less network traffic and generally elevated performance. Also {{with the support of}} DOM model and XMLHttp Object in major popular browsers, numerous client side AJAX libraries are available to make these calls. The paper examines and compares the typical and Ajax based invocation of web services with remedies to improve the performance of web services...|$|R
50|$|Initially, the Quebec - New England Transmission {{consisted}} of the 172 km section between the Des Cantons station near Windsor, Quebec and the Frank D. Comerford Dam near Monroe, New Hampshire which, because of the <b>asynchronous</b> <b>operation</b> of the American and Québec power grids, had to be implemented as HVDC. This bipolar electricity transmission line, which is overhead for its whole length except the crossing of Saint Lawrence river, went into service in 1986. It could transfer a maximum power of 690 megawatts. The operating voltage was ±450kV or 900 kV from line to line.|$|E
50|$|To invoke asynchronicity, {{a special}} file {{descriptor}} called a trap queue {{had to have}} been created via the Type 2 opcode F_OTQ. A Type 1 call would have the F_NOWAIT bit OR-ed with its function value, and one of the additional parameters to dnix(2) was the trap queue file descriptor. The return value from an asynchronous call was not the normal value but a kernel-assigned identifier. At such time as the asynchronous request completed, a read(2) (or F_READ) of the trap queue file descriptor would return a small kernel-defined structure containing the identifier and result status. The F_CANCEL operation was available to cancel any <b>asynchronous</b> <b>operation</b> that hadn't yet been completed, one of its arguments was the kernel-assigned identifier. (A process could only cancel requests that were currently owned by itself. The exact semantics of cancellation was up to each request's handler, fundamentally it only meant that any waiting was to be terminated. A partially completed operation could be returned.) In addition to the kernel-assigned identifier, one of the arguments given to any <b>asynchronous</b> <b>operation</b> was a 32-bit user-assigned identifier. This most often referenced a function pointer to the appropriate subroutine that would handle the I/O completion method, but this was merely convention. It was the entity that read the trap queue elements that was responsible for interpreting this value.|$|E
50|$|RPyC {{is based}} on the work of Eyal Lotem (aka Lotex) on PyInvoke, which is no longer maintained. The first public release was 1.20, which allowed for {{symmetric}} and transparent RPC, but not for <b>asynchronous</b> <b>operation.</b> Version 1.6, while never publicly released, added the concept of 'events', as a means for the server to inform the client. Version 2.X, the first release of which was 2.2, added thread synchronization and the Async concept, which can be used as a superset of events. Version 2.40 adds the execute method, that can be used to execute code on the other side of the connection directly.RPyC 3 is a complete rewrite of the library, adding a capability-based security model, explicit services, and various other improvements.|$|E
50|$|HDi is an {{implementation}} of the Advanced Content specification; as such applications written for HDi are written using the XML dialect and ECMAScript, the latter of which is processed by the JScript engine when running on Microsoft Windows platforms. The HDi runtime exposes the APIs defined by the Advanced Content standard. It provides only a single threaded programming model, though certain operations (such as network and persistent storage access) are executed as <b>asynchronous</b> <b>operations.</b>|$|R
40|$|AbstractIn this paper, we {{describe}} a methodology {{for the design}} {{and the development of}} component-based real-time systems. In our model, a component consists of a set of concurrent real-time threads that communicate by means of synchronous and <b>asynchronous</b> <b>operations.</b> In addition, each component can specify its own local scheduling algorithm. We also discuss the support that must be provided at the operating system level, and present an implementation in the SHaRK operating system...|$|R
40|$|We {{present a}} simple library which equips MPI {{implementations}} with truly <b>asynchronous</b> non-blocking point-to-point <b>operations,</b> {{and which is}} independent of the underlying communication infrastructure. It utilizes the MPI profiling interface (PMPI) and the MPI_THREAD_MULTIPLE thread compatibility level, and works with current versions of Intel MPI, Open MPI, MPICH 2, MVAPICH 2, Cray MPI, and IBM MPI. We show performance comparisons on a commodity InfiniBand cluster and two tier- 1 systems in Germany, using low-level and application benchmarks. Issues of thread/process placement and the peculiarities of different MPI implementations are discussed in detail. We also identify the MPI libraries that already support <b>asynchronous</b> <b>operations.</b> Finally we show how our ideas can be extended to MPI-IO. Comment: 12 pages, 5 figure...|$|R
