200|155|Public
25|$|The {{three-dimensional}} Froebel star is assembled {{from four}} identical paper strips with a width-to-length proportion of between 1:25 and 1:30. The weaving and folding procedure {{can be accomplished}} in about forty steps. The product is a paper star with eight flat prongs and eight cone-shaped tips. The <b>assembly</b> <b>instructions</b> can be aborted midway, producing a two-dimensional eight–pronged star without cones.|$|E
25|$|The Thing-O-Matic was {{discontinued}} in {{the spring}} of 2012. MakerBot agreed to support the Thing-o-Matic until their supply of parts was exhausted. <b>Assembly</b> <b>instructions</b> are available online through the MakerBot Wiki. The Thing-O-Matic is open-source hardware and is licensed under the GNU GPLv3. As such, the Thing-O-Matic can be heavily altered and improved by users. Some MakerBot operators developed upgrades to the platform that were later incorporated into factory kits. MakerBot has credited those early innovators in their documentation, and even on some of the PCB silkscreen layouts.|$|E
2500|$|Around the 1980s to 1990s, Woman's Weekly {{magazine}} {{gave away}} a plastic on-needle knitting row counter of unusual design. It {{was presented as}} a self-assembly kit, in a small blue envelope with <b>assembly</b> <b>instructions</b> and a diagram on the back. According to the diagram, the gadget consists of (a) two blue front and back plates, pierced to show the numbers; (b) an inner white soft plastic frame to hold the number discs and to which are attached the two loops to bend back and thread on the needle; (c) the two number discs. [...] So the disks don't spin on an axis; they spin within circular spaces in the inner frame.|$|E
5000|$|<b>Assembly</b> <b>Instruction</b> Set Architecture (ISA): A smart {{assembler}} may convert {{an abstract}} assembly language common {{to a group}} of machines into slightly different machine language for different implementations ...|$|R
50|$|A similar feature {{exists in}} Microchip dsPIC's for (unnested) loops {{provided}} by the 'DO' <b>assembly</b> <b>instruction.</b> Its interruptible and trivial nesting goes up to one level with an additional 5 levels in software.|$|R
5000|$|Invoking an {{interrupt}} {{can be done}} {{using the}} INT x86 <b>assembly</b> language <b>instruction.</b> For example, to print a character to the screen using BIOS interrupt 0x10, the following x86 <b>assembly</b> language <b>instructions</b> could be executed: ...|$|R
2500|$|Bono and {{his friend}} Gavin Friday {{continued}} {{to work on the}} song after Lanois and Eno declined to do so. Bono credits Friday with rescuing the song and rearranging it, believing it could be a hit. Eno added a keyboard arpeggio, similar to the one from [...] "Bad". The song's fate was still in doubt when the Edge was sent a prototype of the Infinite Guitar by Canadian musician Michael Brook, with whom he had collaborated for the Captive soundtrack. The instrument allowed sustained notes to be played, producing [...] "a similar effect to the E-Bow", but with the ability to provide all the [...] "mid-points between no sustain and infinite sustain" [...] that the E-Bow cannot provide. The prototype included elaborate <b>assembly</b> <b>instructions</b> and as the Edge recollects, [...] "one wrongly placed wire and you could get a nasty belt of electricity. This piece of gear would have failed even the most basic of safety regulations." [...] On subsequent tours, his guitar technician occasionally received electric shocks from the instrument when preparing it for performances.|$|E
50|$|The ARB Fragment Program {{extension}} provides APIs to load ARBfp1.0 <b>assembly</b> <b>instructions,</b> enable selected programs, {{and to set}} various GPU parameters.|$|E
5000|$|Software Fault Isolation (SFI), allows running untrusted {{native code}} by {{sandboxing}} all store, read and jump <b>assembly</b> <b>instructions</b> to isolated segments of memory.|$|E
5000|$|... int eighty's stage name {{is based}} on a Linux <b>assembly</b> <b>instruction</b> ("technically 'int 0x80.'") while c64 refers to both the Commodore 64 {{computer}} and a combination of his first initial and his height (6 ft 5 in).|$|R
5000|$|SWPB Assembly Programmers Mailing List - the SWPB list is {{a mailing}} list {{dedicated}} to discussing machine code/assembly language programming on the TMS9900 CPU (SWPB is an <b>assembly</b> <b>instruction,</b> meaning [...] "swap bytes" [...] in TMS9900 Assembly Language).|$|R
5000|$|In {{computer}} programming, [...] "orthogonality in a {{programming language}} means that a relatively small set of primitive constructs can be combined in {{a relatively small number}} of ways to build the control and data structures of the language" [...] (...) [...] The term is most-frequently used regarding <b>assembly</b> <b>instruction</b> sets, as orthogonal instruction set.|$|R
50|$|The level {{names were}} all chosen from x86 <b>assembly</b> <b>instructions</b> where each instruction's {{workings}} and purpose roughly describe the main {{challenge of the}} level.|$|E
5000|$|This is only {{a partial}} list of <b>assembly</b> <b>instructions</b> a {{reference}} can be found here : Shader Assembly Language (ARB/NV) Quick Reference Guide for OpenGL.|$|E
50|$|Autofest City {{has a few}} models {{assembled}} from intricate kits, {{which in}} many instances have called {{for the use of}} more resourceful skills over the standard <b>assembly</b> <b>instructions.</b>|$|E
40|$|Reverse {{execution}} can {{be defined}} as a method which recovers the states that a program attains during its execution. Therefore, reverse execution eliminates the need for repetitive program restarts every time a bug location is missed. This potentially shortens debug time considerably. This thesis presents a new approach which, {{for the first time ever}} (to the best of the author's knowledge), achieves reverse execution at the <b>assembly</b> <b>instruction</b> level on general purpose processors via execution of a reverse program. A reverse program almost always regenerates destroyed states rather than restoring them from a record. Furthermore, a reverse program provides <b>assembly</b> <b>instruction</b> by <b>assembly</b> <b>instruction</b> execution in the backward direction. This significantly reduces state saving and thus decreases the associated memory and time costs of reverse execution support. Furthermore, this thesis presents a new dynamic slicing algorithm that is built on top of <b>assembly</b> <b>instruction</b> level reverse execution. Dynamic slicing is a technique which isolates the code parts that influence an erroneous variable at a program point. The algorithm presented in this thesis achieves dynamic slicing via execution of a reduced reverse program. A reduced reverse program is obtained from a full reverse program by omitting the instructions that recover states irrelevant to the dynamic slice under consideration. This provides a reverse execution capability along a designated dynamic slice only. The use of a reduced reverse program for dynamic slicing removes the need for runtime execution trajectories. The methodology of this thesis has been implemented on a PowerPC processor with a custom made debugger. As compared to previous work, all of which heavily use state saving techniques, the experimental results show up to 2206 X reduction in runtime memory usage, up to 403 X reduction in forward execution time overhead and up to 2. 32 X reduction in forward execution time for the tested benchmarks. Measurements on the selected benchmarks also indicate that the dynamic slicing method presented in this thesis can achieve up to six orders of magnitude (1, 928, 500 X) speedups in reverse execution along the dynamic slice as compared to full-scale reverse execution. Ph. D. Committee Chair: Mooney, Vincent J.; Committee Member: LeBlanc, Richard J.; Committee Member: Madisetti, Vijay K.; Committee Member: Pande, Santosh; Committee Member: Sivakumar, Raghupath...|$|R
50|$|Pascal, Fortran, Java have index {{checking}} ability. The VAX {{computer has}} an INDEX <b>assembly</b> <b>instruction</b> for array index checking which takes six operands, {{all of which}} can use any VAX addressing mode. The B6500 and similar Burroughs computers performed bound checking via hardware, irrespective of which computer language had been compiled to produce the machine code. A limited number of later CPUs have specialised instructions for checking bounds, e.g., the CHK2 instruction on the Motorola 68000 series.|$|R
50|$|INT is an <b>assembly</b> {{language}} <b>instruction</b> for x86 processors {{that generates}} a software interrupt. It takes the interrupt number formatted as a byte value.|$|R
50|$|<b>Assembly</b> <b>instructions</b> {{contain the}} bill of {{material}} {{as well as the}} data for the parts assembly that is important for the specific assembly (ex.: adjusting tolerance + 0.03/-0.01 mm).|$|E
50|$|The paper, {{glue and}} model making tools {{required}} for assembly were not supplied with any {{version of the}} package, although <b>assembly</b> <b>instructions</b> for components were provided in the extensive manual.|$|E
50|$|How to make ribs, frames.,fittings, form blocks, jigs. Construction tips. Forming of parts. Assemblies. “Pop riveting’ techniques. Fitting and {{drilling}} of Plexiglass. VW engine <b>assembly</b> <b>instructions,</b> parts list, installation photo, etc.|$|E
50|$|A script file {{may contain}} Debug subcommands and <b>assembly</b> {{language}} <b>instructions.</b> This method {{can be used}} to create or edit binary files from batch files.|$|R
5000|$|The above example will compile {{to exactly}} the same <b>assembly</b> {{language}} <b>instructions</b> as if [...] "" [...] had been written directly instead of mixed in.|$|R
50|$|A CIL <b>assembly</b> and <b>instructions</b> are {{generated}} by either a compiler or a utility called the IL Assembler (ILAsm) that is shipped with the execution environment.|$|R
5000|$|... 197? - Set No. ???? - Helicopter. This set {{contained}} a yellow chopper, control unit, operating unit, connection gear, cardboard landing mat (with <b>assembly</b> <b>instructions</b> {{printed on the}} back) and various pick-up items. Made in Hong Kong.|$|E
50|$|An {{electronic}} kit is {{a package}} of electrical components used to build an electronic device. Generally, kits are composed of electronic components, a circuit diagram (schematic), <b>assembly</b> <b>instructions</b> and often {{a printed circuit board}} (PCB) or another type of prototyping board.|$|E
50|$|Printed {{materials}} {{missing from}} initial backer rewards were later released in low resolution watermarked PDF format {{on the website}} DriveThru RPG for backers to print copies along with updated <b>assembly</b> <b>instructions</b> to all game pieces requiring assembly, free of charge.|$|E
50|$|If {{these two}} <b>assembly</b> {{pseudocode}} <b>instructions</b> {{run in a}} pipeline, after fetching and decoding the second instruction, the pipeline stalls, waiting until {{the result of the}} addition is written and read.|$|R
5000|$|In {{computer}} science, a NOP, no-op, or NOOP (pronounced [...] "no op"; {{short for}} no operation) is an <b>assembly</b> language <b>instruction,</b> programming language statement, or computer protocol command that does nothing.|$|R
40|$|Abstract. 3 D digital {{assembly}} process design {{technology is the}} combination of the three dimensions and information with the new software technology in traditional process design. This article is based on an aviation manufacturing enterprise’s priority to the realization of the whole {{assembly process}} design, simulation and verification business process, which mainly with Dassault Company’s DELMIA and 3 DVIA Composer platform. In this paper, some process design thinking and methods are introduced to the aircraft product process about the separation technology division, BOM reconstruction, process simulation, 3 d <b>assembly</b> <b>instruction</b> compiling, and the like. It also introduces some application methods of system integration...|$|R
50|$|Digital Prototyping also enables product {{teams to}} share {{detailed}} <b>assembly</b> <b>instructions</b> digitally with manufacturing teams. While paper assembly drawings can be confusing, 3D visualizations of digital prototypes are unambiguous. This early and clear collaboration between manufacturing and engineering teams helps minimize manufacturing {{problems on the}} shop floor.|$|E
5000|$|Evidence {{of the use}} of {{interchangeable}} parts can be traced back over two thousand years to Carthage in the First Punic War. Carthaginian ships had standardized, {{interchangeable parts}} that even came with <b>assembly</b> <b>instructions</b> akin to [...] "tab a into slot b" [...] marked on them.|$|E
50|$|Since there is, typically, a {{one-to-one}} {{relationship between}} <b>assembly</b> <b>instructions</b> and machine instructions, the instruction path length is frequently taken {{as the number}} of <b>assembly</b> <b>instructions</b> required to perform a function or particular section of code. Performing a simple table lookup on an unsorted list of 1,000 entries might require perhaps 2,000 machine instructions (on average, assuming uniform distribution of input values), while performing the same lookup on a sorted list using a binary search algorithm might require only about 40 machine instructions, a very considerable saving. Expressed in terms of instruction path length, this metric would be reduced in this instance by a massive factor of 50 - a reason why actual instruction timings might be a secondary consideration compared to a good choice of algorithm requiring a shorter path length.|$|E
50|$|Each x86 <b>assembly</b> <b>instruction</b> is {{represented}} by a mnemonic which, often combined {{with one or more}} operands, translates to one or more bytes called an opcode; the NOP instruction translates to 0x90, for instance and the HLT instruction translates to 0xF4. There are potential opcodes with no documented mnemonic which different processors may interpret differently, making a program using them behave inconsistently or even generate an exception on some processors. These opcodes often turn up in code writing competitions as a way to make the code smaller, faster, more elegant or just show off the author's prowess.|$|R
50|$|Other than a {{dedicated}} <b>assembly</b> <b>instruction</b> that performs the CLZ type operation, the fastest method to compute CLZ is reading a pre-computed value from a lookup table. A 4-bit lookup table, clz_table_4bit16, {{is used in}} above examples. The following are C language examples of CLZ for a 8-bit, 16-bit, 32-bit input value. The tables must be pre-computed by functions not shown here. An alternate 8-bit approach could pack two results in each table entry thus needing a 128 entry table instead of 256 entry table, because the bit count is 0 to 8 which fits in a 4-bit nibble.|$|R
5000|$|When {{written in}} <b>assembly</b> language, the <b>instruction</b> is written like this: ...|$|R
