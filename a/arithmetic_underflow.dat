14|6|Public
25|$|The {{justification}} for this definition {{is to preserve}} {{the sign of the}} result in case of <b>arithmetic</b> <b>underflow.</b> For example, in the single-precision computation 1/(x/2), where x = ±2−149, the computation x/2 underflows and produces ±0 with sign matching x, and the result will be ±∞ with sign matching x. The sign will match that of the exact result ±2150, but the magnitude of the exact result is too large to represent, so infinity is used to indicate overflow.|$|E
2500|$|In a {{computer}} implementation, {{as the three}} s'j sums become large, {{we need to consider}} round-off error, arithmetic overflow, and <b>arithmetic</b> <b>underflow.</b> The method below calculates the running sums method with reduced rounding errors. This is a [...] "one pass" [...] algorithm for calculating variance of n samples without the need to store prior data during the calculation. Applying this method to a time series will result in successive values of standard deviation corresponding to n data points as n grows larger with each new sample, rather than a constant-width sliding window calculation.|$|E
5000|$|... {{which also}} defines , the scaled {{complementary}} error function (which can be used instead of erfc to avoid <b>arithmetic</b> <b>underflow).</b> Another form of [...] for non-negative [...] is known as Craig's formula: ...|$|E
25|$|<b>Arithmetic</b> {{overflow}} or <b>underflow.</b>|$|R
50|$|The {{method of}} {{complements}} {{can be extended}} to other number bases (radices); in particular, it is used on most digital computers to perform subtraction, represent negative numbers in base 2 or binary <b>arithmetic</b> and test <b>underflow</b> and overflow in calculation.|$|R
40|$|Approved for Public ReleaseTable of {{contents}} include the following: (1) Electromagnetic scattering from radially or axially inhomogeneous objects; (2) Application of equivalent edge currents {{to correct the}} backscattered physical optics field of flat plates; (3) Application of parallel processing to a surface patch wire junction EFIE code; (4) A recursive technique to avoid <b>arithmetic</b> overflow and <b>underflow</b> when computing slowly convergent eigenfunction type expansions; and (5) H-oriented and B-oriented methods in a problem of nonlinear magnetostatics...|$|R
5000|$|The term <b>arithmetic</b> <b>underflow</b> (or [...] "floating point underflow", or just [...] "underflow") is a {{condition}} in a computer program where {{the result of a}} calculation is a number of smaller absolute value than the computer can actually store in memory on its CPU.|$|E
50|$|The log {{form of the}} {{geometric}} mean is generally the preferred alternative for implementation in computer languages because calculating the product of many numbers can lead to an arithmetic overflow or <b>arithmetic</b> <b>underflow.</b> This {{is less likely to}} occur with the sum of the logarithms for each number.|$|E
50|$|However {{the squares}} of very {{large or small}} values of x and y may exceed the range of machine {{precision}} when calculated on a computer, leading to an inaccurate result caused by <b>arithmetic</b> <b>underflow</b> and/or arithmetic overflow. The hypot function was designed to calculate the result without causing this problem.|$|E
40|$|Abstract: Let IIR be the set {{of closed}} and bounded {{intervals}} of real numbers. Arithmetic in IIR can be defined via the power set IPIR ({{the set of}} all subsets) of real numbers. If divisors containing zero are excluded, arithmetic in IIR is an algebraically closed subset of the arithmetic in IPIR, i. e., an operation in IIR performed in IPIR gives a result that is in IIR. Arithmetic in IPIR also allows division by an interval that contains zero. Such division results in closed intervals of real numbers which, however, are no longer bounded. The union of the set IIR with these new intervals is denoted by (IIR). The paper shows that arithmetic operations can be extended to all elements of the set (IIR). On the computer, arithmetic in (IIR) is approximated by arithmetic in the subset (IF) of closed intervals over the floating-point numbers F ⊂ IR. The usual exceptions of floating-point <b>arithmetic</b> like <b>underflow,</b> overflow, division by zero, or invalid operation do not occur in (IF) ...|$|R
40|$|The {{demise of}} the Mars Orbiter and Mars Polar Lander {{missions}} has highlighted the criticality of software reliability for Mars missions. In both cases, problems manifested themselves at the software level, even if the causes {{are to be found}} somewhere else (e. g., design process). Therefore, it is fair to assume that many problems could be caught during software verification provided that one uses the right tools and looks for the right types of errors. In this paper, we describe a study in which we apply this theory to the flight software of a current mission, i. e., the Mars Exploration Rover mission (MER). The study consists of applying a static analysis tool to the MER code to identify runtime errors, such as un-initialized variables, out-of-bound array accesses, and <b>arithmetic</b> overflows and <b>underflows.</b> The goal is both to demonstrate the usefulness of formal methods in a real software development context, and more importantly, to participate in the verification of the code that will fly during this mission. The work was conducted by a tool expert and a code expert. All identified problems were passed on to the appropriate developers. This paper describes the setup of the study, the findings, and proposals for integrating such a tool in a software development process. It also includes illustrative examples of the problems found by the analysis. 1...|$|R
40|$|The {{data type}} bigfloat is the high-precision {{floating}} point type of LEDA. A bigfloat is {{a number of the}} form s. 2 "e where s and e are integers. s is called the significant or mantissa and e is called the exponent. Arithmetic on bigfloats is governed by two parameters: the mantissa length and the rounding mode. Both parameters can either be set globally or for a single operation. The arithmetic on bigfloats works as follows: first the exact result of an operation is computed and then the mantissa is rounded to the prescribed number of digits as dictated by the rounding mode. The available rounding modes are TONEAREST (round to the nearest representable number), TOPINF (round upwards), TONINF (round downwards), TOZERO (round towards zero), TOINF (round away from zero) and EXACT. The latter mode only applies to addition, substraction and multiplication. In this mode the presicion parameter is ignored and no rounding takes place. Since the exponents of bigfloats are arbitrary integers (type integer) <b>arithmetic</b> operations never <b>underflow</b> or overflow. However, exceptions (division by zero, square root of a negative number) may occur. They are handled according of the IEEE floating point standard, e. g. 5 / 0 evaluates to #infinity#, - 5 / 0 evaluates to -#infinity#, + #infinity# + 5 evaluates to +#infinity# and 0 / 0 evaluates to NaN (=not a number). This report is structured as follows. Section 2 defines the bigfloat through its manual page and the remaining sections contain the implementation. The implementation is split into files bigfloat. h and bigfloat. c. (orig.) SIGLEAvailable from TIB Hannover: RR 1912 (96 - 1 - 002) / FIZ - Fachinformationszzentrum Karlsruhe / TIB - Technische InformationsbibliothekBundesministerium fuer Bildung, Wissenschaft, Forschung und Technologie, Bonn (Germany) DEGerman...|$|R
5000|$|In IEEE 754 binary {{floating}} point numbers, zero values {{are represented by}} the biased exponent and significand both being zero. Negative zero has the sign bit set to one. One may obtain negative zero {{as the result of}} certain computations, for instance as the result of <b>arithmetic</b> <b>underflow</b> on a negative number, or , or simply as [...]|$|E
50|$|In floating-point calculations, NaN is not {{the same}} as infinity, {{although}} both are typically handled as special cases in floating-point representations of real numbers as well as in floating-point operations. An invalid operation is also not the same as an arithmetic overflow (which might return an infinity) or an <b>arithmetic</b> <b>underflow</b> (which would return the smallest normal number, a denormal number, or zero).|$|E
50|$|<b>Arithmetic</b> <b>underflow</b> {{can occur}} when the true result of a {{floating}} point operation is smaller in magnitude (that is, closer to zero) than the smallest value representable as a normal floating point number in the target datatype. Underflow can in part be regarded as negative overflow of the exponent of the floating point value.For example, if the exponent part can represent values from &minus;128 to 127, then a result with a value less than &minus;128 may cause underflow.|$|E
50|$|The {{justification}} for this definition {{is to preserve}} {{the sign of the}} result in case of <b>arithmetic</b> <b>underflow.</b> For example, in the single-precision computation 1/(x/2), where x = ±2−149, the computation x/2 underflows and produces ±0 with sign matching x, and the result will be ±∞ with sign matching x. The sign will match that of the exact result ±2150, but the magnitude of the exact result is too large to represent, so infinity is used to indicate overflow.|$|E
5000|$|In a {{computer}} implementation, {{as the three}} sj sums become large, {{we need to consider}} round-off error, arithmetic overflow, and <b>arithmetic</b> <b>underflow.</b> The method below calculates the running sums method with reduced rounding errors. This is a [...] "one pass" [...] algorithm for calculating variance of n samples without the need to store prior data during the calculation. Applying this method to a time series will result in successive values of standard deviation corresponding to n data points as n grows larger with each new sample, rather than a constant-width sliding window calculation.|$|E
40|$|The {{function}} y = g(x) = log(W(e^x)), where W() {{denotes the}} Lambert W function, {{is the solution}} to the equation y + e^y = x. It appears in various problem situations, for instance the calculation of current-voltage curves for solar cells. A direct calculation of g(x) may be inaccurate because of <b>arithmetic</b> <b>underflow</b> or overflow. We present a simple algorithm for calculating g(x) that is robust, in that it will work for almost all x values which are representable in the arithmetic of one's chosen computer language. The algorithm does not assume that the chosen computer language implements the Lambert W function...|$|E
40|$|Based on an idea in [4] {{we propose}} a new {{iterative}} multiplicative filtering algorithm for label assignment matrices {{which can be}} used for the supervised partitioning of data. Starting with a row-normalized matrix containing the averaged distances between prior features and the observed ones the method assigns in a very efficient way labels to the data. We interpret the algorithm as a gradient ascent method with respect to a certain function on the product manifold of positive numbers followed by a reprojection onto a subset of the probability simplex consisting of vectors whose components are bounded away from zero by a small constant. While such boundedness away from zero is necessary to avoid an <b>arithmetic</b> <b>underflow,</b> our convergence results imply that they are also necessary for theoretical reasons. Numerical examples show that the proposed simple and fast algorithm leads to very good results. In particular we apply the method for the partitioning of manifold-valued images...|$|E
40|$|However, the {{proposed}} receiver and channel selection scheme still {{suffer from the}} mismatches picked up during RF-to-IF conversion. Therefore, a system called phase and amplitude mismatch cancellers is adopted {{to deal with the}} problem. Existing implementations neglected several critical behaviors of the cancellers, and provide image rejection ratios (IRR) ranging from 50 dB to 65 dB only. These behaviors include (i) <b>arithmetic</b> <b>underflow,</b> (ii) angular obscurity and (iii) spurious intermodulation products (IMD) produced by cancellers. We analyzed them and established several design rules, by which a far better IRR of at least 82. 5 dB was achieved. The system makes {{the proposed}} receiver and channel selection method feasible. In traditional receivers involving intermediate frequency (IF), two different RF channels, Signal and Image, are converted to the same IF and overlap with each other. The Signal is always wanted with the Image eliminated, so each RF LO frequency can only select one RF channel. By digital low-IF, the IF-to-baseband conversion can be configured so that either channel can be selected, then each RF LO frequency can select two RF channels. This enhanced channel selection scheme can effectively reduce the number of LO frequency locations by half as well as the requirements of RF PLL frequency synthesizer. An existing approach makes use of configurable sampling scheme to achieve the same aim, but its use of analog sampling circuits results in phase and amplitude mismatches, from which the performance of image rejection suffers. Digital low-IF does not have this problem, since no mismatches are introduced to the signals after digitization. The proposed digital low-IF Weaver receiver, together with the enhanced channel selection scheme and the phase and amplitude mismatch cancellers, are demonstrated to be feasible by a multi-band multi-mode receiver prototype supporting GSM 900 and WCDMA. The receiver architecture proposed in this thesis makes use of Weaver architecture with digital low-IF. Its flexibility allows for any operations to be performed on the digitized signals, as well as the enhanced channel selection scheme proposed in this thesis. Chan Pak Kee. "September 2007. "Adviser: Chiu Sing Choy. Source: Dissertation Abstracts International, Volume: 69 - 08, Section: B, page: 4924. Thesis (Ph. D.) [...] Chinese University of Hong Kong, 2007. Includes bibliographical references (p. 152 - 162). Electronic reproduction. Hong Kong : Chinese University of Hong Kong, [2012] System requirements: Adobe Acrobat Reader. Available via World Wide Web. Electronic reproduction. [Ann Arbor, MI] : ProQuest Information and Learning, [200 -] System requirements: Adobe Acrobat Reader. Available via World Wide Web. Abstracts in English and Chinese. School code: 1307...|$|E

