39|250|Public
40|$|Abstract. In {{order to}} {{facilitate}} automated reasoning about large Boolean combinations of non-linear arithmetic constraints involving transcendental functions, we extend the paradigm of lazy theorem proving to intervalbased <b>arithmetic</b> <b>constraint</b> solving. Algorithmically, our approach deviates substantially from “classical ” lazy theorem proving approaches in that it directly controls <b>arithmetic</b> <b>constraint</b> propagation from the SAT solver rather than completely delegating arithmetic decisions to a subordinate solver. From the constraint solving perspective, it extends intervalbased constraint solving with all the algorithmic enhancements that were instrumental to the enormous performance gains recently achieved in propositional SAT solving, like conflict-driven learning combined with non-chronological backtracking. ...|$|E
40|$|This paper {{outlines}} the modeling, implementation and refinement {{of a solution}} to the International Timetabling Competition using Constraint Logic Programming methods. This is primarily carried out within the ECLiPSe constraint programming framework using lib(ic), the hybrid integer/real interval <b>arithmetic</b> <b>constraint</b> solver librar...|$|E
40|$|In {{order to}} {{facilitate}} automated reasoning about large Boolean combinations of nonlinear arithmetic constraints involving transcendental functions, we provide a tight integration of recent SAT solving techniques with interval-based <b>arithmetic</b> <b>constraint</b> solving. Our approach deviates substantially from lazy theorem proving approaches in that it directly controls <b>arithmetic</b> <b>constraint</b> propagation from the SAT solver rather than delegating arithmetic decisions to a subordinate solver. Through this tight integration, all the algorithmic enhancements that were instrumental to the enormous performance gains recently achieved in propositional SAT solving carry over smoothly to the rich domain of non-linear arithmetic constraints. As a consequence, our approach is able to handle large constraint systems with extremely complex Boolean structure, involving Boolean combinations of multiple thousand arithmetic constraints over some thousands of variables...|$|E
40|$|International audienceWe present {{three new}} methods that {{investigate}} the equalities implied {{by a system}} of linear <b>arithmetic</b> <b>constraints.</b> Implied equalities {{can be used to}} simplify linear <b>arithmetic</b> <b>constraints</b> and are valuable in the context of Nelson-Oppen style combinations of theories. The first method efficiently checks whether a system of linear <b>arithmetic</b> <b>constraints</b> implies an equality at all. In case the system does, the method also returns a valid equality as an explanation. The second method uses the first method to compute a basis for all implied equalities, i. e., a finite representation of all equalities implied by the linear <b>arithmetic</b> <b>constraints.</b> The third method uses the second method to check efficiently whether a system of linear <b>arithmetic</b> <b>constraints</b> implies a given equality...|$|R
50|$|Constraint logic {{programming}} does {{provide support for}} linear <b>arithmetic</b> <b>constraints,</b> but within a completely different theoretical framework.|$|R
40|$|We {{define a}} new {{aggregation}} operator µ_n for constraint databases {{that makes it}} possible to measure infinite subsets of the n-dimensional space defined by constraints. We show that it is well defined for real linear <b>arithmetic</b> <b>constraints</b> and integer linear <b>arithmetic</b> <b>constraints</b> together with periodicity constraints. We also show that relational algebra augmented with µ_n is closed in the real case and, under certain restrictions, in the integer case as well...|$|R
40|$|We {{discuss a}} method to {{automatically}} transform a clas-sical planning problem into an <b>arithmetic</b> <b>constraint</b> satisfaction problem (aCSP). This transformation specifies the variables of the aCSP, their ranges and the binary arithmetic constraints over these variables. A bounds consistency solver is then called to build ranges consistent with the arithmetic constraints. The transformation {{presented in this paper}} only pro-duces totally ordered plans and propositional classical planning...|$|E
40|$|We {{present a}} {{declarative}} language CFLP (R) which integrates lazy functional programming, logic programming and constraint solving over real numbers. Both a (higher order, polymorphic, lazy) functional language and (pure) CLP (R) can be isolated as subsets of our language. The execution {{mechanism of the}} language consists {{of a combination of}} lazy narrowing and constraint solving. As a very simple method for implementing the language, we propose a translation of CFLP (R) -programs into a logic programming language supporting real <b>arithmetic</b> <b>constraint</b> solving. This shows the practicability of the proposal...|$|E
40|$|We {{introduce}} the WEIGHTEDGRAMMAR constraint and propose propagation algorithms {{based on the}} CYK parser and the Earley parser. We show that the traces of these algorithms can be encoded as a weighted negation normal form (WNNF), a generalization of NNF that allows nodes to carry weights. Based on this connection, we prove the correctness and complexity of these algorithms. Specifically, these algorithms enforce domain consistency on the WEIGHTEDGRAMMAR constraint in time O(n 3). Further, we propose that the WNNF constraint can be decomposed into a set of primitive <b>arithmetic</b> <b>constraint</b> without hindering propagation...|$|E
40|$|Contents 1 Introduction 3 2 The {{distribution}} 3 3 How to use clp(FD,S) ? 4 4 About the semiring used by SFD 4 5 Basic {{notions about}} the solver 4 5. 1 FD variables............................. 5 5. 2 The core language: SFD....................... 5 6 Generic builtins 5 6. 1 <b>Arithmetic</b> <b>constraints........................</b> 7 6. 2 Complex <b>arithmetic</b> <b>constraints...................</b> 12 6. 3 Boolean constraints.......................... 13 6. 4 Meta constraints........................... 14 6. 5 Domains................................ 16 6. 6 Relations............................... 18 6. 7 Enumeration............................. 19 6. 8 Optimization.......................... ...|$|R
40|$|We {{report on}} {{a new way of}} {{handling}} non-linear <b>arithmetic</b> <b>constraints</b> and its implementation into the QUAD-CLP(R) language. Important properties of the problem at hand are a discretization through geometric equivalence classes and decomposition into convex pieces. A case analysis of those equivalence classes leads to a relaxation (and sometimes recasting) of the original constraints into linear constraints, much easier to handle. Complementing earlier expositions in [18] and [19], the present focus is on applications upholding its worth. 1 Motivation This paper presents the constraint programming language QUAD-CLP(R) which offers a powerful novel solving strategy for non-linear <b>arithmetic</b> <b>constraints</b> under the computing paradigm of logic programming. Emphasis will be given here to the techniques involved in the constraint solver for quadratic constraints over R and to applications making use of this added power. Despite the enormous potential of non-linear <b>arithmetic</b> <b>constraints</b> in [...] ...|$|R
50|$|<b>Arithmetic</b> <b>constraints</b> over finite domains, finite set constraints, {{generalized}} propagation, interval reasoning over non-linear constraints, interfaces {{to external}} simplex solvers, constraint handling rules (CHR) and more.|$|R
40|$|We {{present a}} new {{approach}} to checking assertion properties for RTL design verification. Our approach combines structural, word-level automatic test pattern generation (ATPG) and modular arithmetic constraint-solving techniques to solve the constraints imposed by the target assertion property. Our word-level ATPG and implication technique not only solves the constraints on the control logic, but also propagates the logic implications to the datapath. A novel <b>arithmetic</b> <b>constraint</b> solver based on modular number system is then employed to solve the remaining constraints in datapath. The advantages of the new method are threefold. First, the decision-making process of the word-level ATPG is confined to the selected control signals only. Therefore, the enumeration of enormous number of choices at the datapath signals is completely avoided. Second, our new implication translation techniques allow word-level logic implication being performed across the boundary of datapath and control logic, and therefore, efficiently cut down the ATPG search space. Third, our <b>arithmetic</b> <b>constraint</b> solver is based on modular instead of integral number system. It can thus avoid the false negative effect resulting from the bit-vector value modulation. A prototype system has been built which consists of an industrial front-end HDL parser, a propertyto -constraint converter and the ATPG/arithmetic constraint-solving engine. The experimental results on some public benchmark and industrial circuits demonstrate the efficiency of our approach and its applicability to large industrial designs...|$|E
40|$|Abstract In this paper, we {{introduce}} a new validity checking problem over linear arithmetic constraints and present a decision procedure for the problem. Instead of considering the validity of any particular linear <b>arithmetic</b> <b>constraint,</b> we consider the following problem: Given a finite automaton accepting linear arithmetic constraints, does the automaton produce any constraint that is a tautology? This problem arises {{in the context of}} static verification of meta-programs, i. e., programs dynamically generating other programs. This paper gives the first decision procedure to perform validity checking of finite automata over linear arithmetic constraints. Our algorithm will enable advanced verification of meta-programs. ...|$|E
40|$|In {{this paper}} we {{describe}} the complete workflow of analyzing the dynamic behavior of safety-critical embedded systems with HySAT. HySAT is an <b>arithmetic</b> <b>constraint</b> solver with a tightly integrated bounded model checker for hybrid discrete-continuous systems which — in contrast to many other solvers — {{is not confined to}} linear arithmetic, but can also deal with nonlinear constraints involving transcendental functions. Based on a controller for train separation implementing a “moving block ” interlocking scheme in the forthcoming European Train Control System Level 3, we exemplify the usage of the tool over the whole cycle from encoding a hybrid system to interpreting the results...|$|E
40|$|Abstract. Abduction {{is usually}} {{carried out on}} partially-defined predicates. In this paper we {{investigate}} abduction applied to fully-defined predicates, specifically linear <b>arithmetic</b> <b>constraints</b> over the real numbers. Abduction in this context has application to query answering using views and type inference, and potential relevance to analysis of concurrent/constraint/logic programs. We show that only rarely do abduction problems over linear <b>arithmetic</b> <b>constraints</b> have unique most general answers. We characterize the cases where most general answers exist. In general there may be infinitely many maximally general answers, or even answers that are not represented by maximally general answers. We take steps towards representing such answers finitely. ...|$|R
40|$|We {{introduce}} {{and study}} {{a new class}} of queries that we refer to as ACMA (<b>arithmetic</b> <b>constraints</b> on multiple attributes) queries. Such combinatorial queries require the simultaneous satisfaction of <b>arithmetic</b> <b>constraints</b> on three or more attributes from different relations, and thus often involve expensive multi-join operations. Building on techniques from constraint programming, we develop preprocessing methods, algorithms, and a new constrained join operator that allow ACMA queries to be evaluated efficiently within a conventional relational database engine. We present the results of a careful performance evaluation of both our new approach and the conventional nested-loop join algorithm. Measurements of tuples read, intermediate tuples generated, and execution time shows that our approach achieves superior performance for ACMA joins. 1...|$|R
40|$|Abstract. Symbolic model {{checkers}} use BDDs {{to represent}} <b>arithmetic</b> <b>constraints</b> over bounded integer variables. The size of such BDDs can be exponential {{in the number}} and size (in bits) of the integer variables in the worst case. In this paper we show how to construct linear-sized BDDs for linear integer <b>arithmetic</b> <b>constraints.</b> We present basic constructions for atomic equality and inequality constraints and extend them to handle arbitrary linear arithmetic formulas. We also present three alternative ways of handling out-of-bounds transitions, and discuss multiple bounds on integer variables. We experimentally compare our approach to other BDD-based symbolic model checkers and demonstrate that the algorithms {{presented in this paper}} can be used to improve their performance significantly. ...|$|R
40|$|AbstractLocal {{consistency}} {{techniques for}} numerical constraints over interval domains combine interval <b>arithmetic,</b> <b>constraint</b> inversion and bisection to reduce variable domains. In this paper, we study {{the problem of}} integrating any specific interval arithmetic library in constraint solvers. For this purpose, we design an interface between consistency algorithms and arithmetic. The interface has a two-level architecture: functional interval arithmetic at low-level, which is only a specification to be implemented by specific libraries, {{and a set of}} operations required by solvers, such as relational interval arithmetic or bisection primitives. This work leads to the implementation of an interval component by means of C++ generic programming methods. The overhead resulting from generic programming is discussed...|$|E
40|$|Although CLP(R) is a {{promising}} {{application of the}} logic programming paradigm to numerical computation, it has not addressed what {{has long been known}} as ``the pitfalls of [numerical] computation''. These show that rounding errors induce a severe correctness problem wherever floating-point computation is used. Independently of logic programming, constraint processing has been applied to problems in terms of real-valued variables. By using the techniques of interval <b>arithmetic,</b> <b>constraint</b> processing can be regarded as a computer-generated proof that a certain real-valued solution lies in a narrow interval. In this paper we propose a method for interfacing this technique with CLP(R). This is done via a real-valued analogy of Apt's proof-theoretic framework for constraint processing...|$|E
40|$|Abstract. We {{present a}} constraint-based {{algorithm}} for {{the synthesis of}} invariants expressed in the combined theory of linear arithmetic and uninterpreted function symbols. Given a set of programmer-specified invariant templates, our algorithm reduces the invariant synthesis problem to a sequence of <b>arithmetic</b> <b>constraint</b> satisfaction queries. Since the combination of linear arithmetic and uninterpreted functions is a widely applied predicate domain for program verification, our algorithm provides a powerful tool to statically and automatically reason about program correctness. The algorithm {{can also be used}} for the synthesis of invariants over arrays and set data structures, because satisfiability questions for the theories of sets and arrays can be reduced to the theory of linear arithmetic with uninterpreted functions. We have implemented our algorithm and used it to find invariants for a low-level memory allocator written in C. ...|$|E
40|$|In {{this paper}} we present {{algorithms}} for ecient image computation for systems represented as <b>arithmetic</b> <b>constraints.</b> We use automata {{as a symbolic}} representation for such systems. We show that, for a common class of systems, given a set of states and a transition, the time required for image computation is bounded by {{the product of the}} sizes of the automata encoding the input set and the transition. We also show that the size of the result has the same bound. We obtain these results using a linear time projection operation for automata encoding linear <b>arithmetic</b> <b>constraints.</b> We also experimentally show the bene ts of using these algorithms by comparing our implementation with LASH and BRAIN...|$|R
40|$|Symbolic model {{checkers}} use BDDs {{to represent}} <b>arithmetic</b> <b>constraints</b> over bounded integer variables. The size of such BDDs can be exponential {{in the number}} and size (in bits) of the integer variables in the worst case. In this paper we show how to construct linear-sized BDDs for linear integer <b>arithmetic</b> <b>constraints.</b> We present basic constructions for atomic equality and inequality constraints and extend them to handle arbitrary linear arithmetic formulas. We also present three alternative ways of handling out-of-bounds transitions, and discuss multiple bounds on integer variables. We experimentally compare our approach to other BDD-based symbolic model checkers and demonstrate that the algorithms {{presented in this paper}} can be used to improve their performance significantly...|$|R
40|$|We {{present a}} new {{algorithm}} for deciding satisfiability of nonlinear <b>arithmetic</b> <b>constraints.</b> The algorithm performs a Conflict-Driven Clause Learning (CDCL) -style {{search for a}} feasible assignment, while using projection operators adapted from cylindrical algebraic decomposition to guide the search away from the conflicting states...|$|R
40|$|Abstract. In its {{combination}} with conflict-driven clause learning the two-watched-literal scheme led to enormous performance gains in propositional SAT solving. The {{idea of this}} approach is to accelerate the deduction phase of a SAT solver by saving a high number of unnecessary and expensive computation steps originating in visits of indefinite clauses. In this paper we give a detailed explanation of the generalized watch scheme, called two-watched-atom scheme, implemented in our interval-based constraint solver HySAT, the latter being a solver for mixed Boolean and non-linear <b>arithmetic</b> <b>constraint</b> formulae. As opposed to the purely Boolean setting, the more general form of atomic formulae to be watched in our solver necessitates an extension of the original scheme and calls for a careful design of the data structures employed in the implementation. We present experimental results to demonstrate the speed-up obtained by the proposed scheme. ...|$|E
40|$|Abstract. The {{stochastic}} satisfiability modulo theories (SSMT) prob-lem is a {{generalization of}} the SMT problem on existential and random-ized (aka. stochastic) quantification over discrete variables of an SMT formula. This extension permits the concise description of diverse prob-lems combining reasoning under uncertainty with data dependencies. Solving problems with {{various kinds of}} uncertainty has been extensively studied in Artificial Intelligence. Famous examples are stochastic satisfi-ability and stochastic constraint programming. In this paper, we extend the algorithm for SSMT for decidable theories presented in [FHT 08] to non-linear arithmetic theories over the reals and integers which are in general undecidable. Therefore, we combine approaches from Constraint Programming, namely the iSAT algorithm tackling mixed Boolean and non-linear <b>arithmetic</b> <b>constraint</b> systems, and from Artificial Intelligence handling existential and randomized quantifiers. Furthermore, we evalu-ate our novel algorithm and its enhancements on benchmarks from the probabilistic hybrid systems domain. ...|$|E
40|$|A Pseudo-Boolean (PB) {{constraint}} is {{a linear}} <b>arithmetic</b> <b>constraint</b> over Boolean variables. PB constraints are convenient and {{widely used in}} expressing NP-complete problems. We introduce a new, two step, method for transforming PB constraints to propositional CNF formulas. The first step involves re-writing each PB constraint as a conjunction of PB-Mod constraints. The advantage is that PB-Mod constraints are easier to transform to CNF. In the second step, we translate each PB-Mod constraints, obtained in the previous step, into CNF. The resulting CNF formulas are small, and unit propagation can derive facts that it cannot derive using in the CNF formulas obtained by other commonly-used transformations. We also characterize the constraints for which one can expect the SAT solvers to perform well on the produced CNF. We show {{that there are many}} constraints for which the proposed encoding has a good performance. Comment: Used as the reference for SAT- 2013 submissio...|$|E
40|$|We propose here {{a number}} of {{approaches}} to implement <b>constraint</b> propagation for <b>arithmetic</b> <b>constraints</b> on integer intervals. To this end we introduce integer interval arithmetic. Each approach is explained using appropriate proof rules that reduce the variable domains. We compare these approaches using a set of benchmarks...|$|R
40|$|Action Language Verifier (ALV) is an {{infinite}} state model checker which specializes on systems specified with linear <b>arithmetic</b> <b>constraints</b> on integer variables. An Action Language specification consists of integer, boolean and enumerated variables, param-eterized integer constants {{and a set}} of modules and actions which are composed us...|$|R
40|$|Abstract. We propose here {{a number}} of {{approaches}} to implement <b>constraint</b> propagation for <b>arithmetic</b> <b>constraints</b> on integer intervals. To this end we introduce integer interval arithmetic. Each approach is explained using appropriate proof rules that reduce the variable domains. We compare these approaches using a set of benchmarks...|$|R
40|$|We {{present a}} {{verification}} algorithm for duration properties of real-time systems. While simple real-time properties constrain the total elapsed time between events, duration properties constrain the accumulated satisfaction time of state predicates. We formalize {{the concept of}} durations by introducing duration measures for timed automata. A duration measure assigns to each finite run of a timed automaton a real number [...] {{the duration of the}} run [...] which may be the accumulated satisfaction time of a state predicate along the run. Given a timed automaton with a duration measure, an initial and a final state, and an <b>arithmetic</b> <b>constraint,</b> the duration-bounded reachability problem asks if there is a run of the automaton from the initial state to the final state such that the duration of the run satisfies the constraint. Our main result is an (optimal) Pspace decision procedure for the duration-bounded reachability problem...|$|E
40|$|We {{present and}} analyze several {{implementations}} of the interval arithmetic narrowing function for multiplication. Starting from the Cleary algorithm for narrowing multiplication we describe two optimizations which produce code that is 10 - 15 times faster on the average. Finally, we propose {{a few simple}} RISC instructions which would allow efficient execution of interval arithmetic and narrowing routines. These new instructions require a new rounding mode which extends the "round-toward-infinity" mode of the IEEE 754 floating point standard. 1 Introduction One {{of the most exciting}} advances in Constraint Logic Programming {{over the last few years}} has been the development of <b>arithmetic</b> <b>constraint</b> solvers based on relational interval arithmetic [1],[10],[3], [6],[11]. These solvers all rely on various types of narrowing procedures for solving the constraints. In this paper we take a close look at the narrowing procedure for the most basic non-trivial constraint, the multiplication relation x [...] ...|$|E
40|$|Recent {{developments}} in termination analysis for declarative programs emphasize {{the use of}} appropriate models for the logical theory representing the program at stake as a generic approach to prove termination of declarative programs. In this setting, Order-Sorted First-Order Logic provides a powerful framework to represent declarative programs. It also provides a target logic to obtain models for other logics via transformations. We investigate the automatic generation of numerical models for order-sorted first-order logics and its use in program analysis, in particular in termination analysis of declarative programs. We use convex domains to give domains to the different sorts of an order-sorted signature; we interpret the ranked symbols of sorted signatures by means of appropriately adapted convex matrix interpretations. Such numerical interpretations {{permit the use of}} existing algorithms and tools from linear algebra and <b>arithmetic</b> <b>constraint</b> solving to synthesize the models. Comment: In Proceedings PROLE 2015, arXiv: 1512. 0617...|$|E
40|$|We {{investigate}} different solution {{techniques for}} solving a basic part of configuration problems, namely linear <b>arithmetic</b> <b>constraints</b> over integer variables. Approaches include integer programming, constraint programming over finite domains and hybrid techniques. We also discuss important {{extensions of the}} basic problem and how these can be accommodated in the different solution approaches. ...|$|R
40|$|Acyclic {{constraint}} satisfaction problems with <b>arithmetic</b> <b>constraints</b> and domains consisting of sets of disjoint intervals have exponential complexity, since disjunctions of intervals may be introduced while propagating through the constraints. This has prompted many researchers to use approximations on {{the bounds of}} sets of intervals, resulting in sound, but incomplete, algorithms. We delineate the complexity of propagation of sets of intervals through <b>arithmetic</b> <b>constraints.</b> For many types of constraint networks, our analysis shows linear, rather than exponential, complexity bounds. Furthermore, exponential complexity is a worst-case scenario that is surprisingly hard to achieve. In some cases, the number of disjoint intervals in the output of an acyclic {{constraint satisfaction}} problem is independent {{of the number of}} disjoint intervals in the input. Some empirical results are presented, showing that the worst-case bound is not achieved for random intervals. 1 Introducti [...] ...|$|R
40|$|Table Constraints {{are very}} useful for {{modeling}} combinatorial problems in Constraint Programming (CP). They are a universal mechanism for representing constraints, but unfortunately {{the size of}} their tables can grow exponentially with their arities. In this paper, we propose to authorize entries in tables to contain simple <b>arithmetic</b> <b>constraints,</b> replacing classical tuples of values by so-called smart tuples. Smart table constraints can thus be viewed as logical combinations of those simple <b>arithmetic</b> <b>constraints.</b> This new form of tuples allows us to encode compactly many constraints, including a dozen of well-known global constraints. We show that, under a very reasonable assumption about the acyclicity of smart tuples, a Generalized Arc Consistency algorithm of low time complexity can be devised. Our experimental results demonstrate that the smart table constraint is a highly promising general purpose tool for CP...|$|R
