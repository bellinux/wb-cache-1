700|391|Public
5000|$|<b>Algebraic</b> <b>specification,</b> is a {{software}} engineering technique for formally specifying system behavior. <b>Algebraic</b> <b>specification</b> seeks to systematically develop more efficient programs by: ...|$|E
50|$|Another {{well-known}} {{approach to}} formal specification is <b>algebraic</b> <b>specification.</b>|$|E
50|$|Consider {{a formal}} <b>algebraic</b> <b>specification</b> for the boolean data type.|$|E
40|$|More {{than two}} decades ago, Peter Freyd {{introduced}} essentially <b>algebraic</b> <b>specifications,</b> a well-behaved generalization of <b>algebraic</b> <b>specifications,</b> allowing for equational partiality. These essentially <b>algebraic</b> <b>specifications</b> {{turn out to have}} a number of very interesting applications in computer science...|$|R
40|$|Abstract computable {{functions}} {{are defined by}} abstract finite deterministic algorithms on manysorted algebras. We show that there exist finite universal <b>algebraic</b> <b>specifications</b> that specify uniquely (up to isomorphism) (i) all absract computable functions on any many-sorted algebra; and (ii) all functions effectively approximable by abstract computable functions on any metric algebra. We show that there exist universal <b>algebraic</b> <b>specifications</b> for all the classically computable functions on the set R of real numbers. The <b>algebraic</b> <b>specifications</b> used are mainly bounded universal equations and conditional equations. We investigate the initial algebra semantics of these specifications, and derive situations where <b>algebraic</b> <b>specifications</b> define precisely the computable functions...|$|R
40|$|A {{long lasting}} myth of formal methods {{is that they}} are {{difficult}} to learn and expensive to apply. This paper reports a controlled experiment to test if this myth is true or false in the context of writing <b>algebraic</b> formal <b>specifications.</b> The experiment shows that writing <b>algebraic</b> <b>specifications</b> for software components can be learnt by ordinary university students. It does not heavily depend on mathematical knowledge and skills. Moreover, it is not time consuming to write <b>algebraic</b> <b>specifications</b> for software components...|$|R
5000|$|J. A. Bergstra, J. Heering and P. Klint (editors), <b>Algebraic</b> <b>Specification,</b> Addison Wesley, 1989.|$|E
50|$|The <b>algebraic</b> <b>specification</b> {{therefore}} describes {{all possible}} {{states of the}} data element, and all possible transitions between states.|$|E
5000|$|Martin Wirsing: <b>Algebraic</b> <b>Specification.</b> In: J. van Leeuwen (ed.): Handbook of Theoretical Computer Science, Amsterdam, North-Holland, 1990, pp. 675-788 (...) ...|$|E
40|$|Abstract. From {{the range}} of {{techniques}} available for <b>algebraic</b> <b>specifications</b> we select a core set of features which we define to be the elementary <b>algebraic</b> <b>specifications.</b> These include equational specifications with hidden functions and sorts and initial algebra semantics. We give an elementary equational specification of the field operations and conjugation operator on the rational complex numbers Q(i) and discuss some open problems...|$|R
40|$|<b>Algebraic</b> <b>specifications</b> of {{data types}} provide a natural basis for testing data types implementations. In this framework, the {{conformance}} relation {{is based on}} the satisfaction of axioms. This makes it possible to formally state the fundamental concepts of testing: exhaustive test set, testability hypotheses, oracle. Various criteria for selecting finite test sets have been proposed. They depend on the form of the axioms, and on the possibilities of observation of the implementation under test. This last point is related to the well-known oracle problem. As the main interest of <b>algebraic</b> <b>specifications</b> is data type abstraction, testing a concrete implementation raises the issue of the gap between the abstract description and the concrete representation. The observational semantics of <b>algebraic</b> <b>specifications</b> bring solutions {{on the basis of the}} so-called observable contexts. After a description of testing methods based on <b>algebraic</b> <b>specifications,</b> the chapter gives a brief presentation of some tools and case studies, and presents some applications to other formal methods involving datatypes...|$|R
40|$|More {{than two}} decades ago, Peter Freyd {{introduced}} essentially <b>algebraic</b> <b>specifications,</b> a well-behaved generalization of <b>algebraic</b> <b>specifications,</b> allowing for equational partiality. These essentially <b>algebraic</b> <b>specifications</b> {{turn out to have}} a number of very interesting applications in computer science. In this paper, we present a deduction system for essentially <b>algebraic</b> <b>specifications</b> that is very suitable as the underlying deduction system of an automated theorem prover. Using the well-known fact that theories of sketches can be constructed as initial algebras of essentially <b>algebraic</b> <b>specifications,</b> we describe a semi-automatic procedure for proving the equivalence of the theories of two sketches. Next, we demonstrate that sketches are a very suitable formalism for making semantic data specifications, as used in database design and software engineering. Two such data specifications are semantically equivalent iff their model categories in FinSet are equivalent. Equivalence of theories is a sufficient condition for semantical equivalence, and hence the procedure to prove the equivalence of the theories of sketches {{can be used as a}} powerful tool to prove semantical equivalence of data specifications. Proving semantical equivalence of data specifications is an important component of the view integration process, i. e. the process of integrating a number of partly overlapping data specifications into one large data specification. (C) 1997 Elsevier Science B. V. status: publishe...|$|R
50|$|The Common <b>Algebraic</b> <b>Specification</b> Language (CASL) is a {{general-purpose}} {{specification language}} based on first-order logic with induction. Partial functions and subsorting are also supported.|$|E
50|$|The ASF+SDF Meta-Environment is an IDE and toolset for {{interactive}} program analysis and transformation. It combines SDF (Syntax Definition Formalism), ASF (<b>Algebraic</b> <b>Specification</b> Formalism) and other technologies.|$|E
50|$|One {{part of this}} field, {{known as}} {{algebraic}} semiotics, combines aspects of <b>algebraic</b> <b>specification</b> and social semiotics, and {{has been applied to}} user interface design and to the representation of mathematical proofs.|$|E
40|$|AbstractMore {{than two}} decades ago, Peter Freyd {{introduced}} essentially <b>algebraic</b> <b>specifications,</b> a well-behaved generalization of <b>algebraic</b> <b>specifications,</b> allowing for equational partiality. These essentially <b>algebraic</b> <b>specifications</b> {{turn out to have}} a number of very interesting applications in computer science. In this paper, we present a deduction system for essentially <b>algebraic</b> <b>specifications</b> that is very suitable as the underlying deduction system of an automated theorem prover. Using the well-known fact that theories of sketches can be constructed as initial algebras of essentially <b>algebraic</b> <b>specifications,</b> we describe a semi-automatic procedure for proving the equivalence of the theories of two sketches. Next, we demonstrate that sketches are a very suitable formalism for making semantic data specifications, as used in database design and software engineering. Two such data specifications are semantically equivalent iff their model categories in FinSet are equivalent. Equivalence of theories is a sufficient condition for semantical equivalence, and hence the procedure to prove the equivalence of the theories of sketches {{can be used as a}} powerful tool to prove semantical equivalence of data specifications. Proving semantical equivalence of data specifications is an important component of the view integration process, i. e. the process of integrating a number of partly overlapping data specifications into one large data specification...|$|R
40|$|From {{the range}} of {{techniques}} available for <b>algebraic</b> <b>specifications</b> we select a core set of features which we define to the elementary <b>algebraic</b> <b>specifications.</b> These include equational specifications with hidden functions and sorts and initial algebra semantics. We give an elementary equational specification of the field operations and conjugation operator on the rational complex numbers Q(i) and discuss some open problems. For Joseph Goguen...|$|R
40|$|Abstract – A {{long lasting}} myth of formal methods {{is that they}} are {{difficult}} to learn and expensive to apply. This paper reports a controlled experiment to test if this myth is true or false in the context of writing <b>algebraic</b> formal <b>specifications.</b> The experiment shows that writing <b>algebraic</b> <b>specifications</b> for software components can be learnt by ordinary university students. It does not heavily depend on mathematical knowledge and skills. Moreover, it is not time consuming to write <b>algebraic</b> <b>specifications</b> for software components. Keywords–Formal methods; Algebraic specification; Software components; Learnability; Cost and expense...|$|R
5000|$|An <b>algebraic</b> <b>specification</b> {{achieves}} {{these goals}} by defining {{one or more}} data types, and specifying a collection of functions that operate on those data types. These functions {{can be divided into}} two classes: ...|$|E
50|$|Sannella {{graduated}} from Yale University, University of California, Berkeley and University of Edinburgh with degrees in computer science. His research interests include: <b>algebraic</b> <b>specification</b> and formal software development, correctness of modular systems, types and functional programming, resource certification for mobile code.|$|E
5000|$|Common <b>Algebraic</b> <b>Specification</b> Language is {{a general}} logic-based {{specification}} language developed within the IFIP working group 1.3 [...] "Foundations of System Specifications" [...] and functions as a de facto standard {{in the area of}} software specifications. It is now being applied to ontology specifications in order to provide modularity and structuring mechanisms.|$|E
40|$|Partiality {{is a fact}} of life, but {{at present}} {{explicitly}} partial <b>algebraic</b> <b>specifications</b> lack tools and have limited proof methods. We propose a sound and complete way to support execution and formal reasoning of explicitly partial <b>algebraic</b> <b>specifications</b> within the total framework of membership equational logic (MEL) which has a high-performance interpeter (Maude) and proving tools. This is accomplished by a sound and complete mapping PMEL ! MEL of partial membership equational (PMEL) theories into total ones...|$|R
40|$|This paper {{presents}} a mechanizable framework for specifying, developing, and reasoning about complex systems. The framework combines features from <b>algebraic</b> <b>specifications,</b> abstract state machines, and refinement calculus, all couched in a categorical setting. In particular, we show how to extend <b>algebraic</b> <b>specifications</b> to evolving specifications (especs) {{in such a}} way that composition and refinement operations extend to capture the dynamics of evolving, adaptive, and self-adaptive software development, while remaining efficiently computable. The framework is partially implemented in the Epoxi system...|$|R
40|$|E. A. van der Meulen CWI, P. O. Box 4079, 1009 AB Amsterdam, The Netherlands. Tel: + 31 20 5924007 Email: emma@cwi. nl Abstract In a {{previous}} paper we described how an incremental implementation {{can be derived}} from <b>algebraic</b> <b>specifications</b> belonging to the subclass of well-presented primitive recursive schemes. We combined term rewriting with techniques for storage and re-use from attribute grammars. Type check specifications typically belong to the class of primitive recursive schemes. The uniformity of <b>algebraic</b> <b>specifications</b> allows us to generalize our incremental algorithms to functions on values of auxiliary data types, without extending or modifying the specification language. Thus, we can obtain fine-grain incremental implementations. This fine-grain incrementality {{can be derived from}} a subclass of <b>algebraic</b> <b>specifications</b> that we will call layered primitive recursive schemes. A fine-grain incremental implementation of a table data type can solve the problem caused by a [...] ...|$|R
50|$|Hans-Jörg Kreowski (born August 10, 1949) is a {{professor}} for computer science at the University of Bremen in North West Germany. His primary research area is theoretical computer science {{with an emphasis on}} graph transformation, <b>algebraic</b> <b>specification,</b> and syntactic picture processing. He {{is also a member of}} the Forum of Computer Scientists for Peace and Social Responsibility (FIfF).|$|E
5000|$|One {{possible}} <b>algebraic</b> <b>specification</b> {{may provide}} two constructor functions for the data-element: a true constructor and a false constructor. Thus, a boolean data element could be declared, constructed, and initialized to a value. In this scenario, all other connective elements, such as XOR and AND, would be additional functions. Thus, a data element could be instantiated with either [...] "true" [...] or [...] "false" [...] value, and additional functions {{could be used}} to perform any operation on the data element.|$|E
50|$|The Larch {{family was}} {{developed}} {{primarily in the}} United States in the 1980s and 1990s, involving researchers at Xerox PARC, DEC/SRC, MIT, and other places. Unlike the Z notation, the Larch family has one language for <b>algebraic</b> <b>specification</b> of abstract data types (LSL, the Larch Shared Language), and a separate interface language tailored to each language in which programs are to be written (Modula-3, C, Smalltalk, etc.). The Larch project also developed tools to {{support the use of}} formal specifications, including LP, the Larch Prover.|$|E
40|$|Abstract. <b>Algebraic</b> <b>specifications</b> of {{data types}} provide a natural basis for testing data types implementations. In this framework, the confor-mance {{relation}} {{is based on}} the satisfaction of axioms. This makes it possible to formally state the fundamental concepts of testing: exhaus-tive test set, testability hypotheses, oracle. Various criteria for selecting finite test sets have been proposed. They depend on the form of the axioms, and on the possibilities of observation of the implementation under test. This last point is related to the well-known oracle problem. As the main interest of <b>algebraic</b> <b>specifications</b> is data type abstraction, testing a concrete implementation raises the is-sue of the gap between abstract description and concrete representation. The observational approaches of <b>algebraic</b> <b>specifications</b> bring solutions {{on the basis of the}} so-called observable contexts. After a description of these methods, the chapter gives a brief presen-tation of some tools and case studies, and presents some applications to other formal methods involving data types...|$|R
40|$|Abstract. Although {{sophisticated}} languages {{have been}} proposed for defining <b>algebraic</b> <b>specifications,</b> the relationships with OO implementations that have been established so far are restricted to very simple cases. Key aspects at the specification side s. a. genericity and subsorting are not covered, although they have obvious counterparts in OO programming that are extremely useful and popular. In this paper we establish a connection between <b>algebraic</b> <b>specifications</b> and objectoriented programs that takes these two aspects into account. More precisely, we propose an interpretation of specifications involving subsorting and parametrisation in terms of Java programs useful for defining a notion of conformance. This connection paves {{the way for the}} extension of CONGU, a tool-based approach we have been developing to support runtime checking of Java programs against <b>algebraic</b> <b>specifications,</b> so that it becomes applicable to a more comprehensive range of situations, namely those that appear {{in the context of a}} typical Algorithms and Data Structures course. ...|$|R
40|$|International audienceAlgebraic {{specifications}} of {{data types}} provide a natural basis for testing data types implementations. In this framework, the conformance relation {{is based on}} the satisfaction of axioms. This makes it possible to formally state the fundamental concepts of testing: exhaustive test set, testability hypotheses, oracle. Various criteria for selecting finite test sets have been proposed. They depend on the form of the axioms, and on the possibilities of observation of the implementation under test. This last point is related to the well-known oracle problem. As the main interest of <b>algebraic</b> <b>specifications</b> is data type abstraction, testing a concrete implementation raises the issue of the gap between the abstract description and the concrete representation. The observational semantics of <b>algebraic</b> <b>specifications</b> bring solutions {{on the basis of the}} so-called observable contexts. After a description of testing methods based on <b>algebraic</b> <b>specifications,</b> the chapter gives a brief presentation of some tools and case studies, and presents some applications to other formal methods involving datatypes...|$|R
50|$|In {{computer}} science, coalgebra {{has emerged}} as a convenient and suitably general way of specifying the behaviour of systems and data structures that are potentially infinite, for example classes in object-oriented programming, streams and transition systems. While <b>algebraic</b> <b>specification</b> deals with functional behaviour, typically using inductive datatypes generated by constructors, coalgebraic specification is concerned with behaviour modelled by coinductive process types that are observable by selectors, much in the spirit of automata theory. An important role is played here by final coalgebras, which are complete sets of possibly infinite behaviours, such as streams. The natural logic to express properties of such systems is coalgebraic modal logic.|$|E
5000|$|Formally, an ADT may {{be defined}} as a [...] "class of objects whose logical {{behavior}} is defined by a set of values and a set of operations"; this is analogous to an algebraic structure in mathematics. What is meant by [...] "behavior" [...] varies by author, with the two main types of formal specifications for behavior being axiomatic (<b>algebraic)</b> <b>specification</b> and an abstract model; these correspond to axiomatic semantics and operational semantics of an abstract machine, respectively. Some authors also include the computational complexity ("cost"), both in terms of time (for computing operations) and space (for representing values). In practice many common data types are not ADTs, as the abstraction is not perfect, and users must be aware of issues like arithmetic overflow that are due to the representation. For example, integers are often stored as fixed width values (32-bit or 64-bit binary numbers), and thus experience integer overflow if the maximum value is exceeded.|$|E
40|$|Essential {{concepts}} of <b>algebraic</b> <b>specification</b> refinement are {{translated into a}} type-theoretic setting involving System F and Reynolds' relational parametricity assertion as expressed in Plotkin and Abadi's logic for parametric polymorphism. At first order, the type-theoretic setting provides a canonical picture of <b>algebraic</b> <b>specification</b> refinement. At higher order, the type-theoretic setting allows future generalisation {{of the principles of}} <b>algebraic</b> <b>specification</b> refinement to higher order and polymorphism. We show the equivalence of the acquired type-theoretic notion of specification refinement with that from <b>algebraic</b> <b>specification.</b> To do this, a generic algebraic-specification strategy for behavioural refinement proofs is mirrored in the type-theoretic setting. 1 Introduction This paper aims to express in type theory certain essential {{concepts of}} <b>algebraic</b> <b>specification</b> refinement. The benefit to <b>algebraic</b> <b>specification</b> is that inherently first-order concepts are tra [...] ...|$|E
40|$|Origin Tracking is a {{technique}} which, {{in the framework of}} first-order term rewriting systems, establishes relations between each subterm t of a normal form and a set of subterms, the origins of t, in the initial term. Origin tracking is based on the notion of residuals. It has been used successfully for the generation of error handlers and debuggers from <b>algebraic</b> <b>specifications</b> of programming languages. Recent experiments with the use of higher-order <b>algebraic</b> <b>specifications</b> for the definition of programming languages, revealed a need to extend origin tracking to higher-order term rewriting systems. This extension is discussed, covering a definition and some alternatives, as well as an assessment with respect to existing specifications. 1 Origin Tracking When <b>algebraic</b> <b>specifications</b> are being executed as term rewriting systems (TRSs), computations are performed by reducing an initial term to its result value [...] - its normal form. Often, it is enough just to compute this result value, [...] ...|$|R
40|$|This article {{describes}} the sophisticated graphical user interface (GUI) of the KIV verification system. KIV is a verification system that works on structured <b>algebraic</b> <b>specifications.</b> The KIV GUI provides means for developing and editing structured <b>algebraic</b> <b>specifications</b> and for developing proofs of theorems. The complete development process is performed through the GUI with two exceptions. For editing the specification files XEmacs is used, and {{for the management of}} the structured <b>algebraic</b> <b>specifications</b> we use daVinci, an extendable graph drawing tool. As proving is the most time-consuming part of formal verification, {{the most important part of}} the KIV GUI is our user interface for proof development. The proof is represented as a tree and can be manipulated through context menus. The main proof work is done in a proof window where the sequent of the current goal, the applicable rules and the main menu are displayed. Which rules are applicable depends on the current goal. KIV also supports the context-sensitive application of proof rules...|$|R
40|$|The {{following}} {{paper is}} a proposal how to compile abstract <b>algebraic</b> <b>specifications</b> into fully concrete specifications where computations are running {{directly in the}} object code. It is assumed that the <b>algebraic</b> <b>specifications</b> are {{in a certain sense}} constructive. This compiler allows the compilation of software systems consisting of mixed abstract (type view) and concrete (imperative view) modules and specified in the #PI#-language into specifications which are described fully concrete (in tems of #PI#: in the imperative view only). (orig.) Available from TIB Hannover: RR 9963 (1) / FIZ - Fachinformationszzentrum Karlsruhe / TIB - Technische InformationsbibliothekSIGLEDEGerman...|$|R
