28|139|Public
40|$|<b>Abstract.</b> <b>Refinement</b> is an {{operation}} of theory change where new or old beliefs (norms) are restricted by some specific condition, {{instead of being}} fully accepted or rejected. We present constructions, based on AGM partial meet contraction and revision, for operators of external, internal and global refinement and show that they satisfy reasonable AGM-like postulates. Then we apply these operators to a hard case and show that global refinement has advantages {{to cope with the}} problem of gaps in normative systems. ...|$|E
40|$|<b>Abstract.</b> <b>Refinement</b> {{types are}} a well-studied manner of {{performing}} in-depth analysis on functional programs. The dependency pair method {{is a very}} powerful method used to prove termination of rewrite systems; however its extension to higher order rewrite systems is still the object of active research. We observe that a variant of refinement types allow us to express a form of higher-order dependency pair criterion that only uses information at the type level, and we prove the correctness of this criterion. ...|$|E
40|$|<b>Abstract.</b> <b>Refinement</b> {{equations}} play {{an important}} role in computer graphics and wavelet analysis. In this paper we investigate multivariate refinement equations associated with a dilation matrix and a finitely supported refinement mask. We characterize the Lp-convergence of a subdivision scheme in terms of the p-norm joint spectral radius of a collection of matrices associated with the refinement mask. In particular, the 2 -norm joint spectral radius can be easily computed by calculating the eigenvalues of a certain linear operator on a finite dimensional linear space. Examples are provided to illustrate the general theory...|$|E
40|$|Communicated by A. Lupa¸s <b>ABSTRACT.</b> New <b>refinements</b> for {{the celebrated}} Hermite-Hadamard {{inequality}} for convex functions are obtained. Applications for special means are pointed out as well. Key words and phrases: Hermite-Hadamard Inequality. 2000 Mathematics Subject Classification. Primary 26 D 15; Secondary 26 D 10...|$|R
40|$|<b>Abstract.</b> A <b>refinement</b> of {{a uniform}} resolvent {{estimate}} is given and several smoothing estimates for Schrödinger equations {{in the critical}} case are induced from it. The relation between this resolvent estimate and a radiation condition is dis-cussed. As an application of critical smoothing estimates, we show a global existence result for derivative nonlinear Schrödinger equations. 1...|$|R
40|$|<b>Abstract.</b> The <b>refinement</b> of the {{partition}} table has improved semaphores, and current trends {{suggest that the}} improvement of public-private key pairs will soon emerge. Given {{the current status of}} cooperative communication, theorists famously desire the natural unification of 802. 11 b and the producer-consumer problem. We disprove that simulated annealing can be made relational, unstable, and certifiable...|$|R
40|$|<b>Abstract.</b> <b>Refinement</b> in bisimulation {{semantics}} {{is defined}} differently from refinement in failure semantics: in bisimulation semantics refinement {{is based on}} simulations between labelled transition systems, whereas in failure semantics refinement is based on inclusions between decorated traces systems. There exist however pairs of refinements, for bisimulation and failure semantics respectively, that have almost the same properties. Furthermore, each refinement in bisimulation semantics implies its counterpart in failure semantics, and conversely each refinement in failure semantics implies its counterpart in bisimulation semantics defined on the canonical form of the compared processes...|$|E
40|$|<b>Abstract.</b> <b>Refinement</b> is {{a method}} to derive correct {{programs}} from specifications. A rich type language {{is another way to}} ensure program correctness. In this paper, we propose a wide-spectrum language mixing both approaches for the ML language. Mainly, base types are simply included into expressions, introducing underdeterminism and dependent types. We focus on the semantic aspects of such a language. We study three different semantics: a denotational, a deterministic operational and a nondeterministic operational semantics. We prove their equivalence. We show that this language is a conservative extension of ML. ...|$|E
40|$|<b>Abstract.</b> <b>Refinement</b> is {{fundamental}} to software development. An earlier work proposed a refinement relation between sequence diagrams basedontheirrequiredbehaviors. Inthispaper,we firstgeneralize therefinement relation by taking into account system variable assignment and event hiding, renaming and substitution. We then give an algorithm as a system of inference rules that does not just verify refinement relationship between twosequence diagrams butalso derives sufficient conditions under which such a relationship holds. The algorithm makes use of a semantics preserving transformation on sequence diagrams. The usefulness of refinement inference is demonstrated with a case study...|$|E
40|$|<b>Abstract.</b> The <b>refinement</b> {{calculus}} {{and type}} theory are both frameworks {{that support the}} specification and verification of programs. This paper presents an embedding of the refinement calculus in the interactive the-orem prover Coq, clarifying {{the relation between the}} two. As a result, refinement calculations can be performed in Coq, enabling the semi-automatic calculation of formally verified programs from their specifica-tion. ...|$|R
40|$|<b>Abstract</b> Several <b>refinements</b> of the Finsler-Hadwiger {{inequality}} and its reverse in the triangle are discussed. A new one parameter family of Finsler-Hadwiger inequalities and their reverses are proved. This {{allows us to}} obtain new bounds for {{the sum of the}} squares of the side lengths of a triangle in terms of other elements in the triangle. Finally, these new bounds are compared to known ones...|$|R
40|$|<b>Abstract.</b> A <b>refinement</b> of Cardelli’s brane {{calculus}} [1] {{is introduced}} where membrane actions are directed. This modification brings the language closer to biological membranes and also obtains a symmetric set of membrane interactions. An associated structural congruence, termed the projective equivalence, is defined and {{shown to be}} preserved under all possible system evolutions. Comparable notions of projective equivalence can be developed in other hierarchical process calculi and might be of interest in other applications. ...|$|R
40|$|<b>Abstract.</b> <b>Refinement</b> is a {{well-established}} and accepted technique for the systematic development of correct software systems. However, for the step from already refined specification to implementation, a correct refinement {{is often not}} possible because the data types used in the specification resp. the implementation language differ. In this paper, we discuss this problem and its consequences, using the integer data types of Java as an example, which do not correctly refine the mathematical integers Z. We present a solution, which {{can be seen as}} a generalisation of refinement and a variant of retrenchment. It has successfully been implemented as part of the KeY software verification system...|$|E
40|$|<b>Abstract.</b> <b>Refinement</b> is a {{well-known}} approach for developing correct-byconstruction software. It has been very successful for producing high quality code e. g., as implemented in the B tool. Yet, such refinement techniques are restricted {{in the sense that}} they forbid aliasing (and more generally sharing of data-structures), which often happens in usual programming languages. We propose a sound approach for refinement in presence of aliases. Suitable abstractions of programs are defined by algebraic data types and the so-called model fields. These are related to concrete program data using coupling invariants. The soundness of the approach relies on methodologies for (1) controlling aliases and (2) checking side-effects, both in a modular way. ...|$|E
40|$|<b>Abstract.</b> <b>Refinement</b> types sharpen {{systems of}} simple and {{dependent}} types by offering expressive means to more precisely classify well-typed terms. Proof irrelevance provides {{a mechanism for}} selectively hiding the identities of terms in type theories. In this paper, we show that refinement types {{can be interpreted as}} predicates using proof irrelevance {{in the context of the}} logical framework LF, establishing a uniform relationship between two previously studied concepts in type theory. The interpretation and its correctness proof are surprisingly complex, lending credence to the idea that refinement types are a fundamental construct rather than just a convenient surface syntax for certain uses of proof irrelevance. ...|$|E
40|$|<b>Abstract.</b> A <b>refinement</b> of Jensen’s {{inequality}} is presented. An extra term {{makes the}} in-equality tighter when the convex function is “superquadratic, ” a strong convexity-type con-dition introduced here. This condition {{is shown to}} be necessary and sufficient for the refined inequality. It is also shown to be strictly intermediate between two points of the scale of convexity from [2]. The refined Jensen’s inequality is used to prove a Minkowski inequality with upper and lower estimates. 1...|$|R
40|$|<b>Abstract</b> Partition <b>refinement</b> {{techniques}} {{are used in}} many algorithms. This tool allows efficient computation of equivalence relations and is somehow dual to union-find algorithms. The goal {{of this paper is}} to propose a single routine to quickly implement all these already known algorithms and to solve a large class of potentially new problems. Our framework yields to a unique scheme for correctness proofs and complexity analysis. Various examples are presented to show the different ways of using this routine...|$|R
40|$|<b>Abstract.</b> <b>Refinements</b> of the Yang–Mills stratifications of {{spaces of}} {{connections}} over a compact Riemann surface Σ are investigated. The motivation {{for this study}} is the search for a complete set of relations between the standard generators for the cohomology of the moduli spaces M(n, d) of stable holomorphic bundles of rank n and degree d when n and d are coprime and n> 2. The moduli space M(n, d) of semistable holomorphic bundles of rank n and degree d over a Riemann surface Σ of genus g ≥ 2 can be constructed as a quotient of an infinite dimensional affine space of connections C(n, d) by a complexified gauge group Gc(n, d), in an infinite-dimensional version of the construction of quotients in Mumford’s geometric invariant theory [30]. When n and d are coprime, M(n, d) is the topological quotient of the semistable subset C(n, d) ss of C(n, d) by the action of Gc(n, d). Any nonsingular complex projective variety on which a complex reductive group G acts linearly has a G-equivariantly perfect stratification by locally closed nonsingular G-invariant subvarieties with its set of semistable points X ss as a...|$|R
40|$|Abstract. In this paper, {{we present}} an {{abstract}} fixpoint checking algorithm with automatic refinement by backward completion in Moore closed abstract domains. We study {{the properties of}} our algorithm and prove it {{to be more precise}} than the counterexample guided <b>abstract</b> <b>refinement</b> algorithm (CEGAR). Contrary to several works in the literature, our algorithm does not require the abstract domains to be partitions of the state space. We also show that our automatic refinement technique is compatible with so-called acceleration techniques. Furthermore, the use of Boolean closed domains does not improve the precision of our algorithm. The algorithm is illustrated by proving properties of programs with nested loops. ...|$|E
40|$|Abstract. We present <b>abstract</b> <b>refinement</b> types which enable {{quantification}} {{over the}} refinements of data- and function-types. Our key insight {{is that we}} can avail of quantification while preserving SMT-based decidability, simply by encoding refinement parameters as uninterpreted propositions within the ground refinement logic. We illustrate how this simple mechanism yields a variety of sophisticated and automatic means for reasoning about programs, including: parametric refinements for reasoning with type classes, index-dependent refinements for reasoning about key-value maps, recursive refinements for reasoning about data structures, and inductive refinements for reasoning about higher-order traversal routines. We have implemented our approach in HSOLVE, a refinement type checker for Haskell, and present experiments using HSOLVE to verify correctness invariants of various programs. ...|$|E
40|$|<b>Abstract.</b> <b>Refinement</b> {{types are}} a well-studied manner of {{performing}} in-depth analysis on functional programs. The dependency pair method {{is a very}} powerful method used to prove termination of rewrite systems; however its extension to higher-order rewrite systems is still the subject of active research. We observe that a variant of refinement types allows us to express a form of higher-order dependency pair method: from the rewrite system labeled with typing information, we build a type-level approximated dependency graph, and describe a type level embeddingorder. We describe a syntactic termination criterion involving the graph and the order, and prove our main result: if the graph passes the criterion, then every well-typed term is strongly normalizing. ...|$|E
40|$|Design {{debugging}} {{is one of}} {{the major}} remaining manual processes in the semiconductor design cycle. Despite recent advances in the area of automated design debugging, more effort is required to cope with the size and complexity of today’s designs. This paper introduces an abstraction and refinement methodology to enable current debuggers to operate on designs that are orders of magnitude larger than otherwise possible. Two abstraction techniques are developed with the goals of improving debugger performance for different circuit structures: State abstraction is aimed at reducing the problem size for circuits consisting purely of primitive gates, while function abstraction focuses on designs that also contain modular and hierarchical information. In both methods, after an initial abstracted model is created, the problem can be solved by an existing automated debugger. If an error site is <b>abstracted,</b> <b>refinement</b> is necessary to reintroduce some of the abstracted components back into the design. This paper also presents the underlying theory to guarantee correctness and completeness of a debugging tool that operates using the proposed methodology. Empirical results demonstrate improvements in run time and memory capacity of two orders of magnitude over a state-of-the-art debugger on a wide range of benchmark and industrial designs...|$|R
40|$|<b>Abstract</b> — <b>Refinement</b> {{is used as}} a way {{to verify}} an {{implementation}} with respect to a specification. States of related systems are linked through a so called gluing invariant which remains always true during the synchronous execution of both systems. Refinement is a sufficient condition for this property. Retrenchment is a generalization of refinement which relax the constraints between both systems. This paper proposes a temporal logic counterpart for some specific forms of retrenchment. Index Terms — refinement, retrenchment, temporal logics, TLA I...|$|R
40|$|<b>Abstract.</b> A <b>refinement</b> {{calculus}} {{provides a}} method for transforming specifica-tions to executable code, maintaining the correctness of the code with respect to its specification. In this paper we extend the refinement calculus for logic programs to include higher-order programming capabilities in specifications and programs, such as procedures as terms and lambda abstraction. We use a higher-order type and term system to describe programs, and provide a semantics for the higher-order language and refinement. The calculus is illustrated by refinement examples. ...|$|R
40|$|Abstract. In {{previous}} work, {{we presented}} a symbolic execution method which {{starts with a}} concrete model of the program but progressively abstracts away details only when these {{are known to be}} irrelevant using interpolation. In this paper, we extend the technique to handle unbounded loops. The central idea is to progressively discover the strongest invariants through a process of loop unrolling. The key feature of this technique, called the minimax algorithm, is intelligent backtracking which directs the search for the next invariant. We then present an analysis of the main differences between our symbolic execution method and mainstream techniques mainly based on <b>abstract</b> <b>refinement</b> (CEGAR). Finally, we evaluate our technique against available state-of-the-art systems. ...|$|E
40|$|<b>Abstract.</b> <b>Refinement</b> type {{systems have}} proved very {{effective}} for security policy verification in distributed authorization systems. In earlier work [12], we have proposed {{an extension of}} existing refinement typing techniques to exploit sub-structural logics and affine typing {{in the analysis of}} resource aware authorization, with policies predicating over access counts, usage bounds and resource consumption. In the present paper, we show that the invariants that we enforced by means of ad-hoc typing mechanisms in our initial proposal can be internalized, and expressed directly as proof obligations for the underlying affine logical system. The new characterization leads to a more general, modular design of the system, and is effective in the analysis of interesting classes of authentication protocols and authorization systems. ...|$|E
40|$|<b>Abstract.</b> <b>Refinement</b> is a {{well-known}} approach for developing correct-by-construction softwares. It has been very successful for producing high quality code e. g. as implemented in the B tool. Yet, such refinement techniques are re-stricted {{in the sense that}} they forbid aliasing (and more generally sharing of data-structures), which happens most of the time in classical programming language such Java, C, etc. We propose an approach for refinement which is sound in presence of aliases. Suitable abstractions of programs are defined by algebraic data types and the so-called model fields. These are related to concrete program data via coupling invariants. A key ingredient for the soundness of the approach is to build upon a methodol-ogy for controlling aliases, based on ownership. Hence, our refinement approach allows also some patterns of data sharing. ...|$|E
40|$|<b>ABSTRACT.</b> A <b>refinement</b> of a {{conjecture}} of Gasper {{concerning the}} values of (a,(3),- 1 / 2 < (3 < 0,- 1 < a + (3 < 0, for which the inequalities n LP~a,i 3) (x) /p~i 3,a) (1) ~ 0,- 1 S; x S; 1, n = 1, 2, [...] . k=O hold, is stated. An algorithm for checking the new conjecture using the package Mathematica is provided. Numerical results {{in support of the}} conjecture are given and a possible approach to its proof is sketched...|$|R
40|$|<b>Abstract.</b> The <b>refinement</b> {{calculus}} is {{a well-established}} theory for formal development of imperative program code and {{is supported by}} a number of automated tools. Via a detailed case study, this article shows how refinement theory and tool support can be extended for a program with real-time constraints. The approach adapts a timed variant of the refinement calculus and makes corresponding enhancements to a theoremprover based refinement tool. Key words: software engineering — real-time programming — formal methods — refinement — verification — tool support...|$|R
40|$|<b>Abstract.</b> Counterexample-guided {{abstraction}} <b>refinement</b> (CEGAR) {{has been}} en vogue for the automatic verification of very large {{systems in the}} past years. When trying to apply CEGAR to the verification of probabilistic systems, various foundational questions arise. This paper explores them {{in the context of}} predicate abstraction. ...|$|R
40|$|<b>Abstract.</b> <b>Refinement</b> is reviewed, {{highlighting}} {{in particular}} the distinction between its use as a specification constructor at a high level, and its use as an implementation mechanism at a low level. Some of its shortcomings as specification constructor at high levels of abstraction are pointed out, and these are used to motivate the adoption of retrenchment for certain high level development steps. Basic properties of retrenchment are described, including a justification of the operation proof obligation, simple examples, its use in requirements engineering and model evolution, and simulation properties. The interaction of retrenchment with refinement notions of correctness is overviewed, as is a range of other technical issues. Two case study scenarios are presented. One is a simple digital redesign control theory problem, the other is {{an overview of the}} application of retrenchment to the Mondex Purse development...|$|E
40|$|This work is {{focusing}} on automatic verification of systems with parallel running processes. We discuss the existing methods and certain possibilities of optimizing them. Existing techniques are essentially based on finding an inductive invariant (for instance using a variant of counterexample-guided <b>abstract</b> <b>refinement</b> (CEGAR)). The effectiveness of these methods depends {{on the size of}} the invariant. In this thesis, we explored the possibility of improving the methods by focusing on finding invariants of minimal size. We implemented a tool that facilitates exploring the space of invariants of the system under scrutiny. Our experimental results show that many practical existing systems indeed have invariants that are much smaller than what can be found by the existing methods. The conjectures and the results of the work will serve as a basis of future research of an efficient method for finding small invariants of parallel systems...|$|E
40|$|State Machines Claus Pahl School of Computer Applications Dublin City University Dublin 9, Ireland cpahl@compapp. dcu. ie <b>Abstract.</b> <b>Refinement</b> is {{the process}} of {{deriving}} specifications on a lower level of abstraction from those on a higher level. A refinement calculus for Abstract State Machines allowing to derive action specifications from another [...] preserving the semantics of the abstract specification [...] will be outlined. Abstract state machines are rephrased as objects with local state. These objects are the structures in which a modal logic of actions is interpreted. Our refinement calculus will be defined on relations between action specifications on different levels of abstraction. 1 Introduction The notation of Abstract State Machines (ASM) [Gur 97] provides means to specify dynamic state-based systems based on state components and transformations on states. We will outline a calculus for refinement of transformations on states which relates specifications on diffe [...] ...|$|E
40|$|<b>Abstract.</b> Step-wise <b>refinement</b> is a {{powerful}} paradigm for developing a complex program from a simple program by adding features incrementally where each feature is an increment in program functionality. Existing works focus on object-oriented representations such as Java or C++ artifacts. For this paradigm {{to be brought to}} the Web, refinement should be realised for XML representations. This paper elaborates on the notion of XML refinement by addressing what and how XML can be refined. These ideas are realised in the XAK language. A Struts application serves to illustrate the approach. ...|$|R
40|$|<b>Abstract.</b> Grain <b>refinement</b> is {{important}} for improving the microstructure and mechanical properties of magnesium alloys. Carbon inoculation is an effective method of grain refinement process for magnesium alloys containing aluminum. In this paper, the C 2 Cl 6 and graphite powder were used as the potential grain refiners for AM 60 and AZ 91 alloys, respectively. The {{results show that the}} microstructure and mechanical properties of these Mg-Al magnesium alloys have been improved with these grain refiners. The mechanism and thermodynamics analyses of grain refinement with carbon inoculation in Mg-Al magnesium alloy have been discussed...|$|R
40|$|<b>Abstract.</b> Lattice <b>refinement</b> in LQC, {{its meaning}} and its {{necessity}} are discussed. The rôle of lattice refinement for the realisation {{of a successful}} inflationary model is explicitly shown. A simple and effective numerical technique to solve the constraint equation for any choice of lattice refinement model is briefly illustrated. Phenomenological and consistency requirements leading to a particular choice of lattice refinement model are presented, while it is subsequently proved that only this choice of lattice refinement leads to a unique factor ordering in the Wheeler-De Witt equation, which is the continuum limit of LQC. 1...|$|R
