2|17|Public
40|$|Propositional Provability Logic was axiomatized in [7]. This logic {{describes}} the behaviour of the <b>arithmetical</b> <b>operator</b> "y is provable". The {{aim of the}} current paper is to provide propositional axiomatizations of the predicate "x is a proof of y" by means of modal logic, {{with the intention of}} meeting some of the needs of computer science...|$|E
40|$|The {{symbolic}} {{representation of}} a number {{should be considered as}} a data structure, and the choice of data structure depends on the arithmetic operations that are to be performed. Numbers are almost universally represented using position based notations based on exponential powers of a base number - usually 10. This representations is computationally efficient for the standard arithmetic operations, but it is not efficient for factorisation. This has led to a common confusion that factorisation is inherently computationally hard. We propose a new representation of the natural numbers based on bags and using the prime successor function as a primitive - prime bags (PBs). This data structure is more efficient for most arithmetic operations, and enables numbers can be efficiently factored. However, it also has the interesting feature that addition appears to be computationally hard. PBs have an interesting alternative interpretation as partitions of numbers represented in the standard way, and this reveals a novel relationship between prime numbers and the partition function. The PB representation can be extended to rational and irrational numbers, and this provides the most direct proof of the irrationality of the square root of 2. I argue that what needs to be ultimately understood is not the peculiar computation complexity properties of the decimal system (e. g. factorisation), but rather what <b>arithmetical</b> <b>operator</b> trade-offs are generally possible. Comment: 10 pages, 1 figur...|$|E
5000|$|Van der Poel, W.L., C.E. Schaap and G. van der Mey. [...] "New <b>Arithmetical</b> <b>Operators</b> in the Theory of Combinators." [...] Proc. Kon. Ned. Akad. v. Wetenschappen, Sept (1980) p. 271-325.|$|R
5000|$|Integer overflows, which {{result in}} {{undefined}} behavior for signed integers in C, are trapped as a run-time error in Swift. Programmers {{can choose to}} allow overflows by using the special <b>arithmetical</b> <b>operators</b> , , , [...] and [...] The properties [...] and [...] are defined in Swift for all integer types {{and can be used}} to safely check for potential overflows, versus relying on constants defined for each type in external libraries.|$|R
40|$|We apply {{interactive}} {{evolutionary computation}} technique to processing images in medical and other fields, analyze its performance of image enhancement, and discuss its capability and further improve-ment. We first show our system scheme {{and the design}} of user interface and then show experimental results of image enhancement. We also propose an idea of new interactive genetic programming that has not only <b>arithmetical</b> <b>operators</b> but also image processing operators in generated mathematical equations to increase its performance for image processing...|$|R
40|$|The Schemata Theory {{analyzes}} {{the effect of}} the selection process, mutation and crossover over the number of individuals that belong to a given schema, within generations. This analysis considers, in its original form, the binary coding and operators. In this article, we present an analogous study, focusing on the real number coding and <b>arithmetical</b> <b>operators.</b> Unfortunately, the conventional schema definition is tightly dependent on discrete alphabets. Therefore, following a generalization of the concept of schema, we present a particular definition that suits better the continuous domain. Using this new definition, we reach an expression simila...|$|R
40|$|Usual applied {{mathematics}} employs three fundamental arithmetical operators: addition, multiplication, and exponentiation. However, for example, transcendental numbers are {{said not to}} be attainable via algebraic combination with these fundamental operators. At the same time, simulation and modelling frequently {{have to rely on}} expensive numerical approximations of the exact solution. The main {{purpose of this article is}} to analyze new fractional <b>arithmetical</b> <b>operators,</b> explore some of their properties, and devise ways of computing them. These new operators may bring new possibilities, for example, in approximation theory and in obtaining closed forms of those approximations and solutions. We show some simple demonstrative examples...|$|R
5000|$|There are a {{large number}} of <b>arithmetical</b> and logical <b>operators,</b> such as , , , , , etc.|$|R
5000|$|The syntax of Ada {{minimizes}} {{choices of}} ways to perform basic operations, and prefers English keywords (such as [...] "or else" [...] and [...] "and then") to symbols (such as [...] "||" [...] and [...] "&&"). Ada uses the basic <b>arithmetical</b> <b>operators</b> [...] "+", [...] "-", [...] "*", and [...] "/", but avoids using other symbols. Code blocks are delimited by words such as [...] "declare", [...] "begin", and [...] "end", where the [...] "end" [...] (in most cases) {{is followed by the}} identifier of the block it closes (e.g., if … end if, loop … end loop). In the case of conditional blocks this avoids a dangling else that could pair with the wrong nested if-expression in other languages like C or Java.|$|R
40|$|Abstract- Machine learning, data mining, {{and several}} related {{research}} areas {{are concerned with}} methods for the automated induction of models and the extraction of patterns from realistic data. Fuzzy classification {{is one of the}} important applications in fuzzy set where values range between 0 and 1. Main objectives of the fuzzy logic and fuzzy set to find a set of fuzzy rules that form a classification model. The set is major advantage of using fuzzy rules for classification applications to maintain transparency as well as high accuracy rate. Fuzzy pattern tree induction introduced as a novel for machine learning method for classification. Pattern tree is a tree-like structure, whose inner nodes are marked with fuzzy logical <b>operators</b> or <b>arithmetical</b> <b>operators</b> and whose leaf nodes are associated with fuzzy terms on input attributes. Pattern tree make use of different aggregation including t-norms and t-conorms. There are two types of Fuzzy Patter...|$|R
40|$|This dataset {{contains}} 33 different spreadsheets (12 artificially created spreadsheets and 21 real-life spreadsheets) and. These spreadsheets contain both <b>arithmetical</b> {{and logical}} <b>operators</b> {{as well as}} the functions SUM and IF. Faulty versions of the spreadsheets (containing single, double and triple faults) were created by randomly selecting formulas and applying mutation operators on them...|$|R
40|$|The {{past decade}} has {{witnessed}} the development of many important declarative languages for knowledge representation and reasoning such as answer set programming (ASP) languages and languages that extend first-order logic. Also, since these languages depend on background solvers, the recent advancements in the efficiency of solvers has positively affected the usability of such languages. This thesis studies extensions of knowledge representation (KR) languages with <b>arithmetical</b> <b>operators</b> and methods to combine different KR languages. With respect to arithmetic in declarative KR languages, we show that existing KR languages suffer from a huge disparity between their expressiveness and their computational power. Therefore, we develop an ideal KR language that captures the complexity class NP for arithmetical search problems and guarantees universality and efficiency for solving such problems. Moreover, we introduce a framework to language-independently combine modules from different KR languages. We study complexity and expressiveness of our framework and develop algorithms to solve modular systems. We define two semantics for modular systems based on (1) a model-theoretical view and (2) an operational view on modular systems. We prove that our two semantics coincide and also develop mechanisms to approximate answers to modular systems using the operational view. We augment our algorithm these approximation mechanisms {{to speed up the}} process of solving modular system. We further generalize our modular framework with supported model semantics that disallows self-justifying models. We show that supported model semantics generalizes our two previous model-theoretical and operational semantics. We compare and contrast the expressiveness of our framework under supported model semantics with another framework for interlinking knowledge bases, i. e., multi-context systems, and prove that supported model semantics generalizes and unifies different semantics of multi-context systems. Motivated by the wide expressiveness of supported models, we also define a new supported equilibrium semantics for multi-context systems and show that supported equilibrium semantics generalizes previous semantics for multi-context systems. Furthermore, we also define supported semantics for propositional programs and show that supported model semnatics generalizes the acclaimed stable model semantics and extends the two celebrated properties of rationality and minimality of intended models beyond the scope of logic programs...|$|R
30|$|The first {{perturbation}} vector (the one multiplying α) is an <b>arithmetical</b> recombination <b>operator,</b> {{while the}} second perturbation vector (the one multiplying β) is a differential mutation. The parameters α and β have a scaling role toward best and arbitrary directions, respectively. A priori knowledge of problem convexity, uni-modality or multi-modality eases the selection of good values of α and β. Unimodal and convex (multimodal and non-convex) fitness landscapes would favor values of α (β) being larger than β (α) to induce in an exploitative (explorative) behavior in both the global and local neighborhood, and to ease the faster convergence. Without a-prior knowledge of the fitness landscape, it is recommendable to use α, β∈ (0, 2) to avoid overshooting while sampling in the search space [25, 26]. Furthermore, note that when α = β and w = 1, the above Differential Evolution {{is equivalent to the}} conventional DE/target-to-best/ 1 strategy [26]; thus, the above algorithm is a generalization in which it considers not only the global population, but also the local neighborhood.|$|R
40|$|AbstractTo {{successfully}} {{identify the}} metamorphic viruses oriented {{from the same}} base, anti-virus software has adopted the code normalization technique to transform the variations to a more uniform signature representation. Current code normal-ization technique focuses on the simplication of the <b>arithmetical</b> or logical <b>operators.</b> In this paper, we introduce a new technique of generating metamorphic viruses by embedding complicated manipulation functions that cannot be normalized into the malicious executables. Using encryption/decryption functions as an example, we present this evasion strategy that malware writers could employ in the future. We demonstrate the strategy’s effec-tiveness in evading detection by current anti-virus technologies. We also discuss the potential mitigation mechanisms. I...|$|R
40|$|Transreal {{arithmetic}} is total, in {{the sense}} that the fundamental operations of addition, subtraction, multiplication and division can be applied to any transreal numbers with the result being a transreal number [1]. In particular division by zero is allowed. It is proved, in [3], that transreal arithmetic is consistent and contains real arithmetic. The entire set of transreal numbers is a total semantics that models all of the semantic values, that is truth values, commonly used in logics, such as the classical, dialetheaic, fuzzy and gap values [2]. By virtue of the totality of transreal arithmetic, these logics can be implemented using total, <b>arithmetical</b> functions, specifically <b>operators,</b> whose domain and counterdomain is the entire set of transreal number...|$|R
40|$|AbstractIn this paper, a new hybrid {{particle}} swarm optimization {{and genetic}} algorithm is proposed to minimize a simplified model of the energy function of the molecule. The proposed algorithm is called Hybrid Particle Swarm Optimization and Genetic Algorithm (HPSOGA). The HPSOGA is based on three mechanisms. The first mechanism is applying the {{particle swarm optimization}} to balance between the exploration and the exploitation process in the proposed algorithm. The second mechanism is the dimensionality reduction process and the population partitioning process by dividing the population into sub-populations and applying the <b>arithmetical</b> crossover <b>operator</b> in each sub-population {{in order to increase}} the diversity of the search in the algorithm. The last mechanism is applied {{in order to avoid the}} premature convergence and avoid trapping in local minima by using the genetic mutation operator in the whole population. Before applying the proposed HPSOGA to minimize the potential energy function of the molecule size, we test it on 13 unconstrained large scale global optimization problems with size up to 1000 dimensions in order to investigate the general performance of the proposed algorithm for solving large scale global optimization problems then we test the proposed algorithm with different molecule sizes with up to 200 dimensions. The proposed algorithm is compared against the standard particle swarm optimization to solve large scale global optimization problems and 9 benchmark algorithms, in order to verify the efficiency of the proposed algorithm for solving molecules potential energy function. The numerical experiment results show that the proposed algorithm is a promising and efficient algorithm and can obtain the global minimum or near global minimum of the molecular energy function faster than the other comparative algorithms...|$|R
40|$|In the Novikov–Krichever {{formula for}} a fourth-order {{operator}} L 4, occurring in a commuting pair of pank two and genus one, {{there is an}} <b>arithmetical</b> error; the <b>operator</b> L 4 has the form (1) L 4 = (d 2 /dx 2 + u) 2 + a d/dx+ d/dx a+ b (one of the terms d/dx a has been omitted), where a = λ′ 1 µ 1 (λ 1 − λ 2), b = −λ 1 − λ 2, λi = ℘(γi), µi = −℘′(γi). For all the quotations and formulas see the paper by Grinevich in this issue. Theorem 1. The operator L 4 is formally symmetric {{if and only if}} a = 0, i. e., λ 1 = λ 2 (the constant γ 0 = 0 modulo the semiperiods of the function ℘). In this case the formulas for the coefficients are strongly simplified: (2) a = 0, b = − 2 λ, where λ = ℘(c(x)), u = 1 4 λ′′ 2 λ′ 2 − 1 2 λ′′...|$|R

