6|10000|Public
5000|$|... #Subtitle level 3: Caller {{identification}} control, on a <b>Call</b> <b>by</b> <b>Call</b> basis - mobile only ...|$|E
40|$|Grants 388 / 99 and 126 / 02, the Wharton Financial Institutions Center, the NSF and the Technion {{funds for}} the {{promotion}} of research and sponsored research. A call center is a service network in which agents provide telephone-based services. Customers that seek these services are delayed in tele-queues. This paper summarizes an analysis of a unique record of call center operations. The data comprise a complete operational history of a small banking call center, <b>call</b> <b>by</b> <b>call,</b> over a full year. Taking the perspective of queueing theory, we decompose the service process into three fundamental components: arrivals, customer abandonment behavior and service durations. Each component involves different basic mathematical structures and requires a different style of statistical analysis. Some of the key empirical results are sketched, along with descriptions of the varied techniques required...|$|E
40|$|The {{fundamental}} issue of quality-of-service (QoS) routing hits triggered {{a lot of}} research during the last few years. However, the proposed Algorithms attempt to route commumication demands only on a <b>call</b> <b>by</b> <b>call</b> basis, without taking into account future traffic. There are nonetheless cases where the traffic profile is known. In this paper, we address this related problem to QoS routing, more specifically, the off-line planning of bandwidth allocation to demands known in advance. Shortest-path routing is the traditional technique applied to this problem [...] However, this can lead to poor network utilization and even congestion. We show how an abstraction technique combined with systematic search algorithms and heuristics derived from artificial intelligence make it possible to solve this problem more efficiently and in much tighter networks, in terms of bandwidth usage. In addition, this abstraction technique also allows to explain during search why some allocation problems are indeed infeasible. Then, the network regions between which bandwidth must be added are then identified...|$|E
5000|$|It {{eliminates}} {{having to}} pass references and then dereference them, when using <b>call</b> <b>by</b> reference (or <b>call</b> <b>by</b> address, or <b>call</b> <b>by</b> sharing).|$|R
50|$|November 19, 2007 Jajah {{launches}} the Jajah Direct service, {{which enables}} users to {{make phone calls}} without having to be next to a computer. Jajah Direct is a phone service {{that allows you to}} make long-distance or international <b>calls</b> <b>by</b> <b>calling</b> a local number, it works with every phone. There are no free calls using this service.|$|R
5000|$|<b>Call</b> <b>by</b> sharing (also {{referred}} to as <b>call</b> <b>by</b> object or <b>call</b> <b>by</b> object-sharing) is an evaluation strategy first named by Barbara Liskov et al. for the language CLU in 1974. It is used by languages such as Python, Iota, Java (for object references), Ruby, JavaScript, Scheme, OCaml, AppleScript, and many others. However, the term [...] "call by sharing" [...] is not in common use; the terminology is inconsistent across different sources. For example, in the Java community, they say that Java is <b>call</b> <b>by</b> value. <b>Call</b> <b>by</b> sharing implies that values in the language are based on objects rather than primitive types, i.e. that all values are [...] "boxed".|$|R
40|$|Abstract—The {{fundamental}} issue of quality-of-service (QoS) routing has triggered {{a lot of}} research during the last few years. However, the proposed algorithms attempt to route communication demands only on a <b>call</b> <b>by</b> <b>call</b> basis, without taking into account future traffic. There are nonetheless cases where the traffic profile is known. In this paper, we address this related problem to QoS routing, more specifically, the off-line planning of bandwidth allocation to demands known in advance. Shortest-path routing is the traditional technique applied to this problem. However, this can lead to poor network utilization and even congestion. We show how an abstraction technique combined with systematic search algorithms and heuristics derived from artificial intelligence make it possible to solve this problem more efficiently and in much tighter networks, in terms of bandwidth usage. In addition, this abstraction technique also allows to explain during search why some allocation problems are indeed infeasible. Then, the network regions between which bandwidth must be added are then identified. Index Terms—Abstraction, constraint satisfaction, constraint-based routing, quality-of-service (QoS) routing, resource allocation. I...|$|E
40|$|A {{call center}} is a service network in which agents provide telephone-based {{services}}. Customers that seek these services are delayed in tele-queues. This paper summarizes an analysis of a unique record of call center operations. The data comprise a complete operational history of a small banking call center, <b>call</b> <b>by</b> <b>call,</b> over a full year. Taking the perspective of queueing theory, we decompose the service process into three fundamental components: arrivals, customer abandonment behavior and service durations. Each component involves different basic mathematical structures and requires a different style of statistical analysis. Some of the key empirical results are sketched, along with descriptions of the varied techniques required. Several statistical techniques are developed for analysis of the basic components. One of these is a test that a point process is a Poisson process. Another involves estimation of the mean function in a nonparametric regression with lognormal errors. A new graphical technique is introduced for nonparametric hazard rate estimation with censored data. Models are developed and implemented for forecasting of Poisson arrival rates. We then survey how the characteristics deduced from the statistical analyses form the building blocks for theoretically interesting and practically useful mathematical models for call center operations. Key Words: call centers, queueing theory, lognormal distribution, inhomogeneous Poisson process, censored data, human patience, prediction of Poisson rates, Khintchine-Pollaczek formula, service times, arrival rate, abandonment rate, multiserver queues. ...|$|E
40|$|AN ovel concept behind {{cellular}} {{and personal}} communication systems is the frequency reuse principle. Under this principle, various channel assignment (CA) algorithms are formulated for spectral management. A good CA algorithm {{is required to}} maximize through-put performance while link quality is guaranteed to satisfy some minimum requirement. As the cell sizes are shrinking down {{to the order of}} few hundred meters, CA algorithms for future personal communication systems (PCS) may have good chance to encounter rather drastic changes in traffic patterns, both temporally and spatially. Clearly, conventional fixed channel assignment (FCA) schemes, whose performance is at best when traffic pattern is statistically static, will not function well under such circumstances. Indeed, Dynamic Channel Assignment (DCA) schemes with markov allocation, which assign channels in a <b>call</b> <b>by</b> <b>call</b> basis and whose assignment schemes follow changes of traffic patterns, have been demonstrated to outperform FCA schemes in throughput performance in the scenario of dynamic traffic patterns. Like FCA schemes, CA decision making in conventional DCA schemes is centralized. This can be a major factor to hinder DCA schemes be useful for PCS as the complexity of DCA schemes can become prohibitively high when sizes of PCS are large. More recently, distributed DCA (DDCA) schemes, where CA decision making is distributed at every cell site, have been proposed. Clearly, the complexity of DDCA algorithms is invariant to PCS sizes. Since every base station is capable in making CA decision, DDCA algorithms can adapt to dynamic traffic, and can resolve cellular traffic congestion in a timely manner. There have been two lines of research in the formulation of DDCA schemes. One with the use of on-line measurements and another with pre evaluation of compatibility constraints, making use of statistical assessment of propagational environment. In the case of on-line meaurements, the way to incorporate efficient channel search strategies utilised in conventional CA schemes is yet unknown. On the other hand, the schemes with pre evaluated compatibility constraints utilise values of constraints, which are worst case parameters, and hence there is a, tendency to waste the precise spectral resources. In the project presented in this thesis, an alternative to the fixed compatibility constraint is investigated. In this approach, compatibility constraints are adaptive to the temporal and spatial variations of traffic. Such adaptivity is achieved with the use of "Fuzzy Theory". Depending on the prevailing traffic conditions, the new class of algorithms observe an aggressive policy where the worst case compatibility constraints are violated to increase the throughput. No channel rearrangements are assumed. The computational and implemen-tational complexities of this class of algorithms are more or less similar to the conventional DCA algorithms, but are able to achieve incredibly higher throughput compared to such convetional algorithms. Though there is a trade off with the quality in terms of the probability of bad links, the grade of service (a function of througput and quality) is found to be better than any conventional DCA algorithms executed without channel rearrangements. The formulations assume a distributed implementation. Each of the base stations maintain a local database of small sizes (information with regard to the channel occupancy patterns, at most for 18 neighbouring cells and the host cell). Each base stat ion can carry out channel assignment autonomously and information exchange is only with the set of neighbour base stations causing significant interference. The new class of algorithms is termed Aggressive Fuzzy Distributed Dynamic Channel Assignment (AFDDCA) algorithms. Several varients are formulated and studied via simulations...|$|E
40|$|We {{demonstrate}} how {{to model the}} following common programmingsconstructs {{in terms of an}} applicative order language similar to LISP: Simple Recursion, Iteration, Compound Statements and Expressions, GO TO and Assignment, Continuation-Passing, Escape Expressions, Fluid Variables, <b>Call</b> <b>by</b> Name, <b>Call</b> <b>by</b> Need, and <b>Call</b> <b>by</b> Reference. The models require only (possibly self-referent) lambda application, conditionals, and (rarely) assignment. No complex data structures such as stacks are used. The models are transparent, involving only local syntactic transformations. This paper is partly tutorial in intent, gathering all the models together for purposes of context...|$|R
50|$|Google Voice {{uses the}} caller's Google Voice number as the CLID on {{outgoing}} calls when the user places a <b>call</b> <b>by</b> <b>calling</b> the user's own Google Voice number {{and using the}} service's menu choices, or when the web-based account portal is used to place a call. With {{the introduction of the}} Google Voice application on iPhone, Android and BlackBerry phones, Google Voice users can directly dial from the Google Voice app with their Google Voice number as the outgoing CLID.|$|R
5000|$|... unlink (...) : the {{underlying}} system <b>call</b> <b>called</b> <b>by</b> this user space program for its main functionality ...|$|R
50|$|When the {{reference}} is {{passed to the}} callee uninitialized, this evaluation strategy may be <b>called</b> <b>call</b> <b>by</b> result.|$|R
50|$|Likewise, the {{operational}} semantics of simply typed lambda calculus {{can be fixed}} as for the untyped lambda calculus, using <b>call</b> <b>by</b> name, <b>call</b> <b>by</b> value, or other evaluation strategies. As for any typed language, type safety is a fundamental property {{of all of these}} evaluation strategies. Additionally, the strong normalization property described below implies that any evaluation strategy will terminate on all simply typed terms.|$|R
5000|$|... 1) A Context Imported task or {{function}} can access (read or write) any SystemVerilog data object <b>by</b> <b>calling</b> (PLI/VPI) or <b>by</b> <b>calling</b> Export task {{or function}}. Therefore, {{a call to}} Context task or function is a barrier for SystemVerilog compiler optimization.|$|R
2500|$|When news of Borland's {{situation}} reached Little Rock, {{the state}} Military Board responded to Borland's <b>call</b> for aid <b>by</b> <b>calling</b> out the 8th Militia Brigade {{under the command}} of Brig. Gen. Phillips: ...|$|R
40|$|The formal {{definition}} of the syntax and semantics of A Parameter Passing Language (APPL) is presented. APPL is a simple, nested structure language which permits the communication of parameters between a main program and a subroutine using <b>call</b> <b>by</b> reference, <b>call</b> <b>by</b> value, or <b>call</b> <b>by</b> name. The methodology and techniques of the Vienna Definition Language {{are used in the}} formalization of APPL. The syntactic {{definition of}} APPL consists of phrase structure grammars for concrete and abstract representations of valid APPL programs. The semantic definition of APPL is in terms of an abstract machine which interprets abstract programs. The machine specification consists of the machine state components and a trasition function that maps states into successor states. The semantics of various parameter passing mechanisms is thus formalized as the sequenceof machine states assumed by the abstract machine during the interpretation of abstract programs...|$|R
50|$|The {{mechanism}} of references, if varying in implementation, {{is a fundamental}} programming language feature common to nearly all modern programming languages. Even some languages that support no direct use of references have some internal or implicit use. For example, the <b>call</b> <b>by</b> reference <b>calling</b> convention can be implemented with either explicit or implicit use of references.|$|R
50|$|For {{immutable}} objects, {{there is}} no real difference between <b>call</b> <b>by</b> sharing and <b>call</b> <b>by</b> value, except if object identity is visible in the language. The use of <b>call</b> <b>by</b> sharing with mutable objects is an alternative to input/output parameters: the parameter is not assigned to (the argument is not overwritten and object identity is not changed), but the object (argument) is mutated.|$|R
40|$|Variables and substitutions Free {{and bound}} {{variables}} Subterms and substitution Grafting and substitution Ordered {{list of variables}} Identifying terms modulo bound variables Syntactic identity revised Exercises ◮ Aims To acquaint the students with the syntax and semantics of lambda calculus and reduction strategies. Solving mutually recursive equations and fixed point theorems. Substitution, <b>call</b> <b>by</b> name, <b>call</b> <b>by</b> value, termination. ◮ Learning Outcomes Competence in lambda calculus, different variable techniques (de Bruijn indices, combinator variables), semantics of small programs...|$|R
5000|$|There are now two control rooms {{currently}} operating for NEAS. Bernicia House (Newcastle upon Tyne); Russell House (Hebburn) 999 emergency {{calls and}} NHS 111 urgent care <b>calls</b> are answered <b>by</b> <b>call</b> takers at all two sites. The Patient Transport Service <b>calls</b> are answered <b>by</b> the <b>call</b> takers primarily HQ, ...|$|R
5000|$|... (2) {{calls to}} the federal {{customer}} service call center, including the number of <b>calls</b> received <b>by</b> the <b>call</b> center, problems identified <b>by</b> users, and referrals of those calls; ...|$|R
50|$|In {{practical}} terms, {{many modern}} programming languages have converged on a call-by-value/call-by-reference evaluation strategy for function calls (C#, Java). Some languages, especially lower-level languages such as C++, combine several notions of parameter passing. Historically, <b>call</b> <b>by</b> value and <b>call</b> <b>by</b> name {{date back to}} ALGOL 60, a language designed in the late 1950s. <b>Call</b> <b>by</b> reference is used by PL/I and some Fortran systems. Purely functional languages like Haskell, as well as non-purely functional languages like R, use <b>call</b> <b>by</b> need.|$|R
50|$|Programming {{languages}} {{that employ}} <b>call</b> <b>by</b> value semantics provide a called subroutine {{with its own}} local copy of the arguments passed to it. In most languages, these local parameters are treated the same as other local variables within the subroutine. In contrast, <b>call</b> <b>by</b> reference and <b>call</b> <b>by</b> name semantics allow the parameters to act as aliases of the values passed as arguments, allowing the subroutine to modify variables outside its own scope.|$|R
5000|$|In some cases, {{the term}} [...] "call by value" [...] is problematic, as the value which is passed {{is not the}} value of the {{variable}} as understood by the ordinary meaning of value, but an implementation-specific reference to the value. The effect is that what syntactically looks like <b>call</b> <b>by</b> value may end up rather behaving like <b>call</b> <b>by</b> reference or <b>call</b> <b>by</b> sharing, often depending on very subtle aspects of the language semantics.|$|R
50|$|ECL was an {{interactive}} system where programs were represented within the system; {{there was a}} compatible compiler and interpreter. It had an ALGOL-like syntax and an extensible data type system, with data types as first-class citizens. Data objects were values, not references, and the calling conventions gave a choice between <b>call</b> <b>by</b> value and <b>call</b> <b>by</b> reference for each argument.|$|R
40|$|For a long time, I {{have liked}} to compare the parameter-passing modes of Algol 60 (some of you are {{probably}} old enough to remember) with speakers at scientific conferences. Namely, <b>call</b> <b>by</b> value vs. <b>call</b> <b>by</b> name in Algol, and authors of regular papers vs. invited speakers at conferences. This time I am {{lucky enough to be}} in the latter category; I also used to sa...|$|R
25|$|Components are <b>called</b> <b>by</b> {{assigning}} their <b>calls</b> to named component instances. Names {{cannot be}} re-used {{within a single}} workflow. There are special components for input files that include external files to the script. Supported atomic types are integer, float, boolean and string, and typing is done implicitly.|$|R
5000|$|Jensens device {{relies on}} <b>call</b> <b>by</b> name, but <b>call</b> <b>by</b> name is subtle and has some problems. Consequently, <b>call</b> <b>by</b> {{name is not}} {{available}} in most languages. Knuth comments that ALGOL 60 cannot express an [...] procedure that increases its argument <b>by</b> one; the <b>call</b> [...] does not do the expected action if [...] is a functional that changes with each access. Knuth says, [...] "The use of macro definition facilities to extend language, instead of relying solely on procedures for this purpose, results in a more satisfactory running program." ...|$|R
5000|$|As {{with all}} unix-like commands, the options are {{specific}} to the version of mount and are precisely detailed in its man page. In addition to the system call mount, the function mount_root (...) mounts the first, or root filesystem. In this context mount is <b>called</b> <b>by</b> the system <b>call</b> setup.|$|R
50|$|Conventions happen {{every five}} years, {{the length of}} the officers' terms. Special {{conventions}} can be <b>called</b> <b>by</b> a 40% <b>call</b> from members in good standing. The members of the executive board (president, vice president, secretary-treasurer, and four elected trustees) do not have power to overrule votes by delegates at convention.|$|R
50|$|To {{implement}} the head reduction of a term u v {{which is an}} application, but {{which is not a}} redex, one must reduce the body u to exhibit an abstraction and therefore create a redex with v. When a redex appears, one reduces it. To reduce always the body of an application first is <b>called</b> <b>call</b> <b>by</b> name. The Krivine machine implements <b>call</b> <b>by</b> name.|$|R
40|$|AbstractCall <b>by</b> {{value and}} <b>call</b> <b>by</b> name have some {{subtleties}} {{when used in}} a nondeterministic programming language. A common formalism is used to establish the denotational semantics of recursive programs <b>called</b> <b>by</b> name and <b>called</b> <b>by</b> value. Ashcroft and Hennessy introduced the idea of differentiating between selecting arguments from a set of arguments {{at the point of}} invocation and selecting arguments during the run of the procedure. This distinction is shown to be independent of the evaluation according to value or name, giving rise to four possible parameter passing methods, all of which have a suitable least fixed point semantics...|$|R
40|$|VG call(s) continuous, loud 4 -noted {{advertising}} <b>by</b> one bird, VG <b>call(s)</b> continuous, rolling nest <b>call</b> <b>by</b> another, VG <b>call(s)</b> continuous, {{advertising and}} rolling nest -same two, VG miscellaneous(s) wing noise as one bird jumps at other, G call(s) continuous, soft churring growl <b>by</b> third bird, VG <b>call(s)</b> continuous, advertising and rolling nest -same tw...|$|R
40|$|A fixed-point {{characterization}} of the inside-out (IO) and outside-in (OI) context-free tree languages is given. This characterization is used to obtain a theory of nondeterministic systems of context-free equations with parameters. Several “Mezei-and-Wright-like” results are obtained which relate the context-free tree languages to recognizable tree languages and to nondeterministic recursive program(scheme) s (<b>called</b> <b>by</b> value and <b>called</b> <b>by</b> name). Closure properties of the context-free tree languages are discussed. Hierarchies of higher level equational subsets of an algebra are considered...|$|R
50|$|The {{notion of}} the {{categorical}} abstract machine arose in the mid-1980s. It took its place in computer science {{as a kind of}} theory of computation for programmers, represented by Cartesian closed category and embedded into the combinatory logic. CAM is a transparent and sound mathematical representation for the languages of functional programming. The machine code can be optimized using the equational form of a theory of computation. Using CAM, the various mechanisms of computation such as recursion or lazy evaluation can be emulated as well as parameter passing, such as <b>call</b> <b>by</b> name, <b>call</b> <b>by</b> value, and so on. In theory, CAM preserves all the advantages of object approach towards programming or computing.|$|R
