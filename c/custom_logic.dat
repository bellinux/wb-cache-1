89|62|Public
50|$|In electronics, {{glue logic}} is the <b>custom</b> <b>logic</b> {{circuitry}} used to interface {{a number of}} off-the-shelf integrated circuits.|$|E
50|$|On the {{expansion}} card or motherboard controller, this involves much <b>custom</b> <b>logic,</b> with digital logic engines in the motherboard's controller chip, plus analog circuitry managing the high-speed differential signals. On the software side, {{it requires a}} device driver (called a Host Controller Driver, or HCD).|$|E
50|$|Dual ARM7TDMI cores with shared SRAM (3x 32KB banks). Errata {{in memory}} {{controller}} leads to halved data cache performance but fast SRAM. As the ARM7TDMI {{does not support}} cache coherency, individual ARM7TDMI cores do not have coherent views of DRAM. <b>Custom</b> <b>logic</b> is used to introduce coherency into the SRAM.|$|E
5000|$|The RapidAPI {{platform}} allows {{its users}} to create <b>custom</b> backend <b>logic</b> - compiled out of [...] "blocks". These blocks are basic functions {{offered by the}} platform, performing actions such as saving to a database, or sending an email.|$|R
6000|$|... [363] It is a {{striking}} indication of the tenacity of <b>custom</b> against <b>logic</b> that in France, though civil marriage was made not merely permissive, as with us, but compulsory in 1792, divorce was banished from French law from 1816 down to 1884.|$|R
50|$|RESTHeart {{inherits}} {{the same}} Undertow's pipeline architecture, where specialized handlers are chained together {{to serve the}} requests. In order to provide additional application <b>logic,</b> <b>custom</b> handlers can be bound under the /_logic URL.|$|R
50|$|DraCos {{featured}} a Fast SCSI II interface to provide fast disk access with minimum cpu usage (transfer speeds were approximately 9 MB per second). An internal 50 pin and an external sub D 25 pin connectors were both present. The scsi interface and its <b>custom</b> <b>logic</b> were {{built into the}} Eltanin board.|$|E
50|$|Tensilica is {{a company}} based in Silicon Valley in the {{semiconductor}} intellectual property core business. It is now a part of Cadence Design Systems. Its dataplane processors (DPUs) combine the strengths of CPUs and DSPs and <b>custom</b> <b>logic</b> with 10 to 100 times the performance, making them suited for data-intensive processing tasks.|$|E
5000|$|ZDNet says, that {{according}} to private e-mail, Glacier runs on [...] "inexpensive commodity hardware components". In 2012, ZDNet quoted a former Amazon employee as saying that Glacier is based on custom low-RPM hard drives attached to <b>custom</b> <b>logic</b> boards where only a percentage of a rack's drives can be spun at full speed at any one time. (Similar technology is also used by Facebook.) ...|$|E
30|$|In this paper, we have {{discussed}} our choice, adaptation, and use of a rapid prototyping platform and design flow suitable {{for the design of}} on-chip motion controllers and other SoCs with a need for analog interfacing. It supports embedded application software coupled with <b>custom</b> FPGA <b>logic</b> and analog interfacing, and is very well suited to FPGA-in-the-loop control and SoC controller prototyping. Such platform is suitable for academia and research communauty that cannot afford the expensive commercial solutions for FPGA-in-the-loop simulation [12, 13].|$|R
3000|$|... – The {{development}} {{context of}} IoT cloud applications has grown beyond writing <b>custom</b> business <b>logic</b> (e.g., services) components to also considering the involved IoT devices (e.g., their capabilities) {{as well as}} the deployment and provisioning of such services across the IoT cloud infrastructure. The main reasons for this are complex and strong dependence of the business logic on the underlying devices (and their specific capabilities), novel (resource) features that need to be considered, such as device location and the heterogeneity of the utilized IoT cloud resources.|$|R
50|$|TACTIC organizes {{workflows}} through pipelines, production command chains that grant users {{the ability}} to define discrete processes within a workflow. In each process, files can be checked in and versioned, tasks created, notes added and triggers responding to events in the process executed. Users can also configure their workflows to assign arbitrary metadata, send notifications and update the status of projects. TACTIC's trigger system allows <b>custom</b> business <b>logic</b> to be attached to any event in the system, including every data change and file check-in.|$|R
50|$|The VAX 8800 family central {{processing}} unit (CPU) operates at 22.22 MHz (45 ns cycle time) and is implemented with discrete emitter-coupled logic (ECL) devices spread over eight modules. The majority of the ECL devices are macrocell arrays with 1,200 logic gates, while the general-purpose registers and floating-point units are <b>custom</b> <b>logic</b> devices developed by Digital. The CPU has 64 KB of cache implemented with 10 ns and 15 ns ECL random access memory devices.|$|E
50|$|The Ganymede server {{is meant}} to be {{programmed}} by the adopter, who can define arbitrary object data types along with <b>custom</b> <b>logic</b> to interact with the user through the GUI and to maintain consistency within and between objects. Adopters can also create custom tasks which can be executed at specified times by the internal Ganymede scheduler. Such custom tasks can make changes in the server's object database and/or can run external scripts to update external services.|$|E
50|$|The RACE {{can also}} be used as an element in complex {{high-speed}} modulators and demodulators, frequency doublers (owing to the RACE generating output pulses on both the rising and falling edges of a single cycle of the control waveform), and high-speed <b>custom</b> <b>logic</b> elements. The combination of high speed and scalability and the ability to reject imperfections in the sampling control signal enable the RACE {{to be used as a}} building block in new integrated circuits capable of parallel processing a large number of rapidly acquired samples, potentially opening up new fields of microwave sampling applications that will allow more complex and more accurate real-time processing of fast signals than was formerly possible.|$|E
40|$|As {{the study}} of large graphs over {{hundreds}} of gigabytes becomes increasingly popular for various data-intensive applications in cloud computing, developing large graph processing systems has become a hot and fruitful research area. Many of those existing systems support a vertex-oriented execution model and allow users to develop <b>custom</b> <b>logics</b> on vertices. However, the inherently ran-dom access pattern on the vertex-oriented computation generates {{a significant amount of}} network traffic. While graph partitioning is known to be effective to reduce network traffic in graph processing, there is little attention given to how graph partitioning can be effectively integrated into large graph processing in the cloud environment. In this paper, we develop a novel graph partitioning framework to improve the network performance of graph partitioning itself, partitioned graph storage and vertex-oriented graph processing. All optimizations are specifically designed for the cloud network environment. In experiments, we develop a system prototype following Pregel (the latest vertex-oriented graph engine by Google), and extend it with our graph partitioning framework. We conduct the experiments with a real-world social network and synthetic graphs over 100 GB each in a local cluster and on Amazon EC 2. Our experimental results demonstrate the efficiency of our graph partitioning framework, and the effectiveness of network performance aware optimizations on the large graph processing engine...|$|R
30|$|The {{mobile device}} is the {{interface}} between the user, the sensor network, and the Internet application repositories. The mobile device contains a network manager that controls the mapping and execution of the service graph on the Titan nodes, a service directory that contains {{a list of all}} available services discovered in the PAN, and a set of service graphs (representing various applications) waiting to be mapped to the sensor network. In addition, it can execute <b>custom</b> application <b>logic</b> services downloaded from the Internet application repositories, in the form of Java code.|$|R
5000|$|Business Rules can {{be created}} and applied against model data to ensure that <b>custom</b> {{business}} <b>logic</b> is adhered to. In order to be committed into the system data must pass all business rule validations applied to them. e.g. Within the Customer Entity {{you may want to}} create a business rule that ensures all members of the 'Country' Attribute contain either the text [...] "USA" [...] or [...] "Canada". The Business Rule once created and ran will then verify all the data is correct before it accepts it into the approved model.|$|R
5000|$|... public {{interface}} IProduct{ string GetName (...) string SetPrice(double price);}public class Phone : IProduct { private double _price; public string GetName (...) { return [...] "Apple TouchPad"; } public string SetPrice(double price) { this._price = price; return [...] "success"; }}/* Almost same as Factory, just {{an additional}} exposure {{to do something}} with the created method */public abstract class ProductAbstractFactory{ protected abstract IProduct DoSomething (...) public IProduct GetObject (...) // Implementation of Factory Method. { return this.DoSomething (...) }}public class PhoneConcreteFactory : ProductAbstractFactory{ protected override IProduct DoSomething (...) { IProduct product = new Phone (...) //Do something with the object after you get the object. [...] product.SetPrice(20.30); return product; }}You can see we have used DoSomething in concreteFactory. As a result, you can easily call DoSomething (...) from it to get the IProduct. You might also write your <b>custom</b> <b>logic</b> after getting the object in the concrete Factory Method. The GetObject is made abstract in the Factory interface.|$|E
50|$|The Windows Vista network stack {{includes}} Windows Filtering Platform, {{which allows}} external applications to access and hook into the packet processing pipeline of the networking subsystem. WFP allows incoming and outgoing packets to be filtered, analyzed or modified at {{several layers of}} the TCP/IP protocol stack. Because WFP has an inbuilt filtering engine, applications need not write any custom engine, they just need to provide the <b>custom</b> <b>logic</b> for the engine to use. WFP includes a Base Filtering Engine which implements the filter requests. The packets are then processed using the Generic Filtering Engine, which also includes a Callout Module, where applications providing the custom processing logic can be hooked up. WFP can be put to uses such as inspecting packets for malware, selective packet restriction, such as in firewalls, or providing custom encryption systems, among others. Upon its initial release WFP was plagued with bugs including memory leaks and race conditions.|$|E
5000|$|Ted Dabney and Nolan Bushnell {{developed}} the Atari gaming {{system in the}} 1970s. Originally operating under the name [...] "Syzygy", Bushnell and Dabney changed {{the name of their}} company to [...] "Atari" [...] in 1972. In 1973, Atari Inc. had purchased an engineering think tank called Cyan Engineering to research next-generation video game systems, and had been working on a prototype known as [...] "Stella" [...] (named after one of the engineers' bicycles) for some time. Unlike prior generations of machines that use <b>custom</b> <b>logic</b> to play a small number of games, its core is a complete CPU, the famous MOS Technology 6502 in a cost-reduced version known as the 6507. It was combined with a RAM-and-I/O chip, the MOS Technology 6532, and a display and sound chip known as the Television Interface Adaptor (TIA). The first two versions of the machine contain a fourth chip in the video circuitry, a standard CMOS 4050 buffer IC, making Stella cost-effective (?). Some later versions of the console eliminated the buffer chip.|$|E
40|$|Neutrino 2016 conference proceedings, 3 pagesInternational audienceThe STEREO experiment, {{aiming to}} probe short {{baseline}} neutrino oscillations by precisely measuring reactor anti-neutrino spectrum, is currently under installation. It {{is located at}} short distance from the compact research reactor core of the Institut Laue-Langevin, Grenoble, France. Dedicated electronics, hosted in a single μTCA crate, were designed for this experiment. In this article, the electronics requirements, architecture and the performances achieved are described. It is shown how intrinsic Pulse Shape Discrimination properties of the liquid scintillator are preserved and how <b>custom</b> adaptable <b>logic</b> is used to improve the muon veto efficiency...|$|R
50|$|With {{programmable}} logic devices, designers use inexpensive software tools to quickly develop, simulate, and test their designs. Then, a design {{can be quickly}} programmed into a device, and immediately tested in a live circuit. The PLD that is used for this prototyping {{is exactly the same}} PLD that will be used in the final production of a piece of end equipment, such as a network router, a DSL modem, a DVD player, or an automotive navigation system. There are no NRE costs and the final design is completed much faster than that of a <b>custom,</b> fixed <b>logic</b> device.|$|R
40|$|With the {{increasing}} demand in the <b>custom</b> built <b>logic</b> for avionics systems, FPGA is used in this proposed interfacing card design. This FPGA based intelligent data handling card (IDHC) for the IVHM system, will interface the data from aircraft subsystems to the aircraft digital data bus. This IDHC interfacing card {{is based on the}} Virtex- 5 FPGA (Field Programmable Gate Array), which provides flexibility by re-programming, {{so that it can be}} configured to the required functionality. Fault detection can be done within the FPGA and only the anomalies passed to the computer, so that the bus bandwidth can be utilized effectively and also excessive wiring can be eliminated, that would have been required for multiple individual systems. The work concentrates on designing the schematic using OrCAD...|$|R
40|$|Computer {{architectures}} can use <b>custom</b> <b>logic</b> {{in addition}} to general pur- pose processors to improve performance {{for a variety of}} applications. The use of <b>custom</b> <b>logic</b> allows greater parallelism for some algorithms. While conventional CPUs typically operate on words, ne-grained <b>custom</b> <b>logic</b> can improve e ciency for many bit level operations. The commodi ca- tion of eld programmable devices, particularly FPGAs, has improved the viability of using <b>custom</b> <b>logic</b> in an architecture. This thesis introduces an approach to reasoning about the correctness of compilers that generate <b>custom</b> <b>logic</b> that can be synthesized to provide hardware acceleration for a given application. Compiler intermediate representations (IRs) and transformations that are relevant to genera- tion of <b>custom</b> <b>logic</b> are presented. Architectures may vary in the way that <b>custom</b> <b>logic</b> is incorporated, and suitable abstractions are used in order that the results apply to compilation for a variety of the design parameters that are introduced by the use of <b>custom</b> <b>logic.</b> EThOS - Electronic Theses Online ServiceGBUnited Kingdo...|$|E
40|$|Explore the {{differences}} between microprocessor-based, and custom-VLSI logic-based, computing system models. – Compare the difference in execution between microprocessor computing and <b>custom</b> <b>logic</b> computing architectures, using a set of benchmark algorithms. – Write/select assembler programs that execute on a standard microprocessor (the Motorola 68000), and create corresponding <b>custom</b> <b>logic</b> architectures and designs for these same algorithms using an appropriate VLSI design method. – Examine {{the differences}} in algorithmic processing between the two classes of computing architectures. – Draw conclusions {{about the nature of}} algorithm processing between the two computing architecture models—the “old” and the “new”...|$|E
30|$|Whether FPGAs are {{integrated}} into data centres via proposed virtualized methods [3] or by more direct Open-CL based methods [11, 12] the FPGA fabric itself {{will need to}} consist of two separate regions. A static region of logic will exist {{in order for the}} FPGA to bootstrap itself and configure the minimum communication protocols necessary for it to interact with the host system. The second (dynamic) region will be an area of the fabric that is partially reconfigurable at runtime to allow for <b>custom</b> <b>logic</b> to be placed onto the device. This <b>custom</b> <b>logic</b> will then accelerate a specific compute-intensive task call of the application’s algorithm, or run the application as a whole entirely on the FPGA.|$|E
40|$|Initially, IP cores in System-On-Chip (SOC) were {{interconnected}} through <b>custom</b> interface <b>logics.</b> The {{more recent}} use of standard on-chip buses has eased integration and eliminated inefficient glue logic, and hence boosted {{the production of}} IP functional cores. However, once an IP block is designed to target a particular on-chip bus standard, retargeting to a different bus is time consuming and tedious. As new bus standards are introduced and different interconnection methods are proposed, this problem increases. Industry standard Bus Wrappers are intended to ease the interface problem, but performance overheads make them unattractive. A new methodology is presented that can automate the connection of an IP block {{to a wide variety}} of interface architectures with low overhead through the use a special Interface Adaper Logic layer...|$|R
40|$|This paper {{presents}} a novel phase unwrapping architecture for accelerating the computational speed of digital holographic microscopy (DHM). A fast Fourier transform (FFT) based phase unwrapping algorithm providing a minimum squared error solution is adopted for hardware implementation {{because of its}} simplicity and robustness to noise. The proposed architecture is realized in a pipeline fashion to maximize through put of thecomputation. Moreover, the number of hardware multipliers and dividers are minimized to reduce the hardware costs. The proposed architecture {{is used as a}} <b>custom</b> user <b>logic</b> in a system on programmable chip (SOPC) for physical performance measurement. Experimental results reveal that the proposed architecture is effective for expediting the computational speed while consuming low hardware resources for designing an embedded DHM system...|$|R
40|$|The OpenFire {{processor}} is an simple, {{open source}} solution for implementing a MicroBlaze-compliant Application-Specific Instruction-Set Processor (ASIP) on an FPGA. Its small size and adjustable feature set {{also make it}} attractive for Single Chip Multiple Processor (SCMP) research. Until now the OpenFire has been dependent upon a host MicroBlaze processor or <b>custom</b> user <b>logic</b> for access to external memory or peripherals. In {{order to make the}} OpenFire a self sufficient, convenient research platform for both ASIP and SCMP, the addition of a standard peripheral bus such as the On-Chip Peripheral Bus (OPB) is necessary. In this paper we implement a solution to this problem, compare our implementation to the standard MicroBlaze implementation, and discuss future work that we hope to acheive. 1...|$|R
40|$|Virtualization of <b>custom</b> <b>logic</b> {{computations}} (i. e., {{by sharing}} a fixed function across distinct data streams) {{provides a means}} of reusing hardware resources, particularly when resources are limited. This is common practice in traditional processors where more than one user can share processor resources. In this paper, we virtualize a <b>custom</b> <b>logic</b> block using C-slow techniques to support fine-grain context-switching. We then develop and present an analytic model for several performance measures (throughput, latency, input queue occupancy) for both fine-grained and coarse-grained context switching (to a secondary memory). Next, we calibrate the analytic performance model with empirical measurements. We then validate the model via discrete-event simulation and use the model to predict the performance and develop optimal schedules for virtualized logic computations. We present results for a Taylor series expansion of a cosine function with added feedback and an AES encryption cipher [...] Read complete abstract on page 2...|$|E
40|$|Programmable packet {{processors}} {{have replaced}} traditional fixed-function <b>custom</b> <b>logic</b> {{in the data}} path of routers. This programmability introduces new vulnerabilities in these sys-tems {{that can lead to}} new types of network attacks. We propose a modular packet processor monitoring technique that can help in detecting and avoiding such attacks. Using information about the processing time distribution of indi-vidual modules, input/output traffic characteristics can be inferred and abnormal behavior can be detected...|$|E
40|$|Staff Design Engineer in Access, Power, and Sensors division. CMOS and bipolar {{design of}} high {{performance}} mixed-signal products. Experience includes amplifiers, data converters, regulators, voltage references, oscillators, power converters, charge pumps, ESD, DSP, firmware, MEMS design and modeling, high voltage devices, PLL, CDR, <b>custom</b> <b>logic</b> cells and ROMs, polysilicon fuse development, RTL design, synthesis, and place and route, high performance analog layout design, chip assembly. Technical leader on ProSLICTM and Digital Isolator product teams...|$|E
40|$|One {{can argue}} that {{hardware}} design is fast disappearing into the ether of software, especially for embedded systems. Complex algorithms can be synthesized directly into hardware by designers who are ignorant {{of many of the}} tradeoffs being made right under their nose. Application-specific engines are synthesized in <b>custom</b> programmable <b>logic</b> and interfaced to embedded soft and hard IP cores in days rather than months. The ability to leverage existing IP allows complex systems to be realized in a fraction the design time and cost. That being said, the vast majority of such systems use fixed hardware designs where the system is composed of and largely exists in custom software and software interfaces. There are several issues with this strategy, the most pressing being system feedback loop delays depend on software timing and tim...|$|R
40|$|In this paper, {{we present}} a new method for neural spike sorting based on Continuous Time (CT) signal processing. A set of CT based {{features}} are proposed and extracted from CT sampled pulses, and a complete event-driven spike sorting algorithm that performs classification based on these features is developed. Compared to conventional methods for spike sorting, the hardware implementation of the proposed method does not require any synchronisation clock for logic circuits, and thus its power consumption depend solely on the spike activity. This has been implemented using a variable quantisation step CT analogue to digital converter (ADC) with <b>custom</b> digital <b>logic</b> that is driven by level crossing events. Simulation results using synthetic neural data shows a comparable accuracy compared to template matching (TM) and Principle Components Analysis (PCA) based discrete sampled classification...|$|R
30|$|This {{contribution}} {{focuses on}} the optimization of matching-based motion estimation algorithms widely used for video coding standards using an Altera custom instruction-based paradigm and a combination of synchronous {{dynamic random access memory}} (SDRAM) with on-chip memory in Nios II processors. A complete profile of the algorithms is achieved before the optimization, which locates code leaks, and afterward, creates a custom instruction set, which is then added to the specific design, enhancing the original system. As well, every possible memory combination between on-chip memory and SDRAM has been tested to achieve the best performance. The final throughput of the complete designs are shown. This manuscript outlines a low-cost system, mapped using very large scale integration technology, which accelerates software algorithms by converting them into <b>custom</b> hardware <b>logic</b> blocks and showing the best combination between on-chip memory and SDRAM for the Nios II processor.|$|R
