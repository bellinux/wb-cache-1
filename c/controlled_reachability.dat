1|69|Public
40|$|We {{consider}} {{the problem of}} driving a system from some initial configuration to a desired configuration while avoiding some unsafe configurations. The system to be controlled is a dynamical system that can operate in different modes. The goal is to synthesize the logic for switching between the modes so that the desired reachability property holds. In this paper, we first present a sound and complete inference rule for proving reachability properties of single mode continuous dynamical systems. Next, we present an inference rule for proving <b>controlled</b> <b>reachability</b> in multi-modal continuous dynamical systems. From a constructive proof of <b>controlled</b> <b>reachability,</b> we show how to synthesize the desired switching logic. We show that our synthesis procedure is sound and produces only non-zeno hybrid systems. In practice, we perform a constructive proof of <b>controlled</b> <b>reachability</b> by solving an Exists-Forall formula {{in the theory of}} reals. We present an approach for solving such formulas that combines symbolic and numeric solvers. We demonstrate our approach on some examples. All results extend naturally to the case when, instead of reachability, interest is in until properties...|$|E
40|$|AbstractWe {{study the}} {{relationship}} between the asynchronous π-calculus and the specification language MSRNC combining multiset rewriting over first-order atomic formulas (MSR) and name constraints (NC) proposed in [ENTCS 50 (4) (2001) ]. We exploit this connection to define a sound and fully automatic procedure for attacking <b>control</b> <b>reachability</b> for infinite-state specifications given in asynchronous π-calculus, i. e., for specifications of mobile processes with unbounded control, name generation, and name mobility...|$|R
40|$|We {{study the}} {{relationship}} between the asynchronous -calculus and the specication language MSRNC combining multiset rewriting over rst-order atomic formulas (MSR) and name constraints (NC) proposed in [10]. We exploit this connection to de ne a sound and fully automatic procedure for attacking <b>control</b> <b>reachability</b> for in nite-state specications given in asynchronous -calculus, i. e., for specications of mobile processes with unbounded control, name generation, and name mobility. ...|$|R
40|$|Abstract. We {{study the}} <b>control</b> <b>reachability</b> {{problem in the}} Dolev-Yao model of {{cryptographic}} protocols when principals are represented by tail recursive processes with generated names. We propose a conservative approximation of the problem by reduction to a non-standard collapsed operational semantics and we introduce checkable syntactic conditions entailing the equivalence of the standard and the collapsed semantics. Then we introduce a conservative and decidable set-based analysis of the collapsed operational semantics and we characterize {{a situation where the}} analysis is exact...|$|R
40|$|We {{study the}} <b>control</b> <b>reachability</b> {{problem in the}} Dolev-Yao model of cryptograp- hic {{protocols}} when principals are represented by tail recursive processes with generated names. We propose a conservative approximation of the problem by reduction to a non-standard collapsed operational semantics and we introduce checkable syntactic conditions entailing the equivalence of the standard and the collapsed semantics. Then we introduce a conservative and decidable set-based analysis of the collapsed operational semantics and we characterize {{a situation where the}} analysis is exact. Finally, we describe how our framework can be used to specify secrecy and freshness properties of cryptographic protocols...|$|R
40|$|We {{address the}} problem of statically {{checking}} <b>control</b> state <b>reachability</b> (as in possibility of assertion violations, race conditions or runtime errors) and plain reachability (as in deadlock-freedom) of phaser programs. Phasers are a modern non-trivial synchronization construct that supports dynamic parallelism with runtime registration and deregistration of spawned tasks. They allow for collective and point-to-point synchronizations. For instance, phasers can enforce barriers or producer-consumer synchronization schemes among all or subsets of the running tasks. Implementations %of these recent and dynamic synchronization are found in modern languages such as X 10 or Habanero Java. Phasers essentially associate phases to individual tasks and use their runtime values to restrict possible concurrent executions. Unbounded phases may result in infinite transition systems even in the case of programs only creating finite numbers of tasks and phasers. We introduce an exact gap-order based procedure that always terminates when checking <b>control</b> <b>reachability</b> for programs generating bounded numbers of coexisting tasks and phasers. We also show verifying plain reachability is undecidable even for programs generating few tasks and phasers. We then explain how to turn our procedure into a sound analysis for checking plain reachability (including deadlock freedom). We report on preliminary experiments with our open source tool...|$|R
40|$|Personal Communication Support enhances <b>control</b> over <b>reachability</b> in telecommunication. Conversion and {{screening}} technologies of communication media, combined with QoS evaluation, allow {{to focus on}} the semantic of the information instead on carriage. A CORBA-based implementation allows scaling from Java clients to IN service nodes and TINA integration...|$|R
40|$|We study a {{terminal}} state <b>control</b> (<b>reachability)</b> problem for certain elastic systems of “hybrid ” type {{consisting of a}} single space dimension distributed parameter part coupled, at one endpoint of the relevant spatial, x, interval, to a lumped mass component. The example discussed here concerns an Euler- Bernoulli beam system “clamped ” at x = 0 and attached, at x = L, to a mass with both translational and rotational inertia. In both cases the controls act on the mass, which is modeled by a finite dimensional system of differential equations. Analysis of the reachability problem is facilitated by a preliminary “feedback type” transformation of the control variable which decouples the point mass from the distributed system. A concluding analysis shows that the component of the control generated by feedback lies in the same space as the originally applied control...|$|R
40|$|This paper {{describes}} a concept for <b>controlling</b> personal <b>reachability</b> {{while maintaining a}} high degree of privacy and data protection. By easy negotiation of their communication requests users can reach others without disturbing the called partners and without compromising their own privacy. Reachability management can strengthen the called subscriber's right to self-determined communication without violating the callersÕ interests in protecting their personal data...|$|R
40|$|Modern {{multiprocessor}} systems use weak (relaxed) memory {{models in}} order to execute memory sharing multi-threaded code in an efficient manner, but are much harder for programmers to reason about than systems using the sequential consistency memory model. The SB abstraction and its implementation in the Memorax tool allows sound and complete checking of <b>control</b> state <b>reachability</b> under the TSO memory model, used in modern x 86 processors. In this paper, I present a formalisation of the PSO memory model using the semantics of the Sun SPARC documentation and an alternate semantic, called Partial Write Serialisation, I conjecture to be equivalent with my formalisation under the <b>control</b> state <b>reachability</b> problem. PWS is {{proved to be a}} well-structured system which allows sound and complete reachability analysis. An implementation of PWS is presented  as part of the Memorax tool and demonstrated  experimentally to be capable of analysing reachability and inferring minimal fence sets on many non-trivial and real world examples in reasonable time and memory usage...|$|R
40|$|ABSTRACT. Multiset pushdown {{systems have}} been {{introduced}} by Sen and Viswanathan as an adequate model for asynchronous programs where some procedure calls can be stored as tasks to be processed later. The model is a pushdown system supplied with a multiset of pending tasks. Tasks may {{be added to the}} multiset at each transition, whereas a task is taken from the multiset only when the stack is empty. In this paper, we consider an extension of these models where tasks may be of different priority level, and can be preempted at any point of their execution by tasks of higher priority. We investigate the <b>control</b> point <b>reachability</b> problem for these models. Our main result is that this problem is decidable by reduction to the reachability problem for a decidable class of Petri nets with inhibitor arcs. We also identify two subclasses of these models for which the <b>control</b> point <b>reachability</b> problem is reducible respectively to the reachability problem and to the coverability problem for Petri nets (without inhibitor arcs). ...|$|R
40|$|The <b>control</b> state <b>reachability</b> {{problem is}} decidable for well-structured in nite-state systems like (Lossy) Petri Nets, Vector Addition Systems, and Broadcast Protocols. An {{abstract}} algorithm that solves {{the problem is}} the backward reachability algorithm of [1, 21]. The algorithm computes the closure of the predecessor operator with respect to a given upward-closed set of target states. When applied to this class of veri cation problems, symbolic model checkers based on constraints like [7, 29] suffer from the state explosion problem...|$|R
40|$|Abstract. We {{introduce}} MEMORAX, a {{tool for}} the verification of <b>control</b> state <b>reachability</b> (i. e., safety properties) of concurrent programs manipulating finite range and integer variables and running on top of weak memory models. The verification task is non-trivial as it involves exploring state spaces of arbitrary or even infinite sizes. Even for programs that only manipulate finite range variables, the sizes of the store buffers could grow unboundedly, and hence the state spaces {{that need to be}} explored could be of infinite size. In addition, MEMORAX in-corporates an interpolation based CEGAR loop to make possible the verification of <b>control</b> state <b>reachability</b> for concurrent programs involving integer variables. The reachability procedure is used to automatically compute possible memory fence placements that guarantee the unreachability of bad control states under TSO. In fact, for programs only involving finite range variables and running on TSO, the fence insertion functionality is complete, i. e., it will find all minimal sets of memory fence placements (minimal in the sense that removing any fence would result in the reachability of the bad control states). This makes MEMORAX the first freely available, open source, push-button verification and fence insertion tool for programs running under TSO with integer variables. ...|$|R
40|$|Lossy channel {{systems are}} a {{classical}} model with applications {{ranging from the}} modeling of communication protocols to programs running on weak memory models. All existing work assume that messages traveling inside the channels are picked from a finite alphabet. In this paper, we extend the model by assuming that each message {{is equipped with a}} clock representing the age of the message, thus obtaining the model of Timed Lossy Channel Systems (TLCS). The main contribution of the paper is to show that the <b>control</b> state <b>reachability</b> problem is decidable for TLCS...|$|R
40|$|Abstract. Ping-pong {{protocols}} with recursive {{definitions of}} agents, {{but without any}} active intruder, are a Turing powerful model. We show that under the environment sensitive semantics (i. e. by adding an active intruder capable of storing all exchanged messages including full analysis and synthesis of messages) some verification problems become decidable. In particular we give an algorithm to decide <b>control</b> state <b>reachability,</b> a problem related to security properties like secrecy and authenticity. The proof is via a reduction to a new prefix rewriting model called Monotonic Set-extended Prefix rewriting (MSP). We demonstrate further applicability of the introduced model by encoding a fragment of the ccp (concurrent constraint programming) language into MSP. ...|$|R
40|$|Ground Tree Rewrite Systems with State {{are known}} to have an {{undecidable}} <b>control</b> state <b>reachability</b> problem. Taking inspiration from the recent introduction of scope-bounded multi-stack push-down systems, we define Senescent Ground Tree Rewrite Systems. These are a restriction of ground tree rewrite systems with state such that nodes of the tree may no longer be rewritten after hav-ing witnessed an a priori fixed number of control state changes. As well as generalising scope-bounded multi-stack pushdown sys-tems, we show — via reductions to and from reset Petri-nets — that these systems have an Ackermann-complete control state reacha-bility problem. However, reachability of a regular set of trees re-mains undecidable...|$|R
40|$|Multi-stack pushdown {{systems are}} a well-studied model of {{concurrent}} computation using threads with first-order procedure calls. While, in general, reachability is undecidable, {{there are numerous}} restrictions on stack behaviour that lead to decidability. To model higher-order procedures calls, a generalisation of pushdown stacks called collapsible pushdown stacks are required. Reachability problems for multi-stack collapsible pushdown systems have been little studied. Here, we study ordered, phase-bounded and scope-bounded multi-stack collapsible pushdown systems using saturation techniques, showing decidability of <b>control</b> state <b>reachability</b> and giving a regular representation of all configurations that can reach a given control state. Comment: Long version of paper appearing in FSTTCS 201...|$|R
40|$|In {{order to}} make multithreaded {{programming}} manageable, programmers often follow a design principle where they break the problem into tasks which are then solved asynchronously and concurrently on different threads. This paper investigates the problem of model checking programs that follow this idiom. We present a programming language that encapsulates this design pattern. extends simplified form of sequential Java to which we add the capability of making asynchronous method invocations {{in addition to the}} standard synchronous method calls and the ability to execute asynchronous methods in threads atomically and concurrently. Our main result shows that the <b>control</b> state <b>reachability</b> problem for finite programs is decidable. Therefore, such multithreaded programs can be model checked using the counter-example guided abstraction-refinement framework...|$|R
40|$|Abstract — In {{this paper}} we study a <b>reachability</b> <b>control</b> problem for {{distributed}} systems modeled by timed continuous Petri nets. In particular, we generalize our previous works in this framework where we solved this problem only for distributed systems composed by two subsystems. We will {{show how the}} existing algorithm can be adapted {{in order to be}} able to deal with distributed systems composed by a finite number of subsystems. I...|$|R
40|$|Abstract. Recent {{works have}} {{provided}} formal models for parameterized verification of Ad Hoc Networks {{in which the}} communication topology is represented by a graph and the behavior of each node is given by a finite state automaton. In this paper we study time specifications of protocols for Ad Hoc Networks in which nodes are modeled by timed automata communicating via selective broadcast. The problem we consider is <b>control</b> state <b>reachability</b> for networks of arbitrary size. For continuous time, we show that the restrictions which allow to gain decidability in the untimed case do not hold anymore, even when assuming that each node uses at most one clock. When considering discrete time, we retrieve the same decidability results as for the untimed case. ...|$|R
40|$|Abstract. The <b>control</b> state <b>reachability</b> {{problem is}} decidable for well-structured infinite-state systems like {{unbounded}} Petri Nets, Vector Addition Systems, Lossy Petri Nets, and Broadcast Protocols. An abstract algorithm that solves {{the problem is}} given in [ACJT 96,FS 99]. The algorithm computes {{the closure of the}} predecessor operator w. r. t. a given upward-closed set of target states. When applied to this class of verification problems, traditional (infinite-state) symbolic model checkers suffer from the state explosion problem even for very small examples. We provide BDD-like data structures to represent in a compact way collections of upwards closed sets over numerical domains. This way, we turn the abstract algorithm of [ACJT 96,FS 99] into a practical method. Preliminary experimental results indicate the potential usefulness of our method...|$|R
40|$|Analysis: {{stability}} analysis, parameter {{and system}} identification, sensitivity analysis • Modeling: nonlinear ordinary differential equations; hybrid dynamical systems • Control: linear and nonlinear feedback <b>control,</b> model-based diagnostics, <b>reachability</b> analysis • Laboratory: testing and data acquisition for parameter identification and algorithm validation pur-pose in energy storage system, multi-phase electrical machines and electromagnetic actuators labora-tories, including some experience with hardware-in-the-loop engine control systems • Programming: C, Matlab, Fortran • Writing: strong experience writing and managing projects, proposals, and grants with federal agencie...|$|R
40|$|A {{variety of}} {{concepts}} for service integration and corresponding service platforms {{emerged in the}} last two years. On the one hand, they aim for the interworking and integration of classical telecommunication and data communication services, such as telephony, voicemail, fax, e-mail, paging, etc. On the other hand they focus on universal service access from a variety of end user systems, including both fixed and mobile terminals. One form of these concepts are Unified Messaging Systems, which are proposed to enhance the <b>control</b> over <b>reachability</b> in telecommunications. This paper presents the evolution of messaging system and an outlook of future developments in the area of communication and information services. Based on this analysis it shows the drawbacks of the current understanding of Unified Messaging. The second part of the paper proposes a system architecture from the technical perspective to overcome the examined disadvantages...|$|R
40|$|Abstract. We {{show the}} {{regularity}} of the discrete time behaviour of hybrid automata {{in which the}} rates of continuous variables are governed by linear differential operators in a diagonal form and in which {{the values of the}} continuous variables can be observed only with finite precision. We do not demand resetting of the values of the continuous variables during mode changes. We can cope with polynomial guards and we can tolerate bounded delays both in sampling the values of the continuous variables and in effecting changes in their rates required by mode switchings. We also show that if the rates are governed by diagonalizable linear differential operators with rational eigenvalues and there is no delay in effecting rate changes, the discrete time behaviour of the hybrid automaton is recursive. However, the <b>control</b> state <b>reachability</b> problem in this setting is undecidable. ...|$|R
40|$|Abstract: Optimal <b>control</b> and <b>reachability</b> {{analysis}} of continuous-state systems often require computa-tional algorithms with high complexity. The use of finite abstractions of continuous-state systems reduces such problems to path-planning problems on directed graphs with {{a finite number}} of nodes, which can be computed efficiently. In this research, we discuss the design of finite abstractions of stabilizable discrete-time linear systems based on approximately bisimulation. First, we focus our attention to a class of finite-state system that are expressed by the state-quantization of the original system. Then, the original problem reduces to the design of a quantization function, which is formulated as a kind of semidefinite programming problem. Moreover, we show that a suboptimal solution to optimal control problems with a known error bound is obtained by simulating the optimal path of an approximately bisimilar finite abstraction. 1...|$|R
40|$|This paper {{describes}} a concept for <b>controlling</b> personal <b>reachability</b> {{while maintaining a}} high degree of privacy and data protection. By easy negotiation of their communication requests users can reach others without disturbing the called partners and without compromising their own privacy. Reachability management can strengthen the called subscriber's right to self-determined communication without violating the callers' interests in protecting their personal data. * Keywords Security and Protection; Communications Applications * Parts of this work are funded by the Gottlieb Daimler and Karl Benz Foundation (Ladenburg, Germany) as part of its Kolleg "Security in Communication Technology". This document was created with FrameMaker 4. 0. 4 1 PERSONAL REACHABILITY MANAGEMENT AND MULTILATERAL SECURITY Current opportunities for mobile communication increase the technical reachability of users. This, of course, endangers their right to self-determined communication. Persons, who need to be [...] ...|$|R
40|$|The <b>control</b> state <b>reachability</b> {{problem is}} decidable for wellstructured infinite-state systems like {{unbounded}} Petri Nets, Vector Addition Systems, Lossy Petri Nets, and Broadcast Protocols. An abstract algorithm that solves {{the problem is}} given in [AČJT 96, FS 99]. The algorithm computes {{the closure of the}} predecessor operator w. r. t. a given upward-closed set of target states. When applied to this class of verification problems, traditional (infinite-state) symbolic model checkers suffer from the state explosion problem even for very small examples. We provide BDD-like data structures to represent in a compact way collections of upwards closed sets over numerical domains. This way, we turn the abstract algorithm of [AČJT 96, FS 99] into a practical method. Preliminary experimental results indicate the potential usefulness of our method. © Springer-Verlag Berlin Heidelberg 2000. TACAS' 00 SCOPUS: cp. kinfo:eu-repo/semantics/publishe...|$|R
40|$|In this paper, {{we present}} a social network based network {{communication}} architecture, Davis Social Links (DSL). DSL uses the trust and relationships inherent to human social networks to provide an enhanced communication architecture for future Internet designs. We begin with a conceptual discussion of how future network architectures can leverage social networks. Next, we describe the DSL architecture and how it provides to end-users <b>control</b> over their <b>reachability</b> within the network. We conclude {{with a discussion of}} the capability to manage dynamic communities within DSL. 1...|$|R
40|$|The {{topic of}} this {{graduation}} project is Reachability Management. The need for Reachability Management research {{results from the}} progress in (communication) technology that enables people to reach each other at all times, using all kinds of communication, no matter where people are. The drawback of this new technology is that you might receive communication when you don't want to be disturbed by communication, e. g. if your phone rings when you are sleeping. Reachability Management must give a person more <b>control</b> over her <b>reachability...</b>|$|R
40|$|We {{address the}} problem of {{efficient}} verification of multi-threaded programs running over Total Store Order (TSO) memory model. It has been shown that even with finite data domain programs, the complexity of <b>control</b> state <b>reachability</b> under TSO is non-primitive recursive. In this paper, we first present a bounded-buffer verification approach wherein a bound on the size of buffers is placed; verification is performed incrementally by increasing the size of the buffer with each iteration of the verification procedure until the said bound is reached. For programs operating on finite data domains, we also demonstrate the existence of a buffer bound k such that if the program is safe under that bound, then it is also safe for unbounded buffers. We have implemented this technique in a tool ProofTraPar. Our results against memorax [2], a state-of-the-art sound and complete verifier for TSO memory model, have been encouraging...|$|R
40|$|The <b>control</b> state <b>reachability</b> {{problem is}} decidable for wellstructured innite-state systems like {{unbounded}} Petri Nets, Vector Addition Systems, Lossy Petri Nets, and Broadcast Protocols. An abstract algorithm that solves {{the problem is}} given in [A CJT 96,FS 99]. The algorithm computes {{the closure of the}} predecessor operator w. r. t. a given upward-closed set of target states. When applied to this class of verication problems, traditional (innite-state) symbolic model checkers suer from the state explosion problem even for very small examples. We provide BDD-like data structures to represent in a compact way collections of upwards closed sets over numerical domains. This way, we turn the abstract algorithm of [A CJT 96,FS 99] into a practical method. Preliminary experimental results indicate the potential usefulness of our method. 1 Introduction In the last years many eorts have been made to extend the theoretical results and practical methods developed for nite-state [...] ...|$|R
40|$|A {{variety of}} {{concepts}} for service integration and corresponding service platforms {{emerged in the}} last two years which aim on the one hand for the interworking and integration of classical telecommunications and data communications services, such as telephony, voicemail, fax, e-mail, paging, etc. and on the other hand for universal service access from a variety of end user systems, including both fixed and mobile terminals. Unified Messaging as a branch of Personal Communication Support enhances <b>control</b> over <b>reachability</b> in telecommunication. Conversion technologies of communication media applying QoS evaluation allow to focus on the semantic of the information instead on carriage. An ODP system design and a CORBA-based prototype implementation provide the first step for a unified messaging system. This system can be integrated into other communication networks, e. g. as an IN service node or as a backbone service in an Extranet environment. This paper focuses on storage handling within the existing implementation and describes the quality enhancement in detail...|$|R
40|$|The {{notion of}} bisimulation in {{theoretical}} computer science {{is one of}} the main complexity reduction methods for the analysis and synthesis of labeled transition systems. Bisimulations are special quotients of the state space that preserve many important properties expressible in temporal logics, and, in particular, reachability. In this paper, the framework of bisimilar transition systems is applied to various transition systems that are generated by linear control systems. Given a discrete-time or continuous-time linear system, and a finite observation map, we characterize linear quotient maps that result in quotient transition systems that are bisimilar to the original system. Interestingly, the characterizations for discrete-time systems are more restrictive than for continuous-time systems, due to the existence of an atomic time step. We show that computing the coarsest bisimulation, which results in maximum complexity reduction, corresponds to computing the maximal <b>controlled</b> or <b>reachability</b> invariant subspace inside the kernel of the observations map. These results establish strong connections between complexity reduction concepts in control theory and computer science...|$|R
40|$|In this paper, we {{consider}} the synthesis of control laws for piecewise-affine hybrid systems on simplices. The construction {{is based on the}} solution to the control-to-facet problem at the continuous level, and on dynamic programming at the discrete level. The construction is given as an explicit algorithm using only linear algebra and reach-set computations for automata; no numerical integration is required. The method is conservative, in that it may fail to find a control law where one exists, but one cannot hope for a sharp algorithm for <b>control</b> synthesis since <b>reachability</b> for piecewise-affine hybrid systems is undecidable. © 2006 IEEE...|$|R
40|$|The {{structural}} and geometric {{approach is a}} consolidated means of analysis and synthesis in multivariable linear systems. Introduced in the late 1960 s, this approach has received a multiplicity of contributions throughout the following decades, thus giving rise to a complete theory, expounded in the authoritative books [1, 2]. The fundamental objects of this theory (e. g. <b>controlled</b> invariant subspaces, <b>reachability</b> subspaces, conditioned invariant subspaces, etc.) are also extensively treated in recent books for graduate level courses in system theory, like e. g. References [3, 4]. Nonetheless, the research domain of system structure and control is still very active (see e. g...|$|R
40|$|AbstractAsynchronous {{programming}} is a paradigm that supports asynchronous function calls {{in addition to}} synchronous function calls. Programs in such a setting can be modeled by automata with counters that {{keep track of the}} number of pending asynchronous calls for each function, as well as a call stack for synchronous recursive computation. These programs have the restriction that an asynchronous call is processed only when the call stack is empty. The decidability of the <b>control</b> state <b>reachability</b> problem for such systems was recently established. In this paper, we consider the problems of checking other branching time properties for such systems. Specifically we consider the following problems — termination, which asks if there is an infinite (non-terminating) computation exhibited by the system; control state maintainability, which asks if there is a maximal execution of the system, where all the state visited lie in some “good” set; whether the system can be simulated by a given finite state system; and whether the system can simulate a given finite state system. We present decision algorithms for all these problems...|$|R
