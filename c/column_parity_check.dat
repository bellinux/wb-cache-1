0|1708|Public
5000|$|Any [...] <b>columns</b> of a <b>parity</b> <b>check</b> matrix for [...] are linearly independent.|$|R
30|$|Changing the {{positions}} of any two <b>columns</b> of the <b>parity</b> <b>check</b> matrix H {{does not change the}} characteristics of the Hamming code.|$|R
3000|$|The vector z^T = (011)^T is {{identical}} to the fourth <b>column</b> of the <b>parity</b> <b>check</b> matrix H. Thus, an error is detected at the fourth position of C′, and C′ is corrected by C′ = C′ ⊕ e [...]...|$|R
40|$|AbstractSteiner triple {{systems are}} well studied {{combinatorial}} designs {{that have been}} shown to possess properties desirable for the construction of multiple erasure codes in RAID architectures. The ordering of the <b>columns</b> in the <b>parity</b> <b>check</b> matrices of these codes affects system performance. Combinatorial problems involved in the generation of good and bad column orderings are defined, and examined for small numbers of accesses to consecutive data blocks in the disk array...|$|R
40|$|This work {{explains}} {{the relationship between}} cycles, stopping sets, and dependent <b>columns</b> of the <b>parity</b> <b>check</b> matrix of low-density parity-check (LDPC) codes. Furthermore, it discusses how these structures limit LDPC code performance under belief propagation decoding. A new metric called extrinsic message degree (EMD) measures cycle connectivity in bipartite graphs. Using an easily computed estimate of EMD, we propose a Viterbi-like algorithm that selectively avoids cycles and increases stopping set size. This algorithm yields codes with error floors that are orders of magnitude below those of girth-conditioned codes. I...|$|R
40|$|Conference PaperThe major {{drawback}} of the LDPC codes {{versus the}} turbo-codes is their comparative low convergence speed: 25 - 30 iterations vs. 8 - 10 iterations for turbo-codes. Recently, Hocevar showed by simulations that the convergence {{rate of the}} LDPC decoder can be accelerated by exploiting a â turbo-schedulingâ applied on the bit-node messages (rows of the <b>parity</b> <b>check</b> matrix). In this paper, we show analytically that the convergence rate {{for this type of}} scheduling is about two times increased for most of the regular LDPC codes. Second we prove that â turbo-schedulingâ applied on the rows of the <b>parity</b> <b>check</b> matrix is identical belief propagation algorithm as standard message passing algorithm. Furthermore, we propose two new message passing schedules: 1) a turbo-scheduling is applied on the checknode messages (<b>columns</b> of the <b>parity</b> <b>check</b> matrix); 2) a hybrid version of both previous schedules where the turbo-effect is applied on both check-nodes and bit-nodes. Frame error rate simulations validate the effectiveness of the proposed schedules...|$|R
40|$|AbstractA 1 -blocking {{set in the}} {{projective}} space PG(m, 2), m⩾ 2, is a set B of points such that any (m− 1) -flat meets B and no 1 -flat is contained in B. A binary linear code {{is said to be}} uneven if it contains at least one codeword of odd weight. If B is a 1 -blocking set in PG(r− 1, 2) and dim〈B〉=r− 1 any matrix H whose columns are the vectors in B is a <b>parity</b> <b>check</b> matrix for an uneven binary code of length n=|B|, redundancy r, and minimum distance at least 4; Conversely, if B is the set of <b>columns</b> of the <b>parity</b> <b>check</b> matrix of such a code then it is a 1 -blocking set. Using this and results on uneven binary codes of minimum distance 4, the author shows that there exists a 1 -blocking set of cardinality n if and only if 5 ⩽n⩽ 5 ⋯ 2 m− 3...|$|R
40|$|International Telemetering Conference Proceedings / November 14 - 16, 1978 / Hyatt House Hotel, Los Angeles, CaliforniaIn {{this paper}} {{we present a}} {{decoding}} scheme for Alternant codes. The syndromes are calculated from the received vector and the <b>parity</b> <b>check</b> matrix H. Let t be the error correcting capability of the decoder. Then we determine a Key Equation by adding t <b>columns</b> of the <b>parity</b> <b>check</b> matrix H. We raise this equation t- 1 times {{to the power of}} n, where n is the number of columns of H. Next we consider a matrix At whose elements are the set of coefficients from the Key Equations which we obtained. We make a decision based on the determinant of the matrix A(t). If the matrix A(t) is singular, then we test the matrix A(t- 1) for singularity and continue up to A(t-t+ 1) which in fact the decoder can correct one error. if any one of the matrices A(t) through A(t-t+ 1) is nonsingular we change the first digit of the received vector, then recompute the syndromes and recheck Δt'. If Δt' is zero the change is retained. If not, the digit is changed again. The Algorithm then proceeds to the next digit. This Algorithm for decoding Alternant codes has significant improvements over previous schemes since the step-by-step decoding can be carried out at selected areas of the received word...|$|R
40|$|Abstract—Using group theory, we analyze cycle GF(2 p) {{codes that}} use Cayley graphs as their {{associated}} graphs. First, {{we show that}} through row and <b>column</b> permutations the <b>parity</b> <b>check</b> matrix H can {{be put in a}} concatenation form of row-permuted block-diagonal matrices. Encoding utilizing this form can be performed in linear time and in parallel. Second, we derive a rule to determine the nonzero entries of H and present determinate and semi-determinate codes. Our simulations show that the determinate and semi-determinate codes have better performance than codes with randomly generated nonzero entries for GF(16) and GF(64), and have similar performance for GF(256). The constructed determinate and semi-determinate codes over GF(64) and GF(256) can outperform the binary irregular counterparts of the same block lengths. One distinct advantage for determinate and semi-determinate codes is that they greatly reduce the storage cost ofH for decoding. The results in this correspondence are appealing for the implementation of efficient encoders and decoders for this class of promising LDPC codes, especially when the block length is large. Index Terms—Cayley graph, cycle code, Galois field, group theory, LDPC. I...|$|R
40|$|Steiner triple {{systems are}} well studied {{combinatorial}} designs {{that have been}} shown to possess properties desirable for the construction of multiple erasure codes in RAID architectures. The ordering of the <b>columns</b> in the <b>parity</b> <b>check</b> matrices of these codes affects system performance. Combinatorial problems involved in the generation of good and bad column orderings are defined, and examined for small numbers of accesses to consecutive data blocks in the disk array. 1 Background A Steiner triple system is an ordered pair (S; T) where S is a finite set of points or symbols and T is a set of 3 -element subsets of S called triples, such that each pair of distinct elements of S occurs together in exactly one triple of T. The order of a Steiner triple system (S; T) is the size of the set S, denoted jSj. A Steiner triple system of order v is often written as STS(v). An STS(v) exists if and only if v 1; 3 (mod 6) (see [6], for example). We can relax the requirement that every pair [...] ...|$|R
5000|$|The rows of a <b>parity</b> <b>check</b> matrix are the {{coefficients}} of the <b>parity</b> <b>check</b> equations. That is, they show how linear combinations of certain digits (components) of each codeword equal zero. For example, the <b>parity</b> <b>check</b> matrix ...|$|R
3000|$|The {{processing}} time per iteration {{can be reduced}} substantially if some means is employed to eliminate the inter-lane communications associated with performing <b>parity</b> <b>checks.</b> Consider an alternative approach to testing the correctness of code-symbol polarities in which the <b>parity</b> <b>checks</b> for a given block of rows are incorporated within the corresponding message-passing subiterations. At {{the end of each}} subiteration of the message-passing phase, the posteriors updated during the subiteration are used to determine if the corresponding subset of <b>parity</b> <b>checks</b> are satisfied. The current posterior values required for each <b>parity</b> <b>check</b> are already located in the stream-processor lane in which the <b>parity</b> <b>check</b> is performed since the updates of the same values have just been completed in the same lane. Thus the need for separate inter-lane communications for <b>parity</b> <b>checks</b> is eliminated. We refer to this non-standard schedule of <b>parity</b> <b>checks</b> as the integrated <b>parity</b> <b>check</b> (IPC). The decoding time for the IPC is shown in the second-row entry in Table 1. The {{processing time}} for the integrated message-passing-and-parity-check phase of an iteration is only [...]. 08 μ s greater than the message-passing phase alone in the standard schedule.|$|R
40|$|International audienceWe {{investigate}} {{the use of}} Low Rank <b>Parity</b> <b>Check</b> Codes, originally designed for cryptography applications {{in the context of}} Power Line Communication. Particularly, we propose a new code design and an efficient probabilistic decoding algorithm. The main idea of decoding Low Rank <b>Parity</b> <b>Check</b> Codes is based on calculations of vector spaces over a finite field math formula. Low Rank <b>Parity</b> <b>Check</b> Codes {{can be seen as the}} identical of Low Density <b>Parity</b> <b>check</b> codes. We compare the performance of this code against the Reed-Solomon Code through a Power Line Communication channel...|$|R
40|$|We propose several {{improvements}} for Linear Programming (LP) decoding algorithms for High Density <b>Parity</b> <b>Check</b> (HDPC) codes. First, {{we use the}} automorphism {{groups of}} a code to create <b>parity</b> <b>check</b> matrix diversity and to generate valid cuts from redundant <b>parity</b> <b>checks.</b> Second, we propose an efficient mixed integer decoder utilizing the branch and bound method. We further enhance the proposed decoders by removing inactive constraints and by adapting the <b>parity</b> <b>check</b> matrix prior to decoding according to the channel observations. Based on simulation results the proposed decoders achieve near-ML performance with reasonable complexity. Comment: Submitted to the IEEE Transactions on Communications, November 200...|$|R
5000|$|A {{generator}} matrix {{can be used}} {{to construct}} the <b>parity</b> <b>check</b> matrix for a code (and vice versa). If the generator matrix G is in standard form, [...] , then the <b>parity</b> <b>check</b> matrix for C is ...|$|R
5000|$|B1: Bit Error Monitoring. The B1 Byte {{contains}} {{the result of}} the <b>parity</b> <b>check</b> of the previous STM frame, after scrambling of the actual STM frame. This check is carried out with a Bit Interleaved <b>Parity</b> <b>check</b> (BIP-8).|$|R
5000|$|Static RAM {{consists}} of 16 / 24 / 32 / 40 KB general purpose with hardware <b>parity</b> <b>check,</b> 0 / 8 KB core coupled memory (CCM) with hardware <b>parity</b> <b>check,</b> 64 / 128 bytes battery-backed with tamper-detection erase.|$|R
3000|$|... of the <b>parity</b> <b>check</b> matrix is non-null. Decoding {{algorithms}} {{based on}} Tanner graphs are iterative, based on exchanging information between <b>parity</b> <b>check</b> nodes and variable nodes. Belief propagation {{is applied to}} Tanner graphs to efficiently decode LDPC codes [20, 21].|$|R
50|$|A {{fixed rate}} erasure code, usually {{with a fairly}} high rate, is applied as a 'pre-code' or 'outer code'. This pre-code may itself be a {{concatenation}} of multiple codes, for example in the code standardized by 3GPP a high density <b>parity</b> <b>check</b> code derived from the binary Gray sequence is concatenated with a simple regular low density <b>parity</b> <b>check</b> code. Another possibility would be a concatenation of a Hamming code with a low density <b>parity</b> <b>check</b> code.|$|R
5000|$|B2 : Bit Error Monitoring. The B2 Bytes {{contains}} {{the result of}} the <b>parity</b> <b>check</b> of the previous STM frame, except the RSOH, before scrambling of the actual STM frame. This check is carried out with a Bit Interleaved <b>Parity</b> <b>check</b> (BIP24) ...|$|R
40|$|In this paper, we {{investigate}} an efficient encoding approach for generalized low-density (GLD) <b>parity</b> <b>check</b> codes, a generalization of Gallager's low-density <b>parity</b> <b>check</b> (LDPC) codes. We propose a systematic approach to construct approximate upper triangular GLD <b>parity</b> <b>check</b> matrix which defines {{a class of}} efficientencoding GLD codes. It's shown that such GLD codes have equally good performance. By effectively exploiting the structure sharing in the encoding process, we also present a hardware/software codesign for the practical encoder implementation of these efficientencoding GLD codes...|$|R
40|$|A {{class of}} codes {{defined by the}} <b>parity</b> <b>check</b> matrix of a linear code of minimum {{distance}} at least t + 1 is examined {{and the number of}} <b>parity</b> <b>check</b> symbols is discussed. Determinants of this type are known as alternants (Muir and Metzler, 1930); codes corresponding to such a matrix are termed alternant codes. The <b>parity</b> <b>check</b> matrix is obtained by restricting some of its elements to subfields of GF(q to the m-th power). Minimum distance and redundancy bounds are established for these codes, and some interesting equivalence and invariance properties are derived...|$|R
3000|$|... {{and each}} {{independent}} <b>parity</b> <b>check</b> is tested. If all the <b>parity</b> <b>checks</b> are satisfied, decoding is terminated with a valid decoded code word, {{and the information}} bits are recovered by inverse mapping. If not, but {{the maximum number of}} iterations has been executed, a known decoding failure occurs. Otherwise, another iteration of the algorithm is performed. We use this schedule of updates and <b>parity</b> <b>checks</b> for the TDMP algorithm (with alternating message-passing and parity-check phases) as a benchmark in the article and refer to it as the TDMP algorithm with the standard schedule.|$|R
40|$|Simple {{arguments}} {{suggest that}} shortened codes must have distance properties {{equal to or}} better than those of their parent codes, {{and that they should}} be equally practical to decode. This relationship holds true in the case of low density generator codes and low density <b>parity</b> <b>check</b> codes. We investigate the properties of shortened turbo codes. I. Motivation for Shortening In our previous work on codes based on very sparse matrices we have observed that while codes with a low density generator matrix [1] are asymptotically bad, codes with a low density <b>parity</b> <b>check</b> matrix [2] are asymptotically good [3, 4, 5]. One way of viewing the relationship between low density generator matrix codes and low density <b>parity</b> <b>check</b> matrix codes is that one obtains a low density <b>parity</b> <b>check</b> matrix by taking the M Θ N <b>parity</b> <b>check</b> matrix [P IM] of a (N; K) low density generator matrix code and chopping off its right-most M columns (where M = N Γ K), to yield an M Θ K matrix [P], which [...] ...|$|R
40|$|Recently {{there has}} been {{interest}} {{in the construction of}} small <b>parity</b> <b>check</b> sets for iterative decoding of the Hamming code with the property that each uncorrectable (or stopping) set of size three is the support of a codeword and hence uncorrectable anyway. Here we reformulate and generalise the problem, and improve on this construction. First we show that a <b>parity</b> <b>check</b> collection that corrects all correctable erasure patterns of size m for the r-th order Hamming code (i. e, the Hamming code with codimension r) provides for all codes of codimension $r$ a corresponding ``generic'' <b>parity</b> <b>check</b> collection with this property. This leads naturally to a necessary and sufficient condition on such generic <b>parity</b> <b>check</b> collections. We use this condition to construct a generic <b>parity</b> <b>check</b> collection for codes of codimension r correcting all correctable erasure patterns of size at most m, for all r and m = 3 and r large enough. Finally we discuss some directions for further research. Comment: 13 pages, no figures. Submitted to IEEE Transactions on Information Theory, July 28, 200...|$|R
40|$|Error {{correcting}} codes prevent loss {{of integrity}} in data transmission. Low Density <b>Parity</b> <b>Check</b> codes are {{a family of}} codes that are specified by sparse matrices. Using the Nelder-Mead Downhill Simplex Evolution to design an irregular Low Density <b>Parity</b> <b>Check</b> code, we hope to improve upon the accuracy of decoding...|$|R
5000|$|... 4532624 <b>Parity</b> <b>checking</b> {{arrangement}} for a {{remote switching unit}} network ...|$|R
40|$|It is {{proposed}} {{a method for}} dynamically changing the low-density <b>parity</b> <b>check</b> code parameters in accordance with communication channel qualit y monitoring and device for storing, dynamic selection of <b>parity</b> <b>check</b> matrices and error-correcting encoding. Finally, results of the simulation codes characteristics and performance, which prove the effectiveness of proposed method, are presented...|$|R
40|$|A {{simple but}} {{effective}} decoding procedure, applicable to any (n,k) linear block code with symbols from GF(q), is described. The technique involves {{a transformation of}} the <b>parity</b> <b>check</b> equations which focuses the code's correction power on the soft symbol set while still retaining the capability to correct one symbol error from outside this set. The soft symbol set is defined to be the n-k least reliably detected code symbol positions whose <b>parity</b> <b>check</b> row-spaces are linearly independent. The process generates a number of error vector screening candidates, each {{a solution to the}} <b>parity</b> <b>check</b> equations, and the maximum-likelihood candidate is accepted...|$|R
40|$|The {{information}} hiding deals with distortion reduction using steganography and security enhancement using cryptography. Distortion reduction is done using Tree Based <b>Parity</b> <b>Check</b> which uses Majority vote strategy. The Tree Based <b>Parity</b> <b>Check</b> is very optimal for cloaking {{a message on}} image. The proposed majority vote strategy results in least distortion. The SHA- 1 algorithm is implemented for security enhancement. The result obtained in proposed method works effectively even with large payload. Codes to improve the computational complexity of wet paper codes derive d a hash function to efficiently obtain the stego object. Proposed a scheme called tree-based <b>parity</b> <b>check...</b>|$|R
30|$|To {{make the}} {{encoding}} and decoding of LDPC codes in DVB-T 2 more efficient, the sparse {{part of the}} <b>parity</b> <b>check</b> matrix {{is designed to be}} in a quasi-cyclic form [25, 26]. Thus, further efficient manipulation {{of the structure of the}} <b>parity</b> <b>check</b> matrix can make it suitable for layered decoding [27 – 29].|$|R
40|$|Abstract—Foward error {{correction}} (FEC) {{scheme based on}} low density <b>parity</b> <b>check</b> codes (LDPC) codes is presented in this paper. We show that LDPC codes provide a significant system performance enhancement {{with respect to the}} state-of-the-art FEC schemes employed in optical communication systems. Index Terms—Forward {{error correction}}, long-haul transmis-sion, low-density <b>parity</b> <b>check</b> codes, optical communications. I...|$|R
40|$|Till now {{communication}} is possible of 7 bit information data string by transmitting 11 bit data string in single frame {{due to this}} speed of communication system is very slow. And we can transmit very minimum number of configuration of data string. To increase the speed of communication system and increase the numbers of configuration data string author design some communication system by different methodologies of Hamming code. About all these communication systems all methodologies are discuss here. First, author design communication system to make communication by even <b>parity</b> <b>check</b> method for 25 bit information data string. In second paper, author design communication system to make communication by odd <b>parity</b> <b>check</b> method for 25 bit information data. In third paper, author again design communication system for 25 bit information data string by even parity and odd <b>parity</b> <b>check</b> method by using VHDL by single system. Till now, for 25 bit information data string {{communication is}} possible only in simplex mode. So that now author, design 25 bit hamming code transceiver to make communication possible in full duplex mode. Key word Hamming code, VHDL code, Xilinx ISE 10. 1 simulator, even <b>parity</b> <b>check,</b> odd <b>parity</b> <b>check,</b> transmitter, receiver, transceiver...|$|R
5000|$|... #Subtitle level 3: <b>Parity</b> <b>checking</b> {{limited to}} only 6 of 10 bits ...|$|R
50|$|In the Hagelbarger code, {{inserted}} <b>parity</b> <b>check</b> bits {{are spread}} out in time so that an error burst {{is not likely to}} affect more than one of the groups in which <b>parity</b> is <b>checked.</b>|$|R
50|$|Each packet {{consisted}} of a 32-bit header and a 16-bit header <b>parity</b> <b>check</b> word, followed by up to 80 bytes of data and a 16-bit <b>parity</b> <b>check</b> word for the data. The header contained address information identifying a particular user {{so that when the}} Menehune broadcast a packet, only the intended user's node would accept it.|$|R
