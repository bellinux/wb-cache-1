3|8447|Public
5000|$|Analysis of {{frequency}} of calls by city and area <b>code,</b> <b>if</b> <b>available</b> ...|$|E
40|$|Operating {{systems are}} complex and their {{behavior}} depends on many factors. Source <b>code,</b> <b>if</b> <b>available,</b> does not directly help understand the OS’s behavior, as the behavior depends on actual workloads and external inputs. Runtime profiling is a key technique for understanding the behavior and mutual-influence of modern OS components. Such profiling is useful to prove new concepts, debug problems, and optimize the performance of existing OSs. Unfortunately, existing profiling methods lack in important areas: they do not provide much of the necessary information about the OS’s behavior; they require OS modification and therefore are not portable; or they exact high overheads thus perturbing the profiled OS. The latency of any OS operation contains important information about its execution. Latency can be easily collected but cannot be easily analyzed; it contains a mix of latencies of differen...|$|E
40|$|Operating {{systems are}} complex and their {{behavior}} depends on many factors. Source <b>code,</b> <b>if</b> <b>available,</b> does not directly help one to understand the OS’s behavior, as the behavior depends on actual workloads and external inputs. Runtime profiling is a key technique to prove new concepts, debug problems, and optimize performance. Unfortunately, existing profiling methods are lacking in important areas—they do not provide enough information about the OS’s behavior, they require OS modification and therefore are not portable, or they incur high overheads thus perturbing the profiled OS. We developed OSprof: a versatile, portable, and efficient OS profiling method based on latency distributions analysis. OSprof automatically selects important profiles for subsequent visual analysis. We have demonstrated that a suitable workload {{can be used to}} profile virtually any OS component. OSprof is portable because it can intercept operations and measure OS behavior from user-level or from inside the kernel without requiring source code. OSprof has typical CPU time overheads below 4 %. In this paper we describe our techniques and demonstrate their usefulness through a series of profiles conducted on Linux, FreeBSD, and Windows, including client/server scenarios. We discovered and investigated a number of interesting interactions, including scheduler behavior, multi-modal I/O distributions, and a previously unknown lock contention, which we fixed. ...|$|E
50|$|Metering is via a silicon {{photocell}} (SPC) giving 6-zone evaluative metering, center-weighted metering, and 6.5% partial metering. The metering range, at ISO 100 with a 1.4 lens, is EV 1-20. Exposure {{compensation of}} ±2 EV {{can be applied}} in half-stop increments; the same range and increments apply to 3-shot auto-bracketing. The film speed range supported is ISO 25 to 8000, using DX <b>coding</b> <b>if</b> <b>available.</b>|$|R
40|$|This paper {{reports on}} an {{exemplary}} {{study of the}} performance of Computational Fluid Dynamics (CFD) computer codes for the case study of interfacial flows including surface tension. The finite volume codes of ANSYS, Inc., Fluent and CFX have been evaluated by performing CFD-simulations of collapsing water columns with and without an obstacle within enclosures. In both of these computer codes, the interfaces are treated by the volume of fluid method. The main difference is attributed to the absence of any surface reconstruction algorithms in ANSYS, Inc., CFX. Rather, the so-called “compressive scheme” is applied instead to overcome numerical diffusion and smearing of the interface. ANSYS, Inc., Fluent, however, employs the geometric reconstruction algorithm based on the Piecewise Linear Interface Construction (PLIC) method. The study assesses the simulation results obtained through the two computer codes by comparing against experimental observations and measurements as well as numerical predictions from other CFD <b>codes</b> <b>if</b> <b>available.</b> © 2009, Multi Science Publishin...|$|R
40|$|FIGURE 3. Bayesian {{phylogeny}} of 20 mitochondrial cytochrome b lineages of Plasmodium spp. and 8 lineages of Haemoproteus spp. One {{lineage of}} Leucocytozoon {{is used as}} outgroup. Posterior probabilities ≥ 0. 7 are indicated near the nodes. <b>Codes</b> of lineages (<b>if</b> <b>available)</b> are indicated, followed in parentheses by GenBank accessions, and parasite species names. Names of parasite described {{in this study are}} given in bold. Branch lengths are drawn proportionally to the amount of changes (scale bars are shown). Vertical bars A and B indicate malaria parasites belonging to the subgenera Novyella and Haemamoeba, respectively...|$|R
50|$|Because the Sweave files {{together}} with any external R files {{that might be}} sourced from them and the data files contain all the information necessary to trace back all steps of the data analyses, Sweave also {{has the potential to}} make research more transparent and reproducible to others. However, this is only the case {{to the extent that the}} author makes the data and the R and Sweave <b>code</b> <b>available.</b> <b>If</b> the author only publishes the resulting PDF document or printed versions thereof, a report created using Sweave is no more transparent or reproducible than the same report created with other statistical and text preparation software.|$|R
2500|$|Development of Swift {{started in}} July 2010 by Chris Lattner, with the {{eventual}} collaboration {{of many other}} programmers at Apple. Swift took language ideas [...] "from Objective-C, Rust, Haskell, Ruby, Python, C#, CLU, and far too many others to list". On June 2, 2014, the Apple Worldwide Developers Conference (WWDC) application became the first publicly released app written in Swift. A beta version of the programming language was released to registered Apple developers at the conference, but the company did not promise that {{the final version of}} Swift would be source code compatible with the test version. Apple planned to make source <b>code</b> converters <b>available</b> <b>if</b> needed for the full release.|$|R
40|$|In Object-Oriented programming, a {{significant}} {{effort has been}} made in recent years to increase the expressiveness of programming constructs for the production of code. Developers can implement more functionality in less lines, and with more compile-time guarantees. We have not seen such a similar evolution in the design and specification of code. Support for code specification remains a feature that is rarely integrated in the language itself (e. g., Eiffel), and is too often migrated to ad hoc language additions (e. g., annotations). The lack of such first-class, language-integrated support leads to (1) developers who are forced to write ad-hoc code specifications in a non-standardized manner, often ex-post and time-permitting, and (2) to situations in which other developers, who reuse that code, are tempted to read the <b>code</b> itself (<b>if</b> <b>available)</b> rather than the specification, in order to understand what the code actually does. In this paper, we take an evolutionary approach to language-integrated specification constructs, with the ambition to enhance the overall expressiveness of specifications in object- oriented languages. We start from existing best practices and propose improvements through specification patterns that not only enhance the expressiveness of specifications, but also aid developers in specifying their code through concrete “structures” in order to avoid ad-hoc, non-standardized specifications. Finally, we also propose language constructs that help aim to increase the level of abstraction, by shielding developers from boilerplate specification as much as possible. status: publishe...|$|R
5000|$|One typical {{implementation}} in C++ could be: class CBaseGfxAPI { virtual void DrawPoint(int x, int y) = 0; /* Abstract concept for the null driver */ virtual void DrawLine(int x1, int y1, int x2, int y2) { /* DrawPoint (...) repeated */} virtual void DrawSquare(int x1, int y1, int x2, int y2) { /* DrawLine (...) repeated */} }; class COriginalGfxAPI : public CBaseGfxAPI { virtual void DrawPoint(int x, int y) { /* The only necessary native calls */ } virtual void DrawLine(int x1, int y1, int x2, int y2) { /* If this function exists a native DrawLine routine will be used. Otherwise the base implementation is run. */} }; class CNewGfxAPI : public CBaseGfxAPI { virtual void DrawPoint(int x, int y) { /* The only necessary for native calls */ } };Note that the [...] function is never used, per se, as any graphics call goes {{through one of}} its derived classes. So a call to [...] would have its first chance to render a square by the [...] class. If no native implementation exists, then the base class is called, {{at which point the}} virtualization takes over and means that [...] is called. This gives the [...] class a “second chance” to use native <b>code,</b> <b>if</b> any is <b>available.</b>|$|R
5000|$|Ownership of <b>code</b> (<b>if</b> the client's, he {{bears the}} {{development}} cost) ...|$|R
50|$|The target returns this status <b>code</b> <b>if</b> an auto-contingent {{allegiance}} condition has occurred.|$|R
5000|$|... A {{specified}} error <b>code</b> <b>if</b> {{there was}} an error invoking the method, otherwise null.|$|R
50|$|A {{customer}} {{enters a}} card and a <b>code.</b> <b>If</b> it is valid then SimpleMat accepts the card.|$|R
40|$|Extreme programmers have {{confidence}} in their <b>code</b> <b>if</b> it passes their unit tests. More experienced extreme programmers only {{have confidence}} in their <b>code</b> <b>if</b> they also {{have confidence in}} their tests. A technique used by extreme programmers to gain confidence in their tests {{is to make sure}} that their tests spot deliberate errors in the code. This sort of manual test testing is either time consuming or very superficial...|$|R
50|$|In both <b>codes,</b> <b>if</b> {{the ball}} is caught by an {{opposition}} player this results in an interception and possession changes hands.|$|R
5000|$|Place {{of birth}} (Province with romanized transcription, or the country <b>code</b> <b>if</b> born abroad, along with Chinese {{abbreviation}} of the country) ...|$|R
5000|$|Furthermore, {{the code}} element [...] is {{designated}} as an escape <b>code</b> <b>if</b> {{the number of}} regular user-assigned code elements is not sufficient.|$|R
5000|$|For example, a {{triangular}} code is a ternary <b>code</b> , <b>if</b> , and quaternary , if [...]For R-nary triangular codes the following equalities are valid: ...|$|R
3000|$|At the {{receiver}} side, for MDS <b>codes,</b> <b>if</b> there are lost information packets, {{we have to}} solve the following system of equations for [...]...|$|R
50|$|Stories, with {{previous}} publishers, <b>if</b> <b>available.</b>|$|R
2500|$|Theorem (Distinct Cosets). A {{linear code}} [...] is an -burst-error-correcting <b>code</b> <b>if</b> all the burst errors of length [...] lie in {{distinct}} cosets of [...]|$|R
3000|$|..., {{for each}} symbol is relayed twice by two relays in the {{designed}} distributed GLD <b>code.</b> <b>If</b> {{there is not}} any relay node, that is, [...]...|$|R
5000|$|An [...] {{linear code}} {{is called a}} proper {{shortened}} cyclic <b>code</b> <b>if</b> it {{can be obtained by}} deleting [...] positions from an [...] cyclic code.|$|R
5000|$|Theorem (Distinct Cosets). A {{linear code}} [...] is an -burst-error-correcting <b>code</b> <b>if</b> all the burst errors of length [...] lie in {{distinct}} cosets of [...]|$|R
40|$|AbstractThis paper finds all the odd primes p {{which can}} divide {{the order of}} the group of an extremal doubly-even (72, 36, 16) <b>code</b> (<b>if</b> one exists) and an extremal {{quaternary}} (24, 12, 10) <b>code</b> (<b>if</b> one exists). Information is given about the cycle structure of the element of order p which could aid in the construction of these codes. A number of new techniques are given for determining if an element of odd prime order can be in the group of a code...|$|R
2500|$|... including, <b>if</b> <b>available,</b> {{photos and}} biographies (in French).|$|R
5000|$|It is {{possible}} to interrogate {{the elements of the}} block and change their values, thus altering the behavior of the <b>code</b> <b>if</b> it were to be evaluated: ...|$|R
5000|$|Opt-out policy {{describing}} {{procedure for}} account termination, <b>if</b> <b>available</b> ...|$|R
25|$|Prenatal alcohol {{exposure}} {{is determined by}} interview of the biological mother or other family members knowledgeable of the mother's alcohol use during the pregnancy (<b>if</b> <b>available),</b> prenatal health records (<b>if</b> <b>available),</b> and review of available birth records, court records (if applicable), chemical dependency treatment records (if applicable), or other reliable sources.|$|R
40|$|Many {{commercial}} enterprises effectively utilize {{open source}} code when developing various software products—virtually every software developer uses open source {{in his or}} her work. But along with economic benefits and production efficiency come significant legal risks, exacerbated by the wide availability of OSS components. While some licenses are permissive and demand very little, others require any work based on, or even containing only parts of an open source code, to be distributed only as OSS. Most commercial enterprises and software developers recognize potential business and legal risks and implement some sort of compliance mechanism as a best practice. But what should the enterprise do if its software developer either intentionally or inadvertently incorporates open source code? Can one remedy such a situation? What are the chances that the licensor will actually enforce the license requirements? And if the company decides to comply, what does compliance then entail? This Comment, in an attempt to answer these questions, concludes that the risks associated with OSS, although not minimal, are generally known and an effective toolset to prevent intermixing of open source code with closed <b>code</b> is <b>available.</b> <b>If</b> the violation nevertheless occurs, there are steps a business could take to either remedy the violation or comply with the licensing requirements...|$|R
3000|$|In this way, all the {{constituent}} codes forwarded by the relays construct a distributed GLD <b>code.</b> <b>If</b> all {{the constituent}} codes are forwarded successfully, each code symbol [...]...|$|R
50|$|<b>If</b> <b>available,</b> song {{lists are}} {{provided}} with release-based catalog numbers.|$|R
5000|$|GERAN-preferred: uses {{cellular}} networks <b>if</b> <b>available,</b> {{otherwise the}} 802.11 radio ...|$|R
5000|$|Use strong email {{passwords}} {{and enable}} two-factor authentication <b>if</b> <b>available.</b>|$|R
3000|$|Let C be {{a linear}} block code over a finite field F of block length n. C {{is called a}} cyclic <b>code,</b> <b>if</b> for every {{codeword}} c[*]=[*](c 1,…,c [...]...|$|R
