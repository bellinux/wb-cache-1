1075|763|Public
25|$|The {{discussion}} below {{focuses on}} the case of multiple computers, although many of the issues are the same for <b>concurrent</b> <b>processes</b> running on a single computer.|$|E
25|$|The use of <b>concurrent</b> <b>processes</b> that {{communicate}} by message-passing {{has its roots}} in operating system architectures studied in the 1960s. The first widespread distributed systems were local-area networks such as Ethernet, which was invented in the 1970s.|$|E
25|$|In 1968 Dijkstra {{published}} his seminal paper 'Cooperating sequential processes', a 70-page essay that originated {{the field of}} concurrent programming. He discussed in it the notion of mutual exclusion (mutex) and the criteria a satisfactory solution should satisfy. He also redressed the historical perspective left out of his 1965 paper by including the first known correct solution to the mutual exclusion problem, for two processes, due to Theodorus Dekker. Dijkstra subsequently generalized Dekker's solution to n processes. Further, he proposed the first synchronisation mechanism for <b>concurrent</b> <b>processes,</b> the semaphore with its two operations, P and V. He also identified the 'deadlock problem' (called there 'the problem of the deadly embrace') and proposed an elegant 'Banker's algorithm' that prevents deadlock. The deadlock detection and prevention became perennial research problems {{in the field of}} concurrent programming.|$|E
40|$|The <b>concurrent</b> <b>process</b> design {{involves}} the simultaneous considerations of product design, tool design, machine-selection, production scheduling, and cost {{as early as}} possible in the design stage, the main theme being to capture and handle a large variety and volume of knowledge. Knowledge-based system is one of the promising approaches to facilitate <b>concurrent</b> <b>process</b> design. In order to manage heterogeneous knowledge bases, an effective architecture is required to implement such a process design procedure, where more than one domain expert is involved. In this paper, blackboard architecture for <b>concurrent</b> <b>process</b> design is presented, a blackboard-based system for <b>concurrent</b> <b>process</b> design of injection moulding being developed and presented. (C) 1997 Elsevier Science S. A...|$|R
40|$|Abstract. The {{differences}} of development cycle between product serial and <b>concurrent</b> development <b>process</b> are obtained through simulation in this paper, which implies {{the importance of}} rational planning {{in the process of}} product development. The models of product serial and <b>concurrent</b> development <b>process</b> are built based on witness. Three types of models for both simple and complex products have been made respectively to simulate,and then compared results have been got under six different conditions. Among six situations, the results of four are that the time of <b>concurrent</b> <b>process</b> is much shorter than that of serial process; one is that the time is very close; another is that <b>concurrent</b> <b>process</b> is much longer. We draw a conclusion that product development process must be rationally planned in order to shorten the development cycle for some complex products. 1...|$|R
40|$|Algorithms are {{presented}} for detecting errors and anomalies in programs which use synchronization constructs to implement concurrency. The algorithms employ data flow analysis techniques. First used in compiler object code optimization, the techniques have more recently {{been used in}} the detection of variable usage errors in single process programs. By adapting these existing algorithms the same classes of variable usage error can be detected in <b>concurrent</b> <b>process</b> programs. Important classes of errors unique to <b>concurrent</b> <b>process</b> programs are also described, and algorithms for their detection {{are presented}}...|$|R
2500|$|In {{as much as}} it is {{concerned}} with <b>concurrent</b> <b>processes</b> that exchange messages, the Actor model is broadly similar to CSP. However, the two models make some fundamentally different choices with regard to the primitives they provide: ...|$|E
2500|$|Another basic {{aspect of}} {{distributed}} computing architecture is {{the method of}} communicating and coordinating work among <b>concurrent</b> <b>processes.</b> Through various message passing protocols, processes may communicate directly with one another, typically in a master/slave relationship. Alternatively, a [...] "database-centric" [...] architecture can enable distributed computing to be done without any form of direct inter-process communication, by utilizing a shared database.|$|E
2500|$|Jorge N. Amely Vélez (born 1955) – {{a native}} of San German, is an {{inventor}} who holds various patents {{in the field of}} Medical Technology. In 1989, Amely Vélez earned his Master's degree in Electrical Engineering from California State University at Northridge. Among Amely Vélez's inventions are two which involve the methods and apparatuses for timing events within an implantable medical device capable of performing many <b>concurrent</b> <b>processes.</b> He authored a method to help prevent defibrillator output stage short circuit failures in implantable devices. Amely Vélez invented methods for a microprocessor based implantable device to have a configurable memory to assist in software development and patching [...] "Read Only Memory" [...] (ROM) based systems. He coauthored inventions in the field of rechargeable lithium silver vanadium oxide batteries for implantable devices and holds a patent for intracardiac lead impedance measurements using a painless waveform. It is a leakage detection system that includes a switch. He also holds another patent for an implantable defibrillator with sensing and pacing auto-capture capabilities. Amely Vélez has other patents pending. He is the coauthor of a patent which is pending for radio frequency antennas in implantable devices. The other two patents that are pending cover work related to magnetic and electric noise shielding in medical devices.|$|E
50|$|However, {{application}} of an activity based recording may be applied as {{an addition to}} activity based accounting, not as a replacement of any costing model, but to transform <b>concurrent</b> <b>process</b> accounting into a more authentic approach.|$|R
40|$|We prove {{soundness}} and completeness {{for some}} ACP-style concrete, relative-time, discrete-time process algebras. We treat non-delayable actions, delayable actions, and immediate deadlock. Basic process algebras are examined extensively, {{and also some}} <b>concurrent</b> <b>process</b> algebras are considered. We conclude with ACPdrt, which combines all described features in one theory...|$|R
40|$|In {{undergraduate}} {{operating systems}} classes, {{students learn about}} <b>concurrent</b> <b>process</b> synchronization, including such things as shared data, race conditions, critical sections, mutual exclusion, semaphores, monitors, and the test-and-set hardware instruction. They also study interprocess communication, message passing, rendezvous, and remote procedure calls. Solutions to classical problems, such as the dining philosophers, producers and consumers, bounded buffers, and readers and writers, are presented using the above concepts. However, students need to write programs in a language that provides facilities for concurrent programming in order to appreciate fully the above concepts. This paper describes the SR language and discusses its successful use as an environment for concurrent programming in an undergraduate operating systems class. 1 Introduction Standard undergraduate operating systems textbooks, such as [1, 2, 3] cover the important concepts involved in <b>concurrent</b> <b>process</b> synchr [...] ...|$|R
5000|$|The {{coroutine}} as {{the basic}} building block for <b>concurrent</b> <b>processes</b> ...|$|E
5000|$|Concurrent Haskell—lazy, pure {{functional}} language operating <b>concurrent</b> <b>processes</b> on shared memory ...|$|E
5000|$|Anne Kaldewaij (1986: A Formalism for <b>Concurrent</b> <b>Processes.</b> Technische Universiteit Eindhoven) (Secondary advisor: Frans Kruseman Aretz) ...|$|E
40|$|This paper {{describes}} {{our initial}} experiences of running simple blood-clot simulations on Grid infrastructure. The individual simulations are <b>concurrent</b> <b>process</b> networks programmed in occampi, containing over ten thousand parallel processes. The Minimum intrusion Grid (MiG) infrastructure {{is used to}} distribute program execution and result collection automatically across a set of processing nodes...|$|R
40|$|Abstract—This paper {{describes}} {{our initial}} experiences of running simple blood-clot simulations on Grid infrastructure. The individual simulations are <b>concurrent</b> <b>process</b> networks programmed in occam-π, containing over ten thousand parallel processes. The Minimum intrusion Grid (MiG) infrastructure {{is used to}} distribute program execution and result collection automatically across a set of processing nodes. Index Terms—grid, simulation, occam-pi, blood-clot, nanit...|$|R
40|$|AbstractWhen {{concurrency}} is {{a primitive}} notion, models of process calculi usually include commuting diamonds and observations of causality links or of abstract locations. However {{it is still}} debatable if the existing approaches are natural, or rather if they are an ad hoc addition to the more basic interleaving semantics. In the paper a treatment of <b>concurrent</b> <b>process</b> calculi is proposed where the same operational and abstract concurrent semantics described in the literature now descend from general, uniform notions. More precisely we introduce a tile-based semantics for located CCS and we show it consistent with the ordinary concurrent (via permutation of transitions) and bisimilarity based location semantics. Tiles are rewrite rules with side effects, reminiscent of both Plotkin SOS and Meseguer rewriting logic rules. We argue that the tile model is particularly well suited for defining directly operational and abstract semantics of <b>concurrent</b> <b>process</b> calculi in a compositional style...|$|R
50|$|The {{discussion}} below {{focuses on}} the case of multiple computers, although many of the issues are the same for <b>concurrent</b> <b>processes</b> running on a single computer.|$|E
50|$|Constraint {{handling}} rules {{can be seen}} as a form of concurrent constraint logic programming, but {{are used}} for programming a constraint simplifier or solver rather than <b>concurrent</b> <b>processes.</b>|$|E
5000|$|These {{couplings}} are <b>concurrent</b> <b>processes,</b> called behaviours, {{which take}} the local sensing data and compute the best action to take independently {{of what the}} other processes are doing.|$|E
40|$|In {{this paper}} {{we present a}} general {{approach}} to give semantics of synchronous languages. By applying this approach, we define two semantics for Timed Default Concurrent Constraint Programming. 1 Introduction Nondeterministic <b>concurrent</b> <b>process</b> languages are languages for the description of interactive systems, namely systems interacting with their environment at their own rate. In [8] and [9] Letichevsky and Gilbert present a general theory for such languages. They introduce Action Language as a common model for nondeterministic <b>concurrent</b> <b>process</b> languages and define two semantics for it, an intensional semantics and an interactive semantics. The intensional semantics of a program gives its behavior by abstracting from {{the behavior of the}} environment. The idea of interactive semantics is that the meaning of a program is a transformation of its environment, which corresponds to inserting the program into the environment. If a notion of behavior of the environment is defined, then the i [...] ...|$|R
40|$|To {{understand}} the patterns and possible consequences of Latino suburbanization, {{it is necessary}} to comprehend the historical demographic processes which have resulted in this centralization (urbanization) and decentralization (intra-metropolitan dispersion). This paper will describe these processes, discuss their distinctiveness, and finally, consider the implications which point to a <b>concurrent</b> <b>process</b> for Latinos in Los Angeles of "traditional" suburbanization and new barrio formation...|$|R
40|$|International audienceMarkov {{decision}} processes (MDP) {{are useful}} to model <b>concurrent</b> <b>process</b> optimisation problems, but verifying them with numerical methods is often intractable. Existing approximative approaches {{do not scale}} well and are limited to memoryless schedulers. Here we present the basis of scalable verification for MDPs, using an O(1) memory representation of history-dependent schedulers. We thus facilitate scalable learning techniques {{and the use of}} massively parallel verification...|$|R
5000|$|Cooperating <b>concurrent</b> <b>processes</b> have an {{inherent}} need for synchronization, which ensures that changes {{happen in a}} correct and predictable fashion. Three basic situations that define {{the scope of this}} need: ...|$|E
50|$|Maurice Herlihy (1991) {{proved that}} fetch-and-add has a finite {{consensus}} number, {{in contrast to}} the compare-and-swap operation. The fetch-and-add operation can solve the wait-free consensus problem for no more than two <b>concurrent</b> <b>processes.</b>|$|E
50|$|To {{solve the}} {{consensus}} {{problem in a}} shared-memory system, concurrent objects must be introduced. A concurrent object, or shared object, is a data structure which helps <b>concurrent</b> <b>processes</b> communicate to reach an agreement.|$|E
40|$|Part 1 : Production ProcessInternational audienceThe cyclic {{scheduling}} problem modeled {{in terms of}} Cyclic <b>Concurrent</b> <b>Process</b> Systems is considered. The problem {{can be seen as}} a kind of Diophantine problem, hence its solvability, i. e. schedulability, plays a pivotal role in many supply-chain problems. In contradiction to the traditionally offered solutions the approach proposed allows one to take into account such behavioral features as transient periods and deadlocks occurrence. So, the contribution’s aim is the modeling framework enabling an evaluation of cyclic {{scheduling problem}}s solvability, i. e., the declarative approach to reachability problems regarding cyclic steady states determination as well as conditions guaranteeing assumed performance of multimodal processes executed within a <b>concurrent</b> cyclic <b>processes</b> environment...|$|R
40|$|In this {{dissertation}} {{we investigate}} presheaf models for concurrent computation. Our {{aim is to}} provide a systematic treatment of bisimulation {{for a wide range of}} <b>concurrent</b> <b>process</b> calculi. Bisimilarity is defined abstractly in terms of open maps as in the work of Joyal, Nielsen and Winskel. Their work inspired this thesis by suggesting that presheaf categories could provide abstract models for concurrency with a built-in notion of bisimulation. We show ho...|$|R
40|$|We {{develop a}} 2 -categorical theory for recursively defined domains. In particular, we generalise the {{traditional}} approach based on order-theoretic structures to categorytheoretic ones. A motivation for this development is the need of a domain theory for concurrency, with an account of bisimulation. Indeed, the leading examples throughout the paper are provided by recursively defined presheaf models for <b>concurrent</b> <b>process</b> calculi. Further, we use the framework to study (open-map) bisimulation...|$|R
5000|$|... #Caption: A {{semaphore}} (seinpaal, {{the term}} used in Dijkstra's original description). In the early 1960s Dijkstra proposed the first synchronisation mechanism for <b>concurrent</b> <b>processes,</b> the semaphore with its two operations, P and V.|$|E
50|$|Maurice Herlihy (1991) {{proved that}} test-and-set has a finite {{consensus}} number and can solve the wait-free consensus problem for at-most two <b>concurrent</b> <b>processes.</b> In contrast, compare-and-swap offers {{a more general}} solution to this problem.|$|E
50|$|The fourth word is the wait/nowait switch. A {{single-threaded}} server expects inetd to {{wait until}} it finishes reading all the data. Otherwise inetd lets the server run and spawns new, <b>concurrent</b> <b>processes</b> for new requests.|$|E
40|$|We make {{a mixture}} of Milner's π-calculus and our {{previous}} work on truly <b>concurrent</b> <b>process</b> algebra, which is called π_tc. We introduce syntax and semantics of π_tc, its properties based on strongly truly concurrent bisimilarities. Also, we include an axiomatization of π_tc. π_tc {{can be used as}} a formal tool in verifying mobile systems in a truly concurrent flavor. Comment: 20 pages. arXiv admin note: text overlap with arXiv: 1703. 00159, arXiv: 1611. 0903...|$|R
40|$|Parafrase {{transforms}} a FORTRAN code, subroutine by subroutine, into {{a parallel}} code for a vector and/or shared-memory multiprocessor system. Parafrase {{is not a}} compiler; it transforms a code and provides information for a vector or <b>concurrent</b> <b>process.</b> Parafrase uses a data dependency to reveal parallelism among instructions. The data dependency test distinguishes between recurrences and statements that can be directly vectorized or parallelized. A number of transformations are required to build a data dependency graph...|$|R
40|$|Markov {{decision}} processes (MDP) {{are useful}} to model <b>concurrent</b> <b>process</b> optimisation problems, but verifying them with numerical methods is often intractable. Existing approximative approaches {{do not scale}} well and are limited to memoryless schedulers. Here we present the basis of scalable verification for MDPSs, using an O(1) memory representation of history-dependent schedulers. We thus facilitate scalable learning techniques {{and the use of}} massively parallel verification. Comment: V 4 : FMDS version, 12 pages, 4 figure...|$|R
