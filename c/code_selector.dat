13|16|Public
25|$|Almost every ARM {{instruction}} has a conditional execution feature called predication, {{which is}} implemented with a 4-bit condition <b>code</b> <b>selector</b> (the predicate). To allow for unconditional execution, {{one of the}} four-bit codes causes the instruction to be always executed. Most other CPU architectures only have condition codes on branch instructions.|$|E
5000|$|ALQ-144A(V)5 - Increased {{protection}} with a dual phaselocked transmitters and jam <b>code</b> <b>selector</b> {{switch on}} the operator control unit ...|$|E
50|$|The first code {{selectors}} had {{levels for}} local exchange calls and {{calls to the}} local tandem exchange. An exchange with up to 23 outgoing routes would require a second code selection stage on some calls, and for more outgoing routes (up to 93) some third selection stages. But as a nearby business exchange might have 50 TU (traffic units) in the BH (busy hour), and more distant exchanges might have only 2 or 3 TUs, the busy routes {{should be on the}} first code selectors and the least busy routes only via a second and perhaps a third selection stage. Hence for a hypothetical example with 30 outgoing routes, three schemes are possible with (A) three second and no third <b>code</b> <b>selector</b> groups, (B) two second and one third <b>code</b> <b>selector</b> groups, and (C) one second and two third <b>code</b> <b>selector</b> groups. The number of switches for the hypothetical traffic distribution is 348, 302 and 315 switches, i.e. scheme B is the optimum; but each exchange must be calculated individually. The busy routes should also be allocated to the lower levels on the selectors to minimise setting-up time and also the number of operations of the mechanism and hence the wear on them.|$|E
50|$|Each local {{exchange}} incorporated {{up to eight}} groups of directors which translated the first three digits (ABC digits) comprising the exchange name into a pulse train of one to six digits, as required for each exchange and unique to that exchange. The translated digits {{were sent to the}} <b>code</b> <b>selectors,</b> and then the four numeric digits were sent to three switching stages in the terminating exchange (two group selectors and a final selector). Hence local calls within the exchange and busy direct junction routes to exchanges with high traffic from that exchange could be trunked via one code selection stage, which reduced both the setting-up time and the total numbers of selectors required in the network. Distant exchanges which did not justify direct junction routes could be called via one or more tandem exchanges; being routed via one, two or three local <b>code</b> <b>selectors</b> in the originating exchange, one or more selectors in the tandem exchange(s), and finally the numeric selection stages in the terminating exchange for the last four digits, which were stored and forwarded without translation.|$|R
40|$|A multi-output {{instruction}} (MOI) is {{an instruction}} that produces multiple outputs to its destination locations. Such inherently parallel instructions {{are becoming more}} and more popular in embedded processors, due to the advances in application-specific architectures. In order to provide high-level programmability and thus guarantee widespread acceptance, sophisticated compiler support for these programmable cores is necessary. However, traditional tree-based approaches for instruction selection, although very fast, fail to exploit MOIs mainly because of the fundamental limitation of the tree representation. In fact, to generate optimal code with MOIs requires a more general graph-based formulation of the instruction selection problem, which is at least NP-complete. In this paper we present a new methodology to automatically generate from simple instruction set descriptions, graph-based <b>code</b> <b>selectors</b> that can effectively utilize all provided instructions including MOIs. Our experimental results using a set of benchmarks on a target processor with various MOIs of up to two outputs demonstrate that our generated <b>code</b> <b>selectors</b> can quickly and effectively exploit many MOIs at the application level, and therefore are highly desirable both for architecture exploration and as code generators after architecture is fixed. close...|$|R
40|$|Abstract{Besides high code quality, {{a primary}} issue in {{embedded}} code generation is retargetability of code generators. This paper presents techniques for automatic generation of <b>code</b> <b>selectors</b> from externally speci ed processor models. In contrast to previous work, our retargetable compiler Record does not requiretoolspeci c modelling formalisms, but starts from general HDL processor models. From an HDL model, all processor aspects needed for code generation are automatically derived. As demonstrated by experimental results, short turnaround times for retargeting are achieved, which permits {{to study the}} HW/SW trade-o between processor architectures and program execution speed. ...|$|R
50|$|Almost every ARM {{instruction}} has a conditional execution feature called predication, {{which is}} implemented with a 4-bit condition <b>code</b> <b>selector</b> (the predicate). To allow for unconditional execution, {{one of the}} four-bit codes causes the instruction to be always executed. Most other CPU architectures only have condition codes on branch instructions.|$|E
50|$|Local call {{metering}} {{must be done}} at the originating exchange, {{and when}} local calls were charged by distance it was preferable for the first <b>code</b> <b>selector</b> levels to determine the number of unit fees required. The fee was 1 unit up to 5 miles, 2 units 5 to 7½ miles, 3 units 7½ to 12½ miles, and 4 units 12½ to 15 miles.|$|E
5000|$|As {{described}} above, unreal mode {{usually involves}} using {{one or more}} data selectors to address data in memory more efficiently. This has been common practice and {{often referred to as}} [...] "big" [...] real mode."Huge" [...] real mode is attained by, in addition, loading the <b>code</b> <b>selector</b> (CS) from a descriptor allowing access to the whole memory and having the 32-bit attribute ("D" [...] bit) set to one. This rarely used [...] "mode" [...] presents some advantages but it is more difficult to set up, since real mode interrupts do not automatically preserve the high sixteen bits of the extended instruction pointer, EIP.|$|E
50|$|The Class <b>Selector</b> <b>code</b> {{points are}} of the form 'xxx000'. The first three bits are the IP {{precedence}} bits. Each IP precedence value can be mapped into a DiffServ class. CS0 equals to IP precedence 0, CS1 to IP precedence 1, and so on. If a packet is received from a non-DiffServ aware router that used IP precedence markings, the DiffServ router can still understand the encoding as a Class <b>Selector</b> <b>code</b> point.|$|R
40|$|Besides high code quality, {{a primary}} issue in {{embedded}} code generation is retargetability of code generators. This paper presents techniques for automatic generation of <b>code</b> <b>selectors</b> from externally specified processor models. In contrast to previous work, our retargetable compiler Record {{does not require}} toolspecific modelling formalisms, but starts from general HDL processor models. From an HDL model, all processor aspects needed for code generation are automatically derived. As demonstrated by experimental results, short turnaround times for retargeting are achieved, which permits to study the HW/SW trade-off between processor architectures and program execution speed. 1 Introduction Today, many designs of embedded VLSI systems are based on programmable processors. Compared to custom hardware, processor-based design offers increased reusability and flexibility. Many standard processors are currently available in form of cores, which can be instantiated like library components. How [...] ...|$|R
40|$|We {{deal with}} the {{generation}} of <b>code</b> <b>selectors</b> in compiler backends. The fundamental concepts are systematically derived from the theory of regular tree grammars and finite tree automata. We use this general approach to construct algorithms that generalize and improve existing methods. 1 Introduction A code generator for a compiler is applied to an intermediate representation (IR) of the input program that has been computed during preceding phases of compilation. This intermediate representation {{can be viewed as}} code for an abstract machine. The task of code generation is to translate this code into an efficient sequence of instructions for a concrete machine. Besides register allocation and instruction scheduling (for processors with pipelined architectures), code selection, i. e., the selection of instructions, is one subtask of code generation. It is especially important for CISC (Complex I nstruction Set Computer) architectures where there are usually many possibilities to generat [...] ...|$|R
50|$|To make a call, the subscriber's uni{{selector}} seizes a free 1st <b>code</b> <b>selector,</b> {{which in}} turn seizes an A-digit selector via an A-digit hunter uniselector. The A-digit selector returns dial tone, steps to the first dialled digit and searches for a free director from that group. The director includes a two-motion selector - the BC switch - which steps vertically and then horizontally according to the two BC digits. This selector has 6 banks to permit up to 6 pulse trains to be generated by the director to step the code selectors; the bank contacts are strapped via a translation field to indicate the digit required (or to a DCO lead to indicate that all translation digits have been sent). The pulse train output begins after the C-digit is received from the subscriber's telephone. This is generated {{under the control of}} the send switch uniselector as it searches for the marks provided by the translation field straps for the exchange code received. Meanwhile, the subscriber has continued to dial and the four digits of the numerical portion of the number are stored on four more uniselectors. These set up four more marks, and after completing the output of the code translation the send switch uniselector searches for them in turn in order to forward the numerical digits unchanged to step the numerical selectors at the terminating exchange.|$|E
40|$|Code Selection in {{translation}} has been effectively abstracted out {{in terms of}} tree rewriting or pattern matching based approaches. However, modelling register files in an architecture independent way is a problem which is bypassed in most available algorithms. Architectural parameterization is frequently just <b>code</b> <b>selector</b> generation while architectural registers and operand constraints are handled in a machine-specific way. To partially address this issue, we present an abstraction for register allocation and assignment in non-uniform register file architectures in terms of bipartite graph matching...|$|E
40|$|AbstractThe goal of {{this work}} {{is to provide a}} general {{framework}} for the pattern matching approach to the code selection problem with the following properties: recent approaches can be reformulated and compared in this framework, it accommodates increased expressive power for defining intermediate languages, it provides formal criteria for the completeness of a <b>code</b> <b>selector</b> specification, it uses a straightforward generalization of known pattern matching techniques, it offers a new way to integrate the “nonsyntactic” subtasks of code generation with the pattern matching process. These properties are achieved by formulating pattern matching as the problem of constructing an inverse to a hierarchic derivor between order-sorted term algebras...|$|E
25|$|At {{international}} level Biggs was dropped once more, when the charismatic James Brothers were reselected over {{him for the}} England game during the 1899 Championship. England were beaten convincingly, but the James brothers both turned professional shortly afterwards, making themselves ineligible for further appearances under the rugby union <b>code.</b> The <b>selectors</b> brought Lloyd back into the squad to partner Biggs {{in the final two}} games of the tournament, losses to Scotland and Ireland.|$|R
50|$|By this time, {{the pace}} of Mac {{development}} had produced such a proliferation of hardware configurations and hardware and software add-ons from Apple and third parties that a simple version check was no longer enough to determine {{the features of the}} system. Instead, Gestalt maintains a dynamically-extensible table of OSType <b>selector</b> <b>codes.</b>|$|R
40|$|Projet CHLOEPagode is a {{back-end}} generator {{which produces}} automatically the various engines of a <b>code</b> generator (instruction <b>selector,</b> scheduler and register allocator) from a target machine specification. This report mainly {{focuses on the}} features of the target machine which aim at producing the scheduler, and on the heuristics used by the kernel of the scheduler...|$|R
40|$|International audienceEfficient {{architecture}} {{exploration and}} design of application specific instruction-set processors (ASIPs) requires retargetable software development tools, in particular C compilers that can be quickly adapted to new architectures. A widespread approach is to model the target architecture in a dedicated architecture description language (ADL) and to generate the tools automatically from the ADL specification. For C compiler generation, however, most existing systems are limited either by the manual retargeting effort or by redundancies in the ADL models that lead to potential inconsistencies. We present {{a new approach to}} retargetable compilation, based on the LISA 2. 0 ADL with instruction semantics, that minimizes redundancies while simultaneously achieving a high degree of automation. The key of our approach is to generate the mapping rules needed in the compiler's <b>code</b> <b>selector</b> from the instruction semantics information. We describe the required analysis and generation techniques, and present experimental results for several embedded processors...|$|E
40|$|Over {{the past}} few years, the ever {{increasing}} complexity and performance requirements of new wireless communications, automotive and consumer electronics applications are changing the way embedded systems are designed and implemented today. The current trend is towards programmable System-on-Chip platforms {{in order to improve}} the design efficiency and reduce the risk and costs of hardware redesign cycles. An increasing number of such systems employ Application Specific Instruction-set Processors (ASIPs) as building blocks due to their balance between computational efficiency and flexibility. Consequently, more and more commercial platforms are available for ASIP architecture exploration and design. These platforms comprise retargetable software development tools (C-compiler, assembler, linker, simulator etc.) that can be quickly adapted to varying target processor configurations. Such tools are usually driven by a processor model given in a dedicated Architecture Description Language (ADL). Advanced ADLs are even capable of generating the system interfaces and a synthesizable hardware model from the same specification. The most challenging task designing an ADL, though, is to capture the architectural information needed for the tool generation in an unambiguous and consistent way. This is particularly difficult for compiler and simulator as they essentially need both the information about the instruction's semantics but from different points of view. The compiler, more specifically the compiler's <b>code</b> <b>selector,</b> needs to know what an instructions does in order to select appropriate instructions for a given piece of source code, while the simulator needs to know how the instruction is executed. In practice it is quite difficult, if not impossible, to derive one information from the other. None of the existing ADLs - if compiler generation is supported at all - solves this problem in a sophisticated manner. Either redundancies are introduced or the language's flexibility is sacrificed. Another challenge in this context is retargetable compilation for high-level programming languages like C/C++. Meanwhile, compilers became a necessity in order to attain high software development productivity and to cope with the ever growing complexity of today's applications. Retargetable C compilers however, are often hampered by their limited code quality as compared to hand-written compilers or assembly code since there is usually a trade-off between the compiler's flexibility and the quality of compiled code. In order to narrow the code quality gap this demands flexible retargetable optimization techniques for common architectural features which can be quickly adapted to varying target processor configurations. This thesis presents a novel technique for extracting the <b>code</b> <b>selector</b> description fully automatically from ADL processor models. The approach is based on the Language for Instruction Set Architectures (LISA) ADL using a language extension for instruction semantics description. This enables the automatic generation of C compilers from a LISA processor description without loosing flexibility or introducing inconsistencies. In this way, a high speedup in compiler generation is achieved, that contributes to a more efficient ASIP design flow. The feasibility of the approach is demonstrated for several contemporary embedded processors. Furthermore, two popular architectural classes are selected which demand for specific code optimization techniques, namely processors equipped with SIMD instructions and those with Predicated Execution support. This thesis implements these specific techniques such that retargetability and high code quality within the given processor class are obtained. Moreover, to ease the manual creation of dedicated optimizations on the assembly level, this thesis implements a new retargetable assembler which provides an application programmer interface for user defined code optimizations like e. g. a peephole optimizer...|$|E
40|$|The {{study of}} {{architectural}} parameterization has long neglected other parameterizations {{in favour of}} <b>code</b> <b>selector</b> descriptions. In this dissertation, we are concerned with providing linguistic notations for modelling architectures with special emphasis on translation. We focus on high level descriptions to aid code selection and storage allocation. The view taken in the thesis is that a description specializes a framework with a particular architecture. Independently, the framework must support other translation algorithms without constraining their freedom or forcing them towards architecture-specific idioms. The first contribution is an architectural description language with features tuned towards better parameterizability. Emphasis is laid on addressing site (compile time) parameterizability. Within the notation, the type system of the machine is decoupled {{from that of the}} language with the mapping being left to the user as a compile-time parameterization. This gives one more degree of freedom for the user to decide on the precision required based on the available realizations. We also give adequate representation to addressing modes. They are considered to be almost equivalent to operations in complexity. This makes the specification simpler for operations. From the framework's perspective, as a second contribution, we propose an algorithm for maintaining registers during allocation. Register allocation algorithms depend on the framework to inform them when registers are exhausted. In such a situation, we pro- pose an adaptation of bipartite graph matching to keep track of register usage during translation in the presence of architec- tural constraints. The research also aims at structuring both the specification and software to prevent the closed-syntax bottle- neck of a lot of specification languages. We also describe the architecture of the implementation in terms of a very flexible model called the blackboard model...|$|E
5000|$|Note that, in {{protected}} mode, code may always modify all segment registers except CS (the <b>code</b> segment <b>selector).</b> This {{is because}} the current privilege level (CPL) of the processor is stored in the lower 2 bits of the CS register. The only way to raise the processor privilege level (and reload CS) is through the lcall (far call) and int (interrupt) instructions. Similarly, {{the only way to}} lower the privilege level (and reload CS) is through lret (far return) and iret (interrupt return) instructions. In real mode, code may also modify the CS register by making a far jump (or using an undocumented [...] instruction on the 8086 or 8088)). Of course, in real mode, there are no privilege levels; all programs have absolute unchecked access to all of memory and all CPU instructions.|$|R
40|$|Abstract:- In this paper, a CMOS radio {{frequency}} (RF) multi-band band-pass amplifier using a high-Q active inductor load with a binary <b>code</b> band <b>selector</b> suitable for multi-standards wireless applications is proposed. By employing the improved high-Q active inductor including two bits binary controlled code, the RF multi-band amplifier operating at four different frequency bands is realized. The proposed amplifier circuit is designed in TSMC 0. 18 -um CMOS technology. Based on the simulation results, the amplifier can operate at 900 MHz, 1. 8 GHz, 2. 4 GHz, and 3. 6 GHz with forward gain (S 21) of 21. 9 dB, 21. 9 dB, 21. 8 dB, and 12. 5 dB, respectively. Furthermore, the power dissipation of this amplifier can retain constant at all operating frequency bands and consume around 5. 27 mW from 1. 8 -V power supply. Key-Words:- CMOS, High-Q Active Inductor, Bands Selector, Multi-Band Amplifier, and Multi-Standards. ...|$|R
40|$|The task of {{analyzing}} command line options {{is present in}} most production applications. This option-processing task normally involves a set of option handlers and associated guards. A guard defines the situations where its handler is executed. These guards typically {{take the form of}} a selector from a set of characters. In addition, command line options are generally associated with a particular feature. If an application is constructed by the composition of features, that construction should include the composition of associated command line options. The inclusion of any given option should depend on whether its feature is included in the generated application. Composition of selector-guarded option handlers requires more care then needed for composition of linear <b>code</b> sequences. <b>Selectors</b> that share a common domain need to share the value space defined by the domain: there should be no overlap among the selectors and any unrecognized value should be uniformly handled by the applicatio [...] ...|$|R
40|$|A digitalized two channel audio {{recording}} adapter {{which can be}} used in conjuction with the home type video tape recorder has been trially manufactured. This report describes the overall system design and the outline of its recording circuits. An adaptive delta modulator having a digital <b>code</b> detector and <b>selector</b> was used for a simple analog to digital conversion. The sampling rate of the modulator was selected as 1. 1025 Mbits/s, considering the requirement to record the digitalized data on the home use VTR. Theoretically estimated signal to noise ratio was about 70 dB for low frequency input signal. The recording bit rate of 2. 8665 Mbits/s was selected to record two channel serial data on the VTR...|$|R
50|$|The value {{returned}} by querying a <b>selector</b> <b>code</b> is 32 bits, whose meaning {{depends on the}} selector. Some selectors define this as a version code, while others {{use it as a}} bit mask of available capabilities. Some subsystems define both types of selectors, allowing querying of both the version number and the capabilities. Some even use a Gestalt selector to pass the address of a shared block of data, or even the address of code that could be called. Since the piece of code that installed a Gestalt selector could either install a simple static value or a callback that Gestalt would invoke every time somebody queried the selector, it was possible for the value returned to vary dynamically from call to call, to reflect information about {{the current state of the}} subsystem.|$|R
40|$|One of {{the most}} {{difficult}} tasks a compiler writer faces is the construction of the instruction selector. The instruction selector is that part of the compiler that translates compiler intermediate representation (IR) into instructions for a target machine. Unfortunately, implementing an instruction selector “by hand” is a difficult, time consuming, and error prone task. The details of both the IR and target instruction set must be carefully considered in order to generate correct and efficient code. This, in turn, requires an expert in both the compiler internals as well as the target machine. Even an expert, however, can implement an instruction selector that is difficult to verify and debug. In this dissertation we describe the instruction selector problem, cover previous attempts at solving it, and identify what we believe to be the most prominent factor inhibiting their widespread adoption. ^ This dissertation proposes a generalized approach toward generating instruction selectors automatically. In particular, we propose CISL, a common machine description language for specifying the semantics of compiler IR and target instructions, and GIST, a machine independent heuristic search procedure that can find equivalent instruction sequences between compiler IR and target instructions. CISL is an object-oriented-based language leveraging modern programming language constructs (e. g., classes, inheritance, mixins) and is capable of describing instructions for a variety of IR and target ISAs (Instruction Set Architecture). GIST leverages CISLs well-defined semantics and a canonicalization process to discover automatically instruction selector patterns: target instruction sequences that implement IR semantics. These instruction selector patterns are then generated in a compiler implementation independent format (XML). Small adapter programs use the generated instruction selector patterns to generate compiler specific implementation code. Our experiments show that instruction selector patterns can be discovered automatically and independent of a particular compiler framework or target machine. In addition, experience proved that adapter programs are easy to implement and instruction <b>selector</b> <b>code</b> is easy to generate from generated patterns. Furthermore, the generated instruction selectors are comparable in performance to the original compilers. ...|$|R

