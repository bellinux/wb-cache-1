20|12|Public
60|$|The lord of Brisetout {{walked to}} and fro with {{his hands behind his}} back. Perhaps he was not yet quite settled in his mind about the {{parallel}} between thieves and soldiers; perhaps Villon had interested him by some <b>cross-thread</b> of sympathy; perhaps his wits were simply muddled by so much unfamiliar reasoning; but whatever the cause, he somehow yearned to convert the young man to a better way of thinking, and could not make up his mind to drive him forth again into the street.|$|E
60|$|The {{revolution}} {{that is in}} progress from the old war to a new war, different in its entire nature from the old, is marked primarily by the steady progress in range and efficiency of the rifle and of the field-gun--and more particularly of the rifle. The rifle develops persistently from a clumsy implement, that any clown may learn to use in half a day, towards a very intricate mechanism, easily put out of order and easily misused, but {{of the most extraordinary}} possibilities in the hands of men of courage, character, and high intelligence. Its precision at long range has made the business of its care, loading and aim subsidiary to the far more intricate matter of its use in relation to the contour of the ground within its reach. Even its elaboration as an instrument is probably still incomplete. One can conceive it provided in the future with <b>cross-thread</b> telescopic sights, the focussing of which, corrected by some ingenious use of hygroscopic material, might even find the range, and so enable it to be used with assurance up to a mile or more. It will probably also take on some of the characters of the machine-gun. It will be used either for single shots or to quiver and send a spray of almost simultaneous bullets out of a magazine evenly and certainly, over any small area the rifleman thinks advisable. It will probably be portable by one man, but there is no reason really, except the bayonet tradition, the demands of which may be met in other ways, why it should be the instrument of one sole man. It will, just as probably, be slung with its ammunition and equipment upon bicycle wheels, and be the common care of two or more associated soldiers. Equipped with such a weapon, a single couple of marksmen even, by reason of smokeless powder and carefully chosen cover, might make themselves practically invisible, and capable of surprising, stopping, and destroying a visible enemy in quite considerable numbers who blundered within a mile of them. And a series of such groups of marksmen so arranged as to cover the arrival of reliefs, provisions, and fresh ammunition from the rear, might hold out against any visible attack for an indefinite period, unless the ground they occupied was searched very ably and subtly by some sort of gun having a range in excess of their rifle fire. If the ground they occupied were to be properly tunnelled and trenched, even that might not avail, and there would be nothing for it but to attack them by an advance under cover either of the night or of darkness caused by smoke-shells, or by the burning of cover about their position. Even then they might be deadly with magazine fire at close quarters. Save for their liability to such attacks, a few hundreds of such men could hold positions of a quite vast extent, and a few thousand might hold a frontier. Assuredly a mere handful of such men could stop the most multitudinous attack or cover the most disorderly retreat in the world, and even when some ingenious, daring, and lucky night assault had at last ejected them from a position, dawn would simply restore to them the prospect of reconstituting in new positions their enormous advantage of defence.|$|E
5000|$|The fuel inlet/fuel {{filter housing}} threads {{tend to be}} very fragile. When care is not taken to align the insert, it is {{possible}} for the fuel inlet to <b>cross-thread</b> and to strip when tightened in the main housing. There are several [...] "fixes" [...] available in the aftermarket: New, oversized, self-tapping fuel filter inserts; new fuel filter inserts that seal with O-rings; and Heli-Coil re-threading kits. In nearly all cases, the carburetor will require dis-assembly and internal cleaning of the aluminum thread residue, especially up to and including the needle and seat, (needle valve), to prevent flooding.|$|E
50|$|In {{the case}} of fine {{garments}} four threads are employed in the forming of each aho. The weaver passes two of these threads {{on either side of}} the first io or vertical thread, enclosing it. In the continuing the process the two pairs of threads are reversed, those passing behind the first vertical thread would be brought in front of the next one, then behind the next and so on. Each of the down threads would be enclosed between two or four <b>cross-threads</b> every half inch or so.|$|R
50|$|The weaving process (whatu) for {{clothing}} was performed {{not with a}} loom and shuttle but with the threads being manipulated and tied with fingers. A strong thread is fastened tautly in a horizontal position between two or four upright weaving sticks (turuturu). To this thread (tawhiu) are attached the upper ends of the warp or vertical threads (io). The warp is arranged close together. The weaving process consisted of working in <b>cross-threads</b> from left to right. The closer these threads are together, the tighter the weave, and the finer the garment.|$|R
5000|$|To couple the two parts, the pin(s) on {{the male}} are {{aligned with the}} slot(s) on the female and the two pushed together. Once the pins reach {{the bottom of the}} slot, one or both parts are rotated so that the pin slides along the {{horizontal}} arm of the L until it reaches the [...] "serif". The spring then pushes the male connector up into the [...] "serif" [...] to keep the pin locked into place. A practised user can connect them quickly and, unlike screw connectors, they are not subject to <b>cross-threading.</b> To disconnect, the two parts are pushed together to move the pin out of the [...] "serif" [...] while twisting in the opposite direction than for connecting, and then pulling apart.|$|R
40|$|Record and replay, which records a multithreaded program’s {{execution}} in one run and reproduces it deterministically {{in a second}} run, is useful for program debugging, fault detection and analysis. The key challenge in multithreaded record and replay is ensuring that conflicting, <b>cross-thread</b> accesses to shared variables are properly detected, recorded and reproduced. Numerous solutions have been proposed in both hardware and software to track these <b>cross-thread</b> accesses, but to date all general-purpose software solutions suffer from high overhead or have serious limitations. This paper introduces ROCTET, an approach for performing softwareonly deterministic record and replay. ROCTET is built {{on top of a}} novel dynamic analysis infrastructure, OCTET, which can detect at low overhead any <b>cross-thread</b> dependences during execution by exploiting the fact that most accesses, even of shared objects, are not part of <b>cross-thread</b> dependences. We implement OCTET and ROCTET in a JVM and show they add low overhead for several multithreaded applications. We also show that our implementation of ROCTET can successfully replay recorded executions when it can successfully control or ignore extraneous sources of nondeterminism in the VM, libraries, and system. 1...|$|E
40|$|In {{the present}} work, the {{mechanical}} performance of novel sandwich composite panels based on 3 D-knitted spacer fabrics has been investigated. Composite panels were produced using three {{different types of}} spacer fabrics having different structural parameters. The sandwich panels were fabricated based on an unsaturated polyester resin using a modified vacuum-assisted resin transfer molding process which allowed the formation of low-density core structures. The produced sandwich composite panels were characterized for flexural, compressive, and impact properties. The effect of different fabric structural parameters (such as <b>cross-thread</b> density, linear density of yarn used in face and core, and structure of face) on the processability and mechanical behavior of composite panels has been thoroughly investigated. The {{results showed that the}} composite panels based on spacer fabrics having lesser <b>cross-thread</b> density and made of coarser yarns performed better with respect to compressive and impact properties, whereas the best flexural properties were obtained in case of spacer fabrics with high <b>cross-thread</b> density and made of finer yarns...|$|E
40|$|It is {{notoriously}} challenging to achieve parallel software {{systems that are}} both scalable and reliable. Parallel runtime support—such as multithreaded record & replay, data race and atomicity violation detectors, transactional memory, and support for stronger memory models—helps achieve these goals, but existing commodity solu-tions slow programs substantially in order to capture (track or con-trol) the program’s <b>cross-thread</b> dependences accurately. Captur-ing <b>cross-thread</b> dependences using “pessimistic ” synchronization slows every program access, while “optimistic ” synchronization al-lows for lightweight instrumentation of most accesses but dramati-cally slows accesses involved in <b>cross-thread</b> dependences. This paper introduces (1) a hybrid of pessimistic and opti-mistic synchronization and (2) an adaptive policy that enables fine-grained switching between pessimistic and optimistic synchroniza-tion based on program behavior. The adaptive policy uses online profiling and a cost–benefit model to inform its decisions. We de-sign a dependence recorder on top of our approach to demonstrate its feasibility {{as a framework for}} efficient parallel runtime support. We have implemented our approach in a high-performance Java virtual machine and show that it outperforms parallel runtime sup-port based solely on pessimistic or optimistic synchronization. These results show the potential for adaptive, hybrid synchroniza-tion for efficient parallel runtime support in commodity systems. 1...|$|E
5000|$|... 1988: Al Unser Jr. {{snapped the}} Andretti family winning streak at Long Beach, winning {{the race for}} the first time, in {{dominating}} fashion. Unser Jr. started fourth, but at the start, settled into second behind Mario Andretti. Going into the hairpin {{at the end of the}} first lap, Unser dove below Andretti and took the lead. On his first pit stop, Unser suffered a <b>cross-threaded</b> lug nut, and dropped to sixth, putting Danny Sullivan into the lead. Unser charged, however, gaining nearly a second per lap, re-taking the lead for good on lap 42. Unser led 72 of the 95 laps, lapping the entire field, and when Sullivan dropped out on lap 82, was all alone to the finish. Bobby Rahal finished second, his best career Long Beach result, driving the Judd AV engine.|$|R
40|$|Canada, {{enmeshed in}} the 'China tangle' since 1949, has made only a few, {{haphazard}} attempts {{to cut through}} the web. The web itself has been spun out of material of almost bewildering complexity: the diplomatic problem of recognition of a Communist government, and in this case, one which replaced a régime friendly to the 'West'; concomitant to recognition, the questions of Chinese admission to the United Nations, a body, incidentally, which has branded the Peking government an aggressor, as well as the future of the former government of China - now in exile on Formosa - and in fact, the future of that very island, and Taiwanese claims to self-determination; also, the multiplicity of <b>cross-threads</b> such as Sino Canadian trade and Canadian church interest in the Chinese people themselves; and underlying all, the United States involvement in the China issues and its influence - direct or otherwise - upon Canadian attitudes and policy, or the lack of it...|$|R
50|$|The cams {{at the end}} of each lever on {{the female}} end align with a {{circumferential}} groove on the male end. When the levers are rotated to the locked position, they pull the male end into the female socket, creating a tight seal up against a gasket. The arms lock into position using an over-center arrangement, preventing accidental decoupling. Because the groove is cut all the way around the male end, there is no specific alignment necessary to couple as there would be with threaded connectors, and there is no opportunity for <b>cross-threading.</b> This results in an error-resistant, faster coupling operation. Because the compression between the two fittings is limited by the size of the cams on the end of the levers and the rotation of the levers themselves, there is also no possibility of over- or under-tightening the fitting; the pressure against the sealing gasket is effectively constant from one coupling operation to the next, reducing possibility of leaks.|$|R
40|$|Parallel {{programming}} {{is essential for}} reaping the benefits of parallel hardware, but it is notoriously difficult to develop and debug reliable, scalable software systems. One key challenge is that modern languages and systems provide poor support for ensuring concurrency correctness properties—such as atomicity, sequential consistency, and multithreaded determinism—because all existing approaches are impractical. Dynamic, software-based approaches slow programs by up to {{an order of magnitude}} because capturing <b>cross-thread</b> dependences (i. e., conflicting accesses) requires synchronization at every access to potentially shared memory. This paper introduces a new software-based concurrency control mechanism called OCTET that captures <b>cross-thread</b> dependences soundly but avoids synchronization at non-conflicting accesses. OCTET tracks the locality state of each potentially shared object. Non-conflicting accesses conform to the locality state and require no synchronization, but conflicting accesses require a state change with heavyweight synchronization. This optimistic tradeoff performs well for real-world concurrent programs, which by design execute relatively few conflicting accesses. We have implemented a prototype of OCTET in a high-performance Java virtual machine. Our evaluation demonstrates OCTET’s potential for capturing <b>cross-thread</b> dependences with overhead low enough for production systems. OCTET is an appealing and practical concurrency control mechanism for designing low-overhead, sound and precise analyses and systems that check and enforce concurrency correctness properties. 1...|$|E
40|$|In stark {{contrast}} with the fully participative "bazaar" imagery of open source software (OSS) development, some recent empirical research {{has pointed out that}} much of the OSS development is carried out by a small percentage of developers. This raises serious concerns that concentration of development effort on a few will limit knowledge sharing and underutilize the available resources. Using the notion of strategic interaction, this paper argues that individual developers often interact strategically with other highly resourceful developers by forming a smaller but better organized structure to intensify the types of epistemic interactions that matter most to the OSS development. A general framework of strategic interaction including participation inequality, conversational interactivity, and <b>cross-thread</b> connectivity is proposed to examine its impact on knowledge sharing, and validated using 128 discussion threads from the K Desktop Environment (KDE) developer mailing list. The findings indicate that strategic interaction has expanded knowledge sharing but with the caveat that extreme concentration of development could have an opposite effect. For researchers, this study dovetails the incentive logic by proposing and validating the strategic aspects of OSS participation to better understand the collective dynamics underpinning OSS development. Practitioners can use this approach to evaluate and better support existing knowledge-sharing initiatives. strategic interaction, participation inequality, conversational interactivity, <b>cross-thread</b> connectivity...|$|E
40|$|Thread-level {{speculation}} (TLS) {{has proven}} to be a promising method of extracting parallelism from both integer and scientific workloads, targeting speculative threads that range in size from hundreds to several thousand dynamic instructions and have minimal dependences between them. Recent work has shown that TLS can offer compelling performance improvements for database workloads, but only when targeting much larger speculative threads of more than 50, 000 dynamic instructions per thread, with many frequent data dependences between them. To support such large and dependent speculative threads, hardware must be able to buffer the additional speculative state, and must also address the more challenging problem of tolerating the resulting <b>cross-thread</b> data dependences In this paper we present hardware support for large speculative threads that integrates several previous proposals for TLS hardware. We also introduce support for subthreads: a mechanism for tolerating <b>cross-thread</b> data dependences by checkpointing speculative execution. When speculation fails due to a violated data dependence, with sub-threads the failed thread need only rewind to the checkpoint of the appropriate sub-thread rather than rewinding to the start of execution; this significantly reduces the cost of mis-speculation. We evaluate our hardware support for large and dependent speculative threads in the database domain and find that the transaction response time for three of the five transactions from TPC-C (on a simulated 4 - processor chip-multiprocessor) speedup by a factor of 1. 9 to 2. 9...|$|E
50|$|A helical insert is {{an insert}} made of coiled wire. The {{helically}} formed coils of diamond shaped stainless steel or phosphor bronze wire screw into a threaded hole {{to form a}} mating internal thread for a screw or stud. These inserts provide a convenient means of repairing stripped-out threads and are also used to provide stronger threads in soft materials such as aluminium, zinc die castings, wood, magnesium etc. than {{can be obtained by}} direct tapping of the base metal involved. Another common generic name is screw thread insert (STI), although many users persist in calling them all by a prominent brand name, the registered trademark Heli-Coil. Applications include engine cylinder head repair after unintentional over-torquing or <b>cross-threading</b> of spark plugs strips the thread of the socket. Kits with matched tap and coil exist for this. The straight radial piece in the photo is the driver tang which is used as a key to grip with pliers for driving the coil into place and is discarded after installation.|$|R
50|$|The race {{started with}} Jamie Whincup losing {{a number of}} spots to 4th, and Will Davison having minor front end damage after contact. On lap five, Paul Morris and Brad Jones {{collided}} in turn 7. The collision caused Morris to crash heavily into the barrier, rolled once and end up on its roof on the track, creating a safety car period. At the compulsory pit stop, leader Garth Tander had a <b>cross-threaded</b> nut {{on one of his}} wheels, and dropped 4 positions to 5th. After the pit stops, Rick Kelly lead from his brother Todd and James Courtney. On lap 27, Dean Canto crashed into the wall on the main straight, causing the safety car, to once again come out. This stayed out until lap 35, and due to other AFL commitments for the broadcaster, the race was cut short to a time based race, and Rick Kelly won the race from Todd Kelly and James Courtney. This caused controversy as some drivers, including Garth Tander, claimed they did not know the race was going to finish early.|$|R
40|$|Nearest Neighbor(s) {{search is}} the {{fundamental}} computational primitive to tackle massive dataset. Locality Sensitive Hashing (LSH) has been a bracing tool for Nearest Neighbor(s) search in high dimensional spaces. However, traditional LSH systems cannot be applied in online big data systems to handle a large volume of query/update requests, {{because most of the}} systems optimize the query efficiency with the assumption of infrequent updates and missing the parallel-friendly design. As a result, the state-of-the-art LSH systems cannot adapt the system response to the user behavior interactively. In this paper, we propose a new LSH system called PFO. It handles query/update requests in RAM and scales the system capacity by using flash memory. To achieve high streaming data throughput, PFO adopts a parallel-friendly indexing structure while preserving the distance between data points. Further, it accommodates inbound data in real-time and dispatches update requests intelligently to eliminate the <b>cross-threads</b> synchronization. We carried out extensive evaluations with large synthetic and standard benchmark datasets. Results demonstrate that PFO delivers shorter latency and offers scalable capacity compared with the existing LSH systems. PFO serves with higher throughput than the state-of-the-art LSH indexing structure when dealing with online query/update requests to nearest neighbors. Meanwhile, PFO returns neighbors with much better quality, thus being efficient to handle online big data applications, e. g. streaming recommendation system, interactive machine learning systems...|$|R
40|$|Thread-level {{speculation}} (TLS) {{has proven}} to be a promising method of extracting parallelism from both inte-ger and scientific workloads, targeting speculative threads that range in size from hundreds to several thousand dy-namic instructions and have minimal dependences between them. Recent work has shown that TLS can offer com-pelling performance improvements for database workloads, but only when targeting much larger speculative threads of more than 50, 000 dynamic instructions per thread, with many frequent data dependences between them. To sup-port such large and dependent speculative threads, hard-ware must be able to buffer the additional speculative state, and must also address the more challenging problem of tol-erating the resulting <b>cross-thread</b> data dependences...|$|E
40|$|Abstract—The usual goal in {{implementing}} IPC {{is to make}} a <b>cross-thread</b> procedure call look like a local procedure call. However, formal specifications of IPC typically talk only about data transfer, forcing IPC clients to use additional global invariants to recover the sequential function call semantics. We propose a more powerful specification in which IPC clients exchange knowledge and permissions in addition to data. The resulting specification is polymorphic in the specification of the service provided, yet allows a client to use IPC without additional global invariants. We verify our approach using VCC, an automatic verifier for (suitably annotated) concurrent C code, and demonstrate its expressiveness by applying it to the verification of a multiprocessor flush algorithm. I...|$|E
40|$|Thread-level {{speculation}} (TLS) {{has proven}} to be a promising method of extracting parallelism from both integer and scientific workloads, targeting speculative threads that range in size from hundreds to several thousand dynamic instructions and have minimal dependences between them. Recent work has shown that TLS can offer compelling performance improvements for database workloads, but only when targeting much larger speculative threads of more than 50, 000 dynamic instructions per thread, with many frequent data dependences between them. To support such large and dependent speculative threads, hardware must be able to buffer the additional speculative state, and must also address the more challenging problem of tolerating the resulting <b>cross-thread</b> data dependences. In thi...|$|E
5000|$|... 1992: At the start, Mario {{and his son}} Michael led {{the field}} into the first turn. Michael came around in first, and Mario already a {{somewhat}} distant second. On the 5th lap, a caution came out. Mario ducked into the pits with a misfire. After several pit stops, the problem was fixed and {{he returned to the}} track, but dropped down the standings a lap down. Later in the race, Mario pitted for tires, and <b>cross-threaded</b> a wheel nut. He was again shuffled down in the running order. A few moments later, on a restart, he crashed in turn four. He was among several front-runners to crash due to cold tires on the unusually cold afternoon. Mario suffered broken toes, and was taken to Methodist Hospital in downtown Indianapolis for surgery. A short time later, Mario's son Jeff shattered both of his legs in a terrible crash, and was also taken to the hospital. Both required considerable rehabilitation, although Jeff's was significantly more severe. Back at the track, Mario's other son Michael was dominating the race, and looked poised to win. However, with 11 laps to go, his car quit, and {{he was out of the}} race. Ironically, the rival Unser family prevailed over the dismayed Andrettis yet again, with Al Unser Jr. winning and Al Unser Sr. finishing third. In his autobiography Andretti, Mario described the day, which saw him laid up in a hospital bed, witnessing his youngest son's serious injury, and then woke up to hear the news that his other son Michael had lost, as the [...] "worst day of my life." ...|$|R
40|$|This report presents, in an e-book {{format for}} ease of reference, {{researched}} and evaluated initiatives, models and practices developed to enhance the employability of students of the University and the b. i. b. International College. It concludes the jointly funded stage of the project as planned in the original project proposal. The project {{is based on the}} key themes of work-based learning, industry-focussed learning, international learning and career management learning, and <b>cross-threading</b> I&CT and transnational themes. Many different stakeholders including students, tutors, service support staff and employers from both institutions contributed to the project and its outcomes. The following 4 paragraphs indicate briefly the content of each theme. In response to increasing evidence that HE institutions should be providing more workbased learning opportunities, EU- funded work experience opportunities for b. i. b. and SSU students going to Southampton and Germany respectively are planned, and a more flexible model combining both work experience and the final year project at SSU is planned. An industry focussed learning theme describes models for more industry-related activities. These include a more organised approach to using the University as a business context for live activities (eg analysis of University data warehouse data to inform decision making), an “Everybody-Wins” model for “live”/industry-linked activities and an entrepreneurial activity for primarily Technology courses. An international learning theme describes an experiment designed to enable b. i. b. and SSU students to work collaboratively online in international teams, and consequently enhance their e-portfolio CVs and employability. A career management learning theme completes this contribution to the employability agenda by sharpening the focus on CVs and gaining employment. It presents the results of studies on the application of Mahara at b. i. b. and software for developing communication skills at interview. Following achievement of the intended outcomes of the project, including the embedding of some practice, further work includes the on-going EU and other work-based learning initiatives. In conclusion, diverse, collaborative, shared, scalable and informed practice in our respective institutions should lead in the longer term to improved employability of our students...|$|R
40|$|The Austrian philosopher Ludwig Wittgenstein famously {{proposed}} {{a style of}} philosophy that was directed against certain pictures [bild] that tacitly direct our language and forms of life. His aim was to show the fly {{the way out of}} the fly bottle and to fight against the bewitchment of our intelligence by means of language: “A picture held us captive. And we could not get outside it, for it lay in our language and language seemed to repeat it to us inexorably” (Wittgenstein 1953, 115). In this context Wittgenstein is talking of philosophical pictures, deep metaphors that have structured our language but he does also use the term picture in other contexts (see Owen 2003, 83). I want to appeal to Wittgenstein in my use of the term ideology to refer to the way in which powerful underlying metaphors in neoclassical economics have a strong rhetorical and constitutive force at the level of public policy. Indeed, I am specifically speaking of the notion of ‘the performative’ in Wittgenstein and Austin. The notion of the knowledge economy has a prehistory in Hayek (1937; 1945) who founded the economics of knowledge in the 1930 s, in Machlup (1962; 1970), who mapped the emerging employment shift to the US service economy in the early 1960 s, and to sociologists Bell (1973) and Touraine (1974) who began to tease out the consequences of these changes for social structure in the post-industrial society in the early 1970 s. The term has been taken up since by economists, sociologists, futurists and policy experts recently to explain the transition to the so-called ‘new economy’. It is not just a matter of noting these discursive strands in the genealogy of the ‘knowledge economy’ and related or cognate terms. We can also make a number of observations on the basis of this brief analysis. First, there has been a succession of terms like ‘postindustrial economy’, ‘information economy’, ‘knowledge economy’, ‘learning economy’, each with a set of related concepts emphasising its social, political, management or educational aspects. Often these literatures are not <b>cross-threading</b> and tend to focus on only one aspect of phenomena leading to classic dichotomies such as that between economy and society, knowledge and information. Second, these terms and their family concepts are discursive, historical and ideological products in the sense that they create their own meanings and often lead to constitutive effects at the level of policy. Third, while there is some empirical evidence to support claims concerning these terms, at the level of public policy these claims are empirically underdetermined and contain an integrating, visionary or futures component, which necessarily remains untested and is, perhaps, in principle untestable...|$|R
40|$|This paper {{presents}} a test framework to support unit component testing in distributed component-based {{systems that are}} built upon component technologies like CORBA, COM/. NET, J 2 EE/RMI. The framework exploits automatic code instrumentation at the stubs and the skeletons of the calls in order to monitor a global call session. The calls can be <b>cross-thread,</b> cross-process and cross-processor. We further define certain testing-related interfaces for driver components in the component test harness and extend the IDL compiler, such that at runtime, test-related attributes can be automatically embedded in the call session identifier and propagated system-wide. As a result, various support for unit component testing can be enabled, including behavior coordination for stub components, collaborator component determination from historical execution, selective regression testing, and crash site pinpointing. 1...|$|E
40|$|Chip-multiprocessor (CMP) {{architectures}} are {{a promising}} design alternative {{to exploit the}} everincreasing number of transistors that can be put on a die. To deliver high performance on applications that cannot be easily parallelized, CMPs can use additional support for speculatively executing the possibly data-dependent threads of an application. For <b>cross-thread</b> dependences that must be handled dynamically, the threads {{can be made to}} synchronize and communicate either at the register level or at the memory level. In the past, it has been unclear whether the higher hardware cost of register-level communication is cost-eective. In this paper, we show that the wide-issue dynamic processors that will soon populate CMPs, make fast communication a requirement for high performance. Consequently, we propose an eective hardware mechanism to support communication and synchronization of registers between on-chip processors. Our scheme adds enough support to enable register-level commu [...] ...|$|E
40|$|With {{speculative}} thread-level parallelization, {{codes that}} cannot be fully compiler-analyzed are aggressively executed in parallel. If the hardware detects a <b>cross-thread</b> dependence violation, it squashes offending threads and resumes execution. Unfortunately, frequent squashing cripples performance. This paper proposes a new frameworkof hardware mechanisms to eliminate most squashes due to data dependences in multiprocessors. The frameworkworks by learning and predicting violations, and applying delayed disambiguation, value prediction, and stall and release. The frameworkis suited for directory-based multiprocessors that trackmemory accesses {{at the system}} level with the coarse granularity of memory lines. Simulations of a 16 -processor machine show that the frameworkis very effective. By adding our frameworkto a speculative CC-NUMA with 64 -byte memory lines, we speed-up applications {{by an average of}} 4. 3 times. Moreover, the resulting system is even 23 % faster than a machine that tracks memory accesses at the fine granularity of words – a sophisticated system that is not compatible with mainstream cache coherence protocols. ...|$|E
40|$|With the {{widespread}} deployment of multi-core hardware, writing concurrent programs has become inescapable. This has made fixing concurrency bugs (or crugs) critical in modern software systems. Static analysis techniques to find crugs such as data races and atomicity violations are not scalable, while dynamic approaches incur high run-time overheads. Crugs pose a greater challenge since they manifest only under specific execution interleavings {{that may not}} arise during in-house testing. Thus there is a pressing need for a low-overhead program monitoring technique {{that can be used}} post-deployment. We present Cooperative Crug Isolation (CCI), a low-overhead instrumentation technique to isolate the root causes of crugs. CCI inserts instrumentation that records occurrences of specific thread interleavings at run-time by tracking whether successive accesses to a memory location were by the same thread or by distinct threads. The overhead of this instrumentation is kept low by using a novel <b>cross-thread</b> random sampling strategy. We have implemented CCI on top of the Cooperative Bug Isolation framework. CCI correctly diagnoses bugs in several nontrivial concurrent applications while incurring only 2 – 7 % run-time overhead...|$|E
40|$|OCTET is a {{framework}} for dynamic analysis that soundly captures <b>cross-thread</b> dependences in parallel programs. It optimistically assumes that most accesses do not conflict, enabling the instrumentation to not perform synchronization at non-conflicting accesses. However, OCTET’s performance can suffer substantially if an application triggers more than {{a small fraction of}} conflicting accesses: on the order of 0. 1 % or more of all accesses, according to our investigations. This paper introduces an adaptive approach to replace as many heavyweight conflicting transitions as possible with so-called “pessimistic ” transitions. An adaptive policy determines if an object should switch from an optimistic to a pessimistic state, or from pessimistic to optimistic state, based on online profiling. Experimental results show that this approach can reduce the overhead of OCTET by 30 – 40 % for one program, while adding low overhead for applications that do not have many conflicting accesses. Note to the reader. This technical report (TR) describes recent preliminary innovations and results. In its current form, this TR may not stand on its own, and readers may need to read our prior work on OCTET for background [3]. Questions, suggestions, and feedback are welcome. 1...|$|E
40|$|Abstract Chip-multiprocessor (CMP) {{architectures}} are {{a promising}} design alternative {{to exploit the}} ever-increasing number of transistors that can be put on a die. To deliver high performance on applications that cannot be easily parallelized, CMPs can use additional support for speculatively executing the possibly data-dependent threads of an application. While some of the <b>cross-thread</b> dependences in applications must be handled dynamically, others can be fully determined by the compiler. For the latter dependences, the threads {{can be made to}} synchronize and communicate either at the register level or at the memory level. In the past, it has been unclear whether the higher hardware cost of register-level communication is cost-effective. In this paper, we show that the wide-issue dynamic processors that will soon populate CMPs, make fast communication a requirement for high performance. Consequently, we propose an effective hardware mechanism to support communication and synchronization of registers between on-chip processors. Our scheme adds enough support to enable register-level communication without specializing the architecture so much toward speculation that it leads to much unutilized hardware under workloads that do not need speculative parallelization. Finally, the scheme allows the system to achieve near ideal performance...|$|E
40|$|Reduction {{variables}} {{are an important}} class of <b>cross-thread</b> depen-dence that can be parallelized by exploiting the associativity and commutativity of their operation. In this paper, we define a class of shared variables called partial reduction variables (PRV). These variables either cannot be proven to be reductions or they violate the requirements of a reduction variable in some way. We describe an algorithm that allows the compiler to detect PRVs, and we also discuss the necessary requirements to paral-lelize detected PRVs. Based on these requirements, we propose an implementation in a TLS system to parallelize PRVs that works {{by a combination of}} techniques at compile time and in the hard-ware. The compiler transforms the variable under the assumption that the reduction-like behavior proven statically will hold true at runtime. However, if a thread reads or updates the shared variable {{as a result of an}} alias or unlikely control path, a lightweight hard-ware mechanism will detect the access and synchronize it to ensure correct execution. We implement our compiler analysis and trans-formation in GCC, and analyze its potential on the SPEC CPU 2000 benchmarks. We find that supporting PRVs provides up to 46 % per-formance gain over a highly optimized TLS system and on average 10. 7 % performance improvement...|$|E

