2|390|Public
40|$|This project tackles the {{mentioned}} problems {{through the}} introduction of a Design Pattern to achieve flexibility in selection of same-class components without changing the <b>clientś</b> <b>code.</b> Afterwards the same design pattern will be used to arrive at an architectural design specific to the context of database components and a prototype application will be presented to demonstrate the capabilities and/or shortcomings...|$|E
40|$|In this diploma {{thesis is}} {{described}} information system that offers users presentation of points of interest. Whole system {{is represented by}} two subsystems. First subsystem is server-side application that collects data and offers it to mobile <b>clients.</b> <b>Code</b> for server-side system is written in programming language Java with help of widgets from frame work Vaadin. Server collects data from web service for points of interest named WikiLocation and weather service wunderground. Sever is running on Apache TomCat. Mobile client is second subsystem. Application is build for Android smart phones and therefore written in Java. Mobile client connects to server and fetches data from it. Application represent data with user friendly presentation, that is very helpful in city tours. Mobile application offers users augmented reality view of interesting points near him. Diploma thesis describes how system was build, and all the problems that I had to solve while implementing it. In section describing mobile client there is special chapter about augmented reality...|$|E
5000|$|The <b>client</b> <b>code</b> has no {{knowledge}} whatsoever {{of the concrete}} type, not needing to include any header files or class declarations related to it. The <b>client</b> <b>code</b> deals only with the abstract type. Objects of a concrete type are indeed created by the factory, but the <b>client</b> <b>code</b> accesses such objects only through their abstract interface.|$|R
50|$|WSIF {{provides}} an API {{to allow the}} same <b>client</b> <b>code</b> to access any available binding. As the <b>client</b> <b>code</b> can then be written to the PortType, {{it can be a}} deployment or configuration setting (or a code choice) which port and binding it uses.|$|R
5000|$|... jQuery plugin for {{handling}} code/resources update events in <b>client</b> <b>code</b> ...|$|R
5000|$|Adding new {{concrete}} types {{is done by}} {{modifying the}} <b>client</b> <b>code</b> to use a different factory, a modification which is typically one line in one file. This is significantly easier than modifying the <b>client</b> <b>code</b> to instantiate a new type, which would require changing every location in the code where a new object is created.|$|R
5000|$|File system {{abstraction}} {{to allow}} <b>client</b> <b>code</b> to choose alternate file systems ...|$|R
5000|$|Adding new {{concrete}} types {{is done by}} {{modifying the}} <b>client</b> <b>code</b> to use a different factory, a modification that is typically one line in one file. The different factory then creates objects of a different concrete type, but still returns a pointer of the same abstract type as before [...] - [...] thus insulating the <b>client</b> <b>code</b> from change. This is significantly easier than modifying the <b>client</b> <b>code</b> to instantiate a new type, which would require changing every location in the code where a new object is created (as well as making sure that all such code locations also have knowledge of the new concrete type, by including for instance a concrete class header file). If all factory objects are stored globally in a singleton object, and all <b>client</b> <b>code</b> goes through the singleton to access the proper factory for object creation, then changing factories {{is as easy as}} changing the singleton object.|$|R
5000|$|... a generic, {{extensible}} interface layer, used in <b>client</b> <b>code,</b> {{which can}} interact with heterogeneous types, and ...|$|R
40|$|We {{address the}} problem of testing {{atomicity}} of composed concurrent operations. Concurrent libraries help programmers exploit parallel hardware by providing scalable concurrent operations with the illusion that each operation is executed atomically. However, <b>client</b> <b>code</b> often needs to compose atomic operations {{in such a way that}} the resulting composite operation is also atomic while preserving scalability. We present a novel technique for testing the atomicity of <b>client</b> <b>code</b> composing scalable concurrent operations. The challenge in testing this kind of <b>client</b> <b>code</b> is that a bug may occur very rarely and only on a particular interleaving with a specific thread configuration. Our technique is based on modular testing of <b>client</b> <b>code</b> in the presence of an adversarial environment; we use commutativity specifications to drastically reduce the number of executions explored to detect a bug. We implemented our approach in a tool called COLT, and evaluated its effectiveness on a range of 51 realworld concurrent Java programs. Using COLT, we found 56 atomicity violations in Apache Tomcat, Cassandra, MyFaces Trinidad, and other applications...|$|R
5000|$|... {{a tunnel}} mechanism, which {{translates}} between the heterogeneous types {{expressed in the}} <b>client</b> <b>code</b> into the type understood by ...|$|R
40|$|In this {{position}} paper we present WikiNext 1, a semantic wiki {{we have been}} developing for eight months, written in JavaScript, from database to <b>client</b> <b>code.</b> It uses the HTTP/WebSocket NodeJS server, several frameworks such as NowJS for distributing JavaScript objects between server and <b>client</b> <b>code</b> or MongoDB for persistence. WikiNext proposes {{a new approach to}} deal with classical problems like data storage and representation (both for semantic data and CMS data), working with semantics, including and developing small applications within the wiki, sharing objects between <b>client</b> <b>code</b> running in the browser and server code, mixing HTTP asynchronous communication means with synchronous ones like web sockets, exploit original HTML 5 features and finally use an event based programmatic style on the server side with an dedicated micro HTTP server...|$|R
40|$|The {{standard}} approach {{to dealing with}} OO polymorphism is to require subclasses to be behavioral subtypes of the base class. This ensures that reasoning that has been done about any <b>client</b> <b>code</b> that operates on base class objects will continue to be valid if instances of the subclasses are used in place of the base class objects. But often we are interested in stronger properties of the <b>client</b> <b>code,</b> in particular that its behavior will be appropriate to the specific subclass objects that are used, rather than just generic behavior that ignores the differences between the different subclasses. We present some examples to illustrate the problem, and propose a formal system that allows us to establish stronger properties of the <b>client</b> <b>code</b> {{on the basis of the}} richer behavior provided by the appropriate derived classes...|$|R
5000|$|Referenced - The <b>client</b> <b>code</b> {{contains}} {{a reference to}} reused code, and thus they have distinct life cycles and can have distinct versions.|$|R
40|$|Often, {{a module}} {{developer}} wishes to expose a graph of objects to <b>client</b> <b>code,</b> allowing <b>client</b> <b>code</b> {{to access the}} graph through any node directly, while maintaining hidden consistency conditions over the graph. In this note, we describe how to specify and verify such code using separation logic, using as an example a binary tree structure where each node keeps a count of its descendant nodes. The idea is to describe the tree structure as the separate conjunction of the focus node’s subtree and the focus node’s context. The description can be rewritten to use any other node as the focus node at any time. This enables an elegant modular proof of the tree implementation on the one hand, and <b>client</b> <b>code</b> on the other hand. We describe how we verified an example program using the VeriFast program verifier prototype. 1...|$|R
5000|$|Forked - The <b>client</b> <b>code</b> {{contains}} a local or private {{copy of the}} reused code, and thus they share a single life cycle and a single version.|$|R
50|$|The EJB Container is {{responsible}} for ensuring the <b>client</b> <b>code</b> has sufficient access rights to an EJB. Security aspects can be declaratively applied to an EJB via annotations.|$|R
40|$|We use {{access permissions}} and typestate to specify and verify a Java library that {{implements}} snapshotable search trees, {{as well as}} some <b>client</b> <b>code.</b> We formalize our approach in the Plural tool, a sound modular typestate checking tool. We describe the challenges to verifying snapshotable trees in Plural, give an abstract interface specification against which we verify the <b>client</b> <b>code,</b> provide a concrete specification for an implementation and describe proof patterns we found. We also relate this verification approach to other techniques used to verify this data structure...|$|R
50|$|Data {{abstraction}} enforces a {{clear separation}} between the abstract properties of a data type and the concrete details of its implementation. The abstract properties {{are those that are}} visible to <b>client</b> <b>code</b> that makes use of the data type—the interface to the data type—while the concrete implementation is kept entirely private, and indeed can change, for example to incorporate efficiency improvements over time. The idea is that such changes are not supposed to have any impact on <b>client</b> <b>code,</b> since they involve no difference in the abstract behaviour.|$|R
40|$|Abstract. We use {{access permissions}} and typestate to specify and verify a Java library that {{implements}} snapshotable search trees, {{as well as}} some <b>client</b> <b>code.</b> We formalize our approach in the Plural tool, a sound modular typestate checking tool. We describe the challenges to verifying snapshotable trees in Plural, give an abstract interface specification against which we verify the <b>client</b> <b>code,</b> provide a concrete specification for an implementation and describe proof patterns we found. We also relate this verification approach to other techniques used to verify this data structure. ...|$|R
5000|$|By making Point2D {{implement}} ImmutablePoint2D, <b>client</b> <b>code</b> {{could now}} reference a type {{which does not}} have mutating methods, and thus appears immutable. This is demonstrated in the following example: ...|$|R
40|$|Factory" [3, page 87] or "Product Trader" [4, page 29]. The {{effect of}} this would be that the name of the {{implementing}} classes is no longer part of the <b>client</b> <b>code,</b> making it independent from them. As an added benefit, the implementations can be extended and changed without affecting the <b>client</b> <b>code.</b> The next question that poses itself is which criteria to use in choosing a specific implementation. There is no unqualified answer, since it depends on the intended applications. For the naming service example, the VectorNameImpl class is preferable because name components are used frequently, and efficient access to them is important. In contrast, StringNameImpl would be best used when a large number of names will be used and efficiency in storage is crucial. Through this discussion it becomes obvious that differentiating between the implementations is still important. However, the differences in the implementations and their effects on <b>client</b> <b>code</b> can usually be minimized as long as the [...] ...|$|R
50|$|Once {{we realize}} that two {{different}} factories are needed, we change the class (to the code shown earlier). But since the constructor is now private, the existing <b>client</b> <b>code</b> no longer compiles.|$|R
50|$|This insulates <b>client</b> <b>code</b> from object {{creation}} by having clients ask a factory object {{to create an}} object of the desired abstract type and to return an abstract pointer to the object.|$|R
50|$|Access specifiers do not {{necessarily}} control visibility, in that even private members may be visible to <b>client</b> external <b>code.</b> In some languages, an inaccessible but visible member may be referred to at run-time (for example, by a pointer returned from a member function), but an attempt to use it by referring to {{the name of the}} member from <b>client</b> <b>code</b> will be prevented by the type checker.|$|R
40|$|In {{a typical}} {{client-server}} scenario, a trusted server provides valuable services to a client, which runs remotely on an untrusted platform. Of the many security vulnerabilities that may arise (such as authentication and authorization), guaranteeing {{the integrity of}} the <b>client</b> <b>code</b> {{is one of the most}} difficult to address. This security vulnerability is an instance of the malicious host problem, where an adversary in control of the client’s host environment tries to tamper with the <b>client</b> <b>code.</b> We propose a novel client replacement strategy to counter the malicious host problem. The <b>client</b> <b>code</b> is periodically replaced by new orthogonal clients, such that their combination with the server is functionally-equivalent to the original client-server application. The reverse engineering efforts of the adversary are deterred by the complexity of analysis of frequently changing, orthogonal program code. We use the underlying concepts of program obfuscation as a basis for formally defining and providing orthogonality. We also give preliminary empirical validation of the proposed approach. Categories and Subject Descriptors C. 2. 0 [Computer-communication networks]: General—Securit...|$|R
50|$|The intent behind {{dependency}} injection is {{to decouple}} {{objects to the}} extent that no <b>client</b> <b>code</b> has to be changed simply because an object it depends on needs to be changed to a different one.|$|R
5000|$|Unexploited {{encapsulation}} when <b>client</b> <b>code</b> uses explicit type checks (using chained if-else or switch {{statements that}} {{check for the}} type of the object) instead of exploiting the variation in types already encapsulated within a hierarchy.|$|R
50|$|Mariner was a {{canceled}} {{project to}} add performance and stability enhancements to the layout engine {{used in the}} Netscape Communicator web browser. Mariner became open source in March 1998 when Netscape released its <b>client</b> <b>code</b> and started the Mozilla project.|$|R
50|$|Using the swagger-codegen project, {{end users}} {{generate}} client SDKs {{directly from the}} Open API document, reducing the need for human-generated <b>client</b> <b>code.</b> As of August, 2017, the swagger-codegen project supported over 50 different languages and formats for client SDK generation.|$|R
5000|$|Generic {{programming}} : Template metaprogramming {{allows the}} programmer {{to focus on}} architecture and delegate to the compiler the generation of any implementation required by <b>client</b> <b>code.</b> Thus, template metaprogramming can accomplish truly generic code, facilitating code minimization and better maintainability.|$|R
40|$|International audienceIn {{this paper}} we present an {{approach}} to specify programs performing iterations. The idea is to specify iteration {{in terms of the}} nite sequence of the elements enumerated so far, and only those. In particular, we are able to deal with non-deterministic and possibly innite iteration. We show how to cope with the issue of an iteration no longer being consistent with mutable data. We validate our proposal using the deductive verication tool Why 3 and two iteration paradigms, namely cursors and higher-order iterators. For each paradigm, we verify several implementations of iterators and <b>client</b> <b>code.</b> This is done in a modular way, i. e., the <b>client</b> <b>code</b> only relies on the specication of the iteration...|$|R
50|$|Cassowary is an {{incremental}} constraint solving toolkit that efficiently solves systems of linear equalities and inequalities. Constraints may be either requirements or preferences. <b>Client</b> <b>code</b> specifies the constraints to be maintained, and the solver updates the constrained variables to have values that satisfy the constraints.|$|R
50|$|Early {{development}} {{within the}} Information Technology Center, originally called VICE (Vast Integrated Computing Environment) and VIRTUE (Virtue Is Reached Through Unix and Emacs), focused on centralized tools, {{such as a}} file server, andworkstation tools including a window manager, editor, email, and file system <b>client</b> <b>code.</b>|$|R
50|$|In Eiffel, {{the setup}} for type {{conversion}} {{is included in}} the class code, but then appears to happen as automatically as explicit type conversion in <b>client</b> <b>code.</b> The includes not just assignments but other types of attachments as well, such as argument (parameter) substitution.|$|R
50|$|With EJB 2.1 and earlier, each EJB had {{to provide}} a Java {{implementation}} class and two Java interfaces. The EJB container created instances of the Java implementation class to provide the EJB implementation. The Java interfaces were used by <b>client</b> <b>code</b> of the EJB.|$|R
