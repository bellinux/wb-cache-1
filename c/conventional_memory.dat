266|312|Public
25|$|As DOS {{applications}} grew {{larger and}} more complex in the late 1980s, it became common practice to free up <b>conventional</b> <b>memory</b> by moving the device drivers and TSR programs into upper memory blocks (UMBs) in the upper memory area (UMA) at boot, {{in order to maximize}} the <b>conventional</b> <b>memory</b> available for applications. This had the advantage of not requiring hardware changes, and preserved application compatibility.|$|E
25|$|The first {{memory segment}} (64 KB) of the <b>conventional</b> <b>memory</b> area is named lower memory or low memory area.|$|E
25|$|SBCONFIG.EXE - {{support for}} Sound Blaster 16 audio device; a differently-named driver {{was used for}} various other sound cards, also occupying <b>conventional</b> <b>memory.</b>|$|E
30|$|<b>Conventional</b> flash <b>memories</b> {{are facing}} their {{physical}} and practical limits, so searching of new possible candidates for non-volatile memory applications {{has become very}} much necessary. Regarding this, several new memory types have been suggested as the next-generation non-volatile memory candidates [1, 2]. Among these, {{resistive random access memory}} (RRAM) is being considered as the best candidate for the replacement of <b>conventional</b> <b>memories</b> due to its unique features such as high scaling capability, long memory holding time, smaller device size, fast switching speed, low energy utilization, non-volatility, and simple structure [3]. The memory cell of RRAM is a capacitor-like, metal-oxide-metal (MOM) structure. The bipolar resistive switching (BRS) and unipolar RS (URS) behaviors between two resistance states, i.e., low resistance state (LRS) and high resistance state (HRS) of a resistor film, can be achieved by applying external voltage with appropriate magnitude and polarities [4 – 6].|$|R
50|$|Addition {{of a new}} memory {{management}} architecture called Book-E, replacing the <b>conventional</b> paged <b>memory</b> management architecture for embedded applications. Book-E is application software compatible with existing PowerPC implementations, but needs {{minor changes to the}} operating system.|$|R
40|$|MOS {{memory devices}} {{containing}} semiconductor nanocrystals have drawn considerable attention recently, {{due to their}} advantages {{when compared to the}} <b>conventional</b> <b>memories.</b> Only little work has been done on memory devices containing metal nanoparticles. We describe the fabrication of a novel MOS device with embedded Pt nanoparticles in the HfO 2 / SiO 2 interface of a MOS device. Using as control oxide, a high-k dielectric, our device has a great degree of scalability. The fabricated nanoparticles are very small (about 5 nm) and have high density. High frequency C-V measurements demonstrate that this device operates as a memory device. © 2005 Materials Research Society...|$|R
25|$|SMARTDRV.EXE - install drive cache {{to speed}} up disk reads and writes; {{although}} it could allocate several megabytes of memory beyond 640kb for the drive caching, it still needed {{a small portion of}} <b>conventional</b> <b>memory</b> to function.|$|E
25|$|In MS-DOS 6.0, Microsoft {{introduced}} MEMMAKER, which automated {{this process}} of block matching, matching the functionality third-party memory managers offered. This automatic optimization often still did not provide the same result as doing it by hand, {{in the sense of}} providing the greatest free <b>conventional</b> <b>memory.</b>|$|E
25|$|Most {{standard}} programs {{written for}} DOS {{did not necessarily}} need 640kb or more of memory. Instead, driver software and utilities referred to as Terminate and Stay Resident (TSR) programs {{could be used in}} addition to the standard DOS software. These drivers and utilities typically permanently used some <b>conventional</b> <b>memory,</b> reducing the total available for standard DOS programs.|$|E
40|$|Emerging {{technologies}} such as RRAMs are attracting significant attention due to their tempting characteristics such as high scalability, CMOS compatibility and non-volatility to replace the current <b>conventional</b> <b>memories.</b> However, critical causes of hardware reliability failures, such as process variation due to their nano-scale structure have gained considerable importance for acceptable memory yields. Such vulnerabilities make it essential to investigate new robust design strategies at the circuit system level. In this paper we have analyzed the RRAM variability phenomenon, its impact and variation tolerant techniques at the circuit level. Finally a variation-monitoring circuit is presented that discerns the reliable memory cells affected by process variability. Peer ReviewedPostprint (author's final draft...|$|R
40|$|Reliability of {{advanced}} CMOS {{technology is a}} complex problem that is usually addressed {{from the standpoint of}} specific failure mechanisms rather than overall reliability of a finished microcircuit. A detailed treatment of CMOS reliability in scaled devices can be found in Ref. 1; it should be consulted for a more thorough discussion. The present document provides a more concise treatment of the scaled CMOS reliability problem, emphasizing differences in the recommended approach for these advanced devices compared to that of less aggressively scaled devices. It includes specific recommendations that can be used by flight projects that use advanced CMOS. The primary emphasis is on <b>conventional</b> <b>memories,</b> microprocessors, and related devices...|$|R
3000|$|... [14 – 16] {{are widely}} {{reported}} to replace <b>conventional</b> flash <b>memory.</b> On the other hand, conductive bridging resistive {{random access memory}} (CBRAM) involving the migration of cations (Ag+ or Cuz+, z[*]=[*] 1, 2) in solid electrolytes such as Ge [...]...|$|R
25|$|Hardware {{expansion}} boards {{could use}} any of the upper memory area for ROM addressing, so the upper memory blocks were of variable size and in different locations for each computer, depending on the hardware installed. Some windows of upper memory could be large and others small. Loading drivers and TSRs high would pick a block and try to fit the program into it, until a block was found where it fit, or it would go into <b>conventional</b> <b>memory.</b>|$|E
25|$|Also in {{some cases}} {{third-party}} companies wrote special multi-function drivers that would combine the capabilities of several standard DOS drivers and TSRs into a single very compact program that used just a few kilobytes of memory. For example, the functions of mouse driver, CDROM driver, ANSI support, DOSKEY command recall, and disk caching would all be combined together in one program, consuming just 1 - 2 kilobytes of <b>conventional</b> <b>memory</b> for normal driver/interrupt access, and storing {{the rest of the}} multi-function program code in EMS or XMS memory.|$|E
2500|$|Some {{very common}} DOS drivers and TSRs using <b>conventional</b> <b>memory</b> included: ...|$|E
30|$|Recently, the self-assembled silicon nanocrystals (Si-ncs) {{that are}} formed within ultrathin SiO 2 layer are {{considered}} to be a promising replacement of this conventional floating gate [1, 2]. These isolated Si-ncs embedded in between a tunnel and a top dielectric layer serve as the charge storage nodes and exhibit many physical properties even at room temperature such as Coulomb blockade [3], single-electron transfer [4] and quantization charges effect [5] which differ from bulk crystals. It can reduce the problem of charge loss encountered in <b>conventional</b> <b>memories,</b> cause thinner injection oxides and hence smaller operating voltages, better endurance and faster write/erase speeds. So, the characterisation and understanding of its charging mechanism in such nanostructure is of prime importance.|$|R
5000|$|In 1998, Boaz Eitan of Saifun Semiconductor (later {{acquired}} by Spansion) patented {{a flash memory}} technology named NROM that took advantage of a charge trapping layer to replace the floating gate used in <b>conventional</b> flash <b>memory</b> designs. Two important innovations appear in this patent: ...|$|R
40|$|In {{this paper}} {{we make a}} study of the capabzlities {{required}} of memories to su the synthesis of designs using structured archztectures. We explore the advantag using multi-port memories with two write ports as an architectural component over <b>conventional</b> <b>memories</b> with a single write port in such a synthesis environment. A study the of the memory resources auazlable an some of the current Faeld Programmable Gate Arrays (FPGA) is made. We then propose a multz-port memory structure that could be suetable for use zn programmable structures such as FPGAs, to faczlitate implementations of designs through HLS. The princapal advantages of the proposed memory structure are its flexibilzty, simplzcity and its ability to support more eficient execution of operations than existing memory structures...|$|R
2500|$|Memory {{managers}} on 386-based systems (such as QEMM or MEMMAX (+V) in DR-DOS) {{could achieve}} the same effect, adding <b>conventional</b> <b>memory</b> at 640 KB and moving the barrier to 704 KB (up to segment B000, the start of MDA/HGC) or 736 KB (up to segment B800, {{the start of the}} CGA). [...] Only CGA could be used in this situation, because Enhanced Graphics Adapter (EGA) video memory was immediately adjacent to the <b>conventional</b> <b>memory</b> area below the 640 KB line; the same memory area could not be used both for the frame buffer of the video card and for transient programs.|$|E
2500|$|At startup, drivers {{could be}} loaded high using the [...] "DEVICEHIGH=" [...] directive, while TSRs could be loaded high using the [...] "LOADHIGH", [...] "LH" [...] or [...] "HILOAD" [...] directives. If the {{operation}} failed, the driver or TSR would automatically load into the regular <b>conventional</b> <b>memory</b> instead.|$|E
2500|$|In DOS memory management, <b>conventional</b> <b>memory,</b> {{also called}} base memory, {{is the first}} 640 {{kilobytes}} (...) of the memory on IBM PC or compatible systems. It is the read-write memory directly addressable by the processor {{for use by the}} operating system and application programs. As memory prices rapidly declined, this design decision became a limitation in the use of large memory capacities until the introduction of operating systems and processors that made it irrelevant.|$|E
40|$|Graphics {{processing}} units (GPUs) have specialized throughput-oriented memory systems {{optimized for}} stream-ing writes with scratchpad memories to capture locality explicitly. Expanding {{the utility of}} GPUs beyond graphics encourages designs that simplify programming (e. g., using caches instead of scratchpads) and better support irregular applications with finer-grain synchronization. Our hypothe-sis is that, like CPUs, GPUs will benefit from caches and coherence, but that CPU-style “read for ownership ” (RFO) coherence is inappropriate to maintain support for regular streaming workloads. This paper proposes QuickRelease (QR), which improves on <b>conventional</b> GPU <b>memory</b> systems in two ways. First, QR uses a FIFO to enforce the partial order of writes so that synchronization operations can complete without frequent cache flushes. Thus, non-synchronizing threads in QR can re-use cached data even when other threads are performing synchronization. Second, QR partitions the resources re-quired by reads and writes to reduce the penalty of writes on read performance. Simulation results across {{a wide variety of}} general-purpose GPU workloads show that QR achieves a 7 % average per-formance improvement compared to a <b>conventional</b> GPU <b>memory</b> system. Furthermore, for emerging workloads with finer-grain synchronization, QR achieves up to 42 % per-formance improvement compared to a <b>conventional</b> GPU <b>memory</b> system without the scalability challenges of RFO coherence. To this end, QR provides a throughput-oriented solution to provide fine-grain synchronization on GPUs. 1...|$|R
3000|$|... {{floating}} gate in <b>conventional</b> Flash <b>memory</b> devices, allowing for thinner injection oxides, and subsequently, smaller operating voltages, longer retention time, and faster write/erase speeds [1 – 3]. The performance of such memory structure strongly {{depends on the}} characteristics of the NCs arrays, such as their size, shape, spatial distribution, electronic band alignment.|$|R
25|$|Memory {{cells in}} {{different}} vertical layers do {{not interfere with}} each other, as the charges cannot move vertically through the silicon nitride storage medium, and the electric fields associated with the gates are closely confined within each layer. The vertical collection is electrically identical to the serial-linked groups in which <b>conventional</b> NANDflash <b>memory</b> is configured.|$|R
5000|$|A basic yet {{effective}} method used to optimize <b>conventional</b> <b>memory</b> was to load HIMEM.SYS as a device, thereafter loading EMM386.EXE as a device with the [...] "RAM AUTO" [...] option which allows access into the UMA by loading device drivers as devicehigh. This method effectively loads the fundamental memory managers into <b>conventional</b> <b>memory,</b> and thereafter everything else into the UMA. <b>Conventional</b> <b>memory</b> glutton {{programs such as}} MSCDEX could also be loaded into the UMA in a similar fashion, hence freeing up {{a large amount of}} <b>conventional</b> <b>memory.</b>|$|E
50|$|QEMM {{provides}} up to 635K free <b>conventional</b> <b>memory</b> (RAM under 640K), {{far better}} than pure MS-DOS EMM386, FreeDOS JEMM386, UMBPCI and many other memory manager programs. QEMM maximum RAM is 635K free <b>conventional</b> <b>memory</b> with up to 256MB XMS/256MB EMS shared.|$|E
5000|$|A memory {{swapping}} {{mechanism that}} yielded more free <b>conventional</b> <b>memory</b> ...|$|E
3000|$|When {{compared}} to the soft-decision sensing using <b>conventional</b> NAND Flash <b>memory,</b> this concurrent access scheme greatly reduces the number of data transfer operations, only ⌈N [...]...|$|R
50|$|Shared memory {{machines}} are convenient for programming {{but do not}} scale beyond tens of processors. The Data Diffusion Machine (DDM) overcomes this problem by providing a virtual memory abstraction {{on top of a}} distributed memory machine. A DDM appears to the user as a <b>conventional</b> shared <b>memory</b> machine but is implemented using a distributed memory architecture.|$|R
40|$|Machine. This uses {{combining}} networks on {{a butterfly}} topology with a hashed address space {{to try and}} hide the network latency. [Abolhassan et al., 1991] analyses Ranade's approach in a quantitative way by giving cost models for implementing {{various parts of the}} PRAM machine. This is then used to demonstrate an improvement on Ranade's Fluent machine using multiple butterflies and parallel slackness. It is then shown that the proposed improved Fluent machine would have a similar price / performance ratio of <b>conventional</b> distributed <b>memory</b> architectures. Other attempts at realising the PRAM model involves it's simulation on <b>conventional</b> distributed <b>memory</b> architectures. This method usually involves hashing the address space of the PRAM across the distributed memory of the machine and replication of variables [Mehlhorn and Vishkin, 1984], or using multiple hash functions [Abolhassan et al., 1991]. 2. 2 BSP A Bulk Synchronous Parallel machine consists of a number of processor memo [...] ...|$|R
50|$|Installing and {{configuring}} {{a memory}} manager might involve hours of experimentation with options, repeatedly rebooting the machine, and testing the results. But <b>conventional</b> <b>memory</b> was so valuable that PC owners felt that such time was well-spent if {{the result was}} to free up 30 KiB or 40 KiB of <b>conventional</b> <b>memory</b> space.|$|E
5000|$|Force diskcopy to {{use only}} the <b>conventional</b> <b>memory</b> for {{temporary}} storage: ...|$|E
5000|$|Some {{very common}} DOS drivers and TSRs using <b>conventional</b> <b>memory</b> included: ...|$|E
40|$|Recent {{studies have}} shown that cache-conscious indexes {{outperform}} <b>conventional</b> main <b>memory</b> indexes. Cache-conscious indexes focus on better utilization of each cache line for improving search performance of a single lookup. None has exploited cache spatial and temporal locality between consecutive lookups. We show that conventional indexes, even "cache-conscious" ones, suffer from significant cache thrashing between accesses. Such thrashing can impact [...] ...|$|R
40|$|This letter {{presents}} a low-power switched current (SI) memory cell with CMOS-type configuration. By combining nMOS and pMOS in the SI memory cell {{and using a}} polarity discrimination circuit, we design a CMOS-type SI memory cell which eliminates the quiescent current in the SI memory cell. The simulation result shows that the CMOS-type SI memory cell consumes less power than the <b>conventional</b> class-AB <b>memory</b> cell...|$|R
40|$|A Content Addressable Memory (CAM) is an SRAM based memory {{which can}} be {{accessed}} in parallel in order {{to search for a}} given search word, providing as result the address of the matching data. The use of CAM is widespread in many applications ranging from the controller of a CPU memory cache to the implementation of lookup tables of high speed routers. Like <b>conventional</b> <b>memories,</b> CAM can be affected by the occurrence of Single Event Upsets (SEU) which can alter its operation causing different effects such as pseudo-HIT or pseudo-MISS events. In order to avoid the effects of SEUs different approaches have been proposed in previous literature, but all of these solutions require changes to the internal structure of the CAM itself. Differently from previous approaches, in this paper we propose a method that does not require any modification to a CAM’s internal structure and therefore can be easily applied at system level, using a suitable redundant CAM component in order to obtain a CAM module with error detection and correction capabilities...|$|R
