142|5346|Public
5000|$|... {{namespace}} ObjectPascalExample; {{interface type}} ConsoleApp = class <b>class</b> <b>method</b> Main; end; THelloWorld = <b>class</b> <b>method</b> Put; end; implementation method THelloWorld.Put; begin Console.WriteLine('Hello, World!'); end; <b>class</b> <b>method</b> ConsoleApp.Main; begin var HelloWorld := new THelloWorld; HelloWorld.Put; end;end.|$|E
5000|$|Also, some classes {{implement}} <b>class</b> <b>method</b> initializers. Like , they combine [...] and , {{but unlike}} , they return an autoreleased instance. Some <b>class</b> <b>method</b> initializers take parameters: ...|$|E
50|$|S2 {{incorporates}} {{the idea of}} providing documentation for a <b>class,</b> <b>method,</b> function or property directly within the source code, separate (machine-distinguishable) from conventional comments. Small strings of explanatory text can be added after the header of a <b>class,</b> <b>method,</b> function or property, {{and they can be}} used to generate documentation.|$|E
25|$|<b>Class</b> <b>methods</b> are inherited, like {{instance}} methods; self in <b>class</b> <b>methods</b> is the <b>class</b> the <b>method</b> {{was called}} on.|$|R
5000|$|Like Smalltalk, in Objective-C, <b>class</b> <b>methods</b> {{are simply}} methods {{called on the}} class object, hence a <b>class's</b> <b>class</b> <b>methods</b> must be defined as {{instance}} methods in its metaclass. Because different classes can have different sets of <b>class</b> <b>methods,</b> each <b>class</b> must have its own separate metaclass. Classes and metaclasses are always created as a pair: the runtime has functions [...] and [...] to create and register class-metaclass pairs, respectively.|$|R
40|$|Binary {{methods are}} one of the {{challenges}} for designers of object-oriented programming languages. In this paper we discuss binary <b>class</b> <b>methods</b> (<b>class</b> <b>methods</b> that receive parameters of their own class type) as an alternative for typical uses of binary instances methods and show that they are often less troublesome, more symmetrical and more expressive. However, the main drawback of <b>class</b> <b>methods</b> as they are defined in languages like C++ and Java is that their static binding excludes them from being used in certain codereuse scenarios that need late-bound selfreference. We propose a small and surprisingly simple language mechanism to overcome this drawback. This mechanism can easily be adopted by languages that offer statically bound <b>class</b> <b>methods.</b> We further give the semantics of this extension as a mapping onto an object model without <b>class</b> <b>methods.</b> 1 Introduction A binary method, as defined in [Bru 95], is an instance method of some object of type t that has a parameter of the same [...] ...|$|R
5000|$|... {{namespace}} HelloWorld;interfacetype HelloClass = class public <b>class</b> <b>method</b> Main; end;implementationclass method HelloClass.Main;begin System.Console.WriteLine('Hello World!');end;end.|$|E
5000|$|In Python, it is {{possible}} to nest a class within another <b>class,</b> <b>method</b> or function.|$|E
5000|$|... 60+ {{source code}} metrics (complexity, coupling, cohesion, inheritance, etc.), on {{different}} levels (package, namespace, <b>class,</b> <b>method,</b> etc.) ...|$|E
50|$|In the above, plus signs denote <b>class</b> <b>methods,</b> or {{methods that}} can be called on the class itself (not on an {{instance}}), and minus signs denote instance methods, {{which can only be}} called on a particular instance of the <b>class.</b> <b>Class</b> <b>methods</b> also have no access to instance variables.|$|R
5000|$|Some Rowset <b>class</b> <b>methods</b> (Select, SelectNew, Fill, and so on.) ...|$|R
5000|$|Measures the {{intersection}} of the attributes used in common by the <b>class</b> <b>methods</b> ...|$|R
50|$|As with Objective-C, <b>class</b> <b>method</b> {{definitions}} and instance method definitions start with '+' (plus) and '-' (dash), respectively.|$|E
5000|$|Supported {{coverage}} types: <b>class,</b> <b>method,</b> line, basic block. EMMA {{can detect}} when a single source code line is covered only partially.|$|E
5000|$|Note that a unary {{operator}} {{defined as a}} <b>class</b> <b>method</b> would receive no apparent argument (it only works from [...] ): ...|$|E
50|$|Multimedia {{applications}} are facilitated because the <b>class</b> <b>methods</b> {{associated with the}} data are responsible for its correct interpretation.|$|R
30|$|In Figs.  4, 5, 6, 7 and 8, each smelly <b>class</b> or <b>method</b> is {{represented}} by a row and each system version by a column. Each row is labeled with the corresponding <b>class</b> or <b>method</b> name. Each rectangle represents {{the state of the}} <b>class</b> or <b>method</b> in the system version given by the column. There are two possible states: white and black. A white state indicates that the <b>class</b> or <b>method</b> is present in that system version, but it does not have a code smell. A black state indicates that the <b>class</b> or <b>method</b> is in fact a code smell in that system version. The absence of a square in a version means that the given <b>class</b> or <b>method</b> is not present in the respective version.|$|R
50|$|<b>Classes,</b> <b>methods</b> and {{properties}} {{defined in}} a COM module can be used. COM automation, controls and embedding is supported.|$|R
5000|$|... + (Point *) newWithX: (double) x_val andY: (double) y_val{ //Concisely written <b>class</b> <b>method</b> to {{automatically}} allocate and [...] //perform specific initialization. return setSecondCoord:y_val; } ...|$|E
5000|$|The {{operation}} {{could also}} {{be defined as a}} <b>class</b> <b>method,</b> replacing [...] by the hidden [...] argument; however this forces the left operand to be of type : ...|$|E
5000|$|Like {{property}} {{expressions and}} array operations, anonymous methods {{was introduced in}} Smart Pascal {{as a means to}} improve compatibility with JavaScript. Both Delphi and Free Pascal support anonymous methods, but Smart Pascal has one advantage over these native compilers.Under native Pascal (compilers that produce executable machine code), you have class procedures and ordinary procedures. The only difference between these two is {{that if you want to}} reference the first (<b>class</b> <b>method)</b> you must postfix the declaration with [...] "of object". This way of referencing a <b>class</b> <b>method</b> is typically used for event declarations.|$|E
5000|$|Project and Code Navigation: {{specialized}} project views, file structure {{views and}} quick jumping between files, <b>classes,</b> <b>methods</b> and usages ...|$|R
5000|$|Discover {{and modify}} source code constructions (such as code blocks, <b>classes,</b> <b>methods,</b> protocols, etc.) as a {{first-class}} object at runtime.|$|R
50|$|Since {{metaclass}} objects do not behave differently (you cannot add <b>class</b> <b>methods</b> for a metaclass, so metaclass objects {{all have}} the same methods), they are all instances of the same class—the metaclass of the root class (unlike Smalltalk). Thus, the metaclass of the root class is an instance of itself. The {{reason for this is that}} all metaclasses inherit from root class; hence, they must inherit the <b>class</b> <b>methods</b> of the root class.|$|R
5000|$|The colons in the Objective-C syntax are {{translated}} to underscores. So, the Objective-C <b>class</b> <b>method</b> , if {{belonging to the}} [...] class would translate as , and the instance method (belonging to the same class) [...] would translate to [...]|$|E
5000|$|Following the -clause a file {{contains}} type declarations, {{like they}} are known from Delphi:interfacetype ConsoleApp = class public <b>class</b> <b>method</b> Main; end;As in C#, the Main-method is the entry point for every program. It can have a parameter [...] for passing command line arguments to the program.|$|E
5000|$|... "In this pamphlet, I {{have fallen}} {{back on the}} {{traditional}} working <b>class</b> <b>method</b> for expressing ideas - the anecdote, or {{what is now called}} the [...] "oral tradition" [...] (which is only a fancy term for working-class people talking to each other but not bothering to record what they've heard".|$|E
50|$|Code autocompletion finalizes <b>classes,</b> <b>methods,</b> {{variable}} names, and PHP keywords, plus {{commonly used}} names for fields and variables {{depending on their}} type.|$|R
50|$|Languages {{with most}} of the {{features}} of objects (<b>classes,</b> <b>methods,</b> inheritance), but in a distinctly original form. Examples: Oberon (Oberon-1 or Oberon-2).|$|R
50|$|Other {{programming}} languages, such as Objective-C, have <b>class</b> <b>methods,</b> {{which can}} include constructor-type methods, {{but are not}} restricted to merely instantiating objects.|$|R
5000|$|Java, C++ and D allow {{inheritance}} or overriding a <b>class</b> <b>method</b> to {{be prohibited}} by labeling {{a declaration of}} a class or method, respectively, with the keyword [...] "final". In the book Effective Java, author Joshua Bloch writes (in item 17) that programmers should [...] "Design and document for inheritance or else prohibit it".|$|E
50|$|Python {{allows the}} {{creation}} of class methods and static method via {{the use of the}} @classmethod and @staticmethod decorators. The first argument to a <b>class</b> <b>method</b> is the class object instead of the self-reference to the instance. A static method has no special first argument. Neither the instance, nor the class object is passed to a static method.|$|E
50|$|Example 1:Within a {{subroutine}} {{a programmer}} will mainly {{be interested in}} the parameters and the local variables, which will rarely exceed 64 KB, for which one base register (the frame pointer) suffices. If this routine is a <b>class</b> <b>method</b> in an object-oriented language, then a second base register is needed which points at the attributes for the current object (this or self in some high level languages).|$|E
5000|$|<b>Class</b> <b>methods</b> - {{belong to}} the class {{as a whole and}} have access only to class {{variables}} and inputs from the procedure call ...|$|R
50|$|One common {{drawback}} {{of using}} composition instead of inheritance is that methods being provided by individual components {{may have to}} be implemented in the derived type, even if they are only forwarding methods. In contrast, inheritance does not require all of the base <b>class's</b> <b>methods</b> to be re-implemented within the derived class. Rather, the derived class only needs to implement (override) the methods having different behavior than the base <b>class</b> <b>methods.</b> This can require significantly less programming effort if the base <b>class</b> contains many <b>methods</b> providing default behavior and only a few of them need to be overridden within the derived class.|$|R
3000|$|... [...]), (2) modules {{are either}} classes or aspects, and (3) the ‘operation’ term {{represents}} <b>class</b> <b>methods,</b> aspect methods, and aspect advices, we define [...]...|$|R
