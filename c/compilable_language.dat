4|6|Public
40|$|The {{implementation}} of the Explicit Parallel Programming (EPP) system is described. EPP is a prototype {{implementation of}} a language for writing parallel programs for shared memory multiprocessors. EPP {{may be viewed as}} a coordination language, since it is used to define the sequencing or ordering of various tasks, while the tasks themselves are defined in some other <b>compilable</b> <b>language.</b> The two main components of the EPP system [...] -a compiler and an executive [...] -are described in this report. An appendix is included which contains the grammar defining the EPP language as well as templates used by the compiler in code generation...|$|E
40|$|COORDINSPECTOR is a Software Tool {{aiming at}} extracting the {{coordination}} layer of a software system. Such a reverse engineering process provides {{a clear view}} of the actually invoked services as well as the logic behind such invocations. The analysis process is based on program slicing techniques and the generation of, System Dependence Graphs and Coordination Dependence Graphs. The tool analyzes Common Intermediate Language (CIL), the native language of the Microsoft. Net Frame- work, thus making suitable for processing systems developed in any. Net Framework <b>compilable</b> <b>language.</b> COORDINSPECTOR generates graphical representations of the coordination layer together with business process orchestrations specified in WS- BPEL 2. 0...|$|E
40|$|The Explicit Parallel Programming (EPP) {{language}} is defined and illustrated with several examples. EPP is a prototype {{implementation of a}} language for writing parallel programs for shared memory multiprocessors. EPP {{may be viewed as}} a coordination language, since it is used to define the sequencing or ordering of various tasks, while the tasks themselves are defined in some other <b>compilable</b> <b>language.</b> The prototype described here requires FORTRAN as the base language, but there is no inherent reason why some other imperative language could not be used instead. EPP encourages a structured and readable style of writing parallel programs, and it allows virtually any type of parallelism to be expressed. It maintains as strict a separation as possible between the two main components of a parallel program: semantic actions and logic sequencing. This paper is intended for the first-time user of EPP...|$|E
25|$|The exec call is {{supported}} in many programming <b>languages,</b> including <b>compilable</b> <b>languages</b> and some scripting languages. In OS command interpreters, the exec built-in command replaces the shell process with the specified program.|$|R
40|$|This paper {{describes}} {{several examples}} of usage of two <b>languages,</b> <b>compilable</b> to Java bytecode, namely, Scala and Groovy. We consider some functional and dynamic language constructs {{they bring to}} standard process of Java application development. For that purpose we appeal to the language analysis and IDE development process as comprehensive examples demonstrating the benefits of Scala and Groovy usage. ...|$|R
40|$|An {{algorithm}} is presented for calculating concordance-discordance totals {{in a time}} of order N log N, where N is the number of observations, using a balanced binary search tree. These totals can be used to calculate jackknife estimates and confidence limits in the same time order for a very wide range of rank statistics, including Kendall’s tau, Somers’ D, Harrell’s c, the area under the receiver operating characteristic (ROC) curve, the Gini coefficient, and the parameters underlying the sign and rank-sum tests. A Stata package is introduced for calculating confidence intervals for these rank statistics using this algorithm, which has been implemented in the Mata <b>compilable</b> matrix programming <b>language</b> supplied with Stat...|$|R
40|$|In this paper, {{we present}} a new {{parallel}} and multi-threaded implementation of functional programs. The execution {{is based on a}} new parallel evaluation scheme of functional languages named P 3. The implementation consists of two phases: the first one statically tansforms the program in order to increase the granularity of parallelism; the second phase translates the transformed program in an intermediate multi-threaded, distributed and <b>compilable</b> <b>language.</b> At the first stage, we use a new approach, named GRANIT, of implicit granularity management. It consists of three kinds of grouping: the gathering of the functions of the program into functional packets, each of these must be executed, a priori, sequentially; the abstract grouping of the data into windows: for each packet, one computes by abstract execution its window i. e. the part of the data really necessary for its execution; and the association of the packets with their windows. The concrete grouping of the data is achieved [...] ...|$|E
40|$|We {{describe}} NIMBLE, {{a system}} for programming statistical algorithms for general model structures within R. NIMBLE is designed to meet three challenges: flexible model specification, a language for programming algorithms that can use different models, and a balance between high-level programmability and execution efficiency. For model specification, NIMBLE extends the BUGS language and creates model objects, which can manipulate variables, calculate log probability values, generate simulations, and query the relationships among variables. For algorithm programming, NIMBLE provides functions that operate with model objects using two stages of evaluation. The first stage allows specialization of a function to a particular model and/or nodes, such as creating a Metropolis-Hastings sampler for a particular block of nodes. The second stage allows repeated execution of computations using {{the results of the}} first stage. To achieve efficient second-stage computation, NIMBLE compiles models and functions via C++, using the Eigen library for linear algebra, and provides the user with an interface to compiled objects. The NIMBLE <b>language</b> represents a <b>compilable</b> domain-specific <b>language</b> (DSL) embedded within R. This paper provides an overview of the design and rationale for NIMBLE along with illustrative examples including importance sampling, Markov chain Monte Carlo (MCMC) and Monte Carlo expectation maximization (MCEM). Comment: 20 pages, 2 figure...|$|R

