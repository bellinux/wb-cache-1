0|6400|Public
40|$|Recent work by Lam et al. [1, 2, 3] has {{investigated}} {{the use of}} the logic-programming language Datalog to <b>code</b> <b>program</b> analyses, <b>exploiting</b> a fast implementation of Datalog using binary decision diagrams. Analyses written in Datalog are more compact and easier to reason about than hand-coded versions, while the BDD-based implementation makes their time performance competitive with hand-coded versions. However, this approach has not previously been implemented for the Pegasus intermediate represen-tation. It would be a useful contribution to represent Pegasus graphs, and analyses and transformations on them, in Datalog. We therefore propose to connect Whaley and Lam’s bddbddb implementation of Datalog to the CASH compiler, and use it to implement some dataflow analyses. In Datalog, programs are specified as sets of inference rules defining predicates, as in Prolog. Prolog interprets inference rules by backward chaining: for example, to show that P (x) holds, find rules of the form P (x) ← Q(x) and recursively show that Q(x) holds; this terminates when we get to a rule with no antecedent. Datalog, on the other hand, interprets rules by forward chaining and saturation: starting with some base set of facts, apply any rules for which the current set of facts proves all the antecedents; iterate until saturation (no new facts can be discovered). Since dataflow analyses are typically described via iteration to a fixed point, it is very natural to implement them in Datalog...|$|R
40|$|Object <b>code</b> is a <b>program</b> of a {{processor}} language {{and can be}} directly executed on a machine. Program verification constructs a formal proof that a program correctly implements its specification. Verifying object code therefore ensures that the program {{which is to be}} executed on a machine is correct. However, the nature of processor languages makes it difficult to specify and reason about object <b>code</b> <b>programs</b> in a formal system of logic. Furthermore, a proof of the correctness of an object <b>code</b> <b>program</b> will often be too large to construct manually because of the size of object <b>code</b> <b>programs.</b> The presence of pointers and computed jumps in object <b>code</b> <b>programs</b> constrains the use of automated tools to simplify object code verification. This thesis develops an abstract language which is expressive enough to describe any sequential object <b>code</b> <b>program.</b> The abstract language supports the definition of program logics in which to specify and verify object <b>code</b> <b>programs.</b> This allows the object c [...] ...|$|R
40|$|Object <b>code</b> is a <b>program</b> of a {{processor}} language {{and can be}} directly executed on a machine. Program verification constructs a formal proof that a program correctly implements its specification. Verifying object code therefore ensures that the program {{which is to be}} executed on a machine is correct. However, the nature of processor languages makes it difficult to specify and reason about object <b>code</b> <b>programs</b> in a formal system of logic. Furthermore, a proof of the correctness of an object <b>code</b> <b>program</b> will often be too large to construct manually because of the size of object <b>code</b> <b>programs.</b> The presence of pointers and computed jumps in object <b>code</b> <b>programs</b> constrains the use of automated tools to simplify object code verification. This thesis develops an abstract language which is expressive enough to describe any sequential object <b>code</b> <b>program.</b> The abstract language supports the definition of program logics in which to specify and verify object <b>code</b> <b>programs.</b> This allows the object <b>code</b> <b>programs</b> of any processor language to be verified in a single system of logic. The abstract language is expressive enough that a single command is enough to describe the behaviour of any processor instruction. An object <b>code</b> <b>program</b> can therefore be translated to the abstract language by replacing each instruction with the equivalent command of the abstract language. This ensures that the use of the abstract language does not increase the difficulty of verifying an object <b>code</b> <b>program.</b> The verification of an object <b>code</b> <b>program</b> can be simplified by constructing an abstraction of the program and showing that the abstraction correctly implements the program specification. Methods for abstracting programs of the abstract language are developed which consider only the text of a program. These methods are based on describing a finite sequence of commands as a single, equivalent, command of the abstract language. This is used to define transformations which abstract a program by replacing groups of program commands with a single command. The abstraction of a program formed in this way can be verified in the same system of logic as the original program. Because the transformations consider only the program text, they are suitable for efficient mechanisation in an automated proof tool. By reducing the number of commands which must be considered, these methods can reduce the manual work needed to verify a program. The use of an abstract language allows object <b>code</b> <b>programs</b> to be specified and verified in a system of logic while the use of abstraction to simplify programs makes verification practical. As examples, object <b>code</b> <b>programs</b> for two different processors are modelled, abstracted and verified in terms of the abstract language. Features of processor languages and of object <b>code</b> <b>programs</b> which affect verification and abstraction are also summarised...|$|R
50|$|There {{are several}} {{differences}} that characterize a SROP exploit {{that makes it}} different from a classical return-oriented <b>programming</b> <b>exploit.</b>|$|R
40|$|Highly {{distributed}} {{networks have}} now become a common infrastructure for wide-area distributed applications whose key design principle is network awareness, namely the {{ability to deal with}} dynamic changes of the network environment. Network-aware computing has called for new <b>programming</b> languages that <b>exploit</b> the mobility paradigm as a basic interaction mechanism. In this paper we present the architecture of KLAVA, an experimental Java package for distributed applications and code mobility. We describe how KLAVA permits code mobility by relying on Java and present a few distributed applications that <b>exploit</b> mobile <b>code</b> <b>programmed</b> in KLAVA...|$|R
5000|$|Transana, QDA <b>Coding</b> <b>Program,</b> {{originally}} funded {{development by}} the TalkBank ...|$|R
50|$|Lego Mindstorms' {{programming}} is command box <b>programming,</b> rather than <b>code</b> <b>programming.</b>|$|R
50|$|Since 2005 Inkscape {{has participated}} in the Google Summer of <b>Code</b> <b>program.</b>|$|R
5000|$|Data or {{executable}} <b>code</b> (<b>programs)</b> on the system, {{or other}} connected systems ...|$|R
50|$|Libav {{participated in}} the Google Summer of <b>Code</b> <b>program</b> in 2011 and 2012.|$|R
5000|$|... 2009 | Chat <b>Code</b> <b>Programming</b> for Tradewars Rising (PC) - Published by Sylien Games ...|$|R
5000|$|ADOMD.NET - Extension of ADO.NET[...]NET based and {{suitable}} for managed <b>code</b> <b>programs</b> on CLR platforms.|$|R
5000|$|Code.org, {{to teach}} {{introductory}} programing {{to millions of}} students in their Hour of <b>Code</b> <b>program.</b>|$|R
40|$|Building Energy <b>Codes</b> <b>Program's</b> {{efforts are}} {{designed}} to result in increased stringency in national model energy codes, more rapid and broader adoption by states and localities of updated codes, and increased compliance and enforcement. Report estimates the historical impact of Building Energy <b>Codes</b> <b>Program</b> in terms of energy savings achieved that are based upon various editions of ANSI/ASHRAE/IESNA Standard 90. 1 (ASHRAE Standard 90. 1) ...|$|R
50|$|In April 2009 OpenImageIO was {{accepted}} into the Google Summer of <b>Code</b> <b>program</b> with four student slots.|$|R
5000|$|AMO - For AS 2005 {{and later}} versions[...]NET based and {{suitable}} for managed <b>code</b> <b>programs</b> on CLR platforms.|$|R
50|$|The <b>program</b> <b>exploited</b> {{a buffer}} {{overflow}} bug in Microsoft's SQL Server and Desktop Engine database products. Although the MS02-039 patch {{had been released}} six months earlier, many organizations had not yet applied it.|$|R
50|$|The RVCF is {{a member}} of the Ontario Land Trust Alliance and participates in Imagine Canada's Ethical <b>Code</b> <b>Program.</b>|$|R
50|$|Throughout the years, {{development}} has been funded through the Google Summer of <b>Code</b> <b>program,</b> donations and paid developer time.|$|R
5000|$|In the 2011 film Source Code, [...] "Beleaguered Castle" [...] is {{the call}} {{sign for the}} Source <b>Code</b> <b>program.</b>|$|R
50|$|Part {{of these}} {{developments}} were fostered by Google's Summer of <b>Code</b> <b>program,</b> in which the Blender Foundation has participated since 2005.|$|R
50|$|From 2005, OSAF {{participated in}} Google's Summer of <b>Code</b> <b>programs</b> by {{allowing}} several interns {{to work on}} OSAF projects during the summer.|$|R
50|$|In March 2007, SilverStripe was {{selected}} for the Google Summer of <b>Code</b> <b>program.</b> This program resulted in the 2.2 release of SilverStripe.|$|R
50|$|Applicants for the Full-time Immersive, Flex, and Summer of <b>Code</b> <b>programs</b> {{must pass}} a fundamental-skills evaluation, {{technical}} interview, and in-person interview prior program acceptance.|$|R
5000|$|To {{properly}} {{cooperate with}} non-ARC <b>code,</b> <b>programs</b> must use no method or declared property (unless explicitly choosing a different getter) {{that starts with}} [...]|$|R
50|$|OMP2MPI Automatically generates MPI {{source code}} from OpenMP. Allowing that the <b>program</b> <b>exploits</b> non shared-memory {{architectures}} such as cluster, or Network-on-Chip based(NoC-based) Multiprocessors-System-onChip (MPSoC). OMP2MPI gives {{a solution that}} allow further optimization by an expert that want to achieve better results.|$|R
50|$|AOP is {{the desire}} to make {{statements}} of the form:In program P, whenever condition C arises, perform action A over a conventionally <b>coded</b> <b>program</b> P.|$|R
40|$|This essay {{examines}} common coding practices and, on {{the basis}} that <b>program</b> <b>code</b> should be designed to avoid errors, argues for example that punctuation symbols should not be used in <b>program</b> <b>code</b> as though they were in literary text. Carrying the argument further, it is asserted that the computing profession should not talk about programming languages or about writing <b>programs,</b> but about <b>coding</b> schemes and <b>coding</b> <b>programs...</b>|$|R
40|$|Shows that, {{using the}} {{dynamical}} variable pointer, one can implement a natural link between BASIC variables and binary data, giving powerful features to BASIC's interpreter in data acquisition systems. A machine <b>coded</b> <b>program</b> written for data logging can {{get access to}} BASIC variables and directly transfers data to them without suffering the interpreter's slow speed. BASIC programs just use them as any other variables. A manifold user's call, giving control to different machine <b>coded</b> <b>programs</b> without having to change the user's address as usual. (0 refs) ...|$|R
30|$|NVivo is a {{qualitative}} and mixed methods <b>coding</b> <b>program</b> {{that enables the}} detailed analysis of data to reveal relationships and themes. Please visit [URL] for more information.|$|R
5000|$|In August 1983, New Order {{released}} their iconic [...] "Blue Monday", {{which was}} composed on prototype-level homebrew [...] "step-time" [...] binary <b>code</b> <b>programming,</b> morphologically a MIDI rendition.|$|R
40|$|Innovative {{technology}} of sensory and selective chemical monitoring {{of hazardous wastes}} present in storage tanks are of continued importance to the environment. This multifaceted research <b>program</b> <b>exploits</b> the unique characteristics of micro and nano-fabricated cantilever-based, micro-electro-mechanical systems (MEMES) and nano-electro-mechanical systems (NEMS) in chemical sensing...|$|R
50|$|A {{new project}} started in June 2014 is Made with <b>Code,</b> uses <b>coding</b> <b>programs</b> to allow girls to become {{interested}} {{in the idea of}} coding and develop more female programmers over time.|$|R
40|$|We {{present an}} {{overview}} {{of research at the}} CRPC designed to provide an efficient, portable programming model for scientific applications possessing both task and data parallelism. Fortran M <b>programs</b> <b>exploit</b> task parallelism by providing language extensions for user-defined process management and typed communication channels. A combination of compiler and run-time system support ensures modularity, safety, portability, and efficiency. Fortran D and High Performance Fortran <b>programs</b> <b>exploit</b> data parallelism by providing language extensions for user-defined data decomposition specifications, parallel loops, and parallel array operations. Compile-time analysis and optimization yield efficient, portable programs. We design an interface for using a task-parallel language to coordinate concurrent data-parallel computations. The interface permits concurrently executing data-parallel computations to interact through messages. A key notion underlying the proposed interface is the integration of F [...] ...|$|R
40|$|The {{purpose of}} the current study is to {{investigate}} the effectiveness of the Road to the <b>Code</b> phonological awareness <b>program</b> on the development of at-risk, kindergarten students’ phonological awareness and early reading skills. Six kindergarten students were identified as experiencing difficulty in the area of phonological awareness and were divided into three groups. This study included three phases: a baseline phase, during which no instruction in the Road to the <b>Code</b> <b>program</b> was provided; an intervention phase, during which the Road to the <b>Code</b> <b>program</b> was implemented; and a maintenance phase. Student reading progress was monitored using standardized measures from the Dynamic Indicators of Basic Literacy Skills (DIBELS) and experimenter-developed measures. Program effectiveness was evaluated through a multiple baseline across participants design. Results indicated that participation in the Road to the <b>Code</b> <b>program</b> resulted in an increase in the students’ phonological awareness skills and that these gains maintained following the completion of the program. Additionally, students demonstrated the ability to generalize learned skills to progress monitoring measures containing novel content. Limitations of the study, implications for practice, and future research directions will also be discussed. ...|$|R
50|$|Founded in November, 2012, Digital Bananas has a {{workforce}} {{of about}} 50 digital professionals working with technology and digital media to build apps, <b>code</b> <b>programs,</b> and generally transform {{the way their}} clients operate online.|$|R
