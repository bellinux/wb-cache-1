19|200|Public
50|$|Although dynamic {{dispatch}} {{is not usually}} classified as a <b>conditional</b> <b>construct,</b> it {{is another way to}} select between alternatives at runtime.|$|E
5000|$|Here, {{the use of}} , D's compile-time <b>conditional</b> <b>construct,</b> is {{demonstrated}} to construct a template that performs the same calculation using code {{that is similar to}} that of the function above: ...|$|E
5000|$|Since minimal {{evaluation}} {{is part of}} an operator's semantic definition and not an (optional) optimization, many coding styles rely on it as a succinct (if idiomatic) <b>conditional</b> <b>construct,</b> such as these Perl idioms:some_condition or die; # Abort execution if some_condition is falsesome_condition and die; # Abort execution if some_condition is true ...|$|E
5000|$|Perl also {{provides}} variants {{of the loop}} and <b>conditional</b> <b>constructs</b> that work on a simple statement (an expression evaluated for its side-effects) instead of a block: ...|$|R
2500|$|Conditional {{expressions}} and <b>conditional</b> <b>constructs</b> are {{features of a}} programming language which perform different computations or actions depending on whether a programmer-specified boolean condition evaluates to true or false.|$|R
5000|$|Some {{document}} formats like PostScript, or macros in Microsoft Word, have <b>conditional</b> <b>constructs.</b> (if-then-else) {{that allow}} testing whether a {{location in the}} file has one value or another {{in order to control}} what is displayed.|$|R
5000|$|NB when {{wrapping}} Python's <b>conditional</b> <b>construct</b> into {{a utility}} function, the unalterably eager {{nature of the}} more intuitive language construct for side-effect functions>>> func = lambda b,a1,a2 : (a1,a2)b>>> def true (...) :... print [...] "true"... return [...] "truly">>> def false (...) :... print [...] "false"... return [...] "falsely">>> func(True, true (...) , false (...) [...] )truefalse'truly'>>> func(False, true (...) , false (...) [...] )truefalse'falsely'similar results fromfunc = lambda b,a1,a2: a1 if b else a2func = lambda b,a1,a2: (b and a1 or a2)0func = lambda b,a1,a2: (lambda:a1, lambda:a2)b (...) as the correct call would be>>> func(True, true, false) (...) true'truly'>>> func(False, true, false) (...) false'falsely' ...|$|E
5000|$|This {{refers to}} pattern {{matching}} {{as a distinct}} <b>conditional</b> <b>construct</b> in the programming language - as opposed to mere string pattern matching support, such as regular expression support. [...] The often-encountered [...] in the C family of languages, and in COBOL and Haskell, is not a language feature but a set of nested and independent if then else statements combined with a particular source code layout. However, this also means that a distinct else-if construct is not really needed in these languages. [...] In Haskell and F#, a separate constant choice construct is unneeded, because the same task {{can be done with}} pattern matching. [...] In a Ruby [...] construct, regular expression matching is among the conditional flow-control alternatives available. For an example, see this Stack Overflow question. [...] SQL has two similar constructs that fulfill both roles, both introduced in SQL-92. A [...] "searched [...] " [...] expression [...] works like , whereas a [...] "simple [...] " [...] expression: [...] works like a switch statement. For details and examples see Case (SQL).|$|E
3000|$|... 0 [*]=[*] 46. In this {{frequency}} domain, {{the proposed}} estimator exhibits a slightly larger MSE and maximum error compared to Merdjani, Zhu, and Dun’s methods but {{significantly less than}} Zhang’s method and the simplified method. In other words, although no <b>conditional</b> <b>construct</b> is used, the proposed estimator exhibits similar precision to {{the ones that have}} conditional branches, whereas other existing estimators significantly lose their accuracy. When l [...]...|$|E
50|$|C {{preprocessor}} (CPP) <b>conditional</b> <b>constructs</b> {{can also}} be used to switch between different versions of a symbol. The difference from weak symbols is that weak symbols are interpreted by the linker. The CPP is run during the compilation of each translation unit before the C compiler.|$|R
50|$|Block Layout {{supports}} the complete separation of code and layout. The output templates {{are written in}} XML, with 'xar' namespace tags providing variable access, looping <b>constructs,</b> <b>conditional</b> <b>constructs</b> and inclusion of sub-templates. The output from the standard themes are XHTML and RSS, though {{any other type of}} output can be generated.|$|R
40|$|We {{propose a}} {{combination}} of Bochvar’s strict three-valued logic, McCarthy’s sequential three-valued logic, and process algebra via the <b>conditional</b> guard <b>construct.</b> This combination entails {{the introduction of a}} new constant meaningless in process algebra. We present an operational semantics in SOS-style, and a completeness result for ACP with <b>conditional</b> guard <b>construct</b> and the proposed logic...|$|R
40|$|Every 7 r-calculus {{expression}} can {{be translated}} to a term in "nannal form ll built from +, input and output prefix, match, and inaction. Many difficulties of the 7 r-calculus are easier to understand and address at this simpler normal form level. We introduce a theory called Basic Conditional Process Algebra (BCPA), which we use to study these issues. BCPA is BPA extended with a <b>conditional</b> <b>construct</b> over Boolean expressions which can contain free variables. In this article, we consider a restricted setting without bound variables, since it already presents many non-trivial problems...|$|E
40|$|We give {{sound and}} {{complete}} proof systems {{for a variety}} of bisimulation based equivalences over a message-passing process algebra. The process algebra is a generalisation of pure CCS where the actions consist of receiving and sending messages or data on communication channels; the standard prefixing operator a:p is replaced by the two operators c?x:p and c!e:p and in addition messages can be tested by a <b>conditional</b> <b>construct.</b> The various proof systems are parameterised on auxiliary proof systems for deciding on equalities or more general boolean identities over the expression language for data. The completeness of these proof systems are thus relative to the completeness of the auxiliary proof systems...|$|E
40|$|This article {{presents}} qualitative research {{data about the}} sexuality of men and teenage boys with moderate to profound intellectual disability. Research findings pointed to a <b>conditional</b> <b>construct</b> of sexuality based within a biopsychosocial framework. The notion Conditionally Sexual represents the perceived limitations, within a rights-based discourse, of these men and teenage boys’ sexuality. The limitations to person-centred service delivery from a policy vacuum {{in the area of}} sexuality and intellectual disability represents a major challenge for paid staff. We suggest that a move toward better understanding how to support such a conditional sexual construct will assist the development of a healthy masculine sexuality for men and boys with intellectual disability. <br /...|$|E
50|$|In {{computer}} science, conditional statements, {{conditional expressions}} and <b>conditional</b> <b>constructs</b> are {{features of a}} programming language, which perform different computations or actions depending on whether a programmer-specified boolean condition evaluates to true or false. Apart from the case of branch predication, this is always achieved by selectively altering the control flow based on some condition.|$|R
40|$|Computer games can be {{regarded}} as state machines as far as their stages are concerned. The traditional design for this state machine is to assign ids to the states and to use <b>conditional</b> <b>constructs</b> to direct the game execution to the proper state. However, this approach is not robust enough and can quickly get out of control. This work proposes an object-oriented model to state specification and management, which features state hierarchies...|$|R
5000|$|The {{language}} Lisp (1958) {{never had}} a built-in Boolean data type. Instead, <b>conditional</b> <b>constructs</b> like [...] assume that the logical value false {{is represented by the}} empty list , which is defined to be the same as the special atom [...] or whereas any other s-expression is interpreted as true. For convenience, most modern dialects of Lisp predefine the atom [...] to have value , so that [...] {{can be used as a}} mnemonic notation for true.|$|R
40|$|AbstractIn {{a theory}} of {{processes}} the names are atomic data items which can be exchanged and tested for identify. A well-known example of a calculus for name-passing is the π-calculus, where names are additionally used as communication ports. We provide complete axiomatisations of late and early bisimulation equivalences in such calculi. Since neither of the equivalences is a congruence we also axiomatise the corresponding largest congruences. We consider a few variations of the signature of the language; among these, a calculus of deterministic processes which is reminiscent of sequential functional programs with a <b>conditional</b> <b>construct.</b> Most of our axioms are shown to be independent. The axiom systems differ only by a few simple axioms and reveal the similarities and the symmetries of the calculi and the equivalences...|$|E
40|$|We {{propose a}} notion of quantum control in a quantum {{programming}} language which permits the superposition of finitely many quantum operations without performing a measurement. This notion {{takes the form of}} a <b>conditional</b> <b>construct</b> similar to the if statement in classical programming languages. We show that adding such a quantum if statement to the QPL programming language [11] simplifies the presentation of several quantum algorithms. This motivates the possibility of extending the denotational semantics of QPL to include this form of quantum alternation. We give a denotational semantics for this extension of QPL based on Kraus decompositions rather than on superoperators. Finally, we clarify the relation between quantum alternation and recursion, and discuss the possibility of lifting the semantics defined by Kraus operators to the superoperator semantics defined by Selinger [11]. ...|$|E
40|$|In {{a theory}} of {{processes}} the names are atomic data items which can be exchanged and tested for identity. A well-known example of a calculus for name-passing is the ß-calculus, where names additionally are used as communication ports. We provide complete axiomatisations of late and early bisimulation equivalences in such calculi. Since neither of the equivalences is a congruence we also axiomatise the corresponding largest congruences. We consider a few variations of the signature of the language; among these, a calculus of deterministic processes which is reminiscent of sequential functional programs with a <b>conditional</b> <b>construct.</b> Most of our axioms are shown to be independent. The axiom systems differ only by a few simple axioms and reveal the similarities and the symmetries of the calculi and the equivalences. Work supported by the ESPRIT BRA project 6454 "CONFER". Swedish Institute of Computer Science, Uppsala University, and The Royal Institute of Technology, Sweden y LFCS, Dep [...] ...|$|E
50|$|Often it is {{possible}} to give alternative patterns that are tried one by one, which yields a powerful <b>conditional</b> programming <b>construct.</b> Pattern matching sometimes includes support for guards.|$|R
25|$|Tamoxifen {{is used as}} a {{research}} tool to trigger tissue-specific gene expression in many <b>conditional</b> expression <b>constructs</b> in genetically modified animals including a version of the Cre-Lox recombination technique.|$|R
40|$|Interface {{builders}} only {{support the}} construction of the menus and dialogue boxes of an application. They do not support {{the construction of}} interfaces of many application classes (visualization, simulation, command and control, domain-specific editors) because of the dynamic and complex information that these applications process. HUMANOID is a model-based interface design and construction tool where interfaces are specified by building a declarative description (model) of their presentation and behavior. HUMANOID' s modeling language provides simple abstraction, iteration and <b>conditional</b> <b>constructs</b> to model the interface features of these application classes. HUMANOID provides an easy-touse designer's interface that lets designers build complex interfaces without programming...|$|R
40|$|The {{quality of}} {{high-level}} synthesis results for designs with complex and nested conditionals and loops {{can be improved}} significantly by employing speculative code motions. In this paper, we present two novel techniques that add scheduling steps to the branch of a <b>conditional</b> <b>construct</b> with the fewer scheduling steps. This ``balances'' or equalizes the number of scheduling steps in the conditional branches and increases the scope for application of speculative code motions. We apply these branch balancing techniques ``dynamically'' during scheduling. We implemented algorithms for the dynamic branch balancing techniques in a C-to-VHDL high-level synthesis framework called SPARK. We demonstrate the utility of these techniques by presenting results for experiments on four designs derived from two moderately complex applications, namely, MPEG- 1 and the GIMP image processing tool. These {{results show that the}} two branch balancing techniques can reduce the cycles on the longest path through the design by up to 38 % and the number of states in the controller by up to 37 %...|$|E
40|$|This paper {{continues}} {{our earlier}} work in representing arbitrary preferences in causal reasoning and planning systems, albeit in an oblique fashion. Previously, we defined a very general query language relative to histories; from this we specified {{a second language}} in which preferences on histories are defined. This in turn allowed us to define {{the notion of a}} most preferred history in a set of histories. In this paper, we extend these languages in two directions. First, we add a <b>conditional</b> <b>construct</b> that allows one to select between terms. Second, we add a capability for defining macros. With these two added constructs, one can now define aggregate quantities, such as the total cost of actions in a history, the maximum value of a fluent in a history, or a count of the number of times a fluent goes to zero in a history. Via the preference language, one can then express a preference for histories (or, plans) with minimum action cost, maximum value of a fluent, or in which a fluent is most often zero. We argue that this substantially increases the range of concepts about which one can express preferences...|$|E
40|$|On {{the basis}} of the program {{notation}} PGLD of program algebra, a program notation PGLDg (PGLD with goto's) is proposed with indirect absolute jumps. An indirect absolute jump, also called a goto instruction, instructs the agent executing a program to move to an occurrence of a label catch instruction. The semantics of PGLDg is determined by a projection back to PGLD. An interpretation of flow charts into PGLDg is given, thus demonstrating the expressive strength of PGLDg. PGLDg {{turns out to be a}} useful point of departure for further language extensions, the meaning of more involved languages being determined by a projection back to PGLDg. This semantic method (paradigm) is introduced as projection semantics. As an example a language extension of PGLDg with a <b>conditional</b> <b>construct</b> is discussed. Coprograms are introduced to model the working memory of a machine executing a program. Projection semantics as a paradigm must provide the possibility to translate a program into a PGLDg program together with an appropriate coprogram. A rigorous definition of coprograms is provided. Two modes of cooperation between programs and coprograms are introduced: `use' and `apply'. Coprograms give rise to a natural calculus, which is studied in some detail. The use of coprograms in projection semantics is exemplified in the case of a language extension with recursion...|$|E
40|$|This paper {{presents}} TPDL* (extended temporal profile description language), a general-purpose {{language to}} observe and condition dynamic systems by means of temporal and logical expressions. It describes how time is modelled in TPDL*, gives {{an overview of the}} language through its basic types, primitives and <b>conditional</b> <b>constructs,</b> and its use in computer-aided design of digital systems. The paper discusses TPDL*'s facilities to support the description of hardware behaviour, to define the environment in which devices operate, and {{to observe and}} control both circuits and environments. The characteristics of the language are demonstrated through some representative example...|$|R
40|$|Schematic {{tables are}} a new {{representation}} for conditionals. Roughly a cross between decision tables and data flow graphs, they represent computation and decision-making orthogonally. They unify {{the full range of}} <b>conditional</b> <b>constructs,</b> from if statements through pattern matching to polymorphic predicate dispatch. Program logic is maintained in a declarative canonical form that enforces completeness and disjointness among choices. Schematic tables can be used either as a code specification/generation tool, or as a self-contained diagrammatic programming language. They give program logic the clarity of truth tables, and support high-level direct manipulation of that logic, avoiding much of the mental computation demanded by conventional conditionals...|$|R
30|$|The {{results of}} Figs.  5 and 6 {{show that the}} {{performance}} of the reconstructed audio signal remains similar to other estimators except the two most complexed ones although the proposed algorithm reduces the complexity greatly. The proposed algorithm avoids the spectrum conversion (from MDCT to pseudo-spectrum) used in Merdjani [23] and the simplified algorithm so that the algorithm complexity is irrelevant to the frame length N (as shown in Table  1, typical frame length of audio signal is 1024, 512, or so). At the same time, the proposed algorithm avoids the <b>conditional</b> <b>constructs,</b> which is beneficial to the speed of a frequency estimator in pipelined processor.|$|R
40|$|We {{construct}} a universal and even logically fully abstract realizability {{model for the}} sequential functional programming language of call-by-name FPC. This model is defined within the category of modest sets over the total combinatory algebra L of observational equivalence classes of closed terms of the untyped programming language lambda+Error. This language is untyped lazy call-by-name lambda-calculus extended by a single constant ERR and a <b>conditional</b> <b>construct</b> which distinguishes this constant from any other syntactic value. Universality and (constructive) logical full abstraction of the model are proved in three steps. Firstly, a canonical universal and logically fully abstract realizability model for FPC over the typed combinatory algebra T of observational equivalence classes of closed FPC-terms is constructed. Then the recursive type U := mu alpha. void + [alpha [...] > alpha] is shown to be universal, i. e. any other type is a definable retract of U. Hence this type gives rise to an untyped combinatory algebra U which is applicatively equivalent to the typed combinatory algebra T. As a consequence, the realizability toposes over T and U are equivalent and hence the realizability model for FPC over U also universal and logically fully abstract. Finally it is shown that every closed FPC-term of type U can be defined in the untyped language lambda+Error. Hence the combinatory algebras l U and L are applicatively equivalent. It follows that the realizability model over L is universal and logically fully abstract. As a consequence we prove {{a variant of the}} Longley-Phoa Conjecture...|$|E
40|$|In {{this paper}} we extend the method {{to deal with}} coarsegrain {{operations}} in static scheduled VLIW Processors as is introduced by Busá [1]. We allow functional units with a controller that does not traverse its states in a predefined way. This {{makes it possible to}} execute a function that contains a <b>conditional</b> <b>construct</b> like an if-statement as a single operation on a functional unit. This way the performance penalty otherwise caused by branch instructions is reduced. By adding a valid input and output signals the problem is circumvented that during compilation it is for this type of functional units not known when and how many samples will be consumed or produced. We will refer to these units as Conditional Input/output Units (CIUs). The operations that are executed on CIUs are called Conditional Input/output Operations (CIOs). The difference with guarded operations is that the production of a result of a CIO depends {{on the state of the}} CIU. An example of how CIOs can be applied in a C program is shown in Figure 1. Inside the for-loop the array of input samples is read and supplied as a stream of samples to a function with the name “CIO”. This function represents a CIO at the C program level. It produces its result in the variable dout and the valid signal in the variable vout. The result ¢¡¤£¢¥ is stored in the output array. The address of the location where this result is stored is only incremented when the valid output signal is true. Consequently, invalid results are overwritten in the output array. An additional input signal vin is supplied to the CIO in order to indicate if the current din sample must be processed. void CIO_loop(int *Ain, int size, int *Aout) { int idx 1 = 0, idx 2 = 0, din, dout, vin, vout; for(int i= 0; i<size; i++) ...|$|E
40|$|Three {{studies in}} the machine {{assisted}} proof of recursion implementation are described. The verification system used is Edinburgh LCF (Logic for Computable Functions). Proofs are generated, in LCF, in a goal-oriented fashion by the application of strategies reflecting informal proof plans. LCF is introduced in Chapter 1. We present three case studies in which proof strategies are developed and (except in the third) tested in LCF. Chapter 2 contains {{an account of the}} machine generated proofs of three program transformations (from recursive to iterative function schemata). Two of the examples are taken from Manna and Waldinger. In each case, the recursion is implemented by the introduction of a new data type, e. g., a stack or counter. Some progress is made towards the development of a general strategy for producing the equivalence proofs of recursive and iterative function schemata by machine. Chapter 3 is concerned with the machine generated proof of the correctness of a compiling algorithm. The formulation, borrowed from Russell, includes a simple imperative language with a while and <b>conditional</b> <b>construct,</b> and a low level language of labelled statements, including jumps. We have, in LCF, formalised his denotational descriptions of the two languages and performed a proof of the preservation of the semantics under compilation. In Chapter 4, we express and informally prove the correctness of a compiling algorithm for a language containing declarations and calls of recursive procedures. We present a low level language whose semantics model a standard activation stack implementation. Certain theoretical difficulties (connected with recursively defined relations) are discussed, and a proposed proof in LCF is outlined. The emphasis in this work is less on proving original theorems, or even automatically finding proofs of known theorems, than on (i) exhibiting and analysing the underlying structure of proofs, and of machine proof attempts, and (ii) investigating the nature of the interaction (between a user and a computer system) required to generate proofs mechanically; that is, the transition from informal proof plans to behaviours which cause formal proofs to be performed...|$|E
40|$|Synthesis of DoAll loops {{is a key}} {{aspect of}} High Level Synthesis since they allow to easily exploit the {{potential}} parallelism provided by programmable devices. This type of parallelism can be implemented in several ways: by duplicating the implementation of body loop, by exploiting loop pipelining or by applying vectorization. In this paper a methodology for the synthesis of complex DoAll loops based on outer vectorization is proposed. Vectorization {{is not limited to}} the innermost loops: complex constructs such as nested loops, <b>conditional</b> <b>constructs</b> and function calls are supported. Experimental results on parallel benchmarks show up to 7. 35 x speed-up and up to 40...|$|R
5000|$|... solves {{this problem}} by parsing the code of C source files to {{generate}} a list of dependencies (those header files included directly and indirectly). It is able to understand <b>conditional</b> compilation <b>constructs</b> so as to not generate excessive dependencies. It then appends rules expressing the dependencies to the Makefile.|$|R
40|$|Abstract. The MMX ™ {{technology}} and SSE/SSE 2 (streaming-SIMD-extensions) introduced {{a variety of}} SIMD instructions that can exploit data par-allelism in numerical and multimedia applications. In particular, new saturation and clipping instructions can boost the performance of applications that make extensive use of such operations. Unfortunately, {{due to the lack}} of support for saturation and clipping operators in e. g. C/C++ or Fortran, these operations must be explicitly coded with <b>conditional</b> <b>constructs</b> that test the value of oper-ands before actual wrap-around arithmetic is performed. As a result, inline-assembly or language extensions are most commonly used to exploit the new instructions. In this paper, we explore an alternative approach, where the com-piler automatically maps high-level saturation and clipping idioms onto effi-cient low-level instructions. The effectiveness of this approach is demonstrated with some experiments. ...|$|R
