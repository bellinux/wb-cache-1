5|198|Public
30|$|Although {{there are}} many studies that use {{intercropping}} {{as a way to}} control insect pests but there are necessary more researches because depending on the agro-ecological, genetic variability and meteorological conditions the results may be different. So this study aims to evaluate the effect of onion Allium cepa L, Red Creno landrace in <b>controlling</b> <b>thread</b> caterpillar, dark sword-grass in lettuce by intercropping with onion in agro-ecological conditions of Lichinga.|$|E
40|$|Reasoning {{about the}} {{correctness}} of multithreaded programs {{is complicated by}} the potential for unexpected interference between threads. Previous work on <b>controlling</b> <b>thread</b> interference focused on verifying race freedom and/or atomicity. Unfortunately, race freedom is insufficient to prevent unintended thread interference. The notion of atomic blocks provides more semantic guarantees, but offers limited benefits for non-atomic code and it requires bimodal sequential/multithreaded reasoning (depending on whether code is inside or outside an atomic block). This paper proposes an alternative strategy that uses yield annotations to control thread interference, and we present an effect system for verifying the correctness of these yield annotations. The effect system guarantees that for any preemptively-scheduled execution of a well-formed program, there is a corresponding cooperative execution with equivalent behavior in which context switches happen only at yield annotations. This effect system enables cooperative reasoning: the programmer can adopt the simplifying assumption of cooperative scheduling, even though the program still executes with preemptive scheduling and/or true concurrency on multicore processors. Unlike bimodal sequential/multithreaded reasoning, cooperative reasoning can be applied to all program code...|$|E
40|$|Abstract—Recent {{trends in}} {{technology}} scaling have enabled {{the incorporation of}} multiple processor cores on a single die. Depending {{on the characteristics of}} the cores, the multicore may be either symmetric (SMP) or asymmetric (AMP). Several studies have shown that in general, for a given resource and power budget, AMPs are likely to outperform their SMP counterparts. However, due to the heterogeneity in AMPs, scheduling threads is always a challenge. To address the issue of thread scheduling in AMP, we propose a novel dynamic thread scheduling scheme that continuously monitors the current characteristics of the executing threads and determines the best thread to core assignment. The real-time monitoring is done using hardware performance counters that capture several microarchitecture independent characteristics of the threads {{in order to determine the}} thread to core affinity. By <b>controlling</b> <b>thread</b> scheduling in hardware, the Operating System (OS) need not be aware of the underlying microarchitecture, significantly simplifying the OS scheduler for an AMP architecture. The proposed scheme is compared against a simple Round Robin scheduling and a recently published dynamic thread scheduling technique that allows swapping of threads (between asymmetric cores) at coarse grain time intervals, once every context switch (∼ 20 ms for the Linux scheduler). The presented results indicate that our proposed scheme is able to achieve, on average, a performance/watt benefit of 10. 5 % over the previously published dynamic scheduling scheme and about 12. 9 % over the Round Robin scheme...|$|E
5000|$|One {{working process}} {{consists}} of one <b>control</b> <b>thread</b> and multiple working threads. A working process contains one <b>control</b> <b>thread</b> and ten working threads by default. default.The number of working threads per {{process can be}} set using the initialization parameter, and after Tibero begins, this number cannot be changed.|$|R
5000|$|... c. 28,241 - 259 AD: Events of Hunters of Dune. The Thinking Machines {{are shown}} to <b>control</b> <b>threads</b> of evolution, space and time.|$|R
5000|$|<b>Control</b> <b>thread</b> Creates as many working threads as {{specified}} in the initialization parameter when Tibero is started, allocates new client connection requests to an idle working thread, and Checks signal processing.|$|R
40|$|Ensuring the {{correctness}} of multithreaded {{programs is}} difficult, {{due to the}} potential for unexpected interactions between concurrent threads. We focus on the fundamental non-interference property of atomicity and present a dynamic analysis for detecting atomicity violations. This analysis combines ideas from both Lipton’s theory of reduction and earlier dynamic race detectors such as Eraser. Experimental results demonstrate that this dynamic atomicity analysis is effective for detecting errors due to unintended interactions between threads. In addition, the majority of methods in our benchmarks are atomic, supporting our hypothesis that atomicity is a standard methodology in multithreaded programming. 1 The Need for Atomicity Multiple threads of control are widely used in software development because they help reduce latency and provide better utilization of multiprocessor machines. However, reasoning about the correctness of multithreaded code {{is complicated by the}} nondeterministic interleaving of threads and the potential for unexpected interference between concurrent threads. Since exploring all possible interleavings of the executions of the various threads is clearly impractical, methods for specifying and controlling the interference between concurrent threads are crucial for the development of reliable multithreaded software. Much previous work on <b>controlling</b> <b>thread</b> interference has focused on race conditions, which occur when two threads simultaneously access the same data variable, and {{at least one of the}} accesses is a write [1]. Unfortunately, the absence of race conditions is not sufficient to ensure the absence of errors due to unexpected interference between threads. As a concrete illustration o...|$|E
30|$|In {{the papers}} devoted to {{membrane}} systems {{it is not}} mentioned how the membranes (or groups of membranes) interact or synchronize. The usual thinking is that membrane systems are synchronized locally (a step of a membrane is given by the parallel application of rules) and behave asynchronously at the global level. We emphasize here the global aspects, by adding a form of parameterized barrier synchronization between membranes. A parallel implementation of membrane systems is presented in [6]. It uses a cluster of 64 dual processors, and an MPI library to describe the communication and synchronization of parallel processes. In that parallel simulator, the rules are implemented as threads. At the system initialization phase, one thread is created for each rule. Within one membrane, several rules can be applied concurrently. This parallelism between rule applications within one membrane is modeled with multithreading. Rule applications are performed in terms of rounds. To synchronize each thread (rule) within the system, two barriers implemented as mutexes {{are associated with a}} thread. At the beginning of each round, the barrier that the rule thread is waiting on is released by the primary <b>controlling</b> <b>thread.</b> After the rule application is done, the thread waits for the second barrier, and the primary thread locks the first barrier. During the following round it would repeat the above procedure, releasing and locking alternating barriers. Since many rules are executing concurrently and they are sharing resources, a mutual exclusion algorithm is necessary. The communication and synchronization between membranes are implemented using the Message Passing Interface library of functions for parallel computation. The execution is performed in terms of rounds; {{at the end of each}} round, every membrane exchanges messages with all its children and parent before proceeding to the next round. Another concern is the termination detection problem.|$|E
40|$|This thesis explores a new {{approach}} to building data-parallel accelerators that is based on simplifying the instruction set, microarchitecture, and programming methodology for a vector-thread architecture. The thesis begins by categorizing regular and irregular data-level parallelism (DLP), before presenting several architectural design patterns for data-parallel accelerators including the multipleinstruction multiple-data (MIMD) pattern, the vector single-instruction multiple-data (vector-SIMD) pattern, the single-instruction multiple-thread (SIMT) pattern, and the vector-thread (VT) pattern. Our recently proposed VT pattern includes many <b>control</b> <b>threads</b> that each manage their own array of microthreads. The <b>control</b> <b>thread</b> uses vector memory instructions to efficiently move data an...|$|R
40|$|Practice {{shows that}} it is {{necessary}} to <b>control</b> <b>threaded</b> joint’s assembly tightness when mounting or due to the exploitation. If this condition is not provided in necessary quality and tightness is insufficient or too big, it may cause threaded joint’s damage. The most popular methods for the <b>threaded</b> joint’s assembly <b>control</b> in machine manufacturing are as following: 1) measurement of the screw’s prolongation; 2) control of the screw-nut’s turning angle; 3) measurement of the screw-nut’s tightness moment. The most exact results provide the measurement of the screw’s prolongation. This method is widely used when <b>controlling</b> <b>threaded</b> joint’s tightness for very responsible assembly units, for example, for pitman screw joints...|$|R
5000|$|Moirai, the Fates of Greek mythology who <b>control</b> the <b>Threads</b> of Fate ...|$|R
50|$|In the manga, Legato is {{also said}} to {{have the power to}} <b>control</b> <b>threads,</b> which are {{invisible}} barriers that can control things as well. The biggest example of when he used this was with his first encounter with Knives as a child. He used this power to survive Knives' attack and impressed the killer to allow him to be his right-hand man.|$|R
50|$|The <b>Thread</b> <b>Control</b> Block acts as {{a library}} of {{information}} about the threads in a system. Specific information is stored in the <b>thread</b> <b>control</b> block highlighting important information about each process.|$|R
5000|$|Mechanisms {{for adding}} {{security}} and reliability verification to the language: extended static checking, dependent typing, information flow <b>control,</b> static <b>thread</b> safety.|$|R
40|$|Internet-of-Things end-nodes demand {{low power}} {{processing}} platforms characterized by heterogeneous dedicated units, {{controlled by a}} processor core running concurrent <b>control</b> <b>threads.</b> Such architecture scheme fits {{one of the main}} target application domain of the RISC-V instruction set. We present an open-source processing core compliant with RISC-V on the software side and with the popular Pulpino processor platform on the hardware side, while supporting interleaved multi-threading for IoT applications. The latter feature is a novel contribution in this application domain. We report details about the microarchitecture design along with performance data. Comment: 8 page...|$|R
40|$|In {{traditional}} object-oriented languages, method {{calls are}} synchronous: The <b>thread</b> of <b>control</b> is {{passed from the}} caller to the callee, blocking the caller until the call is finished. This suits tightly coupled systems but leads to unnecessary delays in distributed environments, where objects are dispersed geographically. Another problem shared by thread-based object-oriented languages is that <b>control</b> <b>threads</b> may interfere with each other when operating on the same object. Creol is a language for concurrent objects that addresses these issues through two novel language constructs: asynchronous method calls and explicit processor release points. ...|$|R
40|$|The article {{presents}} a methodology for modelling the <b>control</b> of a <b>threaded</b> plug gauge. There had been examined works of scientists {{who had studied}} the aspects of the average <b>thread</b> diameter <b>control</b> and studied the problems of providing and {{improving the quality of}} threaded joints. At a modern machine-building enterprise, threaded gauges are important in <b>controlling</b> <b>threaded</b> joints of parts. There had been built a functional model of the caliber life-cycle. The article shows possible applications of threaded gauges and examines the method of automating the average <b>thread</b> diameter <b>control</b> on a universal three-axis measuring video microscope. The application of this method is expedient in the conditions of modern production, since that usage reduces time expenses and requirements for the operators' qualification, as well as increases the reliability {{of the results of the}} average <b>thread</b> diameter <b>control...</b>|$|R
50|$|Architectures are changing, {{with greater}} {{internal}} concurrency (multi-core), better fine-grain concurrency <b>control</b> (<b>threading,</b> affinity), and more levels of memory hierarchy. Multithreaded programs {{can take advantage}} of these developments more easily than single-threaded applications. This has already yielded separate, complementary standards for symmetric multiprocessing, namely OpenMP. MPI-2 defines how standard-conforming implementations should deal with multithreaded issues, but does not require that implementations be multithreaded, or even thread-safe. MPI-3 adds the ability to use shared-memory parallelism within a node. Implementations of MPI such as Adaptive MPI, Hybrid MPI, Fine-Grained MPI, MPC and others offer extensions to the MPI standard that address different challenges in MPI.|$|R
40|$|Job {{workflow}} application execution {{over the}} Grid presents significant challenges to current existing job workflow execution models (JWEM). In this paper, we propose executable codes as dynamic services, which acts {{as part of}} Grid resources. Based on service deployment mechanism and where the <b>control</b> <b>thread</b> is, a classification of the JWEMs is presented in this paper. Performance evaluation and comparison studies are carried out on the execution models according to this classification. Our experimental {{studies show that the}} distributed job workflow execution based on dynamic services can achieve better performance than all other models. Department of ComputingRefereed conference pape...|$|R
50|$|She, Decima and Morta {{together}} <b>controlled</b> {{the metaphorical}} <b>thread</b> of life.|$|R
50|$|In a {{multiprocessor}} system executing a single {{set of instructions}} (SIMD), data parallelism is achieved when each processor performs the same task on different pieces of distributed data. In some situations, a single execution <b>thread</b> <b>controls</b> operations on all pieces of data. In others, different <b>threads</b> <b>control</b> the operation, but they execute the same code.|$|R
50|$|The {{tension in}} the yarn is <b>controlled</b> by <b>threading</b> the yarn through the fingers of the left hand. Typically, the yarn is looped around the little finger, across the {{knuckles}} and around the index finger.|$|R
40|$|Design of a {{real-time}} client/server {{data acquisition}} and control system is presented. The {{core of the}} system is designed around a Windows NT based, multi-threaded data acquisition and control server, and several smart, task-specific clients with friendly GUIs. The server supports multiple simultaneous client connections. Each client connection operates in its own thread of execution, which has a lower priority than the real-time acquisition and <b>control</b> <b>thread.</b> Time synchronization among servers and clients is achieved through Network Time Protocol (NTP). Acquisition, control, metering and strip charting clients are connected to the servers using TCP/IP protocol. Discussion of the design requirements, approach and test results are presented. Peer reviewed: NoNRC publication: Ye...|$|R
40|$|This {{dissertation}} addresses {{operating system}} thread scheduling for chip multithreaded processors. Chip multithreaded processors are becoming mainstream {{thanks to their}} superior performance and power characteristics. Threads running concurrently on a chip multithreaded processor share the processor’s resources. Resource contention, and accordingly performance, depends on characteristics of the co-scheduled threads. The operating system <b>controls</b> <b>thread</b> co-scheduling, and thus affects performance of a chip multithreaded system. This dissertation describes the design and implementation of three new scheduling algorithms for chip multithreaded processors: the nonwork-conserving algorithm, the target-miss-rate algorithm, and the cachefair algorithm. These algorithms target contention for the second-level cache, a recognized performance-critical resource, and pursue several objectives: performance optimization, fairness, and performanc...|$|R
5000|$|In {{computer}} science, {{a ticket}} lock is a synchronization mechanism, or locking algorithm, {{that is a}} type of spinlock that uses [...] "tickets" [...] to <b>control</b> which <b>thread</b> of execution is allowed to enter a critical section.|$|R
40|$|In {{order to}} obtain {{continued}} performance improvements from microprocessors, ways must be found to increase the degree of parallel execution. However, the parallelism of single-threaded programs {{is limited by the}} control flow within the code. This paper proposes a technique to reduce the control flow bottleneck by observing that much of the control flow computation can be performed in parallel with data computation. Using this observation the program can be partitioned into a control flow generating portion, called the <b>control</b> <b>thread,</b> and a data computing portion, broken up into work threads. This paper further proposes an architecture to execute the <b>control</b> and work <b>threads</b> in parallel. After a detailed microarchitecture simulation, we observe a perfomance speedup of 1. 03 to 1. 48 on integer benchmarks, with an average of 1. 16 on a dual 4 -wide versus a conventional 4 -wide superscalar processor, and an average of 1. 20 on a dual 8 -wide versus a single 8 -wide superscalar processor. 1...|$|R
40|$|Proyecto de Graduación (Licenciatura en Ingeniería en Seguridad Laboral e Higiene Ambiental) Instituto Tecnológico de Costa Rica, Escuela de Ingeniería en Construcción, 2015. This {{graduation}} project {{consists of}} {{the application of the}} LEAN philosophy in the manufacturing and assembly of the steel structure projects. According to Hernandez, JC & Vizan, this philosophy applies to staff l, defines how to improve and optimize a production system with a focus on identifying and eliminating all forms of waste. The definition of LEAN is clear to be identified as a focus for the managementproduction delivery of a specific project, reducing lead times, improving quality and thus ensuring expected profits in the company budget. In order to implement in the best way the Lean philosophy, it made use of tools such as flow charts, Pareto analysis or 80 - 20, cause-effect diagrams and Balance Card. The objectives of this research were to determine the causes of quality issues and delivery of steel structure projects, identify processes in manufacturing and construction of steel structure projects, analyze the tools available to <b>control</b> <b>threads</b> identify threads of greater relevance, evaluate the productivity of human resources in the main thread and propose improvements to them. As part of the improvements templates for <b>controlling</b> <b>threads,</b> similarly a flowchart of threads both in the factory and on site, and a workshop area distribution with respect to the defined process flow. The development of the company providing document tools and foundations for the implementation of projects by controlling the quality and time, eliminating waste. Instituto Tecnológico de Costa Rica; Servicios Estructurales S. A...|$|R
5000|$|TV-B-Gone Jacket (2008/2011) - hoodie with {{embedded}} TV-B-Gone remote <b>control</b> and conductive <b>thread</b> zipper switch ...|$|R
40|$|PSAM {{consists}} {{of a number of}} multithreaded pipeline processors to support parallel computation. <b>Thread</b> <b>control</b> is implemented using a distributed approach, in which each processor can indepen-dently initiate and terminate a <b>thread.</b> This <b>thread</b> <b>control</b> mechanism is based on data ow model, and allows the degree of multiprocessing to vary with time. Although the basic processor is von Neumann- based, the overhead to support parallelism is very low...|$|R
40|$|This article {{presents}} {{an overview of}} PUMA (Performance-oriented, User-managed Messaging Architecture), a message-passing kernel for massively parallel systems. Message passing in PUMA is based on portals – {{an opening in the}} address space of an application process. Once an application process has established a portal, other processes can write values into the portal using a simple send operation. Because messages are written directly into the address space of the receiving process, {{there is no need to}} buffer messages in the PUMA kernel and later copy them into the applications address space. PUMA consists of two components: the quintessential kernel (Q-Kernel) and the process <b>control</b> <b>thread</b> (PCT). Although the PCT provides management decisions, the Q-Kernel controls access and implements the policies specified by the PCT...|$|R
40|$|Responsive Multithreaded (RMT) Processor that <b>controls</b> <b>thread</b> {{execution}} in Simultaneous Multithreading by introducing thread priority has been invented for parallel and distributed real-time processing. This paper concerns the basic approach of real-time scheduler on RMT processor. Our {{goal is to}} build a system where various types of tasks reside; hard/soft real-time tasks, periodic/aperiodic tasks and so on. We mainly focus on the point of periodic task scheduling and aperiodic task scheduling with making use of hardware supports. Our approaches in this paper are based on the extension of the existing approaches for RMT processor as the algorithm EDF-FF and the deferrable server. The performance evaluation shows the effectiveness of our approach on RMT processor in the sense of deadline miss ratio and response time...|$|R
40|$|High {{selectivity}} {{for long}} AT sequences can be attained by kinetically <b>controlled</b> DNA <b>threading</b> intercalation by binuclear ruthenium(II) complexes. The rate of intercalation is strongly correlated {{to the number}} of consecutive AT basepairs, being up to 2500 times faster with an AT polymer compared to mixed-sequence DNA...|$|R
40|$|Modern {{computer}} systems {{are prone to}} various classes of runtime faults due to their reliance on features such as concurrency and peripheral devices such as sensors. Testing remains a common method for uncovering faults in these systems. However, commonly used testing techniques that execute the program with test inputs and inspect program outputs to detect failures are often ineffective. To test for concurrency and temporal faults, test engineers {{need to be able}} to observe faults as they occur instead of relying on observable incorrect outputs. Furthermore, they {{need to be able to}} <b>control</b> <b>thread</b> or process interleavings so that they are deterministic. This research will provide a framework that allows engineers to effectively test for subtle and intermittent faults in modern systems by providing them with greater observability and controllability...|$|R
40|$|In object {{oriented}} development, classes and relationships {{found in the}} problem domain are carried seamlessly into the design and implementation. Entity-life modeling extends this modeling idea into the time domain. Sequences of event occurrences called event threads are identified in the problem space and {{form the basis for}} <b>control</b> <b>threads</b> in software. This modeling can occur at two levels. The basic level mechanically finds sequences of events in the problem, while the pattern level deals with concurrency structures in the problem such as resource users contending for resources. Such structures are modeled by means of threads and synchronized objects in software. This modeling approach to concurrency leads to the concept of a concurrency level, which indicates the number of threads that is, in a certain sense, optimal for a given problem. 1...|$|R
40|$|This paper {{describes}} experienceprototyping {{the proposed}} IEEE standard "minimal realtime system profile ", whose primary component is support for realtime threads. It provides some background, describes the implementation, and reports preliminary performance measurements. 1 Introduction A thread {{is an independent}} sequential flowof <b>control.</b> <b>Threads</b> differ from processes by sharing a common virtual address space with other threads. Threads are widely accepted as a computational building block for both uniprocessor and multiprocessor environments. In uniprocessor environments, the thread model simplifies the programming of asynchronous operations. In multiprocessor environments, threads may also allow higher throughput, by utilizing more than one processor. The idea of cheap concurrency or "lightweightprocesses " has been around in various forms for a long time, including support for coroutines in the Mesa programming language[13], and multitasking in the Ada programming language[18] [...] . ...|$|R
5000|$|... "From {{every book}} {{invisible}} threads {{reach out to}} other books, and as the mind comes to use and <b>control</b> those <b>threads</b> the whole panorama of the world's life, past and present, becomes constantly more varied and interesting." [...] -Living With Books: the art of book selection (1935, Columbia University Press) ...|$|R
