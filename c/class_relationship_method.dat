0|3371|Public
40|$|The {{design of}} large scale, interacting, {{software}} applications {{is a complex}} task, with the inclusion of security often delegated to latter stages of the lifecycle. Security must be a first class citizen in this process, at early and all stages of the lifecycle, in support of security policy definition, authorization, authentication, enforcement, and security assurance. One of the dominant players in software design is the unified modeling language, UML, a language for specifying, visualizing, constructing and documenting software artifacts. In UML, diagrams provide alternate perspectives for different stakeholders (e. g., users, designers, software engineers, etc.) and offer complementary representations of {{different parts of the}} system. Of particular interest are usecase diagrams for the interaction of users with system components, class diagrams for the static <b>classes</b> and <b>relationships</b> among them, and sequence diagrams for the dynamic behavior of instances of the class diagram. However, UML's support for the definition of security requirements for these diagrams and their constituent elements (e. g., actors, systems, use cases, <b>classes,</b> instances, include/extend/generalize <b>relationships,</b> <b>methods,</b> data, etc.) is lacking. In this paper, we address this issue by incorporating mandatory access control (MAC) into UML use-case, class, and sequence diagrams, providing support for the definition of clearances and classifications for relevant UML elements. In addition, we provide a framework for security assurance...|$|R
40|$|Security {{must be a}} {{first class}} citizen {{in the design of}} large scale, interacting, {{software}} applications, at early and all stages of the lifecycle, for accurate and precise policy definition, authorization, authentication, enforcement, and assurance. One of the dominant players in software design is the unified modeling language, UML, a language for specifying, visualizing, constructing and documenting software artifacts. In UML, diagrams provide alternate perspectives for different stakeholders, e. g. : use case diagrams for the interaction of users with system components, class diagrams for the static <b>classes</b> and <b>relationships</b> among them, and sequence diagrams for the dynamic behavior of instances of the class diagram. However, UML's support for the definition of security requirements for these diagrams and their constituent elements (e. g., actors, systems, use cases, <b>classes,</b> instances, include/extend/generalize <b>relationships,</b> <b>methods,</b> data, etc.) is lacking. In this paper, we address this issue by incorporating mandatory access control (MAC) into use case, class, and sequence diagrams, providing support for the definition of clearances and classifications for relevant UML elements. In addition, we provide a framework for security assurance as users are defining and evolving use case, class, and sequence diagrams, bridging the gap between software engineers and an organization's security personnel in support of secure software design. To demonstrate the feasibility and utility of our work on secure software design, our MAC enhancements for UML have been integrated into Borland's Together Control Center Environment...|$|R
40|$|International audienceThe reverse {{inheritance}} <b>class</b> <b>relationship</b> {{viewed as}} the symmetrical of the inheritance <b>class</b> <b>relationship</b> has great potential in class hierarchy reorganization. Classes from different hierarchies can be reorganized getting a new common superclass, factoring common features, thus avoiding data and code duplication...|$|R
40|$|A {{discontinuity}} {{exists between}} object-oriented modeling and programming languages. This discontinuity arises from ambiguous concepts in modeling languages {{and a lack}} of corresponding concepts in programming languages. It is particularly acute for binary <b>class</b> <b>relationships</b> [...] association, aggregation, and composition. It hinders the traceability between software implementation and design, thus hampering software analysis. We propose consensual definitions of the binary <b>class</b> <b>relationships</b> with four minimal properties [...] exclusivity, invocation site, lifetime, and multiplicity. We describe algorithms to detect automatically these properties in source code and apply these on several frameworks. Thus, we bridge the gap between implementation and design for the binary <b>class</b> <b>relationships,</b> easing software analysis...|$|R
40|$|Program {{analysis}} {{techniques have}} been widely applied in various fields of software engineering, such as debugging, testing, and proof of simple correctness properties. In objectoriented (OO) programs, inheritance, association, and aggregation relationships may introduce complicated dependencies concealed within classes that might obstruct program analysis. This paper proposes a <b>class</b> <b>relationship</b> flow models to provide analysis for inheritance, association, and aggregation of <b>class</b> <b>relationships.</b> The flow model consists of three flows, inheritance, association, and aggregation flows, corresponding to these relationships. A sequence of <b>class</b> <b>relationships</b> is represented as a flow path from one class to another. Along a flow path, each member within a class is associated with an operation, define or use, to represent whether its status is changed or referenced. Thereby, the concealed dependencies introduced by <b>class</b> <b>relationships</b> can be analyzed according to the flow operations. The analysis might {{be used as a}} technique for program understanding, anomaly detection, and program testing...|$|R
40|$|Healthy teacher <b>class</b> <b>relationships</b> are an {{important}} aspect of adequate classroom management. It is often assumed that in new <b>classes</b> these <b>relationships</b> become rather stable within several weeks. However, no empirical evidence for this assumption has been offered yet. This paper studies the development of teacher <b>class</b> <b>relationships</b> in 48 unacquainted teacher class combinations by monitoring the relationship during a period of 16 weeks. Relationships are studied by means of class perceptions of teacher’s Influence and Proximity. It appears that on average both dimensions show a significant downward trend...|$|R
40|$|Abstract: Inheritance is a <b>class</b> <b>relationship</b> {{that enables}} the {{extension}} of object-oriented systems. We use a reverse inheritance <b>class</b> <b>relationship</b> [1] {{in order to address}} the goals of limited adaptation and restricted reuse of object-oriented class hierachies. Reverse inheritance provides class hierarchy reorganization and class composition facilities. The reverse inheritance semantics are based a new class model, designed {{as an extension of the}} “classic ” model of class...|$|R
40|$|A {{discontinuity}} {{exists between}} modeling languages and object-oriented programming languages. This discontinuity {{is a consequence}} of ambiguous notions in modeling languages and lack of corresponding notions in objectoriented programming languages. It hinders the transition between a software design and its implementation, and vice versa. Thus, it hampers the implementation and the maintenance processes. This discontinuity is particularly acute for binary <b>class</b> <b>relationships,</b> which describe, at the design level, notions such as association, aggregation, and composition. From {{the current state of the}} art, we propose synthetic definitions for the binary <b>class</b> <b>relationships</b> at the design level and corresponding definitions at the implementation level. We express the latter definitions in terms of common properties. We present algorithms to synthesize code for these properties and to detect these properties in code. These algorithms allow us to generate and to detect binary <b>class</b> <b>relationships.</b> We verify th...|$|R
40|$|Abstract: The reverse {{inheritance}} <b>class</b> <b>relationship</b> {{has several}} potential uses. It can be exploited {{as a mechanism}} integrated {{in one of the}} object-oriented programming languages or as a mean for reengineering class hierarchies in order to obtain locally adapted software releases. The limited local adaptations and restricted enhancements can be encapsulated in the superclass of the reverse inheritance <b>class</b> <b>relationship</b> and using a software tool they can be applied automatically to each software release. The implementation of the software tool works on Java class hierarchies...|$|R
40|$|Mereology (from the Greek μερος, ‘part’) is {{the theory}} of parthood {{relations}}: of the relations of part to whole and the relations of part to part within a whole. Java is an object oriented language where every entity could be represented as an object {{and the presence of}} part to whole relations and part to part within a whole are present in different ways. The three most common mereological relationships in Java are the binary <b>class</b> <b>relationships</b> of Association, Aggregation and Composition. These binary <b>class</b> <b>relationships</b> are very easy to represent using the modelling languanges such as UML, but hard to detect in Java source code as there is a discontinuity between the source code of a program in Java and the correspoding representation in UML. This project aims to propose an algorithm that will detect the binary <b>class</b> <b>relationships</b> in Java programs and apply the algorithm in some big open source projects to gather statistics on the three mereological relations taken into account for this project. Statistics will be gathered from the application of the algorithm on the big open source projects. The development of the algorithm will be a step forward to bridging the gap between the representation of the binary <b>class</b> <b>relationships</b> in Java programs and their representation in UML. Besides the statistics gathered from the application of the algorithm on some big open source projects will provide useful information on some of the best practices used to implement binary <b>class</b> <b>relationships</b> in Java. Thus the results obtained from the project will be quite useful to writing better dependable software systems...|$|R
50|$|From {{that point}} on, the surplus product is formed within a <b>class</b> <b>relationship,</b> {{in which the}} {{exploitation}} of surplus labour combines with active or passive resistance to that exploitation.|$|R
5000|$|Political {{scientist}} Everett Carll Ladd Jr. in 1976 identified [...] "an {{inversion of}} the old <b>class</b> <b>relationship</b> in voting" [...] due to [...] "the transformations of conflict characteristic of post-industrialism." ...|$|R
5000|$|The three <b>classes</b> of <b>relationships</b> (positive, negative, and neutral) - {{recognising}} the Neutral <b>class</b> of <b>relationships</b> as {{of equal}} importance to Adversity and Synergy, {{not just the}} boundary between them.|$|R
5000|$|Alexander Tropsha - {{expert in}} {{quantitative}} structure-activity <b>relationship</b> <b>methods</b> and validation ...|$|R
5000|$|Interface < name > { {{elements}} = attributes, <b>relationships,</b> <b>methods</b> } ...|$|R
40|$|Abstract: This paper {{reports the}} use of the PatternCoder tool in the {{teaching}} of object-oriented design and programming. This tool has been developed by the authors as an extension to the BlueJ Java Integrated Development Environment (IDE). PatternCoder encapsulates knowledge of design patterns and basic <b>class</b> <b>relationships,</b> and of the techniques required for their implementation in Java. It guides students through a step-by-step process: select an appropriate pattern or relationship; give the classes which participate in the pattern names relevant to the current problem domain; and generate code for minimal Java class definitions which can then be explored and extended. The tool was initially developed with a view to teaching advanced design patterns, but we have explored its use within introductory classes, viewing binary <b>class</b> <b>relationships</b> as simple design patterns. Initial experience with the tool within an introductory Java module has been positive, with students actively choosing to use the tool and feeling that the teaching approach based on its use was beneficial to their understanding of <b>class</b> <b>relationships...</b>|$|R
40|$|A {{discontinuity}} {{exists between}} modeling and objectoriented programming languages. This discontinuity {{is a consequence}} of ambiguous notions in modeling languages and lack of corresponding notions in objectoriented programming languages. It hinders the transition between software implementation and design and hampers software maintenance. This discontinuity is particularly acute for binary <b>class</b> <b>relationships,</b> such as the association, aggregation, and composition relationships. We present a solution to bridge the discontinuity between implementation and design for the binary class relationships: We propose consensual definitions of the binary <b>class</b> <b>relationships</b> in terms of four properties (exclusivity, invocation site, lifetime, multiplicity). We describe algorithms to detect these properties in Java source code. ...|$|R
40|$|We {{propose a}} novel {{algorithm}} for hierarchical classification, the Hierarchical Dependence Network based on non-Hierarchical Predictive Classes (HDN-nHPC) algorithm. HDN-nHPC uses <b>relationships</b> among predictive <b>classes</b> {{that are not}} descendants or ancestors of each other to improve classification performance and, at the same time, provide insights to non-obvious predictive <b>class</b> <b>relationships.</b> To test our algorithm and baselines, we have used hierarchical ageing-related datasets where the classes are terms in the Gene Ontology. We have concluded, based on our experiments, that using non-hierarchical predictive <b>class</b> <b>relationships</b> improves {{the performance of the}} classification algorithm and that, considering one out of three accuracy measures, the HDN-nHPC is statistically significantly better than the other three algorithms that we have tested, while no statistical significant differences were found on the other two measures...|$|R
30|$|We {{agree with}} this {{statement}} but we believe that extending the comparison to ontology components instead of only specialization relations between classes would provide a stronger basis for competency comparison. Note for example that {{in the solar system}} domain, property comparisons are more important than <b>class</b> <b>relationships.</b>|$|R
30|$|In {{the group}} ‘class I malocclusion’, {{subjects}} presenting with bilateral canine and molar <b>class</b> I <b>relationship</b> (permanent dentition) or neutroclusion (mixed dentition) with crowding or other dental malpositions were included. The group ‘class II malocclusion’ consisted of subjects presenting with bilateral canine and molar <b>class</b> II <b>relationship</b> (divisions 1 and 2). The group ‘class III malocclusion’ consisted of subjects presenting with bilateral canine and molar <b>class</b> III <b>relationship.</b> In the group ‘Asymmetries’, subjects {{with a different}} relationship {{on both sides of}} the occlusion and subjects presenting facial asymmetries were included.|$|R
40|$|Multi-class {{problems}} have a richer structure than binary classification problems. Thus, they can potentially improve their performance by exploiting the <b>relationship</b> among <b>class</b> labels. While {{for the purposes}} of providing an automated classification result this class structure {{does not need to be}} explicitly unveiled, for human level analysis or interpretation this is valuable. We develop a multi-class large margin classifier that extracts and takes advantage of <b>class</b> <b>relationships.</b> We provide a bi-convex formulation that explicitly learns a matrix that captures these <b>class</b> <b>relationships</b> and is de-coupled from the feature weights. Our representation can take advantage of the class structure to compress the model by reducing the number of classifiers employed, maintaining high accuracy even with large compression. In addition, we present an efficient formulation in terms of speed and memory. ...|$|R
40|$|In object {{oriented}} distributed systems (OODS), the objects {{are viewed as}} resources. Concurrency control techniques are usually applied on the database tier. This has the limitations of lack of support of legacy files and requirement of separate concurrency control mechanisms for each database model. Hence concurrency control on the objects at server tier is explored. To implement concurrency control on the objects participating in a system, the impact of method types, properties and <b>class</b> <b>relationships</b> namely inheritance, association and aggregation are to be analyzed. In this paper, the types and properties of classes and attributes are analysed. The semantics of the <b>class</b> <b>relationships</b> are analysed to ascertain their lock modes, granule sizes for defining concurrency control in OODS. It is also intended to propose compatibility matrix among all these object relationships...|$|R
40|$|Abstract – In {{this paper}} {{we present a}} new {{approach}} for facilitating the maintenance, reengineering and adaptation of class libraries designed using objectoriented technology. The technique uses a new <b>class</b> <b>relationship</b> called reverse inheritance. We strive to prove that using this <b>class</b> <b>relationship</b> with it’s factoring supporting mechanism {{it is possible to}} factor features from a hierarchy, to add new features to a hierarchy, and to connect two class hierarchies. Also in the paper a list of problems relative to the new approach is formulated. because of the many facilities offered: i) to share common functionalities; ii) inserting a class into an existing hierarchy; iii) extending an existing hierarchy; iv) adding features to a class; v) factoring features from classes. The proposed technique is applied to class libraries and components- in the sense of hierarchies of classes stated by Bertrand Meyer in [8]...|$|R
5000|$|... #Subtitle level 2: Representing substructure: EAV with <b>classes</b> and <b>relationships</b> (EAV/CR) ...|$|R
5000|$|At {{the end of}} the 18th century, Korea {{was ruled}} by the Joseon Dynasty. It was a society based on Confucianism and its hierarchical, <b>class</b> <b>relationships.</b> There was a small {{minority}} of privileged scholars and nobility while the majority were commoners paying taxes, providing labour, and manning the military, all above a slave class.|$|R
5000|$|A {{significant}} proportion of squatters opposed the movement for self-determination by workers that gained impetus in the last decades of the 19th century in Australia. The events of the shearers’ strike of 1891 and the harsh counter-measures by Government and squatters left a bitter legacy that adversely affected <b>class</b> <b>relationships</b> in the ensuing decades.|$|R
40|$|AbstractA {{generalization}} of nondeterminism, called consistent nondeterminism, is investigated. It is shown that consistent storage is exponentially {{more powerful than}} ordinary storage. Simultaneous classes obtained by bounding both amount of storage and amount of consistent nondeterminism are characterized {{in terms of time}} bounded nondeterministic complexity <b>classes.</b> <b>Relationships</b> between consistent storage complexity classes and certain oracle complexity classes are investigated...|$|R
50|$|The {{categorical}} system enables categorizations {{of objects}} or persons {{on the basis}} of their similarities and differences. Forming hierarchies of interrelated concepts about <b>class</b> <b>relationships</b> is an example of the domain of this system. For instance, the general class of plants includes the classes of fruits and vegetables, which, in turn, include the classes of apples and lettuce, etc.|$|R
30|$|The {{structural}} equation model was calculated with the linear structural <b>relationship</b> <b>method,</b> via LISREL 9.1 software. A two-stage analysis was adopted, estimating, firstly, the measurement model and, secondly, the structural model.|$|R
5000|$|Decompose {{a problem}} into <b>classes,</b> define <b>relationships</b> and {{responsibilities}} of those classes. (AB only) ...|$|R
30|$|No {{statistical}} {{significant difference}} was found in the CTT and IRT difficulty indices between questions generated using class-based strategies and terminology-based strategies, and between questions generated using class-based strategies and property-based strategies. This suggests that the students found questions auto-generated using the individual and <b>class</b> <b>relationship</b> in the ontology as difficult as questions generated using the terminology-based strategies and the property-based strategies.|$|R
40|$|This paper proposes an {{extension}} of marginal fisher analysis (EMFA) for dimensionality reduction and analyzes some properties of both EMFA and linear discriminant analysis (LDA), and finally suggests a synthesized discriminant projection (SDP). SDP takes both global <b>class</b> <b>relationship</b> and local geometry structure into account, which maximizes the distance between marginal points and the distance between different class-centers, thus enhances classification. 1...|$|R
40|$|Previous {{research}} has highlighted the {{extensive use of}} the C++ friend construct in both library-based and application-based systems. However, existing software metrics do not concentrate on measuring friendship accurately, a surprising omission given the debate friendship has caused in the Object-Oriented community. In this paper, a number of software metrics, that measure {{the extent to which}} friend <b>class</b> <b>relationships</b> are actually used in systems, are de ned. These metrics are based on the interactions for which the friend construct is necessary, as well as the direction of this association between classes. Our results, in applying these metrics to the top 100 downloaded systems from sourceforge. net, indicate that up to 66 % of friend <b>class</b> <b>relationships</b> in systems are redundant. Elsewhere, friend function declarations would have been more appropriate in many cases. In addition, {{it has been shown that}} friendship-based coupling contributes significantly to the high coupling of friend classes for only 25 % of the systems studied...|$|R
30|$|Class II Division 1 {{malocclusion}} with molar <b>Class</b> II <b>relationship</b> and overjet {{larger than}} 5  mm.|$|R
30|$|In this section, we conduct some {{experiments}} {{to study the}} classification performance of the proposed method on two widely used benchmark datasets: Caltech 101 [33] and Caltech 256 [34]. The mentioned datasets are challenging for image classification because of their large intra class variance and inter <b>class</b> <b>relationship.</b> In particular, in Caltech 256 the intra class variance is very large, making it more challenging for image classification.|$|R
40|$|International audienceOFL for Open Flexible Languages and {{the name}} of a meta model for {{object-oriented}} programming languages based on classes. It relies on three essential concepts of these languages: descriptions which are a generalisation of the notion of <b>class,</b> <b>relationships</b> such as inheritance or aggregation and languages themselves. OFL provides a customisation of these three concepts in order to adapt their operational semantics to the programmer's needs...|$|R
