110|249|Public
25|$|Innovative Routines International (IRI), Inc. is an American {{software}} company first known for bringing mainframe sort merge functionality into open systems. IRI {{was the first}} vendor to develop a commercial replacement for the Unix sort command, and combine data transformation and reporting in Unix batch processing environments. In 2007, IRI's <b>coroutine</b> sort ("CoSort") became the first product to collate and convert multi-gigabyte XML and LDIF files, join and lookup across multiple files, and apply role-based data privacy functions (including AES-256 encryption) for fields within sensitive files.|$|E
25|$|Mutual {{recursion}} {{can also}} implement a finite-state machine, with one function for each state, and single recursion in changing state; this requires tail call optimization {{if the number}} of state changes is large or unbounded. This {{can be used as a}} simple form of cooperative multitasking. A similar approach to multitasking is to instead use coroutines which call each other, where rather than terminating by calling another routine, one <b>coroutine</b> yields to another but does not terminate, and then resumes execution when it is yielded back to. This allows individual coroutines to hold state, without it needing to be passed by parameters or stored in shared variables.|$|E
5000|$|Scala Coroutines {{rely on the}} [...] macro that {{transforms}} {{a normal}} block of code into a <b>coroutine</b> definition. Such a <b>coroutine</b> definition can be invoked with the [...] operation, which instantiates a <b>coroutine</b> frame. A <b>coroutine</b> frame can be resumed with the [...] method, which resumes {{the execution of the}} coroutine's body, until reaching a [...] keyword, which suspends the <b>coroutine</b> frame. Scala Coroutines also expose a [...] method, which effectively duplicates the <b>coroutine.</b>|$|E
40|$|This paper {{defends the}} revival of <b>coroutines</b> as a general control abstraction. After proposing a new {{classification}} of <b>coroutines,</b> we introduce the concept of full asymmetric <b>coroutines</b> and provide a precise definition for it through an operational semantics. We then demonstrate that full <b>coroutines</b> have an expressive power equivalent to one-shot continuations and oneshot partial continuations. We also show that full asymmetric <b>coroutines</b> and one-shot partial continuations have many similarities, and therefore present comparable benefits. Nevertheless, <b>coroutines</b> are easier implemented and understood, specially {{in the realm of}} procedural languages. Finally, we provide a collection of programming examples that illustrate the use of full asymmetric <b>coroutines</b> to support direct and concise implementations of several useful control behaviors, including cooperative multitasking...|$|R
50|$|Fibers {{describe}} {{essentially the}} same concept as <b>coroutines.</b> The distinction, if there is any, is that <b>coroutines</b> are a language-level construct, a form of control flow, while fibers are a systems-level construct, viewed as threads that happen not to run in parallel. Priority is contentious; fibers {{may be viewed as}} an implementation of <b>coroutines,</b> or as a substrate on which to implement <b>coroutines.</b>|$|R
40|$|Concurrent {{programming}} using threads {{is considered}} a hard and error-prone task. <b>Coroutines</b> are conceptually simpler, they are easier to program with due to their sequential nature. Flexible <b>coroutines</b> as presented by Belsnes and Ã˜stvold liberate classical <b>coroutines</b> from their quasi-parallel world and combine them with threads. This allows the programmer to factor programs into sequential and parallel tasks, leading to simpler programs. This thesis presents an extension to the formal semantics for flexible <b>coroutines.</b> A detailed breakdown of the scheduling strategies and parameter passing {{is presented in the}} same formal framework. Some words are given on patterns that emerge when programming with flexible <b>coroutines</b> and these patterns are defined in the formal framework. We present a clean implementation of flexible <b>coroutines</b> in Java, based on standard threads and semaphores. Challenges encountered, such as representing <b>coroutines</b> in Java and invoking methods across threads ar...|$|R
5000|$|<b>Coroutine</b> support (<b>Coroutine</b> in FreeRTOS is a {{very simple}} and {{lightweight}} task that has very limited use of stack) ...|$|E
5000|$|Lua uses coroutines for concurrency. Lua 5.2 {{also offers}} true C <b>coroutine</b> {{semantics}} through the functions lua_yieldk, lua_callk, and lua_pcallk. The CoCo extension allows true C <b>coroutine</b> semantics for Lua 5.1.|$|E
50|$|According to Donald Knuth, Melvin Conway {{coined the}} term <b>coroutine</b> in 1958 when he applied it to {{construction}} of an assembly program. The first published explanation of the <b>coroutine</b> appeared later, in 1963.|$|E
50|$|Since continuations {{can be used}} to {{implement}} <b>coroutines,</b> programming languages that support them can also quite easily support <b>coroutines.</b>|$|R
5000|$|One {{important}} difference between threads and <b>coroutines</b> is that threads are typically preemptively scheduled while <b>coroutines</b> are not. Because threads can be rescheduled at any instant and can execute concurrently, programs using threads {{must be careful}} about locking. In contrast, because <b>coroutines</b> can only be rescheduled at specific points in the program and do not execute concurrently, programs using <b>coroutines</b> can often avoid locking entirely. (This property is also cited as a benefit of event-driven or asynchronous programming.) ...|$|R
50|$|A {{number of}} {{implementations}} of <b>coroutines</b> for languages with generator support but no native <b>coroutines</b> (e.g. Python before 2.5) use this {{or a similar}} model.|$|R
50|$|The queue is then {{completely}} filled or emptied before yielding {{control to}} the other <b>coroutine</b> using the yield command. The further coroutines calls are starting right after the yield, in the outer <b>coroutine</b> loop.|$|E
5000|$|Conversely, in {{the case}} of a [...] clause in a <b>coroutine,</b> like in a Python generator, the <b>coroutine</b> may never {{terminate}} - only ever yielding - and thus in ordinary execution the [...] clause is never executed. If one interprets instances of a <b>coroutine</b> as objects, then the [...] clause can be considered a finalizer of the object, and thus can be executed when the instance is garbage collected. In Python terminology, the definition of a <b>coroutine</b> is a generator function, while an instance of it is a generator iterator, and thus a [...] clause in a generator function becomes a finalizer in generator iterators instantiated from this function.|$|E
5000|$|If {{implemented}} with a <b>coroutine,</b> as in [...]NET async/await, {{creating a}} future calls a <b>coroutine</b> (an async function), which may {{yield to the}} caller, and in turn be yielded back to when the value is used, cooperatively multitasking.|$|E
50|$|<b>Coroutines</b> are a {{fine-grained}} concurrency primitive, {{which may}} be required to yield explicitly. They may enable specifying another function to take control. <b>Coroutines</b> that explicitly yield allow cooperative multitasking.|$|R
25|$|<b>Coroutines</b> can be {{implemented}} as a library if the programming language provides either continuations or generators - so the distinction between <b>coroutines</b> and generators in practice is a technical detail.|$|R
5000|$|<b>Coroutines</b> are [...] computer-program {{components}} that generalize subroutines for non-preemptive multitasking, by allowing multiple entry points for suspending and resuming execution at certain locations. <b>Coroutines</b> are well-suited for implementing familiar program components such as cooperative tasks, exceptions, event loops, iterators, infinite lists and pipes.|$|R
50|$|However, Simula used <b>coroutine</b> control {{structure}} instead of true concurrency.|$|E
5000|$|Coxpcall - <b>coroutine</b> {{compatible}} encapsulation {{of native}} pcall and xpcall ...|$|E
5000|$|The <b>coroutine</b> as {{the basic}} {{building}} block for concurrent processes ...|$|E
5000|$|Subroutines {{are special}} cases of ... <b>coroutines.</b> Donald Knuth.|$|R
50|$|Using <b>coroutines</b> {{for state}} {{machines}} or concurrency {{is similar to}} using mutual recursion with tail calls, as {{in both cases the}} control changes to a different one of a set of routines. However, <b>coroutines</b> are more flexible and generally more efficient. Since <b>coroutines</b> yield rather than return, and then resume execution rather than restarting from the beginning, they are able to hold state, both variables (as in a closure) and execution point, and yields are not limited to being in tail position; mutually recursive subroutines must either use shared variables or pass state as parameters. Further, each mutually recursive call of a subroutine requires a new stack frame (unless tail call elimination is implemented), while passing control between <b>coroutines</b> uses the existing contexts and can be implemented simply by a jump.|$|R
50|$|<b>Coroutines</b> are {{natively}} {{implemented in}} all Perl 6 backends.|$|R
5000|$|When subroutines are invoked, {{execution}} {{begins at}} the start, and once a subroutine exits, it is finished; an instance of a subroutine only returns once, and does not hold state between invocations. By contrast, coroutines can exit by calling other coroutines, which may later return {{to the point where}} they were invoked in the original coroutine; from the coroutine's point of view, it is not exiting but calling another <b>coroutine.</b> Thus, a <b>coroutine</b> instance holds state, and varies between invocations; there can be multiple instances of a given <b>coroutine</b> at once. The difference between calling another <b>coroutine</b> by means of [...] "yielding" [...] to it and simply calling another routine (which then, also, would return to the original point), is that the relationship between two coroutines which yield to each other is not that of caller-callee, but instead symmetric.|$|E
5000|$|<b>Coroutine</b> Duff's device {{can be used}} to {{implement}} coroutines in C/C++ ...|$|E
5000|$|Protothreads, a stackless {{lightweight}} thread implementation using a <b>coroutine</b> like mechanism ...|$|E
50|$|There is {{a library}} for Rust that {{provides}} <b>coroutines.</b>|$|R
40|$|The current AVS flow {{executive}} provides {{only limited}} mechanisms for <b>coroutines</b> synchronization: either they run completely synchronously {{with the entire}} network or completely asynchronously. In many real-time applications, responding to user interaction or to real-time sensors (live camera input), finer-grained synchronization control is needed. This paper presents a token-based handshaking scheme which can be instantiated at runtime between any subgroups of modules and <b>coroutines,</b> allowing users to define control flow in the network, as well as data flow. Developer's Track, Third International AVS User Conference (AVS 94), Boston, MA, May 2 - 4, 1994. 1 INTRODUCTION Interactive data exploration and event monitoring systems need special, continuously running processes to accept asynchronous input from user interaction [4, 5] and remote sensors 1. AVS provides <b>coroutines</b> for this purpose. They complement the more commonly used modules in AVS data flow networks. AVS <b>coroutines</b> execute [...] ...|$|R
50|$|In Tcl 8.6, the {{generator}} mechanism {{is founded on}} named <b>coroutines.</b>|$|R
5000|$|Pipeline (Unix), {{a kind of}} <b>coroutine</b> {{used for}} {{communicating}} between programs ...|$|E
50|$|CO2 - stackless <b>coroutine</b> {{based on}} C++ {{preprocessor}} tricks, providing await/yield emulation.|$|E
5000|$|... tonbit::coroutine - C++11 single [...]h {{asymmetric}} <b>coroutine</b> implementation via ucontext / fiber ...|$|E
5000|$|<b>Coroutines</b> {{landed in}} Clang in May 2017, with libc++ {{implementation}} ongoing.|$|R
5000|$|D (programming language) {{implements}} <b>coroutines</b> as its standard library class Fiber ...|$|R
50|$|Python 3.5 {{introduces}} explicit {{support for}} <b>coroutines</b> with async/await syntax (PEP 0492).|$|R
