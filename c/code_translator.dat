23|41|Public
50|$|Trance JIT is a MorphOS JIT compiler, or <b>code</b> <b>translator,</b> {{for running}} 68k {{applications}} within the MorphOS environment. It {{has been part}} of the MorphOS operating system since MorphOS 1.4.|$|E
5000|$|Since 2009 an {{open source}} version of RMCL (based on MCL 5.2) is hosted at Google Code MCL. This version runs under Rosetta (Apple's PPC to Intel <b>code</b> <b>translator</b> {{that is an}} {{optional}} install under Mac OS X 10.6).|$|E
50|$|ABox is an {{emulation}} sandbox {{featuring a}} PPC native AmigaOS API clone that is binary compatible with both 68k Amiga applications and both PowerUP and WarpOS formats of Amiga PPC executables. ABox {{is based in}} part on AROS Research Operating System. ABox includes Trance JIT <b>code</b> <b>translator</b> for 68k native Amiga applications.|$|E
50|$|<b>Code</b> <b>translators</b> {{differ from}} 1-of-n decoders in that {{multiple}} output bits may be active {{at the same}} time. An {{example of this is}} a seven-segment decoder, which converts an integer into the combination of segment control signals needed to display the integer's value on a seven-segment display digit.|$|R
40|$|ISBN: 0818654104 In {{this paper}} we present {{efficient}} self checking implementations for multiply and divide arrays. These implementations are strongly fault secure or totally self-checking {{for a comprehensive}} fault model which includes stuck-at, stuck-on and stuck-open faults. They are compatible with data paths checked by the parity code (i. e. no <b>code</b> <b>translators</b> are needed), so that the self checking implementation of the whole data path is simplified...|$|R
50|$|Jasmina Tešanović (Serbian: Јасмина Тешановић) (born March 7, 1954) is an author, feminist, {{political}} activist (Women in Black, <b>Code</b> Pink), <b>translator,</b> and filmmaker.|$|R
50|$|As the syntax of Scilab {{is similar}} to MATLAB, Scilab {{includes}} a source <b>code</b> <b>translator</b> for assisting the conversion of code from MATLAB to Scilab. Scilab is available free of cost under an open source license. Due to the open source nature of the software, some user contributions have been integrated into the main program.|$|E
50|$|On {{the receive}} section the {{signal from the}} radio {{receiver}} comes to a tone demodulator, then a polarity inverter, and then to an error checking circuit, {{and at the same}} time to an input shift register that converts from serial to parallel. Next it goes to a <b>code</b> <b>translator</b> to convert from seven bits to five bits. From here the five bit code goes to a parallel to serial converter, controlled by a repetition cycle timer on the receive side.|$|E
50|$|Lucent used Inferno in {{at least}} two {{internal}} products: the Lucent VPN Firewall Brick, and the Lucent Pathstar phone switch. They initially tried to sell source code licenses of Inferno but found few buyers. Lucent did little marketing and missed the importance of the Internet and Inferno's relation to it. During the same time Sun Microsystems was heavily marketing its own Java programming language, which was targeting a similar market, with analogous technology, that worked in web browsers and also filled the demand for object-oriented languages popular at that time. Lucent licensed Java from Sun, claiming that all Inferno devices would be made to run Java. A Java byte code to Dis byte <b>code</b> <b>translator</b> was written to facilitate that. However, Inferno still did not find customers.|$|E
40|$|WO 9321576; GR 920100163; EP 0591490 Method of {{self-checking}} arithmetic {{units and}} data paths using the double rail code for the arithmetic operators and a parity code {{for the other}} blocks. The method uses a single block for the generation of both codes, thus avoiding the need of <b>code</b> <b>translators.</b> The ripple-carry adders, ALU's, multiply and divide arrays are implemented with DCVS or static differential gates, to avoid overhead (Output Checking/Parity Generation Scheme). When the adders or ALU's are of a certain length, the schemes used are the Carry and Output Checking/Parity Generation and Carry Checking/Parity Prediction...|$|R
50|$|The object <b>code</b> <b>translators</b> for the HP 3000 and Tandem T/16 {{are another}} example.They {{translated}} stack code sequences into equivalent sequences of RISC code. Minor 'local' optimizations removed {{much of the}} overhead of a stack architecture. Spare registers were used to factor out repeated address calculations. The translated code still retained plenty of emulation overhead from the mismatch between original and target machines. Despite that burden, the cycle efficiency of the translated code matched the cycle efficiency of the original stack code. And when the source code was recompiled directly to the register machine via optimizing compilers, the efficiency doubled. This shows that the stack architecture and its non-optimizing compilers were wasting {{over half of the}} power of the underlying hardware.|$|R
40|$|Abstract-Arithmetic {{error codes}} {{constitute}} {{a class of}} error codes that are preserved during most arithmetic operations. Effectiveness studies for arithmetic error codes have shown their value for concurrent detection of faults in arithmetic processors, data transmission subsystems, and main storage units in fault-tolerant computers In this paper, it is shown that the same class of codes is also quite effective for detecting storage errors in both shift-register and magnetic-recording mass memories. Some of the results are more general and deal with properties of arithmetic error codes in detecting unidirectional failures. For example, it is shown that a low-cost arithmetic error code with check modulus A = 2 - 1 can detect any unidirectional failure which affects fewer than N bits. The use of arithmetic error codes for checking of mass memories is further justified since it {{eliminates the need for}} hard-core or self-checking <b>code</b> <b>translators</b> and reduces the number of different types of cod...|$|R
5000|$|During the Cold war era, {{the company}} took active {{participation}} in the Blue Streak (UK) and Atlas (U.S.) missile projects, helped to develop capability for many areas of electronic warfare and in missile field, including <b>code</b> <b>translator</b> data systems, ground support equipment, electronic countermeasures testing and antenna systems, infrared homing techniques, also company provided tactically deployed maintenance and technical support teams for mentioned missile systems, it supplied airborne target simulator system for Nike Zeus, electronic countermeasure systems for Douglas EB-66E and Boeing B-52 aircraft. Its R&D divisions (Manson Laboratories in Wilton, Connecticut, and Military Electronics Division in Chicago) developed penetration aids for intercontinental ballistic missiles and participated in various other classified programs. In the words of its advertising sloganry, the company supported “America’s defense umbrella.” ...|$|E
5000|$|On the send section {{the channel}} circuit {{includes}} a delay line feeding a repetition storage. The common send section circuit includes a <b>code</b> <b>translator</b> {{that changes the}} five bit code to the seven bit code. Next the seven bit character goes to an output shift register, {{and then to a}} polarity inverter. For a four channel system the bits would then be interleaved between AB and CD channels. The final send step is a tone modulator and output circuit. The tone is modulated using frequency shift keying. The 0 (or space) signal picks out a lower frequency, and the 1 ( [...] or mark signal) picks out a higher frequency. This signal to frequency conversion may be inverted, and this is common below 10 MHz.|$|E
40|$|A {{series of}} NASA and Contractor studies {{sponsored}} by NASA/KSC {{resulted in a}} specification for the Ground Operations Aerospace Language (GOAL). The Cape Kennedy Facility of the IBM Corporation was given the responsibility, under existing contracts, to perform {{an analysis of the}} Language Specification, to design and develop a GOAL Compiler, to provide a specification for a data bank, to design and develop an interpretive <b>code</b> <b>translator,</b> and to perform associated application studies...|$|E
50|$|At {{the time}} of introduction, the only {{competitors}} were 8-bit processors (mainly Intel 8080, Z80, and MOS Technology 6502 based systems). The MicroEngine could compile Pascal source code in {{a fraction of the}} time (typically about 1/10) required by contemporaries. Fast compilation made the MicroEngine especially nice as a developer's machine, and the inclusion of a semaphore primitive in the microcode was particularly useful for multi user enhancements, which were developed in Melbourne for the Canberra Australia-based Ortex Company, extended to be a multiuser system and often sold with a bundled pharmacy management system, also delivered on the Sage IV computers under UCSD Pascal IV and enabled as a multiuser system using the Sage multiuser bios rather than by extending UCSD Pascal IV to add a semaphore. This performance advantage was eroded by the later availability of p-code to native machine <b>code</b> <b>translators,</b> and mainstream 16-bit microprocessors such as the Intel 8086 and Motorola 68000.|$|R
40|$|A {{spontaneous}} symmetry lifting model {{based on}} Tlusty&#x 27;s elegant topological deconstruction suggests that multiple punctuated ecosystem resilience regime changes in metabolic free energy that were broadly {{similar to the}} aerobic transition enabled a punctuated sequence of increasingly complex genetic <b>codes</b> and protein <b>translators.</b> In {{a manner similar to}} the Serial Endosymbiosis effecting the Eukaryotic transition, <b>codes</b> and <b>translators</b> coevolved until the ancestor of the present narrow spectrum of protein machineries became locked-in by evolutionary path dependence at a relatively modest level of fitness reflecting a modest embedding metabolic free energy ecology. The simplest coevolutionary model of code-translator interaction has high and low fidelity quasi-equilibria consistent with the &#x 27;virus world&#x 27; hypothesis of Koonin et al. (2006). A more detailed search for empirical evidence of &#x 27;preaerobic&#x 27; ecosystem shifts in metabolic free energy availability or efficiency of use might be surprisingly fruitful...|$|R
40|$|Abstract. We {{present a}} trusted source {{translator}} that transforms total functions {{defined in the}} specification language of the HOL theorem prover to simple intermediate <b>code.</b> This <b>translator</b> eliminates polymorphism by code specification, removes higher-order functions through closure conversion, interprets pattern matching as conditional expressions, etc. The target intermediate language can be further translated by proof to a simple imperative language. Each transformation is proven to be correct automatically. The formalization, implementation and mechanical verification of all transformations are done in HOL- 4. ...|$|R
40|$|AbstractWe {{present a}} novel method for 3 D {{anisotropic}} front propagation {{and apply it}} to the simulation of geological folding. The new iterative algorithm has a simple structure and abundant parallelism, and is easily adapted to multithreaded architectures using OpenMP. Moreover, we have used the automated C-to-CUDA source <b>code</b> <b>translator,</b> Mint, to achieve greatly enhanced computing speed on GPUs. Both OpenMP and CUDA implementations have been tested and benchmarked on several examples of 3 D geological folding...|$|E
40|$|Trust {{asymmetry}} is a core, albeit rarely discussed, {{problem in}} scalable computing. Techniques for protecting a host’s operating system (and other processes) from a user’s process are well understood and widely deployed. However, {{there is currently}} no way to protect the user’s process from the OS. Hence, while the host’s owner need not trust the user at all, the user must trust the owner completely. This, we argue, leads to practical limits to scalability for computation that, because of encryption, simply do not exist for communication. We {{argue that it is}} imperative for the grid computing community to address this problem using encrypted computation techniques. We then propose a simple mechanism for encrypted computation of Boolean circuits and show how it can likely be generalized for use in an object <b>code</b> <b>translator.</b> 1...|$|E
40|$|Symbolic {{computation}} {{is employed}} to automatically derive formulas in {{finite element analysis}} (FEA) and to generate parallel numeric code. Key FEA computations parallelized include element stiffness computations and solution of global system of equations. An element-by-element preconditioned conjugate gradient method is used to solve the global system of equations in parallel. Derived formulas are automatically mapped onto the shared-memory architecture. An experimental software system, P-FINGER, is being extented. P-FINGER features a specification language to describe numeric algorithms for which code is to be generated. The specifications also allow an automatic code dependence analysis mechanism to extract parallelism from the specified computational steps. A separate <b>code</b> <b>translator</b> GENCRAY is modified to render code into parallel f 77. Generated parallel routines run {{under the control of}} existing FEA packages. Examples of generated code are also presented...|$|E
40|$|SMEs (Small and {{medium-sized}} enterprises), particularly those whose business {{is focused on}} developing innovative produces, are limited by a major bottleneck on the speed of computation in many applications. The recent developments in GPUs have been the marked increase in their versatility in many computational areas. But {{due to the lack}} of specialist GPU (Graphics processing units) programming skills, the explosion of GPU power has not been fully utilized in general SME applications by inexperienced users. Also, existing automatic CPU-to-GPU <b>code</b> <b>translators</b> are mainly designed for research purposes with poor user interface design and hard-to-use. Little attentions have been paid to the applicability, usability and learnability of these tools for normal users. In this paper, we present an online automated CPU-to-GPU source translation system, (GPSME) for inexperienced users to utilize GPU capability in accelerating general SME applications. This system designs and implements a directive programming model with new kernel generation scheme and memory management hierarchy to optimize its performance. A web-service based interface is designed for inexperienced users to easily and flexibly invoke the automatic resource translator. Our experiments with non-expert GPU users in 4 SMEs reflect that GPSME system can efficiently accelerate real-world applications with at least 4 x and have a better applicability, usability and learnability than existing automatic CPU-to-GPU source translators...|$|R
50|$|The barrio {{was named}} after Dalmacio Vélez Sársfield, the 19th century author of the Argentine civil <b>code,</b> and a <b>translator</b> of Latin poems into Spanish. It is a typical {{low-rise}} housing area, that like many others was mainly populated during the urban explosion {{at the beginning of}} the 20th century.|$|R
5000|$|Translators had {{difficulties}} rendering Buddhist terminology from Sanskrit, Pali, and Middle Indo-Aryan languages into written Chinese (Chien and Creamer 1986: 35). Because of the polysemous {{and sacred}} character of such Buddhist doctrinal concepts as bodhi and prajñā, many Chinese translators preferred to transliterate rather than translate such crucial terms, {{so as not}} to limit their semantic range to a single Chinese meaning. Furthermore, the spiritual efficacy thought to be inherent in the pronunciations of Buddhist mantra spells and dhāraṇī <b>codes</b> compelled <b>translators</b> to preserve as closely as possible the original foreign-language pronunciation (Buswell and Lopez 2013: 1030).|$|R
40|$|Abstract — {{the paper}} deals with {{development}} of time code generator and translator using microcontroller based user interface. TCG/T {{is used in}} order to provide time stamping and event synchronization in satellite stations. TCG (Time Code Generator) is a precision timing system that generates a GPS (Global positioning system) Synchronized serial time code with DS 1307 -RTC (Real time Clock) where the process takes place and gives a serial time output using the IRIG-A (Inter Range Instrumentation Group) time code. TCT (Time <b>Code</b> <b>Translator)</b> is capable of accepting the control signals from TCG and translate the serial time to parallel time using a CPLD (Complex Programmable Logic Device). TCG/T can be programmed to even translate and provide parallel time code to front end hardware for time stamping the satellite raw data ingested by real time data acquisition systems up to microsecond level...|$|E
40|$|The Process Introspection {{project is}} a design and {{implementation}} effort, the main goal {{of which is to}} construct a general purpose, flexible, efficient checkpoint/restart mechanism appropriate for use in high performance heterogeneous distributed systems. This checkpoint/restart mechanism has the primary constraint that it must be platform independent; that is, checkpoints produced on one architecture or operating system platform must be restartable on a different architecture or operating system platform. The Process Introspection mechanism is based on a design pattern for constructing interoperable checkpointable modules. Application of the design pattern is automated by two levels of software tools: a library of support routines that facilitate the use of the design pattern, and a source <b>code</b> <b>translator</b> that automatically applies the pattern to platform independent modules. A prototype implementation of library has been constructed and used to demonstrate that the design pattern can [...] ...|$|E
40|$|In {{this paper}} {{we present a}} system for network based {{visualization}} of profile information generated by Java applets/bytecode. The system, called NetProf, is composed of several components {{each of which is}} interesting in their own right. The components are a bytecode to Java source <b>code</b> <b>translator,</b> a profiler that includes a static pass to insert profiler code, a dynamic runtime library that records relevant events and finally a visualization mechanism which highlights the profile information in an easy to use manner. All of this can be done over the Internet using a client-server approach and is independent of the underlying architecture/machine and human intervention. Keywords: Java, Bytecode, Profiling, Visualization, Client-Server, World Wide Web, Internet. The University of Rochester Computer Science Department supported this work. This work {{was supported in part by}} an NSF Research Initiation Award (CCR- 9409120) and ARPA contract F 19628 - 94 -C- 0057. 1 Introduction The past few [...] ...|$|E
5000|$|The MALPAS toolset {{comprises}} five {{specific analysis}} tools that address various properties of a program. The input to the analysers {{needs to be}} written in MALPAS Intermediate Language (IL); this can be hand-written or produced by an automated translation tool from the original source <b>code.</b> Automatic <b>translators</b> exist for common high-level programming languages such as Ada, C and Pascal, as well as assembler languages such as Intel 80*86, PowerPC and 68000. The IL text is input into MALPAS via the [...] "IL Reader", which constructs a directed graph and associated semantics for the program under analysis. The graph is reduced using a series of graph reduction techniques.|$|R
40|$|Automated coding of {{surgical}} pathology reports is demonstrated. This public-domain translation software operates on surgical pathology files, extracting diagnoses and assigning codes {{in a controlled}} medical vocabulary, such as SNOMED. Context-sensitive translation algorithms are employed, and syntactically correct diagnostic items are produced that are matched with controlled vocabulary. English-language surgical pathology reports, accessioned over one year at the Baltimore Veterans Affairs Medical Center, were translated. With an interface to a larger hospital information system, all natural language pathology reports are automatically rendered as topography and morphology <b>codes.</b> This <b>translator</b> frees the pathologist from the time-intensive task of personally coding each report, and {{may be used to}} flag certain diagnostic categories that require specific quality assurance actions...|$|R
40|$|A {{mathematical}} model based on Tlusty&#x 27;s topological deconstruction suggests that multiple punctuated ecosystem shifts in available metabolic free energy, broadly {{akin to the}} &#x 27;aerobic&#x 27; transition, enabled a punctuated sequence of increasingly complex genetic <b>codes</b> and protein <b>translators</b> under mechanisms similar to the Serial Endosymbiosis effecting the Eukaryotic transition. These evolved until the ancestor to the present narrow spectrum of nearly maximally robust codes became locked-in by path dependence...|$|R
40|$|This {{specification}} identifies {{and describes}} the principal functions and {{elements of the}} Interpretive <b>Code</b> <b>Translator</b> which has been developed for use with the GOAL Compiler. This translator enables the user to convert a compliled GOAL program to a highly general binary format {{which is designed to}} enable interpretive execution. The translator program provides user controls which are designed to enable the selection of various output types and formats. These controls provide a means for accommodating many of the implementation options which are discussed in the Interpretive Code Guideline document. The technical design approach is given. The relationship between the translator and the GOAL compiler is explained and the principal functions performed by the Translator are described. Specific constraints regarding the use of the Translator are discussed. The control options are described. These options enable the user to select outputs to be generated by the translator and to control vrious aspects of the translation processing...|$|E
40|$|The IEC 61508 {{standard}} {{recognizes the}} programming languages defined in IEC 61131 - 3 as being appropriate for safety-related applications, and suggests {{the use of}} static analysis techniques to find errors in the source code. In this context, we have added a semantic verification stage to the MatIEC compiler- an open source ST, IL and SFC <b>code</b> <b>translator</b> to ANSI C. In so doing, we have identified several {{issues related to the}} definition of the semantics of the IL and ST programming languages, {{as well as with the}} data type model defined in IEC 61131 - 3. Most of the issues are related to undefined semantics, which may result in applications generating distinct results, depending on the platform on which they are executed. In this paper we describe some of the issues we uncovered, explain the options we took, and suggest how the IEC 61131 - 3 standard could be made more explicit. 1...|$|E
40|$|The Java {{bytecode}} {{language is}} emerging as a software distribution standard. With major vendors committed to porting the Java run-time environment to their platforms, Java bytecode programs are expected to run without modi cation on multiple platforms. These rst generation run-time environments rely on an interpreter {{to bridge the gap}} between the bytecode instructions and the native hardware. However, Java interpreters cause performance problems with microarchitectural features such as the caches and the Branch Target Bu er. Some of these problems can be solved bytranslating Java bytecode to native code. In this paper we compare the performance ofcode run through the SUN Java interpreter to code compiled through Ca eine, a bytecode to native <b>code</b> <b>translator,</b> as well as to compiled C/C++ versions of the code, using large applications and common benchmarks. We discuss the reasons for several performance problems incurred by both approaches to running Java code, and examine possible solutions. 1...|$|E
40|$|The Comparative Law Bureau of the American Bar Association {{has again}} attested its public service by the {{publication}} of an English translation of the Argentine Civil <b>Code.</b> The <b>translator,</b> the late Frank L. Joannini, had already rendered important service by the translation for the United States Bureau of Insular Affairs {{of several of the}} codes of our insular possessions. The translation before us evidences the valuable supervision of the committee of revision, Messrs. Eder, Kerr and Wheless. No one who has had experience in rendering into English the legal concepts embraced in the system of a civil-law country can fail to appreciate the difficulty of the translator 2 ̆ 7 s task, or be unduly captious in the criticism of terminology...|$|R
50|$|RSRE {{needed a}} newer {{compiler}} for various internal projects so {{the team of}} Currie and Morrison wrote a new compiler designed for machine independence. The compiler itself dealt with the parsing of ALGOL 68, producing a high level intermediate language known as stream language that would then be compiled to machine <b>code</b> by a <b>translator.</b> The compiler only needed to know the sizes of the various object machine types and the character set available.|$|R
5000|$|The trail {{leads to}} Kaliningrad, a Cold War [...] "secret city" [...] and {{home of the}} Baltic Fleet, {{separated}} by {{hundreds of miles from}} the rest of Russia. Arkady delves into Tatiana’s past and a surreal world of wandering dunes and amber mines. His only link is a notebook written in the personal <b>code</b> of a <b>translator</b> whose body is found in the dunes. Arkady’s only hope of decoding the symbols lies in Zhenya, a gifted teenage chess hustler.|$|R
