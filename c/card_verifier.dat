5|8|Public
50|$|Punch card verifierÂ In 1910, Powers {{introduced}} the first <b>card</b> <b>verifier,</b> {{which was used}} to check the correctness of punching.|$|E
50|$|Powers {{managed to}} invent his own system which bore no {{resemblance}} to Hollerith's one. The system included the whole set of machines, necessary for tabulating, namely, the electric card punch, <b>card</b> <b>verifier,</b> sorting machine, and printing tabulator.|$|E
5000|$|... #Caption: Two women {{entering}} data onto {{punched cards}} at Texas A&M in the 1950s. The {{woman at the}} right is seated at an IBM 026 keypunch machine. The woman at left is at an IBM 056 <b>Card</b> <b>Verifier.</b> She would re-enter the data and the '056 verifier machine would check that it matched the data punched onto the cards.|$|E
50|$|The IBM 056 and 059 <b>Card</b> <b>Verifiers</b> were {{companion}} {{machines to}} the IBM 026 and 029 keypunches, respectively. The later IBM 129 keypunch also could {{operate as a}} verifier. In that mode, it read a completed card (record) and loaded the 80 keystrokes into a buffer. A data entry operator reentered the record and the keypunch compared the new keystrokes with those loaded into the buffer. If a discrepancy occurred the operator was {{given a chance to}} reenter that keystroke and ultimately overwrite the entry in the buffer. If all keystrokes matched the original card, it was passed through and received a verification punch. If corrections were required, then the operator was prompted to discard the original card and insert a fresh card on which corrected keystrokes were typed. The corrected record (card) was passed through and received a corrected verification punch.|$|R
50|$|The IBM 056 was the {{verifier}} {{companion to}} the 024 Card Punch and 026 Printing <b>Card</b> Punch. The <b>verifier</b> {{was similar to}} the 026 keypunch except for a red error lens in the machine cover lower center. The verifier operator entered exactly the same data as the keypunch operator and the verifier machine then checked to see if the punched data matched. Successfully verified cards had a small notch punched on the right hand edge.|$|R
40|$|International audienceRobustness testing aims {{at finding}} errors {{in a system}} under invalid conditions, such as {{unexpected}} inputs. We propose a robust-ness testing approach for Event-B based on specification mutation and model-based testing. We assume that a specification describes the valid inputs of a system. By applying negation rules, we mutate the precondition of events to explore invalid behaviour. Tests are generated from the mutated specification using ProB. ProB has been adapted to efficiently process mutated events. Mutated events are statically checked for satisfiability and enability using constraint satisfaction, to prune the transition search space. This has dramatically improve the performance of test generation. The approach {{is applied to the}} Java <b>Card</b> bytecode <b>verifier.</b> Large mutated specifications (containing 921 mutated events) can be easily tackled to ensure a good coverage of the robustness test space...|$|R
5000|$|... #Caption: Two women {{discussing}} their work while entering data onto punched cards at Texas A&M in the 1950s. The {{woman at the}} right is seated at an IBM 026 keypunch machine. The woman at left is at an IBM 056 <b>Card</b> <b>Verifier.</b> Her job would be to re-enter the data and the verifier machine would check that it matched the data punched onto the cards.|$|E
5000|$|The IBM <b>Card</b> <b>Verifier</b> was {{the first}} {{commercial}} device to use infrared LEDs. The LEDs replaced tungsten bulbs that controlled punched card readers. Infrared light was sent through the holes or blocked by the card, which not only significantly reduced the size and power required, but also improved the reliability. In November 1978, Tom M. Hyltin, a former engineering manager at Texas Instruments, published a book titled [...] "The Digital Electronic Watch", in which he cited Dr. Biard and Gary Pittman's 1961 discovery as being fundamentally important {{to the creation of}} the digital wrist-watch.|$|E
5000|$|The goal of {{the system}} is to ease and quicken the process of {{purchasing}} ticket, create better information about actual travel and reduce non-paying passengers. The system utilises RFID technology on smart cards and allows an electronic payment to be made via contactless communication between the <b>card</b> and a <b>verifier.</b> There is also devoped a system of one-time tickets called Impuls. There {{have been a lot of}} delays concerning the implementation of the system, that originally was to be taken into use in 2005.|$|R
40|$|Abstract. Bytecode {{verification}} {{is one of}} the key security {{functions of}} several architectures for mobile and embedded code, including Java, Java Card, and. NET. Over the last few years, its formal correctness has been studied extensively by academia and industry, using general purpose theorem provers. The objective of our work is to facilitate such endeavors by providing a dedicated environment for establishing the correctness of bytecode verification within a proof assistant. The environment, called Jakarta, exploits a methodology that casts the correctness of bytecode verification relatively to a defensive virtual machine that performs checks at run-time, and an offensive one that does not, and can be summarized as stating that the two machines coincide on programs that pass bytecode verification. Such a methodology has been used successfully to prove the correctness of the Java <b>Card</b> bytecode <b>verifier,</b> and may potentially be applied to many other similar problems. One definite advantage of the methodology is that it is amenable to automation. Indeed, Jakarta automates the construction of an offensive virtual machine and a bytecode verifier from a defensive machine, and the proofs of correctness of the bytecode verifier. We illustrate the principles of Jakarta on a simple low-level language extended with subroutines, and discuss its usefulness to proving the correctness of the Java Card platform...|$|R
40|$|Bytecode {{verification}} {{is one of}} the key security {{functions of}} several architectures for mobile and embedded code, including Java, Java Card, and. NET. Over the last few years, its formal correctness has been studied extensively by academia and industry, using general purpose theorem provers. The objective of our work is to facilitate such endeavors by providing a dedicated environment for establishing the correctness of bytecode verification within a proof assistant. The environment, called Jakarta, exploits a methodology that casts the correctness of bytecode ver-ification relatively to a defensive virtual machine that performs checks at run-time, and an offensive one that does not, and can be summarized as stating that the two machines coincide on programs that pass bytecode verification. Such a methodology has been used successfully to prove the correctness of the Java <b>Card</b> bytecode <b>verifier,</b> and may potentially be applied to many other similar problems. One definite advantage of the methodology is that it is amenable to automation. Indeed, Jakarta automates the construction of an offensive virtual machine and a bytecode verifier from a defensive machine, and the proofs of correctness of the bytecode verifier. We illustrate the principles of Jakarta on a simple low-level language extended with subroutines, an...|$|R
40|$|The Java {{security}} policy is implemented by security components {{such as the}} Java Virtual Machine (JVM), the API, the verifier, the loader. It is of prime importance {{to ensure that the}} implementation of these components is in accordance with their specifications. Formal methods can be used to bring the mathematical proof that the implementation of these components corresponds to their specification. In this paper, a formal development is performed on the Java <b>Card</b> byte code <b>verifier</b> using the B method. The whole Java Card language is taken into account in order to provide realistic metrics on formal development. The architecture and the tricky points of the development are presented. This formalization leads to an embeddable implementation of the byte code verifier thanks to automatic code translation from formal implementation into C code. We present the formal models, discuss the integration into the card and the results of such an experiment...|$|R
40|$|Attribute-based {{credentials}} (ABCs) {{are building}} blocks for user-centric identity management. They enable the disclo-sure of a minimum amount of information about their owner to a verifier, typically a service provider, to authorise the credential owner for some service, application, or resource. By directly applying attribute-disclosure protocols, the data is revealed {{not only to the}} verifier, but anyone who has access to the communication channel. Moreover, as ver-ifiers are not intrinsically authenticated, one can accidentally reveal attributes to the wrong party. Therefore, a secure channel has to be established between the prover and the verifier. Although efficient ABC smart-card implementations exist, not always can they perform all prover features. An equality proof, for instance, is essential in creating pseudonyms that enable temporary identification and eventually establishing a channel. Without this feature, other techniques have to be developed. In this paper we apply a more general notion of authentication that does not require card identification or pseudonyms. Based on this concept, we propose a secu-rity model that includes mutual authentication and setting up a channel between a <b>card</b> and a <b>verifier.</b> We present two efficient and provably secure protocols under standard assumptions in the random oracle model...|$|R

