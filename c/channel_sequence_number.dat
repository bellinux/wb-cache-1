0|7153|Public
30|$|In {{the first}} relay selection, under the premise for meeting both energy {{constraint}} and delay constraint, a receiving UE i will select a relaying UE j with the maximum value for ΔTji (see lines 5 ~ 12), {{and also the}} allocated WiFi <b>channel’s</b> <b>sequence</b> <b>number</b> in the WiFi link from UE j to UE i is stored in cji, where cji is set as 0 when no WiFi channel is allocated to this WiFi link.|$|R
3000|$|... is the {{allocated}} WiFi <b>channel’s</b> <b>sequence</b> <b>number</b> of the WiFi link from UE j to UE i, but {{the value}} that equals 0 means that WiFi channel has not been allocated to this WiFi link. If scene (c) in Fig. 1 is replaced with scene (b) in Fig. 1, one constraint (i.e., UEs that both have not requested for data transmitting service and have not acted as a relay could be preselected as relays) should be added to line 10.|$|R
40|$|This paper {{presents}} a technique for accessing <b>channel</b> based on <b>sequencing</b> technique for 802. 11 wireless net-works. The {{objective of this}} method is to reduce, {{as well as to}} avoid the number of collisions while accessing channel by many nodes at the same time. A concept of <b>sequence</b> <b>number</b> is introduced to avoid collisions. The transmission of a node takes place after checking the <b>sequence</b> <b>number.</b> MAC layer issues are very important while accessing channel over wireless networks. Simula-tion results show that the performance of sequence MAC is improved significantly when compared with legacy MAC...|$|R
30|$|We {{will start}} by {{identifying}} the <b>channel</b> <b>sequences</b> arriving at the (turbo) decoder.|$|R
40|$|A {{class of}} {{proteins}} that mimic the fundamental pore structure of authentic ionic channels has been designed, synthesized, and characterized. The design {{is based on}} our earlier result that a 23 -mer peptide with the sequence of the M 2 segment of the Torpedo californica acetylcholine receptor delta subunit [...] Glu-Lys-Met-Ser-Thr-Ala-Ile-Ser-Val-Leu-Leu-Ala-Gln-Ala-Val-Phe -Leu- Leu-Leu-Thr-Ser-Gln-Arg [...] forms cation-selective channels in lipid bilayers, presumably by self-assembly of conductive oligomers. Accordingly, a tethered parallel tetramer was synthesized with four M 2 delta peptides attached to a carrier template [...] a 9 -amino acid backbone with four attachment sites. As expected, the complete 101 -residue protein does form channels in lipid bilayers reproducing several features that are characteristic of authentic acetylcholine receptor channels, such as single-channel conductance, cation selectivity, transitions between closed and open states in the millisecond time range, and sensitivity to local anesthetic channel blockers. An analogue protein, in which the serine residue in position 8 is replaced with alanine {{in each of the}} four M 2 delta 23 -mer peptides ([Ala 8]M 2 delta), also forms channels that, however, exhibit lower single-channel conductance. By contrast, a similar tethered tetramer with M 1 delta peptides does not form channels, in accord with expectations. The general validity of this strategy to other <b>channel</b> <b>sequences</b> and oligomer <b>numbers</b> is anticipated. Thus, synporins [...] a term coined to identify this class of synthetic pore proteins [...] enrich our armamentarium directed toward the elucidation of structure-function relationships...|$|R
5000|$|<b>Sequence</b> <b>Number</b> (32 bits) : A {{monotonic}} strictly increasing <b>sequence</b> <b>number</b> (incremented by 1 {{for every}} packet sent) to prevent replay attacks. When replay detection is enabled, <b>sequence</b> <b>numbers</b> are never reused, because a new security association must be renegotiated before {{an attempt to}} increment the <b>sequence</b> <b>number</b> beyond its maximum value.|$|R
50|$|To {{avoid these}} problems, {{the most common}} {{solution}} is to define a 1 bit <b>sequence</b> <b>number</b> in the header of the frame. This <b>sequence</b> <b>number</b> alternates (from 0 to 1) in subsequent frames. When the receiver sends an ACK, it includes the <b>sequence</b> <b>number</b> of the next packet it expects. This way, the receiver can detect duplicated frames by checking if the frame <b>sequence</b> <b>numbers</b> alternate. If two subsequent frames have the same <b>sequence</b> <b>number,</b> they are duplicates, and the second frame is discarded. Similarly, if two subsequent ACKs reference the same <b>sequence</b> <b>number,</b> they are acknowledging the same frame.|$|R
5000|$|The {{received}} <b>sequence</b> <b>number</b> is {{the last}} <b>sequence</b> <b>number</b> received by this sender.|$|R
5000|$|S: <b>Sequence</b> <b>number</b> bit. Set to 1 if a <b>sequence</b> <b>number</b> is present.|$|R
50|$|If the SYN flag is set (1), {{then this}} is the initial <b>sequence</b> <b>number.</b> The <b>sequence</b> <b>number</b> of the actual first data byte and the {{acknowledged}} number in the corresponding ACK are then this <b>sequence</b> <b>number</b> plus 1.|$|R
5000|$|<b>Sequence</b> <b>number</b> flag(S): a 1-bit {{value that}} states {{whether there is}} a <b>Sequence</b> <b>Number</b> {{optional}} field.|$|R
30|$|Initially, each server s sends signed <b>sequence</b> <b>numbers</b> 1 through K to each client c, {{and sets}} the next <b>sequence</b> <b>number</b> to emit, N_s^c, to K+ 1. Whenever s accepts to certify a new transaction, s {{increments}} N_s^c and sends N_s^c signed to c. Server s only accepts to certify transactions whose <b>sequence</b> <b>numbers</b> belong to set V_s^c. Initially, this set contains <b>sequence</b> <b>numbers</b> 1 to K. Each time s accepts to certify a transaction with <b>sequence</b> <b>number</b> seq, seq is removed from V_s^c and N_s^c {{is added to the}} set after being incremented.|$|R
5000|$|... #Caption: TCP <b>sequence</b> <b>numbers</b> {{and receive}} windows behave {{very much like}} a clock. The receive window shifts each time the {{receiver}} receives and acknowledges a new segment of data. Once it runs out of <b>sequence</b> <b>numbers,</b> the <b>sequence</b> <b>number</b> loops back to 0.|$|R
50|$|When A sends a message, it resends it continuously, {{with the}} same <b>sequence</b> <b>number,</b> until it {{receives}} an acknowledgment from B that contains the same <b>sequence</b> <b>number.</b> When that happens, A complements (flips) the <b>sequence</b> <b>number</b> and starts transmitting the next message.|$|R
5000|$|Transmission <b>sequence</b> <b>number</b> (TSN) : The <b>sequence</b> <b>number</b> for {{the entire}} DATA stream (used in {{fragmentation}} for reassembly).|$|R
25|$|Numbering {{subsequent}} Application {{records with}} a <b>sequence</b> <b>number</b> and using this <b>sequence</b> <b>number</b> {{in the message}} authentication codes (MACs).|$|R
50|$|Lollipop <b>sequence</b> <b>number</b> {{spaces are}} {{a more recent}} and {{sophisticated}} scheme for dealing with finite-sized <b>sequence</b> <b>numbers</b> in protocols.|$|R
5000|$|S: <b>Sequence</b> <b>number</b> bit. Set to 1 if a <b>sequence</b> <b>number</b> is supplied, {{indicating}} a PPTP GRE data packet.|$|R
5000|$|Numbering {{subsequent}} Application {{records with}} a <b>sequence</b> <b>number</b> and using this <b>sequence</b> <b>number</b> {{in the message}} authentication codes (MACs).|$|R
3000|$|... 1) Using the {{pseudorandom}} <b>sequence</b> <b>number</b> X of {{the confusion}} process as the final set X of pseudorandom <b>sequence</b> <b>numbers.</b>|$|R
50|$|Here {{are some}} {{examples}} (in 16 bits, again), comparing some random <b>sequence</b> <b>numbers,</b> against the <b>sequence</b> <b>number</b> with the value 0.|$|R
50|$|A {{means of}} {{comparing}} two <b>sequence</b> <b>numbers</b> i1 and i2 (the unsigned integer representations of <b>sequence</b> <b>numbers</b> s1 and s2) is presented.|$|R
30|$|A <b>sequence</b> <b>number</b> and a loop flag are {{included}} in the data packet header and are used to detect routing loops. When a node receives a downstream data packet, the node records the <b>sequence</b> <b>number</b> of the data. When a node receives data with the same <b>sequence</b> <b>number,</b> the node judges that a loop has occurred and sets the loop flag to one. Each node records nhist <b>sequence</b> <b>numbers</b> of received packets from the newest received one.|$|R
5000|$|It {{is easy to}} {{see that}} the signed {{interpretation}} of the <b>sequence</b> <b>numbers</b> are in the correct order, so long as we [...] "rotate" [...] the <b>sequence</b> <b>number</b> in question so that its 0 matches up with the <b>sequence</b> <b>number</b> we are comparing it against. It turns out that this is simply done, using an unsigned subtraction, and simply interpreting the result as a signed two's complement number. The result is the signed [...] "distance" [...] between the two <b>sequence</b> <b>numbers.</b> Once again, if i1 and i2 are the unsigned binary representations of the <b>sequence</b> <b>numbers</b> s1 and s2, the distance from s1 to s2 is: ...|$|R
30|$|In [19], {{efficient}} spectrum hole discovery with MAC layer sensing {{is proposed}} wherein {{the delay in}} finding the idle channels is minimized by optimizing the sensing period. Also, more idle channels in the PU band are discovered by <b>channel</b> <b>sequencing</b> algorithm taking into consideration the ON/OFF channel usage patterns. Comparative analysis with and without optimized sensing period is performed for different performance scenarios. Performance analysis with and without optimal <b>channel</b> <b>sequencing</b> is also performed for different scenarios. However, the comparative analysis with any other scheme is not given.|$|R
5000|$|So, if {{we simply}} re-cast <b>sequence</b> <b>numbers</b> as 2's {{complement}} integers, and allow {{there to be}} one more <b>sequence</b> <b>number</b> considered [...] "less than" [...] than there are <b>sequence</b> <b>numbers</b> considered [...] "greater than", {{we should be able}} to use simple signed arithmetic comparisons instead of the logically incomplete formula proposed by the RFC.|$|R
5000|$|Many {{communication}} protocols apply serial number arithmetic to packet <b>sequence</b> <b>numbers</b> in their {{implementation of a}} sliding window protocol. Some versions of TCP use [...] protection against wrapped <b>sequence</b> <b>numbers</b> (PAWS). PAWS applies the same serial number arithmetic to packet timestamps, using the timestamp {{as an extension of}} the high-order bits of the <b>sequence</b> <b>number.</b>|$|R
50|$|The {{protocol}} may be initialized {{by sending}} bogus messages and acks with <b>sequence</b> <b>number</b> 1. The first message with <b>sequence</b> <b>number</b> 0 {{is a real}} message.|$|R
50|$|We create log {{records of}} the form (<b>Sequence</b> <b>Number,</b> Transaction ID, Page ID, Redo, Undo, Previous <b>Sequence</b> <b>Number).</b> The Redo and Undo fields keep {{information}} about the changes this log record saves and how to undo them. The Previous <b>Sequence</b> <b>Number</b> is {{a reference to the}} previous log record that was created for this transaction. In the case of an aborted transaction, it's possible to traverse the log file in reverse order using the Previous <b>Sequence</b> <b>Numbers,</b> undoing all actions taken within the specific transaction.|$|R
50|$|It is a ten-digit {{number with}} the format DDMMYY-SSSS, where DDMMYY is {{the date of}} birth and SSSS is a <b>sequence</b> <b>number.</b> The first digit of the <b>sequence</b> <b>number</b> encodes the century of birth (so that centenarians are {{distinguished}} from infants), and the last digit of the <b>sequence</b> <b>number</b> is odd for males and even for females.|$|R
50|$|It is a reader-writer {{consistent}} mechanism which {{avoids the}} problem of writer starvation. A seqlock consists of storage for saving a <b>sequence</b> <b>number</b> {{in addition to a}} lock. The lock is to support synchronization between two writers and the counter is for indicating consistency in readers. In addition to updating the shared data, the writer increments the <b>sequence</b> <b>number,</b> both after acquiring the lock and before releasing the lock. Readers read the <b>sequence</b> <b>number</b> before and after reading the shared data. If the <b>sequence</b> <b>number</b> is odd on either occasion, a writer had taken the lock while the data was being read and it may have changed. If the <b>sequence</b> <b>numbers</b> are different, a writer has changed the data while it was being read. In either case readers simply retry (using a loop) until they read the same even <b>sequence</b> <b>number</b> before and after.|$|R
5000|$|Stream <b>sequence</b> <b>number</b> : Identifier of the <b>sequence</b> <b>number</b> for {{the message}} in this stream. If a message is {{fragmented}} then this value is maintained for all fragments.|$|R
30|$|Calculate all the {{elements}} of the pseudorandom <b>sequence</b> <b>number</b> in (xi[*]×[*] 256)[*]mod[*] 256, and then convert the calculated result into binary, thereby obtaining a binary M[*]×[*]N long <b>sequence</b> <b>number.</b>|$|R
50|$|Lollipop <b>sequence</b> <b>numbering</b> was {{originally}} believed {{to resolve the}} ambiguity problem in cyclic <b>sequence</b> <b>numbering</b> schemes, and was used in OSPF version 1 for this reason. Later work showed {{that this was not}} the case, and OSPF version 2 replaced it with a linear numbering space, with special rules for what happens when the <b>sequence</b> <b>numbers</b> reach the end of the numbering space.|$|R
5000|$|All <b>sequence</b> <b>number</b> {{arithmetic}} {{must deal}} with [...] "wrapping" [...] of <b>sequence</b> numbers; the <b>number</b> 2N−1 is equidistant in both directions, in [...] <b>sequence</b> <b>number</b> terms. In our math, they are both considered to be [...] "less than" [...] each other: ...|$|R
5000|$|Cumulative TSN ACK : Acknowledges all <b>sequence</b> <b>numbers</b> {{received}} in <b>sequence</b> {{so is the}} <b>sequence</b> <b>number</b> of the last received byte. The immediate value after this one has not been received yet.|$|R
