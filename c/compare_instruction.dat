11|333|Public
5000|$|<b>Compare</b> <b>instruction</b> (equivalent to a {{subtract}} instruction without storing the result); ...|$|E
50|$|Except for branch, {{conditional}} move, {{and multiply}} instructions, all other instructions begin and finish execution during stage five for a one cycle latency. Branch and conditional move instructions are executed during stage six {{so they can}} be issued with a <b>compare</b> <b>instruction</b> whose result they depend on.|$|E
50|$|Along with a carry flag, a sign {{flag and}} an {{overflow}} flag, the zero flag {{is used to}} check {{the result of an}} arithmetic operation, including bitwise logical instructions. It is set if an arithmetic result is zero, and reset otherwise. This includes results which are not stored, as most traditional instruction sets implement the <b>compare</b> <b>instruction</b> as a subtract where the result is discarded. It is also common that processors have a bitwise AND-instruction that does not store the result.|$|E
5000|$|... <b>compare</b> <b>instructions</b> (equivalent to {{subtract}} instructions without storing the result); ...|$|R
25|$|The <b>compare</b> <b>instructions</b> <b>compare</b> two {{registers}} or {{a register}} and a literal and write '1' to the destination register if the specified condition is true or '0' if not. The conditions are equality, inequality, {{less than or}} equal to, and less than. With the exception of the instructions that specify the former two conditions, there are versions that perform signed and unsigned compares.|$|R
50|$|Many more {{instructions}} are available as {{the behavior of}} the standard instructions can be modified by setting or clearing status bits: WC (with or without carry) and COM (logical or arithmetic compare). This doubled the number of rotate, add, subtract and <b>compare</b> <b>instructions.</b>|$|R
5000|$|Alternative code {{might involve}} testing a [...] "flag" [...] each time through. The {{unconditional}} branch is slightly {{faster than a}} <b>compare</b> <b>instruction,</b> as well as reducing the overall path length. In later operating systems for programs residing in protected storage this technique {{could not be used}} and so changing the pointer to the subroutine would be used instead. The pointer would reside in dynamic storage and could be altered at will after the first pass to bypass the OPEN (having to load a pointer first instead of a direct branch & link to the subroutine would add N instructions to the path length - but there would be a corresponding reduction of N for the unconditional branch that would no longer be required).|$|E
30|$|Puschner and Burns discuss for a single-path {{programming}} style [13] {{that results}} in a constant execution time. In that case, WCET can easily be measured. However, this programming paradigm is quite uncommon and restrictive. Single-path programming can be inefficient when the control flow is data-dependent. A processor, called SPEAR [14], was especially designed to evaluate the single-path programming paradigm. A single predicate bit can be set with a <b>compare</b> <b>instruction</b> whereby several instructions (e.g., move, arithmetic operations) can be predicated. The SPEAR implements a three-stage in-order pipeline and uses onchip memories for instruction and data instead of caches.|$|E
40|$|AbstractThe {{accurate}} {{measurement of}} the execution time of Java bytecode is one factor that is important in order to estimate the total execution time of a Java application running on a Java Virtual Machine. In this paper we document the difficulties and solutions for the accurate timing of Java bytecode. We also identify trends across the execution times recorded for all imperative Java bytecodes. These trends would suggest that knowing the execution times of a small subset of the Java bytecode instructions would be sufficient to model the execution times of the remainder. We first review a statistical approach for achieving high precision timing results for Java bytecode using low precision timers and then present a more suitable technique using homogeneous bytecode sequences for recording such information. We finally <b>compare</b> <b>instruction</b> execution times acquired using this platform independent technique against execution times recorded using the read time stamp counter assembly instruction. In particular our results show {{the existence of a}} strong linear correlation between both techniques...|$|E
2500|$|In {{interpreted}} programming languages, for-loops can {{be implemented}} in many ways. Oftentimes, the for-loops are directly translated to assembly-like <b>compare</b> <b>instructions</b> and conditional jump instructions. However, {{this is not always}} so. In some interpreted programming languages, for-loops are simply translated to while-loops. For instance, take the following Mint/Horchata code: ...|$|R
50|$|The {{overflow}} flag {{is typically}} changed by all arithmetic operations, including <b>compare</b> <b>instructions</b> (equivalent to a subtract instruction without storing the result). In many processor architectures, the overflow flag is cleared by bitwise operations (and, or, xor, not), possibly including shifts and rotates, {{but it may}} also be left undefined by these. Instructions such as multiply and divide often leave the flag undefined, or affected by the last partial result.|$|R
50|$|AVX-512F {{has four}} new <b>compare</b> <b>instructions.</b> Like their XOP {{counterparts}} {{they use the}} immediate field to select between 8 different comparisons. Unlike their XOP inspiration, however, they save the result to a mask register and initially only support doubleword and quadword comparisons. The AVX-512BW extension provides the byte and word versions. Note that two mask registers may be specified for the instructions, one to write to and one to declare regular masking.|$|R
40|$|The {{accurate}} {{measurement of}} the execution time of Java bytecode is one factor that is important in order to estimate the total execution time of a Java application running on a Java Virtual Machine. In this paper we document the difficulties and solutions for the accurate timing of Java bytecode. We also identify trends across the execution times recorded for all imperative Java bytecodes. These trends would suggest that knowing the execution times of a small subset of the Java bytecode instructions would be sufficient to model the execution times of the remainder. We first review a statistical approach for achieving high precision timing results for Java bytecode using low precision timers and then present a more suitable technique using homogeneous bytecode sequences for recording such information. We finally <b>compare</b> <b>instruction</b> execution times acquired using this platform independent technique against execution times recorded using the read time stamp counter assembly instruction. In particular our results show {{the existence of a}} strong linear correlation between both techniques. Keywords: Java Virtual Machine, Bytecode Timing, Bytecode Sequences, RDTSC. ...|$|E
40|$|Whenever {{an array}} element is accessed, Java virtual {{machines}} execute a <b>compare</b> <b>instruction</b> {{to ensure that}} the index value is within the valid bounds. This reduces the execution speed of Java programs. Array bounds check elimination identifies situations in which such checks are redundant and can be removed. We present an array bounds check elimination algorithm for the Java HotSpot TM VM based on static analysis in the just-in-time compiler. The algorithm works on an intermediate representation in static single assignment form and maintains conditions for index expressions. It fully removes bounds checks if it can be proven that they never fail. Whenever possible, it moves bounds checks out of loops. The static number of checks remains the same, but a check inside a loop is likely to be executed more often. If such a check fails, the executing program falls back to interpreted mode, avoiding the problem that an exception is thrown at the wrong place. The evaluation shows a speedup near to the theoretical maximum for the scientific SciMark benchmark suite (40 % on average). The algorithm also improves the execution speed for the SPECjvm 98 benchmark suite (2 % on average, 12 % maximum) ...|$|E
40|$|AbstractWhenever {{an array}} element is accessed, Java virtual {{machines}} execute a <b>compare</b> <b>instruction</b> {{to ensure that}} the index value is within the valid bounds. This reduces the execution speed of Java programs. Array bounds check elimination identifies situations in which such checks are redundant and can be removed. We present an array bounds check elimination algorithm for the Java HotSpot™ VM based on static analysis in the just-in-time compiler. The algorithm works on an intermediate representation in static single assignment form and maintains conditions for index expressions. It fully removes bounds checks if it can be proven that they never fail. Whenever possible, it moves bounds checks out of loops. The static number of checks remains the same, but a check inside a loop is likely to be executed more often. If such a check fails, the executing program falls back to interpreted mode, avoiding the problem that an exception is thrown at the wrong place. The evaluation shows a speedup near to the theoretical maximum for the scientific SciMark benchmark suite and also significant improvements for some Java Grande benchmarks. The algorithm slightly increases the execution speed for the SPECjvm 98 benchmark suite. The evaluation of the DaCapo benchmarks shows that array bounds checks do not {{have a significant impact on}} the performance of object-oriented applications...|$|E
50|$|This set of vector <b>compare</b> <b>instructions</b> {{all take}} an {{immediate}} {{as an extra}} argument. The immediate controls what kind of comparison is performed. There are eight comparison possible for each instruction. The vectors are compared and all comparisons that evaluate to true set all corresponding bits in the destination to 1, and false comparisons sets all the same bits to 0. This result can be used directly in VPCMOV instruction for a vectorized conditional move.|$|R
5000|$|VME Virtual 8086 Mode Enhancement DE Debugging Extensions PSE Page Size Extensions TSC Time Stamp Counter MSR RDMSR and WRMSR Support PAE Physical Address Extensions MCE Machine Check Exception CXS CMPXCHG8B Instruction (also see Double compare-and-swap and Transactional Synchronization Extensions) APIC APIC on Chip (also see APIC) MTRR Memory Type Range Register PGE PTE Global Bit (also see Page table) MCA Machine Check Architecture CMOV Conditional Move and <b>Compare</b> <b>Instructions</b> (also see FCMOV) ...|$|R
40|$|This study {{examines}} Chinese doctoral students’ perceptions regarding their U. S. universityinstructors’ academic and interactive behaviors. The author interviewed ten Chinese doctoralstudents from two {{universities in the}} Midwest. Participants discussed their instructors’academic behaviors, including pedagogical knowledge, instruction, and engagement, andtheir interactive behaviors, including openness, availability, and respect for students. Participants <b>compared</b> <b>instruction</b> and teaching between U. S. universities and universities inChina. In general, all ten participants were quite satisfied with instructors in U. S. universities. This study addresses implications for research, Chinese students and their U. S. instructors,and university administrators. </p...|$|R
40|$|If-conversion is a {{compiler}} {{technique that}} reduces the misprediction penalties caused by hard-to-predict branches, transforming control dependencies into data dependencies. Although it is globally beneficial, it has a negative side-effect because the removal of branches eliminates useful correlation information necessary for conventional branch predictors. The remaining branches may become harder to predict. However, in predicated ISAs with a compare-branch model, the correlation information not only resides in branches, but also in compare instructions that compute their guarding predicates. When a branch is removed, its correlation information is still available in its <b>compare</b> <b>instruction.</b> We propose a branch prediction scheme based on predicate prediction. It has three advantages: First, since the prediction is not done on a branch basis but on a predicate define basis, branch removal after if-conversion does not lose any correlation information, so accuracy is not degraded. Second, the mechanism we propose permits using the computed value of the branch predicate when available, instead of the predicted value, thus effectively achieving 100 % accuracy on such early-resolved branches. Third, as shown in previous work, the selective predicate prediction is a very effective technique to implement if-conversion on outof-order processors, since it avoids the problem of multiple register definitions and reduces the unnecessary resource consumption of nullified instructions. Hence, our approach enables a very efficient implementation of if-conversion for an out-of-order processor, with almost no additional hard- 1 - 4244 - 0805 - 9 / 07 /$ 25. 00 © 2007 IEE...|$|E
40|$|The {{study was}} {{designed}} to <b>compare</b> <b>instruction</b> related leader behaviors of elementary principals with unit leaders as perceived by teachers in selected Individually Guided Education/Multiunit schools. The study population included 57 teachers from six IGE/MUS-E member schools of the Area Movement for Educationally New Dimension (AMEND) Network Project, School of Education, University of Wisconsin, LaCrosse. Data for the study were secured by means of two questionnaires, adapted from the Leader Behavior Description Questionnaire-Real Form. Participant responses provided teacher perceptions relative to two leader behaviors of Consideration and Initiating Structure of elementary principals and of unit leaders. Data were analyzed statistically. The hypotheses were tested using a 2 x 6 Univariate, two-way Analysis of Variance, fixed-effects procedure. Post-hoc multiple comparisons were made when suggested at the. 05 level of statistical significance by the analysis. The Newman-Keuls procedure and t tests were used in making post-hoc comparisons. Analyses of effects were made when significant interaction effects were present. A summary of findings was organized relative each of the four hypotheses. Hypothesis IThere will be no difference between teacher perceptions of the instruction related leader behavior of Consideration of elementary principals from unit leaders. Teachers perceived the instruction related leader behavior of elementary principals and unit leaders as significantly different regarding the leader behavior of Consideration. Hypothesis IIThere will be no difference between teacher perception of the instruction related leader behavior of Initiating Structure of elementary principals from unit leaders. Teachers perceived the instruction related leader behavior of elementary principals and unit leaders as significantly different regarding the leader behavior of Initiating Structure. Hypothesis IIIThere will be no difference between perceptions of teachers from each particular Individually Guided Education school relative to the instruction related leader behavior of Consideration of elementary principals from unit leaders. Teachers from particular schools perceived the instruction related leader behavior of elementary principals and unit leaders as being different regarding the leader behavior of Consideration. development programs, both pre-service and in-service, have not adequately emphasized the need of building personal leader behavior patterns which reflect commitment to, and belief in, the component aspects of Consideration. Professional staff development programs, both pre-service and in-service have not adequately emphasized the need for building personal leader behavior patterns which reflect commitment to, and belief in, component aspects of Initiating Structure. School officials, responsible for the selection of elementary principals and/or unit leaders to serve in Individually Guided Education schools, should be particularly careful to select individuals with demonstrated effective leader behavior relative to Consideration and Initiating Structure factors. Thesis (D. Ed. ...|$|E
5000|$|Because special {{registers}} {{are closely}} tied to some special function or status of the processor, {{they might not be}} directly writeable by normal instructions (such as adds, moves, etc.). Instead, some special registers in some processor architectures require special instructions to modify them. For example, the program counter is not directly writeable in many processor architectures. Instead, the programmer uses instructions such as return from subroutine, jump, or branch to modify the program counter. For another example, the condition code register might not directly writable, instead being updated only by <b>compare</b> <b>instructions.</b>|$|R
40|$|This study {{investigated}} the effectiveness of Baldi for teaching non-native phonetic contrasts, by <b>comparing</b> <b>instruction</b> illustrating the internal articulatory processes of the oral cavity versus instruction providing just the normal view of the tutor's face. Eleven Japanese speakers of English {{as a second language}} were bimodally trained under both instruction methods to identify and produce American English /r/ and /l/ in a within-subject design. Speech identification and production improved under both training methods although training {{with a view of the}} internal articulators did not show an additional benefit. A generalization test showed that this learning transferred to the production of new words...|$|R
2500|$|Complete set of vector-level <b>compare</b> and branch <b>instructions</b> with no {{condition}} flag ...|$|R
40|$|We {{investigated}} {{the effects of}} using immersive virtual humans to teach users social conversational verbal and non-verbal protocols in south Indian culture. The study was conducted using a between-subjects experimental design, and <b>compared</b> <b>instruction</b> and interactive feedback from immersive virtual humans against instruction based on a written study guide with illustrations of the social protocols. Participants were then tested on how well they learned the social conversational protocols by exercising the social conventions in front of videos of real people. The results of our study suggest that participants who trained with the virtual humans performed significantly better than the participants who studied from literature...|$|R
50|$|Zen {{supports}} AVX2 but {{it requires}} two clock cycles to complete AVX2 <b>instruction</b> <b>compared</b> to Intel's one.|$|R
40|$|In this paper, we {{describe}} an experimental research study, investigating {{the impact of}} varying communication media {{on the quality of}} learning. Our study investigates remote instruction using an object assembly task. The between-subjects independent-measures study <b>compared</b> <b>instruction</b> via audio only, with instruction via a remote gesturing system. Measures included assembly speed and assembly accuracy and were recorded during instruction and post-instruction at 10 min and 24 hr intervals. Perceived Instructor presence and other interpersonal variables were assessed via questionnaire. Results showed that remote gesturing during instruction led to significantly faster self-assembly 24 hrs post instruction (t (13) = 1. 73, p≤ 0. 05). Whilst the use of gesture reportedly reduces communicative rapport, we conclude that gesture-based remote instruction improves the overall efficiency of remote collaboration...|$|R
40|$|Two {{pieces of}} {{literature}} by Thomas A. Wills {{are contained in}} this document: (1) A complete programed text in law, "A Programmed Text in Criminal Law, " and (2) a study <b>comparing</b> <b>instruction</b> with versus instruction {{without the use of}} programed texts, "Development and Evaluation of a Programed Text in Criminal Law. " In the latter, six control and six experimental groups were used to test the hypothesis that students can acquire a basic working knowledge of the rules of law by independent, unsupervised study of a programed text. The results supported the hypothesis. It was concluded that the acquisition and application of complex abstract material can be taught efficiently with programed material. (HW) DOCUMENT RESUME 24 EA 001 45...|$|R
5000|$|The x86 {{instruction}} set includes string load, store, move, scan and <b>compare</b> <b>instructions</b> ( [...] , , , [...] and [...] ) which perform each operation to a specified size ( [...] for 8-bit byte, [...] for 16-bit word, [...] for 32-bit double word) then increments/decrements (depending on DF, direction flag) the implicit address register ( [...] for , [...] for [...] and , and both for [...] and [...] ). For the load, store and scan operations, the implicit target/source/comparison register {{is in the}} , [...] or [...] register (depending on size). The implicit segment registers used are [...] for [...] and [...] for [...] The [...] or [...] register {{is used as a}} decrementing counter, and the operation stops when the counter reaches zero or (for scans and comparisons) when inequality is detected.|$|R
40|$|This {{study is}} a {{comparison}} of the embedded instruction of behavioral chains with more traditional (one-on-one massed trials in special education set-ting) instructional procedures for teaching behavioral chains to students with significant cognitive disabilities. Although embedded instruction has emerged as a promising potential instructional procedure, no literature has examined the efficacy of embedded instructional procedures to teach more complex chained behaviors. To date, all research on embedding instruction at PENNSYLVANIA STATE UNIV on March 5, 2016 bmo. sagepub. comDownloaded from Jameson et al. 321 in general education settings has focused on teaching discrete skills. This study <b>compares</b> <b>instruction</b> of embedded total task chains with more tradi-tional (one-on-one massed trials in special education setting) instructional procedures for teaching behavioral chains. The chains targeted for instruc-tion were selected by state core educational needs and functional skil...|$|R
30|$|There are not {{too many}} works on {{accessibility}} in biometrics [21] {{and there is not}} a standard methodology yet. In this work, we <b>compare</b> <b>instructions</b> with audio feedback in real time following {{the state of the art}} in interfaces [31] accessibility and applying them to biometrics [2]. This work comprises an extensive analysis of the time influence in face recognition for visually impaired users both in performance and usability, obtaining several important outcomes regarding: the importance of the received feedback, the variability of the performance and the usable images rates along with the time spent in the process. This paper is divided as follows: in “Evaluation set up” the evaluation set up is provided. We explain the methodology and the experimentation in the “Methodology and experimentation”. The results are in “Results and discussion” and the conclusions and future work are in “Conclusions and future work”.|$|R
40|$|Calibrated Peer Review ™ (CPR), {{a web-based}} {{instructional}} tool developed {{as part of}} the National Science Foundation reform initiatives in undergraduate science education, allows instructors to incorporate multiple writing assignments in large courses without overwhelming the instructor. This study reports successful implementation of CPR in a large, introductory geology course and student learning of geoscience content. For each CPR assignment in this study, students studied web-based and paper resources, wrote an essay, and reviewed seven essays (three from the instructor, three from peers, and their own) on the topic. Although many students expressed negative attitudes and concerns, particularly about the peer review process of this innovative instructional approach, they also recognized the learning potential of completing CPR assignments. <b>Comparing</b> <b>instruction</b> on earthquakes and plate boundaries using a CPR assignment vs. an instructional video lecture and homework essay with extensive instructor feedback, students mastered more content via CPR instruction...|$|R
40|$|According to Ayala (2009), blended {{learning}} is “the purposeful integration of traditional (i. e., face-to-face) and online learning {{in order to}} provide educational opportunities that maximize the benefits of each platform and thus more effectively facilitate student learning. The {{purpose of this study was}} to explore students’ perceptions of taking courses that utilized a blended instruction approach. Study participants consisted of 36 undergraduate students enrolled in teacher education programs. There were 18 seniors, 12 juniors, and 6 sophomores. For all 36 participants, this was their first blended course. Their perceptions were attained through a survey that <b>compared</b> <b>instruction</b> delivered online to those presented face-to-face. The categories addressed included student learning, course objectives, instructor involvement, media elements, overall learning experience, and advantages. The survey measured if both online and face-to-face instruction were effective in the blended courses, as well as to ascertain advantages over courses offered purely online or face-to-face...|$|R
40|$|Abstract. In {{this paper}} we provide both a {{qualitative}} and a quantitative {{evaluation of a}} decoupled multithreaded architecture that uses non-blocking threads. Our architecture is based on simple in-order pipelines and complete decoupling of memory accesses from execution pipelines. We extend the architecture to support thread level speculation using snooping cache coherency protocols. We evaluate the performance gains from speculations by varying the number of load/store <b>instructions</b> <b>compared</b> to computational <b>instructions,</b> miss speculation rates {{and the degree of}} thread level speculation. Our architecture presents a viable alternative to complex superscalar and super-speculative CPUs...|$|R
40|$|International audienceThe rite {{of magical}} bricks is {{intended}} to protect the mummy and the tomb. It offers the possibility to <b>compare</b> textual <b>instructions</b> (manuscripts of the Book of the Dead) and archaeological application of a funerary practice. The presentation of this funerary rite shows {{how and why the}} practical application of the ritual in tombs can differ from the tradition noted by manuscripts...|$|R
40|$|Abstract. The {{purpose of}} the two studies {{reported}} in this arti-cle was {{to evaluate the effectiveness}} of extended vocabulary instruction during storybook reading with kindergarten students within a small-group intervention setting. Extended vocabulary instruction is characterized by explicit teaching that includes both contextual and definitional information, multiple exposures to target words in varied contexts, and experiences that promote deep processing of word meanings. In Study One, we <b>compared</b> extended <b>instruction</b> of target words to incidental exposure. In Study Two, we <b>compared</b> extended <b>instruction</b> to embedded instruction (i. e., providing simple definitions within the context of the story). Our findings indicated that extended instruction resulted in greater word learning than either incidental exposure or embedded instruction. Moreover, students maintained much of their understanding of word meanings six to eight weeks after instruction. Implications are discussed in relation to a tri-level approach to vocabulary instruction and intervention for kinder-garten students at risk for language and reading disabilities...|$|R
40|$|In view of {{a booming}} market for microelectronic implants, our ongoing {{research}} work is focusing on the specification and design of a novel biomedical microprocessor core targeting a large subset of existing and future biomedical applications. Towards this end, we have taken steps in identifying various tasks commonly required by such applications and profiling their behavior and requirements. A prominent family of such tasks is lossless data compression. In this work we profile a large collection of compression algorithms on suitably selected biomedical workloads. Compression ratio, average and peak power consumption, total energy budget, compression rate and program-code size metrics have been evaluated. Findings indicate the best-performing algorithms across most metrics to be mlzo (scores high in 5 out of 6 imposed metrics) and fin (present in 4 out of 6 metrics). Further mlzo profiling reveals the dominance of i) addressgeneration, load, branch and <b>compare</b> <b>instructions,</b> and ii) interdependent logical-logical and logical-compare instructions combinations...|$|R
