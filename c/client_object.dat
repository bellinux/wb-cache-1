34|171|Public
5000|$|... the <b>client</b> <b>object</b> that is {{depending}} on the service(s) it uses ...|$|E
50|$|The stub acts as {{a gateway}} for client side objects and all {{outgoing}} requests to server side objects that are routed through it. The stub wraps <b>client</b> <b>object</b> functionality and by adding the network logic ensures the reliable communication channel between client and server. The stub can be written up manually or generated automatically depending on chosen communication protocol.|$|E
50|$|The {{wireless}} token {{serves as}} an independent second authentication factor. Local pairing of token with protected networked <b>client</b> <b>object</b> is the authentication procedure. Personalisation of token with user is a preparative action that may be administered apart from network. Allocated user credentials shall be served from networked authorisation server for allowed access to data and function and from authentication server for allowed access to network and clients.|$|E
40|$|Object-oriented {{frameworks}} {{are structured}} {{in terms of}} client/server relationships between objects; an object's services are invoked by <b>client</b> <b>objects</b> through the operations of its interface. A common design requirement is for a server object to maintain state for each client that it is serving. Typically this is implemented by returning handles or untyped pointers to the client {{that are used to}} identify the per-client data structure holding its state. The lack of strong typing can lead to obscure errors that complicate debugging and maintenance. This paper presents the Type-Safe Session pattern which allows objects to maintain per-client state with full type safety and no loss of efficiency. Intent Allow a server <b>object</b> with many <b>client</b> <b>objects</b> to maintain per-client state and maintain type-safety. Also Known As Service Access Point (SAP), Context, Service Handler. Motivation Object-oriented frameworks are structured in terms of client/server 1 relationships between objects; an [...] ...|$|R
50|$|Meeting {{objections}} is {{an important}} step for a seller to learn to handle. When the <b>client</b> <b>objects,</b> it usually means they are interested in what has been presented to them. There are three type of objections; price or value objections, product/service objections, procrastinating objections and hidden objections. Generally these three objections can all be handled easier through listening, clarifying, respecting, and responding.|$|R
50|$|Willems {{was fired}} by Henrys School of Imaging, Canada's largest {{photographic}} school, after a <b>client</b> <b>objected</b> to a nude self-portrait he had posted. His shooting nudes costs him significant business, but he feels that North American society needs changing. He also thinks it would be dishonest not {{to do what he}} asks his models to do, so he continues to both shoot nudes and shoot nude self-portraits.|$|R
50|$|Team Foundation Server {{is built}} on multi-tier, {{scalable}} architecture. The primary structure consists of an application tier responsible for processing logic and maintaining the web application portal (referred to as Team Web Access or TWA). TFS is built using Windows Communication Foundation web services. These may be consumed by any client, although the <b>client</b> <b>object</b> model is recommended. The data tier and application tier can exist on the same machine.|$|E
5000|$|The {{wireless}} lock concept supports initialising {{the client}} with authentication and log-on as electronic key solutions. Beyond that a wireless lock supports automatic log-off after user leaves unlocked network client and independent from time-out conditions. Protection comes into effect, while integrated or galvanically attached and paired receiver/transceiver stays connected with protected <b>client</b> <b>object</b> {{as soon as}} wireless token gets separated from client exceeding a set maximum allowed distance, generally the manual reach required for operating keyboard attached to client.|$|E
50|$|Mock objects {{have the}} same {{interface}} as the real objects they mimic, allowing a <b>client</b> <b>object</b> to remain unaware of whether it is using a real object or a mock object. Many available mock object frameworks allow the programmer to specify which, and in what order, methods will be invoked on a mock object and what parameters will be passed to them, {{as well as what}} values will be returned. Thus, the behavior of a complex object such as a network socket can be mimicked by a mock object, allowing the programmer to discover whether the object being tested responds appropriately to the wide variety of states such mock objects may be in.|$|E
40|$|The {{design and}} {{implementation}} of a distributed multimodal biometric verification system inspired by the BioAPI specification is exposed. Server and <b>Client</b> <b>objects</b> divide processing responsibilities in classes linked by the Java Remote Method Invocation framework. Our framework is secured up to the core security requirements of the X 9. 84 standard. It {{is designed to be}} extensible to other modalities than speech and on-line signature through object-oriented design. 1...|$|R
40|$|This paper {{describes}} the Gaggle, {{a mechanism for}} grouping and naming objects in an object-oriented distributed system. Using Gaggles, <b>client</b> <b>objects</b> can access distributed replicated services without regard {{for the number of}} objects that provide the service. Gaggles are not themselves a replication mechanism; instead they enable programmers to construct their own replicated distributed services in whatever way is appropriate for the application at hand, and then to encapsulate the result. From the poin...|$|R
50|$|The <b>client</b> side <b>object</b> {{participating}} in distributed object communication {{is known as}} a stub or proxy, and {{is an example of a}} proxy object.|$|R
5000|$|Preferred {{when all}} {{dependencies}} {{can be constructed}} first {{because it can be}} used to ensure the <b>client</b> <b>object</b> is always in a valid state, as opposed to having some of its dependency references be null (not be set). However, on its own, it lacks the flexibility to have its dependencies changed later. This can be a first step towards making the client immutable and therefore thread safe. // ConstructorClient(Service service, Service otherService) { if (service == null) { throw new InvalidParameterException("service must not be null"); } if (otherService == null) { throw new InvalidParameterException("otherService must not be null"); } // Save the service references inside this client this.service = service; this.otherService = otherService;} ...|$|E
5000|$|Four terms always {{associated}} with the command pattern are command, receiver, invoker and client. A command object knows about receiver and invokes a method of the receiver. Values for parameters of the receiver method are stored in the command, the receiver object to execute these methods is also stored in the command object by aggregation. The receiver then does the work when the execute (...) method in command is called. An invoker object knows how to execute a command, and optionally does bookkeeping about the command execution. The invoker does not know anything about a concrete command, it knows only about command interface. Invoker object(s), command objects and receiver objects are held by a <b>client</b> <b>object,</b> the client decides which receiver objects it assigns to the command objects, and which commands it assigns to the invoker. The client decides which commands to execute at which points. To execute a command, it passes the command object to the invoker object.|$|E
5000|$|A fashionable garment in {{the early}} 20th century was the [...] "peekaboo waist", a blouse made from broderie anglaise or sheer fabric, which led to {{complaints}} that flesh could be seen through the eyelets in the embroidery or through the thin fabric. In 1913 the so-called [...] "x&#8209;ray dress", defined as a woman's dress that {{was considered to be}} too sheer or revealing, caused similar consternation. In August that year the Chief of Police of Los Angeles stated his intention to recommend a law banning women from wearing the [...] "diaphanous" [...] x‑ray dress on the streets. H. Russell Albee, the Mayor of Portland, Oregon, ordered the arrest of any woman caught wearing an x‑ray dress on the street, which was defined as a gown cut too low at the neck or split to the knee. The following year in 1914, Jean-Philippe Worth, designer for the renowned Paris couture House of Worth, had a <b>client</b> <b>object</b> to the thickness of the taffeta lining of her dress, which was described as [...] "thinner than a cigarette paper". Worth stated that using an even thinner, sheerer lining fabric would have had the effect of an [...] "x&#8209;ray dress".|$|E
25|$|Huckabee {{made sure}} that state {{agencies}} were compliant with charitable choice. His administration issued guidelines in October 2000, which allow religious groups to offer voluntary religious programs and to leave their religious artifacts on the walls as long as welfare clients are not pressured to convert and tax money doesn't directly underwrite them. Religious groups are allowed to reject a job candidate on religious grounds. The guidelines also guarantee that any client can receive alternative placement if the <b>client</b> <b>objects</b> to a religious provider.|$|R
30|$|For the reuse of properties, an {{attachment}} to the relating type object is possible (c.f. Fig. 3 b). This works properly if it represents a predefined set of properties for a specific type. Sharing properties for only a subset of a <b>client</b> <b>objects</b> is forbidden by the schema which, consequently, would imply {{the creation of a}} distinct property set for each client individually. For instance, a manufactured date can be the same value for multiple clients, but is not generally a static value property of a type.|$|R
50|$|Huckabee {{made sure}} that state {{agencies}} were compliant with charitable choice. His administration issued guidelines in October 2000, which allow religious groups to offer voluntary religious programs and to leave their religious artifacts on the walls as long as welfare clients are not pressured to convert and tax money doesn't directly underwrite them. Religious groups are allowed to reject a job candidate on religious grounds. The guidelines also guarantee that any client can receive alternative placement if the <b>client</b> <b>objects</b> to a religious provider.|$|R
5000|$|From {{another point}} of view, the {{real-time}} web consists in making the client interface (or the web side; or the web layer) of a web application, to communicate continuously with the corresponding real-time server, during every user connection. As a fast pic of the client/server model, imagine each <b>client</b> <b>object</b> (each web module of the web GUI of an application) having its object class (which remote-controls the GUI) alive as a sub process (of its user session) in the server environment. In this scenario, the web is considered as the human entrance (interface) to the real-time environment (the server core engine which runs applications): at each connected web URL, or Internet real-time zone, corresponds a different [...] "front-end" [...] web application. The real-time server acts as a logic network operating system for the programmable array of applications; handles the array of connected users for each application; attends for connections from real-world appliances and second level real-time servers. Applications behaviours and the intercommunication procedures between online services or applications, online users, and connected devices or appliances, are settled in the corresponding source code of each real-time service written in the real-time-interpreted programming language of the centric server.|$|E
5000|$|...NET Remoting makes a {{reference}} of a remotable object {{available to a}} client application, which then instantiates and uses a remotable object {{as if it were}} a local object. However, the actual code execution happens at the server-side. A remotable object is identified by Activation URLs and are instantiated by a connection to the URL. A listener for the object is created by the remoting runtime when the server registers the channel that is used to connect to the remotable object. At the client side, the remoting infrastructure creates a [...] that stands-in as a pseudo-instantiation of the remotable object. It does not implement the functionality of the remotable object, but presents a similar interface. As such, the remoting infrastructure needs to know the public interface of the remotable object beforehand. Any method calls made against the object, including the identity of the method and any parameters passed, are serialized to a byte stream and transferred over a communication protocol-dependent [...] to a recipient proxy object at the server side ("marshalled"), by writing to the Channel's transport sink. At the server side, the proxy reads the stream off the sink and makes the call to the remotable object on the behalf of the client. The results are serialized and transferred over the sink to the client, where the proxy reads the result and hands it over to the calling application. If the remotable object needs to make a callback to a <b>client</b> <b>object</b> for some services, the client application must mark it as remotable and have a remoting runtime host a listener for it. The server can connect to it over a different Channel, or over the already existent one if the underlying connection supports bidirectional communication. A channel can be composed of a number of different Channel objects, possibly with different heterogeneous transports. Thus, remoting can also work across systems separated by an interconnection of heterogeneous networks, including the internet. Type safety is enforced by the CTS and the [...]NET Remoting runtime. Remote method calls are inherently synchronous; asynchronous calls can be implemented using threading libraries. Authentication and access control can be implemented for clients by either using custom Channels or by hosting the remotable objects in IIS and then using the IIS authentication system.|$|E
40|$|This paper {{presents}} an approach for architect-ing OO applications for high performance with relational databases. The key ideas {{of this approach}} are: Optimize business object mapping: tune the mapping the between business objects and relational tables to leverage relational tech-nology. Perform <b>client</b> <b>object</b> management: use a client-side object manager to minimize database traffic. This approach enables organizations to derive the benefits of OO technology while leveraging their investments in relational technology...|$|E
40|$|A well {{accepted}} {{technique to}} ensure reliability in a distributed {{system is to}} replicate every object which performs critical processing. However, {{it is not easy}} to achieve replication, i. e to enable a replicated object to communicate with other objects, just as if it were not replicated. This paper presents problems raised by replication encapsulation and describes the solution proposed by the N 2 M service. The latter allows replicated <b>client</b> <b>objects</b> to communicate with replicated server objects using regular invocations. The N 2 M service defines a symetric invocation model to achieve replication encapsulation...|$|R
40|$|Montage is a customizable, {{embeddable}} ActiveX container. Its <b>client</b> <b>objects</b> may {{be positioned}} dynamically by an external layout agent. Montage manages toolbars and user interface modes, integrating disparate components into a single, consistent interface. An {{important part of}} this task is supporting “group repositories” of related objects for data transfer operations such as cut-and-paste, drag-and-drop, save and load. Montage does not rely on large external libraries such as the Microsoft Foundation Classes, and thus is relatively lightweight. The prototypical Montage application is an embeddable display for dynamic networks (abstract graphs) ...|$|R
50|$|When {{writing an}} object pool, the {{programmer}} {{has to be}} careful to make sure the state of the objects returned to the pool is reset back to a sensible state for the next use of the object. If this is not observed, the object will often be in some state that was unexpected by the client program and may cause the client program to fail. The pool is responsible for resetting the <b>objects,</b> not the <b>clients.</b> <b>Object</b> pools full of objects with dangerously stale state are sometimes called object cesspools and regarded as an anti-pattern.|$|R
40|$|Commercially {{available}} middleware systems today offer best-effort Quality-of-Service (QoS) to {{the application}} programs. Due to the natural limitation of resources and {{the differences between the}} priorities and demands of applications, middleware systems must have the capability to offer varying degrees of QoS. The QoS requirements of middleware applications can be monitored and fulfilled by configuring the middleware [1]. This could be implemented, for example, by encapsulating the specific QoS concerns of middleware within the components and by installing the most suitable component on a particular QoS demand. Unfortunately, not all the QoS concerns of a distributed system [2] can be defined and encapsulated by the interfaces of components. So-called crosscutting aspects [3] hinder the adaptation of middleware systems since the implementations of QoS support techniques cannot be restricted to the implementations of components. Consider, for example, a <b>client</b> <b>object</b> that sends a message to a set of server objects. The TCP/IP protocol can be used for this, in case only a few server objects have to receive the message. If, however, the <b>client</b> <b>object</b> wants to send the same message to a large set of server objects, a multicast protocol would be considerably more efficient than the TCP/IP protocol [5]. Transparent QoS management requires the system to automatically switch from TCP/IP to a multicast protocol {{in order to meet the}} QoS demands...|$|E
40|$|Abstract † In this paper, we {{describe}} the design and implementation of a dynamic fuzzy-decision based load balancing system incorporated in a distributed object computing environment. The proposed approach works by using a fuzzy logic controller which informs a <b>client</b> <b>object</b> to use the most appropriate service such that load balancing among servers is achieved. We have chosen Jini to build our experimental middleware platform, on which our proposed approach {{as well as other}} approaches are implemented and compared. Extensive experiments are conducted to investigate the effectiveness of our fuzzy-decision based approach, which is found to be consistently better than other approaches...|$|E
40|$|This paper {{describes}} the Harvest Broker. The Broker plays {{a central role}} in the Harvest Query Manager Broker Storage Manager and Indexer Collector <b>Client</b> <b>Object</b> Cache Replication Manager Provider Gatherer 1. search object & retrieve 2. methods access SOIF SOIF Registry Broker Figure 1. 1 : The Harvest Architecture. architecture. It maintains a dynamic SOIF object database and presents this data to users through a powerful and effective query interface. For the purpose of characterizing access patterns, the Broker is instrumented to collect statistics through a selective logging facility. The Broker also supports real-time administrative control so that administrators can dynamically configure Broker parameters to best fit the environment. 1. 1 Component...|$|E
40|$|PROCOL is an {{object-oriented}} language with distributed delegation. It strongly supports concurrency: many objects may be active simultaneously, they execute in parallel unless engaged in communication. An object has exported operations, called Actions. Only one Action can be active at a time, however special interrupt Actions may interrupt regular Actions. Communication is performed via remote procedure call, or via a one-way synchronous message with short-time binding. In communications both client and server can be specified, either by object instance identifiers, or by type. Therefore client-server mappings may be 1 - 1, n- 1, or 1 -n, though only 1 message is transferred. PROCOL controls object access by an explicit per-object protocol. This protocol is a specification of the legality and serialization {{of the interaction}} between the <b>object</b> and its <b>clients.</b> It also provides for client type checking. The use of protocols in object communication fosters structured, safer and potentially verifiable information exchange between objects. The protocol also plays an important role as a partial interface specification. In addition it acts as a composition rule over <b>client</b> <b>objects,</b> representing relations with the <b>client</b> <b>objects.</b> PROCOL's communication binding is dynamic (run-time); it functions therefore naturally in a distributed, incremental and dynamic object environment. PROCOL also supports constraints, without compromising information hiding. An implementation is available {{in the form of a}} C extension...|$|R
5000|$|Boies was an {{attorney}} at Cravath, Swaine & Moore, {{where he started}} upon law school graduation in 1966 and became a partner in 1973. He left Cravath in 1997 after a major <b>client</b> <b>objected</b> to his representation of the New York Yankees even though the firm itself had found no conflict. He left the firm within 48 hours of being informed of the client's objection and created his own firm, now known as Boies, Schiller & Flexner LLP. It is currently rated 17th in [...] "overall prestige" [...] and 12th among New York law firms by Vault.com, a website on legal career information.|$|R
40|$|In this article, {{we propose}} a {{distributed}} security architecture for incorporation into object-oriented distributed computing systems, and in particular, into OMG 2 ̆ 7 s CORBA architecture. The primary {{objective of the}} security architecture is to make CORBA resilient to malicious attacks. The core of the architecture {{is the notion of}} secure ORB nodes, which are ORB nodes enhanced with ldquopluggablerdquo security system objects interacting through generic security service APIs. Security system objects coupled with protocols facilitate among them the creation and management of <b>clients,</b> <b>objects,</b> and security information, as well as the provision of security services, such as client/object authentication, access control, integrity, and confidentiality protections...|$|R
40|$|Modern distributed, object-based {{systems support}} nested method invocations, whereby one object can invoke methods on another. In this paper {{we present a}} {{framework}} that supports nested method invocations among Byzantine fault-tolerant, replicated objects that are accessed via quorum systems. A challenge {{in this context is}} that <b>client</b> <b>object</b> replicas can induce unwanted method invocations on server object replicas, due either to redundant invocations by client replicas or Byzantine failures within the client replicas. At the core of our framework are a new quorumbased authorization technique and a novel method invocation protocol that ensure the linearizability and failure atomicity of nested method invocations despite Byzantine client and server replica failures. We detail the implementation of these techniques in a system called Fleet, and give preliminary performance results for them...|$|E
40|$|Abstract. Reasoning about {{object-oriented}} programs {{requires an}} appropriate technique {{to reflect a}} fundamental “general relativity ” property of the approach: every operation is relative to a current object, which changes with every quali-fied call; such a call needs access to {{the context of the}} <b>client</b> <b>object.</b> The notion of negative variable, discussed in this article, provides a framework for reason-ing about OO programs in any semantic framework. We introduce a fundamen-tal rule describing the semantics of object-oriented calls, its specific versions for such frameworks as axiomatic (Hoare-style) logic and denotational seman-tics, and its application to such problems as alias analysis and the consistency of concurrent programs. The approach has been implemented as part of a verifica-tion environment for a major object-oriented language and used to perform a number of proofs and analyses...|$|E
40|$|A {{survey of}} {{concurrent}} object-oriented languages is presented. The survey is organized around three models: the Animation Model that describes {{a variety of}} relationships between threads and objects, an Interaction Model that classi#es the possible semantics of invocations and returns between a <b>client</b> <b>object</b> and a server object, and a Synchronization Model that shows di#erentways in which concurrentinvocations can be managed bya server. Anumber of representative languages are brie#y presented. The problem of synchronization in concurrent object-oriented languages is considered in detail including {{a discussion of the}} inheritance anomaly. A synchronization mechanism, called a behavior set, is shown to avoid this anomaly in certain cases. The implementation of behavior sets in ACT++, an actor-based concurrent programming framework implemented in C++, is described. 1 Introduction This survey of concurrent object-oriented programming languages is organized along the following [...] ...|$|E
5000|$|The {{exceptional}} {{situations that}} {{will be required to}} be handled by <b>clients</b> to the <b>object.</b>|$|R
40|$|We {{propose a}} {{distributed}} security architecture for incorporation into object oriented distributed computing systems, and in particular, into OMG 2 ̆ 7 s CORBA based object architectures. The primary {{objective of the}} security architecture is to make CORBA resilient to both component failures and malicious attacks. The core of the architecture {{is the notion of}} secure ORB node-an ORB node enhanced with 2 ̆ 2 pluggable 2 ̆ 2 system security objects interacting through generic security service APIs. System security objects coupled with protocols among them facilitate creation and management of <b>clients,</b> <b>objects,</b> and security information. Security services addressed in the paper include, but are in no way limited to, client/object authentication, access control, and integrity and confidentiality protections...|$|R
50|$|Boies {{represented}} New York Yankees owner George Steinbrenner in a {{suit against}} Major League Baseball. This involved an action against all the teams. The Atlanta Braves were owned by Time Warner, a longtime Cravath <b>client,</b> who <b>objected</b> to his representation of the Yankees.|$|R
