102|165|Public
25|$|<b>Counter</b> <b>machine</b> – {{the most}} {{primitive}} and reduced theoretical {{model of a}} computer hardware. Lacks indirect addressing. Instructions are in the finite state machine {{in the manner of}} the Harvard architecture.|$|E
25|$|Random access machine (RAM) – a <b>counter</b> <b>machine</b> with {{indirect}} addressing and, usually, an augmented instruction set. Instructions {{are in the}} finite state machine {{in the manner of}} the Harvard architecture.|$|E
2500|$|Except {{there is}} a problem: If based on the <b>counter</b> <b>machine</b> chassis this computer-like, von Neumann machine will not be Turing equivalent. It cannot compute {{everything}} that is computable. Intrinsically the model is bounded {{by the size of}} its (very-) finite state machine's instructions. The <b>counter</b> <b>machine</b> based RASP can compute any primitive recursive function (e.g. multiplication) but not all mu recursive functions (e.g. the Ackermann function [...] ).|$|E
40|$|This paper clarifies {{the picture}} about Dense-choice <b>Counter</b> <b>Machines,</b> {{which have been}} less studied than (discrete) <b>Counter</b> <b>Machines.</b> We revisit the {{definition}} of "Dense Counter Machines" so that it now extends (discrete) <b>Counter</b> <b>Machines,</b> and we provide new undecidability and decidability results. Using the first-order additive mixed theory of reals and integers, we give a logical characterization of the sets of configurations reachable by reversal-bounded Dense-choice <b>Counter</b> <b>Machines...</b>|$|R
40|$|Abstract. In this paper, {{we present}} recent results about the verifica-tion of <b>counter</b> <b>machines</b> by using {{decision}} procedures for Presburger arithmetic. We recall several known classes of <b>counter</b> <b>machines</b> {{for which the}} reachability sets are Presburger-definable as well as temporal logics with arithmetical constraints. We discuss issues related to flat <b>counter</b> <b>machines,</b> path schema enumeration, {{and the use of}} SMT solvers. ...|$|R
40|$|AbstractWe {{study the}} time {{relationships}} between several models of computation (variants of <b>counter</b> <b>machines,</b> Turing machines, and random access machines). It is shown that <b>counter</b> <b>machines</b> augmented by a “copy” instruction can be simulated in linear time by <b>counter</b> <b>machines</b> without such an instruction, {{and that these}} <b>counter</b> <b>machines</b> can be simulated by RAM's with speedup by a fixed polynomial. Since the difference between augmented <b>counter</b> <b>machines</b> and RAM's lies partly in the latter's indirect addressing capabilities, we obtain bounds {{on the extent to}} which these capabilities speed up computations. We also show that unit-cost RAM's can simulate multi-dimensional Turing machines with speedup using their addressing capabilities to efficiently implement multidimensional arrays. Evidence is presented to show that on a restricted class of RAM's, “successor” RAM's, efficient implementation of multi-dimensional arrays is not possible...|$|R
2500|$|The {{unbounded}} μ operator is also {{defined by}} Boolos-Burgess-Jeffrey (2002) p.60-61 for a <b>counter</b> <b>machine</b> with an instruction set {{equivalent to the}} following: ...|$|E
2500|$|For a good {{treatment}} of the <b>counter</b> <b>machine</b> see Minsky (1967) Chapter 11 [...] "Models similar to Digital Computers"—he calls the <b>counter</b> <b>machine</b> a [...] "program computer". A recent overview is found at van Emde Boas (1990). A recent {{treatment of}} the Minsky (1961)/Lambek (1961) model can be found Boolos-Burgess-Jeffrey (2002); they reincarnate Lambek's [...] "abacus model" [...] to demonstrate equivalence of Turing machines and partial recursive functions, and they provide a graduate-level introduction to both abstract machine models (counter- and Turing-) and the mathematics of recursion theory. Beginning with the first edition Boolos-Burgess (1970) this model appeared with virtually the same treatment.|$|E
2500|$|Pointer machine [...] – a {{blend of}} <b>counter</b> <b>machine</b> and RAM models. Less common and more {{abstract}} than either model. Instructions are in the finite state machine {{in the manner of}} the Harvard architecture.|$|E
40|$|We {{study the}} decidability status of model-checking freeze LTL over various subclasses of <b>counter</b> <b>machines</b> {{for which the}} {{reachability}} problem {{is known to be}} decidable (reversal-bounded <b>counter</b> <b>machines,</b> vector additions systems with states, flat <b>counter</b> <b>machines,</b> one-counter machines). In freeze LTL, a register can store a counter value and at some future position an equality test can be done between a register and a counter value. Herein, we complete an earlier work started on one-counter machines by considering other subclasses of <b>counter</b> <b>machines,</b> and especially the class of reversal-bounded <b>counter</b> <b>machines.</b> This gives us the opportuniy to provide a systematic classification that distinguishes determinism vs. nondeterminism and we consider subclasses of formulae by restricting the set of atomic formulae or/and the polarity of the occurrences of the freeze operators, leading to the flat fragment...|$|R
40|$|Lossy <b>counter</b> <b>machines</b> {{are defined}} as Minsky <b>counter</b> <b>machines</b> where the values in the {{counters}} can spontaneously decrease at any time. While termination is decidable for lossy <b>counter</b> <b>machines,</b> structural termination (termination for every input) is undecidable. This undecidability result has far-reaching consequences. Lossy <b>counter</b> <b>machines</b> {{can be used as}} a general tool to prove the undecidability of many problems, for example (1) The verification of systems that model communication through unreliable channels (e. g., model checking lossy fifo-channel systems and lossy vector addition systems). (2) Several problems for reset Petri nets, like structural termination, boundedness and structural boundedness. (3) Parameterized problems like fairness of broadcast communication protocols...|$|R
40|$|The {{classes of}} {{sequences}} generated by time- and space- restricted multiple <b>counter</b> <b>machines</b> are {{compared to the}} corresponding classes generated by similarly restricted multiple tape Turing machines. Special {{emphasis is placed on}} the class of sequences generable by machines which operate in real time. Real-time Turing machines are shown to be strictly more powerful than real-time <b>counter</b> <b>machines.</b> A number of questions which remain open for real-time Turing machines are settled for real-time <b>counter</b> <b>machines...</b>|$|R
2500|$|Tally {{counters}} or marks: discrete, indistinguishable {{objects or}} marks {{of only one}} sort suitable for the model. In the most-reduced <b>counter</b> <b>machine</b> model, per each arithmetic operation only one object/mark is either added to or removed from its location/tape. In some <b>counter</b> <b>machine</b> models (e.g. Melzak (1961), Minsky (1961)) and most RAM and RASP models more than one object/mark can be added or removed in one operation with [...] "addition" [...] and usually [...] "subtraction"; sometimes with [...] "multiplication" [...] and/or [...] "division". Some models have control operations such as [...] "copy" [...] (variously: [...] "move", [...] "load", [...] "store") that move [...] "clumps" [...] of objects/marks from register to register in one action.|$|E
2500|$|List of labeled instructions, {{usually in}} {{sequential}} order: A finite list of instructions [...] In {{the case of}} the <b>counter</b> <b>machine,</b> random access machine (RAM) and pointer machine the instruction store is in the [...] "TABLE" [...] of the finite state machine; thus these models are example of the Harvard architecture. In {{the case of the}} RASP the program store is in the registers; thus {{this is an example of}} the von Neumann architecture. See also Random access machine and Random access stored program machine.Usually, like computer programs, the instructions are listed in sequential order; unless a jump is successful the default sequence continues in numerical order. An exception to this is the abacus (Lambek (1961), Minsky (1961)) <b>counter</b> <b>machine</b> models—every instruction has at least one [...] "next" [...] instruction identifier [...] "z", and the conditional branch has two.|$|E
2500|$|Minsky (1967) {{hints at}} the issue in his {{investigation}} of a <b>counter</b> <b>machine</b> (he calls them [...] "program computer models") equipped with the instructions { CLR (r), INC (r), and RPT ("a" [...] times the instructions m to n) }. He doesn't {{tell us how to}} fix the problem, but he does observe that: ...|$|E
40|$|This paper clarifies {{the picture}} about Dense-choice <b>Counter</b> <b>Machines</b> (DCM), a less studied version of <b>Counter</b> <b>Machines</b> where <b>counters</b> range on a dense, rather than discrete, domain. The {{definition}} of DCM is revisited {{to make it}} extend (discrete) <b>Counter</b> <b>Machines,</b> and new undecidability and decidability results are proved. Using the first-order additive mixed theory of reals and integers, the paper presents a logical characterization of the sets of configurations reachable by reversal-bounded DCM. We also relate the DCM model to more common models of systems...|$|R
40|$|Abstract. We {{extend the}} class of reversal-bounded <b>counter</b> <b>machines</b> by autho-rizing {{a finite number of}} alternations between {{increasing}} and decreasing mode over a given bound. We prove that extended reversal-bounded <b>counter</b> <b>machines</b> also have effective semi-linear reachability sets. We also prove that the property of being reversal-bounded is undecidable in general even when we fix the bound, whereas this problem becomes decidable when considering Vector Addition Sys-tem with States. ...|$|R
50|$|The first machine, an FSM {{plus two}} counters, is {{equivalent}} in {{power to a}} Turing machine. See the article on <b>counter</b> <b>machines</b> for a proof.|$|R
2500|$|The papers: The papers {{begin with}} Wang (1957) and his {{dramatic}} simplification of the Turing machine. [...] Turing (1936), Kleene (1952), Davis (1958) {{and in particular}} Post (1936) are cited in Wang (1957); in turn, Wang is referenced by Melzak (1961), Minsky (1961) and Shepherdson-Sturgis (1961-3) as they independently reduce the Turing tapes to [...] "counters". Melzak (1961) provides his pebble-in-holes <b>counter</b> <b>machine</b> model with indirection but doesn't carry the treatment further. The work of Elgot-Robinson (1964) define the RASP—the computer-like random access stored program machines—and {{appear to be the}} first to investigate the failure of the bounded <b>counter</b> <b>machine</b> to calculate the mu-recursive functions. This failure—except with the draconian use of Gödel numbers in the manner of Minsky (1961))—leads to their definition of [...] "indexed" [...] instructions (i.e. indirect addressing) for their RASP model. Elgot-Robinson (1964) and more so Hartmanis (1971) investigate RASPs with self-modifying programs. Hartmanis (1971) specifies an instruction set with indirection, citing lecture notes of Cook (1970). For use in investigations of computational complexity Cook and his graduate student Reckhow (1973) provide the definition of a RAM (their model and mnemonic convention are similar to Melzak's, but offer him no reference in the paper). The pointer machines are an offshoot of Knuth (1968, 1973) and independently Schönhage (1980).|$|E
2500|$|The {{following}} demonstration follows Minsky without [...] "the peculiarity" [...] {{mentioned in}} the footnote. The demonstration will use a [...] "successor" [...] <b>counter</b> <b>machine</b> model {{closely related to the}} Peano Axioms and the primitive recursive functions. The model consists of (i) a finite state machine with a TABLE of instructions and a so-called 'state register' that we will rename [...] "the Instruction Register" [...] (IR), (ii) a few [...] "registers" [...] each of which can contain only a single natural number, and (iii) an instruction set of four [...] "commands" [...] described in the following table: ...|$|E
2500|$|Example: A <b>counter</b> <b>machine</b> {{equipped}} with only four unbounded registers can e.g. multiply any two numbers ( [...] m, n [...] ) together to yield p—and thus be a primitive recursive function—no matter how large the numbers m and n; moreover, less than 20 instructions {{are required to}} do this! e.g. { 1: CLR ( [...] p [...] ), 2: JZ ( [...] m, done [...] ), 3 outer_loop: JZ ( [...] n, done [...] ), 4: CPY ( [...] m, temp [...] ), 5: inner_loop: JZ ( [...] m, outer_loop [...] ), 6: DEC ( [...] m [...] ), 7: INC ( [...] p [...] ), 8: J ( [...] inner_loop [...] ), 9: outer_loop: DEC ( [...] n [...] ), 10 J ( [...] outer_loop [...] ), HALT } ...|$|E
50|$|Post-Turing machine—minimalist one-tape, two-direction, 1 symbol { blank, mark } Turing-like machine {{but with}} default {{sequential}} instruction execution {{in a manner}} similar to the basic 3-instruction <b>counter</b> <b>machines.</b>|$|R
40|$|AbstractFor {{classes of}} {{languages}} accepted in polynomial time by multicounter machines, various trade-offs in computing power obtain among {{the number of}} counters, the amount of time, {{and the amount of}} space required in all cases, deterministic and nondeterministic, on-line and off-line. Hierarchies can be obtained in all cases by varying the number of counters or the amount of time allowed. In the on-line case, nondeterministic <b>counter</b> <b>machines</b> are always more powerful than deterministic <b>counter</b> <b>machines</b> for the same number of counters and the same polynomial time bound. Relationships with open problems are explored...|$|R
50|$|To {{understand}} {{predict the}} behavior of formulas with feedback requires the more sophisticated analysis of sequential circuits. Propositional formulas with feedback lead, in their simplest form, to state machines; they also lead to memories {{in the form of}} Turing tapes and counter-machine counters. From combinations of these elements one can build any sort of bounded computational model (e.g. Turing <b>machines,</b> <b>counter</b> <b>machines,</b> register machines, Macintosh computers, etc.).|$|R
2500|$|A RASP or Random access {{stored program}} machine {{begins as a}} <b>counter</b> <b>machine</b> with its [...] "program of instruction" [...] placed in its [...] "registers". Analogous to, but {{independent}} of, the finite state machine's [...] "Instruction Register", {{at least one of}} the registers (nicknamed the [...] "program counter" [...] (PC)) and one or more [...] "temporary" [...] registers maintain a record of, and operate on, the current instruction's number. The finite state machine's TABLE of instructions is responsible for (i) fetching the current program instruction from the proper register, (ii) parsing the program instruction, (iii) fetching operands specified by the program [...] instruction, and (iv) executing the program instruction.|$|E
2500|$|Minsky (1961) and Shepherdson-Sturgis (1963) {{prove that}} only a few tapes—as few as one—still allow the machine to be Turing {{equivalent}} IF the data on the tape is represented as a Gödel number (or some other uniquely encodable-decodable number); this number will evolve as the computation proceeds. In the one tape version with Gödel number encoding the <b>counter</b> <b>machine</b> must be able to (i) multiply the Gödel number by a constant (numbers [...] "2" [...] or [...] "3"), and (ii) divide by a constant (numbers [...] "2" [...] or [...] "3") and jump if the remainder is zero. Minsky (1967) shows that the need for this bizarre instruction set can be relaxed to { INC (r), JZDEC (r, z) } and the convenience instructions { CLR (r), J (r) } if two tapes are available. A simple Gödelization is still required, however. A similar result appears in Elgot-Robinson (1964) with respect to their RASP model.|$|E
50|$|This page {{supplements}} <b>counter</b> <b>machine.</b>|$|E
40|$|We {{show that}} {{deterministic}} finite automata equipped with $k$ two-way heads are equivalent to deterministic machines {{with a single}} two-way input head and $k- 1 $ linearly bounded counters if the accepted language is strictly bounded, i. e., a subset of $a_ 1 ^*a_ 2 ^* [...] . a_m^*$ for a fixed sequence of symbols $a_ 1, a_ 2, [...] ., a_m$. Then we investigate linear speed-up for <b>counter</b> <b>machines.</b> Lower and upper time bounds for concrete recognition problems are shown, implying that in general linear speed-up does not hold for <b>counter</b> <b>machines.</b> For bounded languages we develop a technique for speeding up computations by any constant factor {{at the expense of}} adding a fixed number of counters...|$|R
40|$|Abstract. This paper {{proves the}} NP-completeness of the {{reachability}} {{problem for the}} class of flat <b>counter</b> <b>machines</b> with difference bounds and, more generally, octagonal relations, labeling the transitions on the loops. The proof {{is based on the}} fact that the sequence of powers {Ri}∞i= 1 of such relations can be encoded as a periodic sequence of matrices, and that both the prefix and the period of this sequence are 2 O(||R|| 2) in the size of the binary encoding ||R|| 2 of a relation R. This result allows to characterize the complexity of the reachability problem for one of the most studied class of <b>counter</b> <b>machines</b> [8, 11], and has a potential impact on other problems in program verification. ...|$|R
40|$|This paper {{proves the}} NP-completeness of the {{reachability}} {{problem for the}} class of flat <b>counter</b> <b>machines</b> with difference bounds and, more generally, octagonal relations, labeling the transitions on the loops. The proof {{is based on the}} fact that the sequence of powers {R^i}_i= 1 ^∞ of such relations can be encoded as a periodic sequence of matrices, and that both the prefix and the period of this sequence are 2 ^O(R) in the size of the binary encoding R of a relation R. This result allows to characterize the complexity of the reachability problem for one of the most studied class of <b>counter</b> <b>machines</b> cav 10,comon-jurski 98, and has a potential impact for other problems in program verification. Comment: 43 page...|$|R
5000|$|The various <b>Counter</b> <b>machine</b> {{instruction}} {{sets are}} like [...] "ultra-RISC instruction sets". And, {{as is the}} case for different RISC machine builders, even for very similar machines, different authors have used different instruction sets. The [...] "basic instructions" [...] are used map these differences on the relevant <b>Counter</b> <b>machine</b> variant models.|$|E
5000|$|Random access machine—RAM: <b>counter</b> <b>machine</b> {{with added}} {{indirect}} addressing capability ...|$|E
50|$|In {{computer}} science, random-access machine (RAM) is {{an abstract}} {{machine in the}} general class of register machines. The RAM {{is very similar to}} the <b>counter</b> <b>machine</b> but with the added capability of 'indirect addressing' of its registers. Like the <b>counter</b> <b>machine</b> the RAM has its instructions in the finite-state portion of the machine (the so-called Harvard architecture).|$|E
2500|$|Multipurpose <b>counter</b> <b>machines</b> with {{computers}} {{were introduced in}} post offices in 1991 to improve customer service and increase staff productivity. 25,000 departmental post offices out of 25,464 were computerized between as of 2011–2012. In 2012, a plan costing [...] was formulated to computerize rural post offices.|$|R
40|$|Abstract. Two {{models of}} conformon-P systems, one {{restricted}} {{in the number}} of input conformons and the other restricted {{in the number of}} input membranes, are proved to induce infinite hierarchies. The described systems do not work under the requirement of maximal parallelism and perform deterministic simulations of restricted <b>counter</b> <b>machines.</b> ...|$|R
40|$|Background and aim:Blood {{cells have}} an {{important}} role in human healthy, so their shapes and numbers are defined as human healthy indexes. These factors are measured by cell <b>counter</b> <b>machines.</b> Presenting a high quality report according to cell counters output is dependant on their operational accuracy. Therefore it was necessary to do a study on quality control of blood cell <b>counter</b> <b>machines</b> in selective medical laboratories of Tehran. Method of study:This study was an experimental type in selective medical laboratories of Tehran. "Brittin method" was used as a general method for 6 selective machines over WBC, RBC, Hb, HCT, MCV, MCH and MCHC. In this method red blood cells index stability with EDTA, in 4 oC for 24 hour is assessed. Data was collected before and after quality controls and finally data analysis was done by T- student (paired samples T test) method and SPSS software. Results:Using Brittin method showed all selective machines had significant differences before and after quality control in one or more quality factors (P-value< 0. 05). Conclusion:Quality control can show inaccuracy in cell <b>counter</b> <b>machines</b> output and finally inaccuracy over patient blood tests. By this subject we can have high quality diagnosis. This study showed parameters producing errors are error in sample volume, biological factors, error in concentration and using bad solutions...|$|R
