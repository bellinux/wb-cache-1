0|3607|Public
30|$|Develop {{analytical}} <b>capabilities</b> <b>based</b> {{on business}} priorities.|$|R
40|$|This paper {{explores the}} {{implications}} of a capability-based conceptual approach {{on the development of}} the systems engineering (SE) discipline. It deals with the identification of some potential limits and gaps of traditional SE approaches and demonstrates the need for new and innovative developments which support the concept of <b>capability</b> <b>based</b> engineering, especially as applied in the military domain and networking environments. The innovative approaches include partnership for capability planning and service descriptions for capability representations. The paper also presents a very brief assessment of the state-of-the-art of cognate domains such as <b>capability</b> <b>based</b> planning alongside requirements engineering and management, and considers the extent to which they <b>address</b> <b>capability</b> <b>based</b> concepts. The related concepts of system of systems (SoS) and the endeavour to extend SE to SoS are necessarily addressed. Key words – capability engineering, system of systems, <b>capability</b> <b>based</b> planning, defence, military operation...|$|R
5000|$|Develop and {{demonstrate}} system level <b>capabilities</b> <b>based</b> on novel low carbon energy technologies or services ...|$|R
40|$|This thesis {{examines}} {{the feasibility of}} using a tagged memory and a stack processor to implement a <b>capability</b> <b>based</b> computer. The hypothesis put forth here is that these two architectural features {{reduce the cost of}} the capability mechanism and result in a simpler implementation. We begin by motivating memory protection and protection systems as a basic need of modern computer systems. A brief historical survey is presented which begins with Dennis and Van Horn 2 ̆ 7 s paper on the semantics of multi-programmed computations and ends with a review of the major capability machines which resulted from this paper. ^ We then introduce the memory and processor organization proposed for this design and compare this organization with that used in previous architectures. This discussion shows that a tagged-memory organization reduces the number of segments used by a process by allowing segments to contain both pointer and data information. This reduces memory management overhead and allows a simpler representation of objects. Moreover, the tagged memory simplifies the mechanisms used to change domains, pass parameters, and address information in primary memory. The stack processor is shown to further reduce the cost of the capability mechanism by providing an inexpensive way to allocate procedure activation records, handle domain changes, and address objects on the stack. ^ Next we present the capability mechanism for the proposed design and discuss the process of mapping <b>capability</b> <b>based</b> virtual <b>addresses</b> into absolute primary memory addresses, and show how the abstract type concept is directly supported by the capability mechanism. ^ A discussion of the hardware facilities needed to support the design follows. This discussion presents a detailed view of the registers of the central processor, the organization of the process stack, the instruction set, and a possible firmware organization which could be used to implement the design. ^ The proposed architecture is then compared with two conventional machines and shown to be more efficient in representing programs. Moreover, evidence is presented which suggests that the performance of the proposed machine would be competitive with current state-of-the-art machines. Finally, two examples are presented which use the abstract type, process synchronization, and process communication facilities provided by the design. ^ The major contribution of this thesis is the thorough examination it provides of the tagged memory approach to capability addressing. Out research shows a tagged-memory capability machine is powerful enough to implement an operating system and the resulting operating system has a complexity about equal to that of the older generation of simple systems with little memory protection. This thesis also illustrates that advanced programming concepts can be implemented quite simply if the proper hardware support is provided. Finally, we show that the process control mechanism introduced in this thesis removes an important source of memory contention from the mutual exclusion mechanism. This is seen as a partial solution to the memory contention problem found on many multi-processor systems. ...|$|R
5000|$|Address, four hex digits, {{representing}} the 16-bit beginning memory address offset of the data. The physical {{address of the}} data is computed by adding this offset to a previously established <b>base</b> <b>address,</b> thus allowing memory addressing beyond the 64 kilobyte limit of 16-bit <b>addresses.</b> The <b>base</b> <b>address,</b> which defaults to zero, can be changed by various types of records. <b>Base</b> <b>addresses</b> and address offsets are always expressed as big endian values.|$|R
50|$|In the x86 architecture, an input/output <b>base</b> <b>address</b> is {{the first}} address {{of a range of}} {{consecutive}} read/write addresses that a device uses on the x86's IO bus. This <b>base</b> <b>address</b> is sometimes called an I/O port.|$|R
50|$|Although MTP {{provides}} routing <b>capabilities</b> <b>based</b> {{upon the}} Point Code, SCCP allows routing using a Point Code and Subsystem number or a Global Title.|$|R
40|$|This conference {{paper was}} {{presented}} at CSER 2009 and is also available at: [URL] paper explores the implications of a capability-based conceptual approach {{on the development of}} the systems engineering (SE) discipline. It deals with the identification of some potential limits and gaps of traditional SE approaches and demonstrates the need for new and innovative developments which support the concept of <b>capability</b> <b>based</b> engineering, especially as applied in the military domain and networking environments. The innovative approaches include partnership for capability planning and service descriptions for capability representations. The paper also presents a very brief assessment of the state-of-the-art of cognate domains such as <b>capability</b> <b>based</b> planning alongside requirements engineering and management, and considers the extent to which they <b>address</b> <b>capability</b> <b>based</b> concepts. The related concepts of system of systems (SoS) and the endeavour to extend SE to SoS are necessarily addressed...|$|R
30|$|For instance, Gusmeroli et al. (2013) and Hernández-Ramos et al. (2013) {{propose the}} use of the <b>Capability</b> <b>based</b> access control model (CapBAC) within IoT ecosystems.|$|R
50|$|Using {{the color}} video buffer space, some {{third-party}} utilities could add memory {{at the top}} of the 640k conventional memory area, to extend memory up to the <b>base</b> <b>address</b> used by hardware adapters. This could ultimately backfill RAM up to the MDA <b>base</b> <b>address.</b>|$|R
50|$|The new, {{electronically}} controlled, {{all-wheel drive}} system is developed and {{supplied by the}} Swedish company Haldex Traction, offering traction and handling <b>capabilities</b> <b>based</b> on their 4th generation technology.|$|R
40|$|Abstract. The {{functioning}} of modern IT-systems with autonomously acting components requires an elaborate {{access control system}} in which each participant can maintain her own trust structure. In this work, we discuss ideas for an extension of <b>capability</b> <b>based</b> access control systems that allow the specification of dynamically changing trust of participants. We propose a classification of credentials and distinguish between credentials that have a positive and those that {{have a negative impact}} on access decisions. Furthermore, we investigate, how our ideas can be implemented in existing approaches for <b>capability</b> <b>based</b> access control systems. ...|$|R
50|$|Under the {{relative}} addressing scheme, {{to obtain an}} absolute <b>address,</b> the relevant <b>base</b> <b>address</b> is taken and offset (aka displacement) is added to it. Under this type of scheme, the <b>base</b> <b>address</b> is the lowest numbered address within a prescribed range, to facilitate adding related positive-valued offsets.|$|R
50|$|November 2014: OrangeFS 2.9.0 {{released}} adding {{support for}} distributed metadata for directory entries using an extensible hashing algorithm modeled after giga+, posix backward compatible <b>capability</b> <b>base</b> security supporting multiple modes.|$|R
5000|$|SecureZIP and PKZIP 15 for z/OS (released 2013-11-13) added {{features}} to expand offloading capabilities for z/OS and mainframe hardware, {{as well as}} compression <b>capabilities</b> <b>based</b> on a partnership with IBM.|$|R
5000|$|It {{introduced}} a 22-bit Vector Base Register (VBR) that holds A32:10 of the 1 KB-aligned <b>base</b> <b>address</b> for the exception vector table. The 68000 vector table was always <b>based</b> at <b>address</b> zero.|$|R
30|$|ASLR randomizes the <b>base</b> <b>addresses</b> of both {{data and}} code in the memory.|$|R
5000|$|GRAPHICS - {{reserved}} {{variable that}} always equals $D000 (the VIC-II chip's <b>base</b> <b>address)</b> ...|$|R
5000|$|SOUND - {{reserved}} {{variable that}} always equals $D400 (the SID chip's <b>base</b> <b>address)</b> ...|$|R
30|$|Because {{changes in}} muscle {{fascicle}} length affect the force-generating <b>capability</b> <b>based</b> on force–length (Gordon et al. 1966) and force–velocity (Hill 1938) relationships, clarifying the precise {{behavior of the}} muscle fascicle is important for better understanding human locomotion.|$|R
50|$|There {{is also an}} {{external}} project, Galera Cluster created by codership, that provides true multi-master <b>capability,</b> <b>based</b> on a fork of the InnoDB storage engine and custom replication plug-ins. Replication is synchronous, so no conflict is possible.|$|R
5000|$|<b>Base</b> <b>address</b> register: To {{store the}} initial address from where data {{transfer}} {{will take place}} ...|$|R
5000|$|A colour {{video card}} with sprite <b>capability</b> <b>based</b> {{on the same}} video chip (the TMS9918) as the TI99/4 and MSX computers, {{designed}} for gaming, and more creative and colorful educational software. A working prototype of this card was finished.|$|R
50|$|Beyond {{the level}} of vision impairment, {{research}} done at the Central Institute on Employment Abilities of the Handicapped in Moscow has found differences in functional <b>capabilities</b> <b>based</b> on differences in visual acuity. This does not {{play a significant role}} in judo.|$|R
40|$|Typical {{high-performance}} {{distributed applications}} con-sist of clients accessing computational and information re-sources implemented by remote servers. Different clients {{may have different}} requirements for accessing a single server resource. A server resource {{may also want to}} pro-vide different kinds of accesses for different clients, depend-ing on factors such as the amount of trust between the server and a client. The requirements or attributes of remote ac-cess, such as data compression (and encryption) or client authentication, can be encapsulated under the concept of remote access capabilities. This paper presents a <b>capabilities</b> <b>based</b> model of com-munication and describes how it is implemented at appli-cation level in a programming environment called Open HPC++. Open HPC++ capabilities are associated with a remote reference and determine the kinds of remote ac-cess that it supports. Capabilities can be exchanged be-tween processes, and can also be changed dynamically to helps applications adapt to varying run-time environments. Capabilities also work with the load-balancing features of Open HPC++ to help applications achieve higher perfor-mance. The paper presents a set of experiments to demon-strate the usefulness of the <b>capabilities</b> <b>based</b> model. It also describes Open HPC++’s communication protocol adap-tivity mechanism, which is the basis of the <b>capabilities</b> <b>based</b> model. 1...|$|R
50|$|Also, {{the task}} {{register}} is expanded in these modes {{to be able}} to hold a 64-bit <b>base</b> <b>address.</b>|$|R
3000|$|... “a dynamic {{global network}} {{infrastructure}} with self- configuring <b>capabilities</b> <b>based</b> on standard and interoperable communication protocols where physical and virtual ‘Things’ have identities, physical attributes, and virtual personalities and use intelligent interfaces, and are seamlessly {{integrated into the}} information network” (Van Kranenburg, 2008).|$|R
50|$|Beyond {{the level}} of vision impairment, {{research}} done at the Central Institute on Employment Abilities of the Handicapped in Moscow has found differences in functional <b>capabilities</b> <b>based</b> on differences in visual acuity. This does not {{play a significant role}} in tandem cycling.|$|R
50|$|Digital synthesis:While it was {{possible}} to create a music workstation with digitally controlled analog synthesis modules, few companies did this, instead seeking to produce new sounds and <b>capabilities</b> <b>based</b> on digital synthesis (early units were based on FM synthesis or sample playback).|$|R
40|$|We {{demonstrate}} a novel technique for generating ultrawideband monocycle pulse with repetition-rate tuning <b>capability</b> <b>based</b> on fiber optical parametric amplifier. High quality monocycle pulse with repetition rate up to 4. 2 GHz is successfully generated. © 2007 Optical Society of America. link_to_subscribed_fulltex...|$|R
5000|$|IRQ, boot ROM, and boot ROM <b>base</b> <b>address</b> {{configured}} with a four-position DIP {{switch block}} at top of card ...|$|R
50|$|Even {{with perfect}} randomization, leakage of memory {{contents}} {{will help to}} calculate the <b>base</b> <b>address</b> of a DLL at runtime.|$|R
50|$|However, one {{can choose}} the index of the first element by an {{appropriate}} choice of the <b>base</b> <b>address</b> B. For example, if the array has five elements, indexed 1 through 5, and the <b>base</b> <b>address</b> B is replaced by B + 30c, then the indices of those same elements will be 31 to 35. If the numbering does not start at 0, the constant B {{may not be the}} address of any element.|$|R
5000|$|The {{subscript}} notation [...] (where [...] designates a pointer) is syntactic sugar for [...] Taking {{advantage of}} the compiler's knowledge of the pointer type, the address that [...] points to is not the <b>base</b> <b>address</b> (pointed to by [...] ) incremented by [...] bytes, but rather is defined to be the <b>base</b> <b>address</b> incremented by [...] multiplied {{by the size of}} an element that [...] points to. Thus, [...] designates the th element of the array.|$|R
50|$|In logical block addressing, {{only one}} number {{is used to}} address data, and each linear <b>base</b> <b>address</b> {{describes}} a single block.|$|R
50|$|For example, if {{an array}} of {{integers}} is stored in a region of the computer's memory starting at the memory cell with <b>address</b> 3000 (the <b>base</b> <b>address),</b> and each integer occupies four cells (bytes), then the elements of this array are at memory locations 0x3000, 0x3004, 0x3008, …, 0x3000 + 4(n − 1). In general, {{the address of the}} ith element of an array with <b>base</b> <b>address</b> b and element size s is b + is.|$|R
