416|706|Public
5000|$|... #Caption: A {{screenshot}} of {{the grammar}} and spell <b>checking</b> <b>tool</b> {{that is available}} to registered users on Orfogrammka.ru.|$|E
5000|$|In Solaris, bcheck ( [...] batch utility for Runtime Checking (RTC)), is {{a memory}} access and memory leak <b>checking</b> <b>tool</b> based on dbx.|$|E
5000|$|The {{mechanic}} installs {{the solid}} lifter and rotates the engine crank until the cam {{is on the}} [...] "base circle" [...] (not on any intake or exhaust cam lobe). An adjustable-length push-rod <b>checking</b> <b>tool</b> is then installed on the valve location being checked. The pushrod length <b>checking</b> <b>tool</b> is extended until there is no slop (zero lash). Then, the <b>checking</b> <b>tool</b> is removed and measured. The mechanic then adds [...]030-.090" [...] of additional length, depending on the specifications of the lifter being installed. [...] A more typical pre-load range used and recommended by most mechanics is {{in the neighborhood of}} [...]030-.060" [...] The length of the adjustable length push-rod plus the desired pre-load chosen then becomes the desired push-rod length that should be installed, which will keep the hydraulic lifter in the middle of its total piston-travel range. Example: Adjustable push-rod at zero lash = 9.0". Desired pre-load = [...]050". 9.0" [...] + [...]050" [...] = 9.050" [...] push-rods should be installed.|$|E
5000|$|Several {{equivalence}} <b>checking</b> <b>tools</b> (minimization and comparisons modulo bisimulation relations), such as BCG_MIN and BISIMULATOR.|$|R
40|$|To {{encourage}} ethical {{practices in}} participatory design with children the <b>CHECk</b> <b>tool</b> was created. This paper reports on an expert {{review of the}} <b>CHECk</b> <b>tool</b> and a validating case study. Four main challenges to the <b>CHECk</b> <b>tool</b> are identified: (1) how to inform children on the research and their role herein, (2) distinguishing between project values and designer or researcher’s personal values, (3) accounting for the dynamic nature and social constructedness of values in design, and (4) the emergence of values in all stakeholders including child design partners. We advocate complementing CHECk with interactive storytelling and show how this narrative {{can be used to}} not only inform participation and achieve ethical symmetry, but also to negotiate values with child design partners...|$|R
3000|$|RQ# 2.3) Can DCL 2 <b>Check</b> <b>tool</b> {{be used in}} real {{software}} development process to perform architectural verification? [...]...|$|R
5000|$|Protocol Verification: This {{involves}} {{converting the}} JSIDL {{definition of a}} service into a PROMELA model, for validation by the SPIN model <b>checking</b> <b>tool.</b> Using PROMELA to model client and server interfaces will allow developers to formally validate JAUS services.|$|E
5000|$|A special gi <b>checking</b> <b>tool</b> {{is often}} used to {{determine}} acceptable measurements and fit of the gi. This tool resembles a block of wood 3.5 cm x 2.5 cm x 15 cm with a slit cut in the middle and is used to measure the following: ...|$|E
50|$|While {{automated}} checking {{tools are}} helpful for website development and maintenance, they cannot guarantee that a document will display as intended in all browsers. Developers should always test documents {{in a variety}} of browsers (including mobile browsers) to locate problems that cannot be detected with a computerized <b>checking</b> <b>tool.</b>|$|E
5000|$|A word {{processor}} (without any spell <b>checking</b> <b>tools)</b> {{can be used}} by pupils who have trouble writing legibly or who are unable to write quickly enough to complete the exam ...|$|R
50|$|Model <b>checking</b> <b>tools</b> were {{initially}} developed to reason about the logical correctness of discrete state systems, but {{have since been}} extended to deal with real-time and limited forms of hybrid systems.|$|R
5000|$|A word {{processor}} (without any spell <b>checking</b> <b>tools)</b> {{can be used}} by students who have trouble writing legibly or who are unable to write quickly enough to complete the exam within the time limit ...|$|R
50|$|A formal {{equivalence}} check {{can be performed}} between any two representations of a design: RTL <> netlist, netlist <> netlist or RTL <> RTL, though the latter is rare compared to the first two. Typically, a {{formal equivalence}} <b>checking</b> <b>tool</b> will also indicate with great precision at which point there exists a difference between two representations.|$|E
50|$|NuSMV is a reimplementation and {{extension}} of SMV symbolic model checker, {{the first model}} <b>checking</b> <b>tool</b> based on Binary Decision Diagrams (BDDs).The tool has been designed as an open architecture for model checking. It is aimed at reliable verification of industrially sized designs, {{for use as a}} backend for other verification tools and as a research tool for formal verification techniques.|$|E
5000|$|As of 2015, {{standardization}} of FFV1 through the Internet Engineering Task Force (IETF) is {{work in progress}} {{as part of the}} European PREFORMA Project, as well as implementation of a conformance checker for FFV1/PCM in a Matroska (MKV) container. Details of FFV1's standardization plan have been prepared by MediaArea (authors of MediaInfo) as part of their conformance <b>checking</b> <b>tool</b> [...] "Media CONCH".|$|E
50|$|Model <b>checking</b> <b>tools</b> face a {{combinatorial}} blow {{up of the}} state-space, {{commonly known}} as the state explosion problem, that must be addressed to solve most real-world problems. There are several approaches to combat this problem.|$|R
30|$|In {{our future}} work, we will {{increase}} the diagnosis granularity by incorporating more finer-grained network state <b>checking</b> <b>tools.</b> We also plan to extend the expressiveness of the current service language to better represent high-level user intents.|$|R
40|$|The {{generalized}} estimating equations (GEE) {{approach has}} been widely used to analyze repeated measures data. However, {{in the absence of}} likelihood ratio tests, model diagnostic <b>checking</b> <b>tools</b> are not well established for the GEE approach, whereas they are for other likelihood-based approaches. Diagnostic <b>checking</b> <b>tools</b> are essential for determining a model's goodness of fit, especially for non-normal data. In this paper, we propose simple residual plots to investigate the goodness of fit of the model based on the GEE approach for discrete data. The proposed residual plots are based on the quantile-quantile (Q-Q) plots of a [chi] 2 -distribution, and are particularly useful for comparing several models simultaneously. ...|$|R
50|$|Rabbit {{is a model}} <b>checking</b> <b>tool</b> for {{real-time}} systems. The modeling {{language are}} timed automata extended with concepts for modular modeling. The tool provides reachability analysis and refinement checking, both implemented using the data structure BDD. Good variable orderings for the BDDs are computed from the modular structure of the model and {{an estimate of the}} BDD size. This leads to a significant performance improvement.|$|E
50|$|Spec# is a {{programming}} language with specification language features that extends {{the capabilities of the}} C# {{programming language}} with Eiffel-like contracts, including object invariants, preconditions and postconditions. Like ESC/Java, it includes a static <b>checking</b> <b>tool</b> based on a theorem prover that is able to statically verify many of these invariants. It also includes a variety of other minor extensions to the language, such as non-null reference types.|$|E
50|$|The Berkeley Lazy Abstraction Software Verification Tool (BLAST) is a {{software}} model <b>checking</b> <b>tool</b> for C programs. The task addressed by BLAST {{is the need}} to check whether software satisfies the behavioral requirements of its associated interfaces. BLAST employs counterexample-driven automatic abstraction refinement to construct an abstract model that is then model-checked for safety properties. The abstraction is constructed on the fly, and only to the requested precision.|$|E
5000|$|Behavioral {{properties}} {{express the}} intended {{functioning of the}} system {{in the form of}} automata (or higher level descriptions, which are then translated into automata). In such a case, the natural approach to verification is equivalence checking, which consists in comparing the system model and its properties (both represented as automata) modulo some equivalence or preorder relation. CADP contains equivalence <b>checking</b> <b>tools</b> that compare and minimize automata modulo various equivalence and preorder relations; some of these tools also apply to stochastic and probabilistic models (such as Markov chains). CADP also contains visual <b>checking</b> <b>tools</b> {{that can be used to}} verify a graphical representation of the system.|$|R
40|$|Purpose: Development of a {{practitioner}} oriented diagnostic framework and health <b>check</b> <b>tool</b> {{to support the}} robust assessment of engineering and technology projects. Design/methodology/approach: The research {{is based on a}} literature review that draws together insights on project assessment and critical success factors to establish an integrated systems view of projects. This is extended to allow a comprehensive diagnostic framework to be developed along with a high-level health <b>check</b> <b>tool</b> that can be readily deployed on projects. The utility of the diagnostic framework and health <b>check</b> <b>tool</b> are explored through three illustrative case studies, with two from Canada and one from the United Kingdom. Findings and Originality/value: The performance of engineering and technology projects can be viewed through a systems perspective and being a function of six contributing subsystems that are: process, technology, resources, impact, knowledge and culture. The diagnostic framework that is developed through this research integrates these sub-systems to provide a robust assessment methodology for projects, which is linked to existing best practice for project reviews, performance management and maturity models. The case studies provide managerial insights that are related to the diagnostic framework but crucially also position the approach in the context of industrial applications for construction engineering and technology management. Research limitations/implications: The case study approach includes two case studies from the construction and facilities development sector with the third case study from the research and technology sector. Further work is required to investigate the use of the diagnostic framework and health <b>check</b> <b>tool</b> in other sectors. Practical implications: The health <b>check</b> <b>tool</b> will be of practical benefit to new projects managers that require access to a robust and convenient project review methodology for assessing the status and health of a given portfolio of projects. The tool can also be used periodically and throughout the project lifecycle in order to track the performance of projects. Originality/value: This paper provides a unique view and supporting management framework to help project managers assess the status and health of projects. Value can be associated with an extension to the literature on diagnostic tools for engineering project management as well as the insights provided in the three international case studies, which explore the scope and applicability of the health <b>check</b> <b>tool</b> to be used in support of projects that have encountered difficulties and which require implementation of project recovery strategies. Peer Reviewe...|$|R
40|$|International audienceWe {{describe}} an event-based approach to specifiy systems with dynamically evolving architecture; {{the study is}} illustrated with the structuring and routing in Mobile Ad-hoc Network. The resulting spec- ification is augmented with desired properties and then analysed using theorem proving and model <b>checking</b> <b>tools...</b>|$|R
50|$|On June 7, 2010, PLT Scheme {{was renamed}} Racket. The {{renaming}} {{coincided with the}} release of Version 5.0. Subsequently, the GUI backend was rewritten in Racket from C++ in Version 5.1 using native UI toolkits on all platforms. Version 5.2 included a background syntax <b>checking</b> <b>tool,</b> a new plotting library, a database library, and a new extended REPL. Version 5.3 included a new submodule feature for optionally loaded modules, new optimization tools, a JSON library, and other features. Version 5.3.1 introduced major improvements to DrRacket: the background syntax checker was turned on by default and a new documentation preview tool was added.|$|E
5000|$|The {{identification}} of overblocked sites is made particularly difficult {{by the fact}} that ISPs do not provide checking tools to allow website owners to determine whether their site is being blocked. In July 2014 the Open Rights Group launched an independent <b>checking</b> <b>tool</b> blocked.org.uk, a revamp of their mobile blocking site to report details of blocking on different fixed line ISPs and mobile providers. The tool revealed that 19% of 100,000 popularly visited websites were being blocked (with significant variation between ISPs) although the percentage of sites hosting legal pornographic material is thought to be around 4%.|$|E
50|$|Hybrid automata come {{in several}} flavors: The Alur-Henzinger hybrid {{automaton}} {{is a popular}} model; it was developed primarily for algorithmic analysis of hybrid systems model checking. The HyTech model <b>checking</b> <b>tool</b> is based on this model. The Hybrid Input/Output Automaton model has been developed more recently. This model enables compositional modeling and analysis of hybrid systems. Another formalism which is useful to model implementations of hybrid automaton is the lazy linear hybrid automaton. A sub-class of hybrid automata are timed automata in which all continuous variables have derivative 1. State reachability is decidable for this sub-class, {{which is why it}} is an interesting formalism for formal verification.|$|E
30|$|It {{is worth}} noting that the {{granularity}} of the faults and their observable symptoms only depends on the SDN symptom-fault reference model, and the availability of various state mismatching (i.e., symptom) <b>checking</b> <b>tools.</b> The model can be extended and continuously updated to improve its accuracy and achieve finer diagnosing granularity.|$|R
40|$|We {{thoroughly}} {{examine the}} experimental batch plant in its two major operation modes: a normal operation mode and a failure operation mode. In {{order to do}} so, we use discrete condition/event system as well as timed automata for the specification and the model <b>checking</b> <b>tools</b> SMV, Kronos and HyTech for verification...|$|R
40|$|Appliance model upgrade {{path and}} {{limitations}} Backing up policies and environment settings Tips for successful upgrade Upgrade checklist and system <b>check</b> <b>tool</b> How to recover if the upgrade runs into problems Transition off-appliance components to 64 -bit platforms 3 7. 6 : A Significant Release Many new features and usability improvements, including...|$|R
50|$|XRumer is a forum {{spamming}} software {{marketed as}} search engine optimization program, created by BotmasterLabs, that {{is able to}} register and post to forums (forum spam) {{with the aim of}} boosting search engine rankings. The program is able to bypass security techniques commonly used by many forums and blogs to deter automated spam, such as account registration, client detection, many forms of CAPTCHAs, and e-mail activation before posting. The program utilises SOCKS and HTTP proxies in an attempt to {{make it more difficult for}} administrators to block posts by source IP and features a proxy <b>checking</b> <b>tool</b> to verify the integrity and anonymity of the proxies used.|$|E
50|$|The concept behind taint {{checking}} is {{that any}} variable that can be modified by an outside user (for example a variable set by a field in a web form) poses a potential security risk. If that variable is used in an expression that sets a second variable, that second variable is now also suspicious. The taint <b>checking</b> <b>tool</b> proceeds variable by variable until it has {{a complete list of}} all variables which are potentially influenced by outside input. If any of these variables is used to execute dangerous commands (such as direct commands to a SQL database or the host computer operating system), the taint checker warns that the program is using a potentially dangerous tainted variable. The computer programmer can then redesign the program to erect a safe wall around the dangerous input.|$|E
40|$|International audienceIn {{time series}} {{analysis}} remaining autocorrelation in the errors of a model implies that it is failing to properly capture the structure of time-dependence of the series under study. This {{can be used as}} a diagnostic <b>checking</b> <b>tool</b> and as an indicator of the adequacy of the model. Through the study of the errors of the model in the Lagrange Multiplier testing framework, in this paper we derive (and validate using simulated and real world examples) a hypothesis test which allows us to determine if there is some left autocorrelation in the error series. This represents a new diagnostic <b>checking</b> <b>tool</b> for fuzzy rule-based modelling of time series and is an important step towards statistically sound modelling strategy for fuzzy rule-based models...|$|E
50|$|MPDS4 {{includes}} {{hard and}} soft clash detection, {{which can be}} applied to a whole project, to separate systems or between selected components. Consistency <b>checking</b> <b>tools</b> allow users to check work against specific design rules. Results can be passed to customisable reports, and components used in a design are automatically included in parts lists.|$|R
40|$|Abstract. Model {{checking}} {{has proven}} to be an effective technology for verification and debugging in hardware and more recently in software domains. We believe that recent trends in both the requirements for software systems and the processes by which systems are developed suggest that domain-specific model checking engines may be more effective than general purpose model <b>checking</b> <b>tools.</b> To overcome limitations of existing tools which tend to be monolithic and non-extensible, we have developed an extensible and customizable model checking framework called Bogor. In this tool paper, we summarize (a) Bogor’s direct support for modeling object-oriented designs and implementations, (b) its facilities for extending and customizing its modeling language and algorithms to create domain-specific model checking engines, and (c) pedagogical materials that we have developed to describe the construction of model <b>checking</b> <b>tools</b> built on top of the Bogor infrastructure...|$|R
50|$|Avinux {{is another}} tool that {{facilitates}} the automatic analysis of Linux device drives and {{is built on}} top of bounded model checker CBMC. There exist fault localization methods to find the bug location as these model <b>checking</b> <b>tools</b> return a long counter example trace {{and it is hard}} to find the exact faulty location.|$|R
