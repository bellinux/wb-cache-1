2|6|Public
40|$|A {{complete}} group presentation {{consists of}} a set of generators and a set of replacement rules generating a well-founded and <b>confluent</b> <b>relation</b> on words, thereby solving the word problem for this presentation. Complete presentations for surface, Coxeter, Dyck and symmetric groups are discussed. These complete presentations possess interesting combinatorial properties and provide uniform algorithms for the word problem...|$|E
40|$|This article aims {{to explore}} the blurred lines of {{thoughts}} on the spirit of translation as a synthetic sign of interaction between the abundant science of cognition and {{the philosophy of the}} unfinalized dialogism of the Russian cultural theorist and social philosopher Mikhail Bakhtin (1895 - 1975). First, it shows the ineluctable view of cultural differences as a house to translation. Second, because humans are different, the article proceeds to reflect the interplay of some views on culture, language and thought, seeking to envisage the <b>confluent</b> <b>relation</b> of the dialogic trans-formation of the act/tact in translation at play. Third, the metaphor of relation is illustrated through the one postcolonial example in the particular setting of the Israel-Palestine political conflict in language. Together with such lines of confluence came a belief about the holistic architectonics of translation in the development of an attitude towards the ‘dialogic turn’ of ‘answerability’ in translation in the future...|$|E
40|$|This paper {{outlines}} various recent {{approaches to}} solving word problems. Term orderings {{are used to}} define a terminating rewrite <b>relation.</b> When <b>confluent,</b> that <b>relation</b> defines unique normal forms {{that can be used}} to decide word problems. Some results obtained by these methods are summarized. 1. Introduction The central idea of rewriting is to impose directionality on the use of equations in proofs. A rewrite rule is an ordered pair of terms, written l ! r. Like equations, rules are used to replace instances of l by corresponding instances of r; unlike equations, rules are not used to replace instances of the right-hand side r. For any given set R of rules, the rewrite relation !R is the closure of R (viewed as a binary relation) under the "replacement" property (within any context) and "fully invariant property" (under any substitution). In other words, s !R t if s contains a subterm that is an instance loe of l, for some rule l ! r in R, and t is s with that subterm replaced by roe [...] ...|$|R
40|$|Indeterminism {{is typical}} for {{concurrent}} computation. If several concurrent actors {{compete for the}} same resource then at most one of them may succeed, whereby {{the choice of the}} successful actor is indeterministic. As a consequence, the execution of a concurrent program may be nonconfluent. Even worse, most observables (termination, computational result, and time complexity) typically depend on the scheduling of actors created during program execution. This property contrast concurrent programs from purely functional programs. A functional program is uniformly confluent in the sense that all its possible executions coincide modulo reordering of execution steps. In this paper, we investigate concurrent programs that are uniformly <b>confluent</b> and their <b>relation</b> to eager and lazy functional programs. We study uniform confluence in concurrent computation within the applicative core of the π-calculus which is widely used in different models of concurrent programming (with interleaving semantics). In particular, the applicative core of the π-calculus serves as a kernel in foundations of concurrent constraint programming with first-class procedure...|$|R
40|$|Narrowing is {{a method}} for solving {{equations}} in the equational theories of term rewriting systems. Unification and rewriting, the central operations in narrowing, are often implemented on graph-like data structures to exploit sharing of common subexpressions. In this paper, we study the completeness of narrowing in graph-based implementations. We show that the well-known condition for the completeness of tree-based narrowing, viz. a normalizing and <b>confluent</b> term rewrite <b>relation,</b> does not suffice. Completeness is restored, however, if the implementing graph rewrite relation is normalizing and confluent. We address basic narrowing and show its completeness for innermost normalizing and confluent graph rewriting. Then we consider the combination of basic narrowing with two strategies for controlling sharing, obtaining minimally collapsing and maximally collapsing basic narrowing. The former is shown to be complete {{in the presence of}} innermost normalization and confluence, the latter in the presence of termination and confluence. Maximally collapsing narrowing sometimes speeds up narrowing derivations drastically. Our results on minimally collapsing basic narrowing correct analogous claims by Krishna Rao [Proc. JICSLP’ 96] which are based on an incomplete version of term graph narrowing...|$|R
40|$|In [7] a {{hierarchy}} of directed acyclic graph (dag) algebras is defined. The dags belonging to an algebra are defined up to an isomorphism which can be expressed by a congruence over a free term algebra, i. e. a dag is described by a congruence class of terms. In this paper {{we deal with the}} following problem: can be defined a canonical form in every congruence class and a canonical (<b>confluent</b> and terminating) <b>relation</b> ! such that for any canonical form w 0 we have w ! ! w 0, for any w in the class [w 0]? 1 Introduction In this paper we consider node-labelled acyclic digraphs, on short dags, which are complete algebraically specified. This means that we consider some atomic constructions - one-node dags and dags defined by relations over finite sets of natural numbers - and operations which with new graphs are constructed. The operations satisfy some laws stated as equations. The set of equations is complete in the sense that two expressions define the same dag iff they can be transforme [...] ...|$|R
40|$|We {{consider}} the orthogonal polynomials on [- 1, 1] {{with respect to}} the weight w_c(x) =h(x) (1 -x) ^α(1 +x) ^βΞ_c(x), α, β >- 1, where h is real analytic and strictly positive on [- 1, 1], and Ξ_c is a step-like function: Ξ_c(x) = 1 for x∈ [- 1, 0) and Ξ_c(x) =c^ 2, c> 0, for x∈ [0, 1]. We obtain strong uniform asymptotics of the monic orthogonal polynomials in C, as well as first terms of the asymptotic expansion of the main parameters (leading coefficients of the orthonormal polynomials and the recurrence coefficients) as n→∞. In particular, we prove for w_c a conjecture of A. Magnus regarding the asymptotics of the recurrence coefficients. The main focus is on the local analysis at the origin. We study the asymptotics of the Christoffel-Darboux kernel in a neighborhood of the jump and show that the zeros of the orthogonal polynomials no longer exhibit the clock behavior. For the asymptotic analysis we use the steepest descendent method of Deift and Zhou applied to the non-commutative Riemann-Hilbert problems characterizing the orthogonal polynomials. The local analysis at x= 0 is carried out in terms of the confluent hypergeometric functions. Incidentally, we establish some properties of these functions that may have an independent interest. Comment: 48 pages, 5 figures. New structure, further results on <b>confluent</b> hypergeometric functions, <b>relation</b> with de Brange space of analytic function...|$|R
40|$|International audienceIndeterminism {{is typical}} for {{concurrent}} computation. If several concurrent actors {{compete for the}} same resource then at most one of them may succeed, whereby {{the choice of the}} successful actor is indeterministic. As a consequence, the execution of a concurrent program may be nonconfluent. Even worse, most observables (termination, computational result, and time complexity) typically depend on the scheduling of actors created during program execution. This property contrast concurrent programs from purely functional programs. A functional program is uniformly confluent in the sense that all its possible executions coincide modulo reordering of execution steps. In this paper, we investigate concurrent programs that are uniformly <b>confluent</b> and their <b>relation</b> to eager and lazy functional programs. We study uniform confluence in concurrent computation within the applicative core of the pi-calculus which is widely used in different models of concurrent programming (with interleaving semantics). In particular, the applicative core of the pi-calculus serves as a kernel in foundations of concurrent constraint programming with first-class procedures (as provided by the programming language Oz). We model eager functional programming in the lambda-calculus with weak call-by-value reduction and lazy functional programming in the call-by-need lambda-calculus with standard reduction. As a measure of time complexity, we count application steps. We encode the lambda-calculus with both above reduction strategies into the applicative core of the pi-calculus and show that time complexity is preserved. Our correctness proofs employs a new technique based on uniform confluence and simulations. The strength of our technique is illustrated by proving a folk theorem, namely that the call-by-need complexity of a functional program is smaller than its call-by-value complexity. The unabridged version of this article is available from Uniform: 99. Due to lack of space, the journal version does not contain the encoding of the delta-calculus (introduced in the paper) into the applicative core of the pi-calculus which is of its own interest...|$|R

