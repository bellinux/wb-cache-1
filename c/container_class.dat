24|117|Public
25|$|Thus, a Lisp list is not {{an atomic}} object, as an {{instance}} of a <b>container</b> <b>class</b> in C++ or Java would be. A list {{is nothing more than}} an aggregate of linked conses. A variable which refers to a given list is simply a pointer to the first cons in the list. Traversal of a list can be done by cdring down the list; that is, taking successive cdrs to visit each cons of the list; or by using any of several higher-order functions to map a function over a list.|$|E
5000|$|The new classes fulfill all the {{requirements}} of a <b>container</b> <b>class,</b> and have all the methods needed to access elements: , , , [...]|$|E
5000|$|Perst {{provides}} {{a subset of}} SQL for filtering elements of a <b>container</b> <b>class.</b> For access to stored objects, Perst implements specialized collection classes including: ...|$|E
5000|$|<b>Container</b> <b>classes</b> are {{expected}} to implement methods to do the following: ...|$|R
5000|$|Generalized <b>container</b> <b>classes</b> for {{representing}} gridded and {{tabular data}} as multidimensional arrays or tables ...|$|R
40|$|The {{maturity}} of object-oriented methods {{has led to}} the wide availability of <b>container</b> classes: <b>classes</b> that encapsulate classical data structures and algorithms. <b>Container</b> <b>classes</b> are included in the C++ and Java standard libraries, and in many proprietary libraries. The wide availability and use of these classes makes reliability essential, and testing plays a central role in achieving that reliability. The large number of cases necessary for thorough testing of <b>container</b> <b>classes</b> makes automated testing essential. This paper presents a novel approach for automated testing of <b>container</b> <b>classes</b> based on combinatorial algorithms for state generation. The approach is illustrated with black-box and white-box test drivers for a class implemented with the red-black tree data structure, used widely in industry and, in particular, in the C++ Standard Template Library. The white-box driver is based on a new algorithm for red-black tree generation. The drivers are evaluated experiment [...] ...|$|R
5000|$|Many ways {{of viewing}} program state and data, {{including}} multiple watch windows, threads, call stack, and modules. The way library and user data types are displayed can be configured (e.g., to show {{contents of a}} <b>container</b> <b>class,</b> rather than its raw structure).|$|E
5000|$|Introduced in the Java JDK 1.2 release, the [...] {{interface}} {{allows the}} iteration of container classes. Each [...] provides a [...] and [...] method, and may optionally support a [...] method. Iterators {{are created by}} the corresponding <b>container</b> <b>class,</b> typically by a method named [...]|$|E
5000|$|NSArray *a = new; // Any <b>container</b> <b>class</b> can be substitutedfor(id obj in a) { // Note {{the dynamic}} typing (we {{do not need}} to know the // Type of object stored in 'a'. In fact, there can be // many {{different}} types of object in the array. printf("%s\n", UTF8String); // Must use UTF8String with %s NSLog(@"%@", obj); // Leave as an object} ...|$|E
5000|$|C++: Used in Standard Template Library and the C++ {{standard}} {{library to}} support generic <b>container</b> <b>classes</b> {{and in the}} Boost TypeTraits library.|$|R
5000|$|Like other {{standard}} code libraries, {{they provide the}} programmer a well-known set of useful facilities, such as <b>container</b> <b>classes</b> and regular expression processing.|$|R
50|$|As {{a general}} rule, the {{framework}} makes as much use as possible of the Standard Template Library, avoiding duplication {{of work on}} things like <b>container</b> <b>classes,</b> or string handling.|$|R
50|$|In computing, {{sequence}} containers {{refer to}} a group of <b>container</b> <b>class</b> templates in the standard library of the C++ programming language that implement storage of data elements. Being templates, they can be used to store arbitrary elements, such as integers or custom classes. One common property of all sequential containers is that the elements can be accessed sequentially. Like all other standard library components, they reside in namespace std.|$|E
50|$|In February 2017, version 6.0 was released, CMS users {{now have}} build-in search in the console, visual {{components}} for much {{easier access to}} adding features and functions to content. Web developers can surface advanced faceted search, build components and use the new <b>Container</b> <b>Class</b> feature to tailor the user experience when editing content. At this point the name changed back to C1 CMS to refer back to the free open source C1 CMS i well known for.|$|E
50|$|The {{primary purpose}} of an {{iterator}} is to allow a user to process every element of a container while isolating the user from the internal structure of the container. This allows the container to store elements in any manner it wishes while allowing the user to treat {{it as if it}} were a simple sequence or list. An iterator class is usually designed in tight coordination with the corresponding <b>container</b> <b>class.</b> Usually, the container provides the methods for creating iterators.|$|E
40|$|The {{maturity}} of object-oriented methods {{has led to}} the wide availability of <b>container</b> classes: <b>classes</b> that encapsulate classical data structures and algorithms. <b>Container</b> <b>classes</b> are included in the C� � and Java standard libraries, and in many proprietary libraries. The wide availability and use of these classes makes reliability important, and testing plays a central role in achieving that reliability. The large number of cases necessary for thorough testing of <b>container</b> <b>classes</b> makes automated testing essential. This paper presents a novel approach for automated testing of <b>container</b> <b>classes</b> based on combinatorial algorithms for state generation. The approach is illustrated with black-box and white-box test drivers for a class implemented with the red–black tree data structure, used widely in industry and, in particular, in the C� � Standard Template Library. The white-box driver is based on a new algorithm for red–black tree generation. The drivers are evaluated experimentally, providing quantitative measures of their effectiveness in terms of block and path coverage. The results clearly show that the approach is affordable in terms of development cost and execution time, and effective with respect to coverage achieved. The results also provide insight into the relative advantages of black-box and white-box drivers, and into the difficult problem of infeasible paths. Copyright © 2000 John Wiley & Sons, Ltd. key words: automated testing; object-oriented; black-box; white-box; C+...|$|R
40|$|<b>Container</b> <b>classes</b> in {{object-oriented}} languages often {{suffer from}} the problem of compiler-generated temporaries. Storage is allocated for each intermediate result in each expression, introducing huge penalties to performance. Loop fusion and array contraction, the most closely related compiler optimizations to this problem, are not powerful enough to optimize the <b>container</b> <b>classes.</b> The current workaround is to perform a manual optimization called Expression Templates (ETs), which utilizes C++ templates to perform arbitrary code generation, but is a very messy and inefficient way of doing things. We present a compiler alternative to ETs that uses programmer annotations to eliminate temporaries through expression fusion. Our solution is much better for programmer productivity than ETs, and also achieves results that are slightly better. iii Table of Content...|$|R
40|$|Version 1. 5 of the Java {{programming}} language will include gener-ics, a language construct for associating typeparameterswith classes and methods. Generics are particularly useful for creating statically type-safe, reusable <b>container</b> <b>classes</b> such that a store of an inappro-priate type causes a compile-time error, {{and that no}} down-casting is needed when retrieving elements. The standard libraries released with Java 1. 5 will include generic versions of popular <b>container</b> <b>classes</b> such as HashMap and ArrayList. This paper presents a method for refactoring Java programs that use current <b>container</b> <b>classes</b> into equivalent Java 1. 5 programs that use their new generic counterparts. Our method uses a variation on an existing model of type constraints to infer the element types of container objects, and it is parameterized by how much, if any, context sensitivity to exploit when generating these type constraints. We present both a context-insensitive instantiation of the framework and one using a low-cost variation on Agesen’s Cartesian Product Algorithm. The method has been implemented in Eclipse, a popular open-source development environment for Java. We evaluated our approach on several small benchmark programs, and found that, {{in all but one}} case, between 40 % and 100 % of all casts can be removed. 1...|$|R
5000|$|... is a <b>container</b> <b>class</b> {{template}} that implements a double-ended queue. It provides similar computational complexity to [...] {{for most}} operations, with {{the notable exception}} that it provides amortized constant-time insertion and removal from {{both ends of the}} element sequence. Unlike , [...] uses discontiguous blocks of memory, and provides no means to control the capacity of the container and the moment of reallocation of memory. Like , [...] offers support for random access iterators, and insertion and removal of elements invalidates all iterators to the deque.|$|E
50|$|Thus, a Lisp list is not {{an atomic}} object, as an {{instance}} of a <b>container</b> <b>class</b> in C++ or Java would be. A list {{is nothing more than}} an aggregate of linked conses. A variable which refers to a given list is simply a pointer to the first cons in the list. Traversal of a list can be done by cdring down the list; that is, taking successive cdrs to visit each cons of the list; or by using any of several higher-order functions to map a function over a list.|$|E
5000|$|Iterators {{are usually}} used in pairs, where one {{is used for}} the actual {{iteration}} and the second serves to mark the end of the collection. The iterators are created by the corresponding <b>container</b> <b>class</b> using standard methods such as [...] and [...] The iterator returned by [...] points to the first element, while the iterator returned by [...] is a special value that does not reference any element. When an iterator is advanced beyond the last element it is by definition equal to the special end iterator value.|$|E
40|$|A pooled, shared C++ {{allocator}} {{developed for}} use with the Standard Template Library (STL) is described. The allocator facilitates communication and control between multiple processes using data organized in STL <b>container</b> <b>classes.</b> The open source system has been compiled and tested on the Linux operating system. ...|$|R
5000|$|Widget toolkits use special widgets {{also called}} Containers to group the other widgets {{together}} (windows, panels, ...). Apart from their graphical properties, {{they have the}} same type of behavior as <b>container</b> <b>classes,</b> as they keep a list of their child widgets, and allow to add, remove, or retrieve widgets amongst their children.|$|R
2500|$|Enumerators are {{typically}} obtained {{by calling the}} [...] method of an object implementing the [...] interface. <b>Container</b> <b>classes</b> typically implement this interface. However, the foreach statement in C# can operate on any object providing such a method, even if it doesn't implement [...] This interface was expanded into generic version in [...]NET 2.0.|$|R
50|$|In 2004, {{generics}} {{were added}} to the Java language, as part of J2SE 5.0. Prior to the introduction of generics, each variable declaration had to be of a specific type. For container classes, for example, this is a problem because there is no easy way to create a container that accepts only specific types of objects. Either the container operates on all subtypes of a class or interface, usually , or a different <b>container</b> <b>class</b> has to be created for each contained class. Generics allow compile-time type checking without having to create many container classes, each containing almost identical code. In addition to enabling more efficient code, certain runtime exceptions are prevented from occurring, by issuing compile-time errors. If Java prevented all runtime type errors ('s) from occurring, it would be type safe.|$|E
5000|$|This simple example {{shows the}} {{situation}} described above. This example is only illustrative {{and will not}} offer any actual drawing of geometric objects, nor specification of what they look like.// Servant class, offering its functionality to classes implementing// Movable Interfacepublic class MoveServant { // Method, which will move Movable implementing class to position where public void moveTo(Movable serviced, Position where) { // Do some other stuff to ensure it moves smoothly and nicely, this is // the place to offer the functionality serviced.setPosition(where); } // Method, which will move Movable implementing class by dx and dy public void moveBy(Movable serviced, int dx, int dy) { // {{this is the place}} to offer the functionality dx += serviced.getPosition (...) [...]xPosition; dy += serviced.getPosition (...) [...]yPosition; serviced.setPosition(new Position(dx, dy)); }}// Interface specifying what serviced classes needs to implement, to be// serviced by servant.public interface Movable { public void setPosition(Position p); public Position getPosition (...)}// One of geometric classespublic class Triangle implements Movable { // Position of the geometric object on some canvas private Position p; // Method, which sets position of geometric object public void setPosition(Position p) { this.p = p; } // Method, which returns position of geometric object public Position getPosition (...) { return this.p; }}// One of geometric classespublic class Ellipse implements Movable { // Position of the geometric object on some canvas private Position p; // Method, which sets position of geometric object public void setPosition(Position p) { this.p = p; } // Method, which returns position of geometric object public Position getPosition (...) { return this.p; }}// One of geometric classespublic class Rectangle implements Movable { // Position of the geometric object on some canvas private Position p; // Method, which sets position of geometric object public void setPosition(Position p) { this.p = p; } // Method, which returns position of geometric object public Position getPosition (...) { return this.p; }}// Just a very simple <b>container</b> <b>class</b> for position.public class Position { public int xPosition; public int yPosition; public Position(int dx, int dy) { xPosition = dx; yPosition = dy; }} ...|$|E
40|$|Java {{applications}} often cast types {{when they}} use the standard library container classes because their element types are Object, and the casting degrades the performance. To cope with this problem, we are developing a bytecode optimizer that eliminates the casts by specializing the container element types. Our optimizer creates a <b>container</b> <b>class</b> specializing its element type for the target program, rewrites the target program so that it uses the specialized class instead of the standard library <b>container</b> <b>class,</b> and then eliminates the casts. The preliminary evaluation using SPECjbb 2005 showed that the cast elimination improves the performance by 14. 8 %...|$|E
40|$|Generating {{test data}} for Object-Oriented (OO) {{software}} {{is a hard}} task. Little {{work has been done}} on the subject, and a lot of open problems still need to be investigated. In this paper we focus on <b>container</b> <b>classes.</b> They are used in almost every type of software, hence their reliability is of utmost importance. We present novel techniques to generate test data for <b>container</b> <b>classes</b> in an automatic way. A new representation with novel search operators is described and tested. A way to reduce the search space for OO software is presented. This is achieved by dynamically eliminating the functions that cannot give any further help from the search. Besides, the problem of applying the branch distances of disjunctions and conjunctions to OO software is solved. Finally, Hill Climbing, Genetic Algorithms and Memetic Algorithms are used and compared. Our empirical case study shows that our Memetic Algorithm outperforms the other algorithms...|$|R
40|$|This paper {{describes}} {{the translation of}} Object-Z specifications of <b>container</b> <b>classes</b> to C++ rest oracle classes. It presents a three-stage translation process and describes how the derived test oracles are integrated into the ClassBench testing framework. The method caters for object-oriented features such as inheritance and aggregation. Translation issues and limitations of the method are discussed. Our approach is illustrated with an example based on an integer set class...|$|R
50|$|The C++ Standard Library defines four {{associative}} <b>container</b> <b>classes.</b> These classes {{allow the}} user to look up a value based on a value of that type. The map containers allow {{the user to}} specify a key and a value, where lookup is done by key and returns a value. However, the lookup is always done by the specific key type, {{whether it is the}} key as in maps or the value itself as in sets.|$|R
40|$|In {{the shelf}} {{area of the}} {{north-western}} Black Sea, samples were collected over the water column using 1) manual collection from a rubber boat for the Danube mouth area, 2) pumping for the shallow waters of the shelf and 3) GoFlo bottles for the shelf break area. Samples were filtered under nitrogen flux inside a clean <b>container</b> (<b>class</b> 100, US norm). JRC. (EI) -Environment Institut...|$|E
40|$|Abstract—As {{the number}} of {{execution}} environments and application contexts rises exponentially, ever-changing non-functional requirements can lead to repeated code refactoring. In addition, scaling up software to support large input sizes may require major modification of code. To address these challenges, we have previously proposed a framework of self-adaptive containers which can automatically adjust their resource usage to meet Service Level Objectives and dynamically deploy the techniques of out-of-core storage and probabilistic data structures. A prototype with limited functionalities was implemented and applied to explicit state space exploration to prove the viability of our framework. In this paper, we broaden the library’s functionalities through support for the important <b>container</b> <b>class</b> of key-value stores and integration of priority queues ’ functionalities into our previously-developed <b>container</b> <b>class.</b> We then utilise them in a new case study centred on route planning, adopting Dijkstra’s shortest path algorithm. For this, a graph representing the full USA road network, which contains approximately 24 million nodes and 58 million arcs, is input to the algorithm so as to find the shortest paths from a random node {{to all the other}} nodes. The experimental results have shown that, under particular Service Level Objectives our library reduces update time by 21. 4 %, primary memory usage of node storage by 85. 3 %, and primary memory consumption required by the priority queue by 78 %, compared with the Standard Template Library...|$|E
40|$|The {{computing}} power of recent massively parallel supercomputers is {{rising to the}} challenge of exploding demands for speed and memory that can be dedicated to a single problem. Still the difficulty in parallel programming persists and there is increasing demand for high level support for building discrete event models to execute on such platforms. We present a parallel DEVS-based (Discrete Event System Specification) simulation environment that can execute on distributed memory multicomputer systems. Underlying the environment is a parallel <b>container</b> <b>class</b> library for hiding the details of message passing technology while providing high level abstractions for hierarchical, modular DEVS models. The objective of Heterogeneous <b>Container</b> <b>Class</b> Library (HCCL) is to provide convenient object-oriented primitives for utilizing a collection of distributed computing resources to solve large problems and to speed up computations. Implemented by ensemble methods, parallel <b>container</b> <b>class</b> provides concurrency and a parallel computing paradigm at a higher level of abstraction encapsulating the details of the underlying message passing mechanisms. The difficulty of the synchronization problem was reduced by the inherent nature of ensemble method primitives. The DEVS/containers architecture for parallel simulation was first implemented on a massively parallel platform (CM- 5) using CMMD message passing library. Then the SP 2 implementation uses portable MPI so that the simulation architecture can be mapped to any heterogeneous and distributed computing environment. Observed performance of the C++ implementation working on the Thinking Machines CM- 5 and IBM SP 2 for high resolution ecosystem models demonstrates that high performance need not be sacrificed in providing high level abstractions to the discrete event modelling. The study of performance and exploitation of the natural parallelism in hierarchical discrete event models are also supported by capability of mapping DEVS models to the processors. The closure under coupling property and a mail message approach to interprocessor communication enable a user to easily partition and map DEVS models onto parallel platforms. We study how the mapping of DEVS models affect the performance and the efficiency of parallel simulation. The results are in agreement with earlier theory which predicts that optimal mappings are predictably influenced by communication overhead and communication/computation ratio...|$|E
50|$|In {{addition}} to C's style of procedural programming, C++ directly supports {{certain forms of}} object-oriented programming, generic programming, and metaprogramming. C++ also comes with a large standard library that includes several <b>container</b> <b>classes.</b> Similarly, Objective-C adds object-oriented programming, dynamic typing, and reflection to C. Objective-C {{does not provide a}} standard library per se, but in most places where Objective-C is used, it is used with an OpenStep-like library such as OPENSTEP, Cocoa, or GNUstep, which provides functionality similar to C++'s standard library.|$|R
40|$|Abstract. Component-based {{software}} development heavily {{relies on the}} ability of reusing components from a library with as little effort as possible. Among others, valuable features for reusing from a component library are: adaptability to many contexts, extensibility, abstraction and high level of robustness with respect to changes in some of their components. In this paper we study {{one of the most widely}} used component library for Ada 95, the Grady Booch’s one, mainly in relation to these features. Our study focuses on the Container-classes family, which present some drawbacks mainly due to the fact that some parent-classes depend on the concrete form of their children-classes. We propose a solution centred on changing the <b>Containers</b> base <b>class.</b> This new version of the <b>Containers</b> <b>class</b> offers a new concept, namely shortcut, that allows not only to avoid the dependencies between parent-classes and their children classes, but also offers some additional advantages, remarkably improving the efficiency of components. ...|$|R
5000|$|Mærsk E-class <b>container</b> ship, the <b>class</b> {{preceding}} the Triple E ...|$|R
