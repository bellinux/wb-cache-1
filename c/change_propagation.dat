315|551|Public
2500|$|From the outset, Revit was {{intended}} to allow architects and other building professionals to design and document a building by creating a parametric three-dimensional model that included both the geometry and non-geometric design and construction information, which {{is also known as}} Building Information Modeling or BIM (1975 Eastman C.). At the time, several other software packages such as ArchiCAD and Reflex allowed working with a three-dimensional virtual building model, and allowed individual components to be controlled by parameters (parametric components). Two key differences in Revit were that its parametric components were created using a graphical [...] "family editor" [...] rather than a programming language, and all relationships between components, views, and annotations were captured by the model so that a change to any element would automatically propagate to keep the model consistent. For example, moving a wall would update the neighboring walls, floors, and roofs, correct the placement and values of dimensions and notes, adjust the floor areas reported in schedules, redraw section views, etc., so that the model would remain connected and all documentation would be coordinated. The concept of bi-directional associativity between components, views, and annotations was a distinguishing feature of Revit for many releases. The ease of making changes inspired the name Revit, a contraction of Revise-It. At the heart of Revit is a parametric <b>change</b> <b>propagation</b> engine that relied on a new technology, context-driven parametrics, that was more scalable than the variational and history-driven parametrics used in mechanical CAD software. [...] The term Parametric Building Model was adopted to reflect the fact that changes to parameters drove the whole building model and associated documentation, not just individual components.|$|E
5000|$|JTL : a {{bidirectional}} model transformation language {{specifically designed}} to support non-bijective transformations and <b>change</b> <b>propagation</b> (see http://jtl.di.univaq.it/).|$|E
50|$|Supporting ADLs {{interoperability}} and <b>change</b> <b>propagation</b> {{is intrinsically}} complex. Furthermore, {{the lack of}} automation does not allow the easy addition of new description languages, and does not guarantee <b>change</b> <b>propagation</b> to multiple models in {{a finite number of}} steps. In general, changes occurring in an architecture model have a strong impact on all the other related architecture models (each of them possibly conforming to different architecture description languages). In order to keep models in a consistent state, changes need to be propagated from the updated model to all the others. When dealing with multiple architecture description languages, propagating changes may be a complex task; such a task is inevitable and requires to be managed by a dedicated approach.|$|E
3000|$|The {{adaptive}} weight cannot <b>change</b> the <b>propagation</b> threshold, {{but it can}} {{induce the}} alcoholism to decay quickly; [...]...|$|R
2500|$|... where sech is the {{hyperbolic}} secant. It still {{depends on}} z, {{but only in}} phase, so {{the shape of the}} field will not <b>change</b> during <b>propagation.</b>|$|R
40|$|The paper {{presents}} a differential interferometry phenomenon in a planar optical structure, {{which uses a}} ferronematic layer of a liquid crystal. This layer <b>changes</b> <b>propagation</b> conditions for TM modes in external magnetic field. Due to the magnetic field action on a ferronematic layer which covers the planar waveguide coated with an additional orientative layer, the ellipsoid of the refractive index changes its orientation in a polarization plane of the TM mode. In consequence, the phase difference of the TM mode occurs under magnetic field influence. This paper provides {{an analysis of the}} influence of a thickness and a refractive index of the orientative layer on interference phenomenon in analyzed structure...|$|R
50|$|JRipples is {{a change}} impact {{analysis}} tool for the Java programming language. It helps a developer calculate the impact of software change. It is an open source Eclipse plug-in. The tool not only give relevant program analysis, but it also organizes the steps of <b>change</b> <b>propagation.</b>|$|E
50|$|Evaluation of {{reactive}} {{programs is}} not necessarily based on how stack based programming languages are evaluated. Instead, when some data is changed, the change is propagated to all data that is derived partially or completely from the data that was changed. This <b>change</b> <b>propagation</b> could be achieved {{in a number of}} ways, where perhaps the most natural way is an invalidate/lazy-revalidate scheme.|$|E
50|$|At the {{implementation}} level, event reaction {{consists of the}} propagation across a graph's information, which characterizes the existence of change. Consequently, computations that are affected by such change, then become outdated, and must be flagged for re-execution. Such computations, are then usually characterized by the transitive closure {{of the change in}} its associated source. <b>Change</b> <b>propagation</b> may then lead to an update {{in the value of the}} graph's sinks.|$|E
25|$|The {{average person}} can notice {{the effects of}} <b>changes</b> in radio <b>propagation</b> in several ways.|$|R
2500|$|In optics, {{the term}} soliton {{is used to}} refer to any optical field that does not <b>change</b> during <b>propagation</b> because of a {{delicate}} balance between nonlinear and linear effects in the medium. There are two main kinds of solitons: ...|$|R
30|$|The <b>change</b> of <b>propagation</b> {{velocity}} of elastic wave {{due to the}} static stress cannot be expressed essentially by the infinitesimal elastic theory. The second and the third-order elastic moduli and additional elastic strains contribute to the <b>change</b> in <b>propagation</b> velocity. The analysis of the applied stress, strain, infinitesimal stress of elastic wave and its strain related to an isotropic elastic body were performed using the theory of Murnaghan combined with the Lagrangian description. The formulas are lengthy, but the contents is simple. Our analytical procedure is different to that of Hughes and Kelly (1953), however the results obtained were equivalent {{in regard to the}} equations giving the propagation {{velocity of}} an elastic wave.|$|R
50|$|The quality {{engineering}} process has to integrate any existing sub-processes that may comprise highly structured {{processes such as}} IT service management and processes with limited structure such as agile software development. Another important aspect is change-driven procedure, where change events, such as changed requirements are {{dealt with in the}} local context of information and actors affected by such change. A pre-requisite for this is methods and tools, which support <b>change</b> <b>propagation</b> and change handling.|$|E
50|$|Graph {{propagated}} {{information can}} {{consist of a}} node's complete state, i.e., the computation result of the involved node. In such cases, the node's previous output is then ignored. Another method involves delta propagation i.e. incremental <b>change</b> <b>propagation.</b> In this case, information is proliferated along a graph's edges which consist only of deltas describing how the previous node was changed. This approach is especially important when nodes hold large amounts of state data, which would otherwise be expensive to recompute from scratch.|$|E
50|$|While DUALLy {{transforms}} a model {{into any}} other by passing first through an A0 model, model changes are propagated accordingly {{first to the}} A0 model and successively forwarded to any other architectural model (it has to {{be noted that the}} obtained result is independent from the order followed in the forwarding). Under the assumption that concurrent modifications to different models cannot apply, the DUALLY architecture ensures the convergence of the <b>change</b> <b>propagation</b> process, that is, it ensures by construction that a modification of a model within the network is propagated to all the other models in a finite number of steps.|$|E
40|$|Abstract. Using {{satellite}} altimetry data, we {{have observed}} {{a series of}} anticyclonic eddies as they form at the Big Island of Hawaii and have tracked them as they {{move away from the}} island. While similar eddies have been observed near the Hawaiian Islands in previous studies, the fate of the anticyclonic eddies has previously been unclear. The eddies that we observed initially propagated to the southwest but consistently <b>changed</b> <b>propagation</b> direction to the northwest later in their lifetimes. This was intriguing to us, as theoretically, the decay of isolated anticyclonic eddies on a/ 3 plane should cause them to continually move toward the southwest. Such isolated eddy dynamics are unable to account for the observed change to northwestward eddy propagation, and the presence of the westward flowing North Equatorial Current turns out to be important to the Big Island eddy dynamics. The eddies are not passively advected by the North Equatorial Current; rather, the mean flow <b>changes</b> the <b>propagation</b> characteristics of the eddies. An existing theory that includes meridionally varying, purely zonal mean flow is shown to account for the observed propagation of the Big Island eddies if the zonal variation of the mean flow is considered...|$|R
5000|$|Optical solitons, an {{equilibrium}} {{solution for}} either an optical pulse (temporal soliton) or spatial mode (spatial soliton) {{that does not}} <b>change</b> during <b>propagation</b> due to a balance between dispersion and the Kerr effect (e.g. self-phase modulation for temporal and self-focusing for spatial solitons).|$|R
3000|$|... can be {{obtained}} from the measured stress and the <b>change</b> ratio in <b>propagation</b> velocity. The coefficients Î± [...]...|$|R
50|$|User {{provisioning}} {{refers to}} the creation, maintenance and deactivation of user objects and user attributes, as they exist {{in one or more}} systems, directories or applications, in response to automated or interactive business processes. User provisioning software may include {{one or more of the}} following processes: <b>change</b> <b>propagation,</b> self-service workflow, consolidated user administration, delegated user administration, and federated change control. User objects may represent employees, contractors, vendors, partners, customers or other recipients of a service. Services may include electronic mail, inclusion in a published user directory, access to a database, access to a network or mainframe, etc. User provisioning is a type of identity management software, particularly useful within organizations, where users may be represented by multiple objects on multiple systems and multiple instances.|$|E
50|$|An {{unlimited}} time period, and {{an unlimited}} {{evolution of the}} system is considered. This means that the system becomes even larger {{in the sense that the}} primitives, and the number of dependencies between them, become infinite or unbounded for an infinite time. This assumption is called the assumption of unlimited systems evolution. The concept of stability demands that the amount of impacts caused by a change cannot be related to the size of the system, and therefore remains constant over time as the system grows. In other words, stability demands that the impact of a change is only dependent on the nature of the change itself. Conversely, the authors term changes, causing impacts that are dependent on the nature of the change itself, as well as the size of the system, combinatorial effects. Combinatorial effects should be eliminated from the system in order to attain stability. Indeed, no <b>change</b> <b>propagation</b> effects should be present within an information system, meaning that a specific change to an information system should require the same effort, irrespective of the information system's size or point in time when being applied.|$|E
5000|$|From the outset, Revit was {{intended}} to allow architects and other building professionals to design and document a building by creating a parametric three-dimensional model that included both the geometry and non-geometric design and construction information, which {{is also known as}} Building Information Modeling or BIM (1975 Eastman C.). At the time, several other software packages such as ArchiCAD and Reflex allowed working with a three-dimensional virtual building model, and allowed individual components to be controlled by parameters (parametric components). Two key differences in Revit were that its parametric components were created using a graphical [...] "family editor" [...] rather than a programming language, and all relationships between components, views, and annotations were captured by the model so that a change to any element would automatically propagate to keep the model consistent. For example, moving a wall would update the neighboring walls, floors, and roofs, correct the placement and values of dimensions and notes, adjust the floor areas reported in schedules, redraw section views, etc., so that the model would remain connected and all documentation would be coordinated. The concept of bi-directional associativity between components, views, and annotations was a distinguishing feature of Revit for many releases. The ease of making changes inspired the name Revit, a contraction of Revise-It. At the heart of Revit is a parametric <b>change</b> <b>propagation</b> engine that relied on a new technology, context-driven parametrics, that was more scalable than the variational and history-driven parametrics used in mechanical CAD software. [...] The term Parametric Building Model was adopted to reflect the fact that changes to parameters drove the whole building model and associated documentation, not just individual components.|$|E
30|$|In {{multi-path}} indoor environment, wireless signals can <b>change</b> signal <b>propagation</b> in a {{more complicated}} way through reflection, diffraction and scattering, and human motion, which results in different amplitude signals under different sensitivities [47]. We were tested under three scenes line-of-sight distance, non-line-of-sight distance, and wall.|$|R
30|$|Coincidentally, we {{get that}} {{matrices}} F and V in model (12) {{are the same as}} that in model (11). Therefore, the reproduction number R_ 0 of model (12) is also given by (15), which implies that the adaptive weights cannot <b>change</b> the <b>propagation</b> threshold.|$|R
3000|$|... {{is set to}} a half of the new {{measured}} RTT. This reset operation {{allows the}} modified loss differentiation scheme to adapting itself to the <b>change</b> in <b>propagation</b> delay due to vertical handover to new wireless network. Furthermore, the modified loss differentiation is not invoked by three-duplicate ACKs for [...]...|$|R
5000|$|... // Hardware-specific support {{functions}} that MUST be customized:#define I2CSPEED 100void I2C_delay(void);bool read_SCL(void); // Return {{current level of}} SCL line, 0 or 1bool read_SDA(void); // Return current level of SDA line, 0 or 1void set_SCL(void); // Do not drive SCL (set pin high-impedance)void clear_SCL(void); // Actively drive SCL signal lowvoid set_SDA(void); // Do not drive SDA (set pin high-impedance)void clear_SDA(void); // Actively drive SDA signal lowvoid arbitration_lost(void);bool started = false; // global datavoid i2c_start_cond(void) { if (started) { [...] // if started, do a restart condition // set SDA to 1 set_SDA (...) I2C_delay (...) set_SCL (...) while (read_SCL (...) == 0) { // Clock stretching // You should add timeout to this loop } // Repeated start setup time, minimum 4.7us I2C_delay (...) } if (read_SDA (...) == 0) { arbitration_lost (...) } // SCL is high, set SDA from 1 to 0. clear_SDA (...) I2C_delay (...) clear_SCL (...) started = true;}void i2c_stop_cond(void) { // set SDA to 0 clear_SDA (...) I2C_delay (...) set_SCL (...) // Clock stretching while (read_SCL (...) == 0) { // add timeout to this loop. } // Stop bit setup time, minimum 4us I2C_delay (...) // SCL is high, set SDA from 0 to 1 set_SDA (...) I2C_delay (...) if (read_SDA (...) == 0) { arbitration_lost (...) } clear_SCL (...) started = false;}// Write a bit to I2C busvoid i2c_write_bit(bool bit) { if (bit) { set_SDA (...) } else { clear_SDA (...) } // SDA <b>change</b> <b>propagation</b> delay I2C_delay (...) // Set SCL high to indicate a new valid SDA value is available set_SCL (...) // Wait for SDA value to be read by slave, minimum of 4us for standard mode I2C_delay (...) while (read_SCL (...) == 0) { // Clock stretching // You should add timeout to this loop } // SCL is high, now data is valid // If SDA is high, check that nobody else is driving SDA if (bit && (read_SDA (...) == 0)) { arbitration_lost (...) } // Clear the SCL to low in preparation for next change clear_SCL (...)}// Read a bit from I2C busbool i2c_read_bit(void) { bool bit; // Let the slave drive data set_SDA (...) // Wait for SDA value to be written by slave, minimum of 4us for standard mode I2C_delay (...) // Set SCL high to indicate a new valid SDA value is available set_SCL (...) while (read_SCL (...) == 0) { // Clock stretching // You should add timeout to this loop } // Wait for SDA value to be written by slave, minimum of 4us for standard mode I2C_delay (...) // SCL is high, read out bit bit = read_SDA (...) // Set SCL low in preparation for next operation clear_SCL (...) return bit;}// Write a byte to I2C bus. Return 0 if ack by the slave.bool i2c_write_byte(bool send_start, bool send_stop, unsigned char byte) { unsigned bit; bool nack; if (send_start) { i2c_start_cond (...) } for (bit = 0; bit < 8; ++bit) { i2c_write_bit((byte & 0x80) != 0); byte <<= 1; } nack = i2c_read_bit (...) if (send_stop) { i2c_stop_cond (...) } return nack;}// Read a byte from I2C busunsigned char i2c_read_byte(bool nack, bool send_stop) { unsigned char byte = 0; unsigned char bit; for (bit = 0; bit < 8; ++bit) { byte = (byte << 1) | i2c_read_bit (...) } i2c_write_bit(nack); if (send_stop) { i2c_stop_cond (...) } return byte;}void I2C_delay(void) { [...] volatile int v; int i; for (i = 0; i < I2CSPEED / 2; ++i) { v; }} ...|$|E
40|$|Context A Software Product Line (SPL) {{is a set}} of {{software}} systems that share common functionalities, so-called features. When features are related, we consider this relation a feature dependency. Whenever a new feature is added, the presence of feature dependencies in the source code may increase the maintenance effort. In particular, along the maintenance of SPL implementation, added features may induce changes in other features, the so-called <b>change</b> <b>propagation.</b> <b>Change</b> <b>propagation</b> is the set of ripple changes required to other features whenever a particular feature is added or changed. Objective The relationship between feature dependency and <b>change</b> <b>propagation</b> is not well understood. Therefore, the objective of our study is to examine the relation between feature dependency and <b>change</b> <b>propagation.</b> Method We investigate <b>change</b> <b>propagation</b> through feature dependencies in additive changes on five evolving SPLs. We analysed a wide range of additive changes in 21 representations of those SPLs. This analysis enabled us to understand whether and how features dependencies and change propagations are related. Results The results have empirically confirmed {{for the first time the}} strong relation between feature dependency and <b>change</b> <b>propagation.</b> We also identified what are the circumstances involving dependent features that are more likely to cause <b>change</b> <b>propagation.</b> Surprisingly, the results also suggested that the extent of <b>change</b> <b>propagation</b> across SPL features might be higher than the one found in previous studies of dependent modules in non-SPLs. We also found a concentration of <b>change</b> <b>propagation</b> in a few feature dependencies. Conclusion Even though the results show that there is a strong relation between feature dependencies and <b>change</b> <b>propagation,</b> such relation is not alike for all dependencies. This indicates that (i) a general feature dependency minimisation might not ameliorate the <b>change</b> <b>propagation,</b> and (ii) feature dependency properties must be analysed beforehand to drive maintenance effort to important dependencies...|$|E
40|$|<b>Change</b> <b>propagation</b> is a {{technique}} for automatically adjusting the output of an algorithm {{to changes in the}} input. The idea behind <b>change</b> <b>propagation</b> is to track the dependences between data and function calls, so that, when the input changes, functions affected by that change can be re-executed to update the computation and the output. <b>Change</b> <b>propagation</b> makes it possible for a compiler to dynamize static algorithms. The practical effectiveness of <b>change</b> <b>propagation,</b> however, is not known. In particular, the cost of dependence tracking and <b>change</b> <b>propagation</b> may seem significant. The contributions of the paper are twofold. First, we present some experimental evidence that <b>change</b> <b>propagation</b> performs well when compared to direct implementations of dynamic algorithms. We implement <b>change</b> <b>propagation</b> on tree-contraction as a solution to the dynamic trees problem and present an experimental evaluation of the approach. As a second contribution, we present a library for dynamic-trees that support a general interface and present an experimental evaluation by considering a broad set of applications. The dynamic-trees library relies on <b>change</b> <b>propagation</b> to handle edge insertions/deletions. The applications that we consider include path queries, subtree queries, least common-ancestor queries, maintenance of centers and medians of trees, nearest-marked-vertex queries, semidynamic minimum spanning trees, and the max-flow algorithm of Sleator and Tarjan...|$|E
40|$|Change {{management}} {{is very important}} to the success of new product development. The earlier that change issues are addressed, the greater that product lifecycle costs can be saved. This paper presents a novel methodology that has been developed to help designers trace, analyse and evaluate engineering changes occurring in the product design phase. A modelling method is employed to enhance the traceability of potential design changes occurring between the functional and structural domains of design. Based on functional and physical models, a matrix is developed to analyse <b>change</b> <b>propagations</b> and help identify design conflicts arising from design changes. A knowledge based methodology has been developed to resolve design conflicts by reusing previous design change knowledge. A wind turbine for power generation from the collaborating company is used to evaluate the developed methodologies...|$|R
40|$|Report {{presents}} {{analysis of}} information content of interferometric measurements of rates of <b>change</b> of <b>propagation</b> delay of radio signals transmitted {{to and from}} spacecraft in orbit around distant planet. "Information content" used here defined, somewhat loosely, as contribution of given measurement or series of measurements to accurate knowledge of orbit...|$|R
40|$|Tomographic {{reconstruction}} [1] is {{a method}} of imaging by illuminating the object in many different directions in the plane of interest, using X-rays or ultrasound. An image is formed from changes in a physical variable occurring in the planar cross section. Typically, <b>changes</b> in <b>propagation</b> delay or arrival time are used to reconstruc...|$|R
40|$|Background: <b>Change</b> <b>propagation</b> {{analysis}} helps {{predict the}} parts of the software that may be affected if a change is made. Existing research on <b>change</b> <b>propagation</b> focuses on design and code level changes. However, as a software evolves, the requirements that drive these changes also have intricate dependencies. Understanding the effect of these requirement dependencies on change prorogation is useful but not trivial. More than twenty requirements dependency types have been identified in the literature, however there still lacks an evaluation of the applicability of these dependency types in requirements and <b>change</b> <b>propagation</b> analysis. Aim: We aim to investigate whether these dependency types are useful for <b>change</b> <b>propagation</b> analysis. Method: We conducted a case study in a real-world industry project. This case study evaluates two representative dependency models covering twenty five types of dependencies. Results: Our initial evaluation has found that five dependency types are particularly useful in <b>change</b> <b>propagation</b> analysis and practitioners with different backgrounds have various viewpoints on <b>change</b> <b>propagation.</b> Thus change impact analysis should involve a wide range of stakeholders including project managers, requirements engineers, designers and developers. Conclusions: Our case study provides insights into requirements dependencies and their effects on <b>change</b> <b>propagation</b> analysis for both research and practice. Background: <b>Change</b> <b>propagation</b> analysis helps predict {{the parts of}} the software that may be affected if a change is made. Existing research on <b>change</b> <b>propagation</b> focuses on design and code level changes. However, as a software evolves, the requirements that drive these changes also have intricate dependencies. Understanding the effect of these requirement dependencies on change prorogation is useful but not trivial. More than twenty requirements dependency types have been identified in the literature, however there still lacks an evaluation of the applicability of these dependency types in requirements and <b>change</b> <b>propagation</b> analysis. Aim: We aim to investigate whether these dependency types are useful for <b>change</b> <b>propagation</b> analysis. Method: We conducted a case study in a real-world industry project. This case study evaluates two representative dependency models covering twenty five types of dependencies. Results: Our initial evaluation has found that five dependency types are particularly useful in <b>change</b> <b>propagation</b> analysis and practitioners with different backgrounds have various viewpoints on <b>change</b> <b>propagation.</b> Thus change impact analysis should involve a wide range of stakeholders including project managers, requirements engineers, designers and developers. Conclusions: Our case study provides insights into requirements dependencies and their effects on <b>change</b> <b>propagation</b> analysis for both research and practice...|$|E
40|$|In {{the current}} work, a simulation-based {{approach}} is proposed {{to assess the}} <b>change</b> <b>propagation</b> effect in an aircraft design process. To this end, three extensions are made to the conventional approach using design structure matrix to model <b>change</b> <b>propagation</b> effect. They are: 1) logistics factor associated with the component supplies of aircraft; 2) manufacturing system flexibility factor; 3) uncertainty in design change parameters. Then the effects of <b>change</b> <b>propagation</b> are simulated using a discrete-event simulation model in Arena involving detailed design process of totally eight components of a real aircraft. Finally, whatif analyses are performed by varying logistics and flexibility factors under uncertainty in design change parameters to assess the <b>change</b> <b>propagation</b> effect. An optimization problem is also solved using OptQuest to determine the <b>change</b> <b>propagation</b> path that minimizes the total risk of design change. Future work is discussed for extending the proposed approach to other related areas. ...|$|E
40|$|Supporting <b>change</b> <b>propagation</b> in UML models A {{critical}} issue in software maintenance and evolution is change propagation: given a primary {{change that is}} made {{in order to meet}} a new or changed requirement, what additional, secondary, changes are needed? We have previously developed techniques for effectively supporting <b>change</b> <b>propagation</b> within design models of intelligent agent systems. In this paper, we propose how this approach is applied to support <b>change</b> <b>propagation</b> within UML design models. Our approach offers a number of advantages in terms of saving substantial time writing hard-coded rules, ensuring soundness and completeness, {{and at the same time}} capturing the cascading nature of <b>change</b> <b>propagation.</b> We will also present and discuss the results of an evaluation performed to assess the scalability of our approach...|$|E
40|$|Surface {{acoustic}} wave (SAW) sensors {{are currently being}} investigated {{in a wide range}} in fields including physical, chemical and bio-sensing. The basic principle in a SAW sensor is the detection of <b>changes</b> in the <b>propagation</b> characteristics of the surface {{acoustic wave}}s which are caused by perturbations on the active surface of the device. The most common situation is measuring the <b>change</b> in <b>propagation</b> velocity of the surface wave as a change in resonant frequency. This chapter is a review of layered SAW devices for sensing applications. A conventional SAW device consists of a piezoelectric substrate with the inter-digital transducer (IDT) patterned on the surface. The layered devices are fabricated by depositing a thin film onto the conventional SAW substrate...|$|R
5000|$|PropNET {{uses the}} APRS {{protocol}} over AX.25 and PSK31 to study radio frequency propagation. PropNET [...] "probes" [...] transmit position reports, along {{with information on}} transmitter power, elevation, and antenna gain, at various frequencies to allow monitoring stations to detect <b>changes</b> in <b>propagation</b> conditions. It is based on ACDS, a special client program running under Microsoft Windows.|$|R
40|$|The {{decline in}} output {{volatility}} in Germany is analysed. A {{lower level of}} variance in an autoregressive model of output growth can be either due {{to a change in}} the structure of the economy (a <b>change</b> in the <b>propagation</b> mechanism) or a reduced error term variance (reduced impulses). In Germany the decline output volatility is due to a decline in the persistence of the growth process. This is in contrast to the US results, where a break in the variance seems to dominate the decline in persistence. A change in the conduct of monetary policy (the establishment of another monetary policy regime) could be part of an explanation for the <b>change</b> in <b>propagation.</b> Stochastic simulations with a New Keynesian DSGE model support the hypothesis. ...|$|R
