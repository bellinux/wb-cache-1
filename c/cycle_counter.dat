23|38|Public
25|$|The memory {{manager and}} {{processes}} scheduler have been improved. The scheduler was modified {{to use the}} <b>cycle</b> <b>counter</b> register of modern processors {{to keep track of}} exactly how many CPU cycles a thread has executed, rather than just using an interval-timer interrupt routine. This new CPU cycle-based thread scheduling gives a greater fairness and more deterministic app behavior. Many kernel data structures and algorithms have been rewritten. Lookup algorithms now run in constant time, instead of linear time as with previous versions.|$|E
50|$|This {{program which}} can be found inside the BDSVM {{directory}} of a BD+ protected disc is called content code. The content code is executed on a virtual big endian DLX-like processor interfacing 4MB of memory. The processor supports 59 different instructions and a register set consisting of 32 general purpose registers and three special purpose registers for the instruction ﬁlter, the clock <b>cycle</b> <b>counter</b> and the program counter. The BD+ Virtual Machine applies memory protection by masking memory access addresses to prevent them from falling outside of the designated memory areas. The execution of content code starts at address 0x1000 relative {{to the beginning of the}} payload of the ﬁrst block of the ﬁle 00001.svm (located inside the BDSVM directory).|$|E
5000|$|Windows NT-based {{operating}} systems use a multilevel feedback queue. 32 priority levels are defined, 0 through to 31, with priorities 0 through 15 being [...] "normal" [...] priorities and priorities 16 through 31 being soft real-time priorities, requiring privileges to assign. 0 {{is reserved for}} the Operating System. Users can select 5 of these priorities to assign to a running application from the Task Manager application, or through thread management APIs. The kernel may change the priority level of a thread depending on its I/O and CPU usage and whether it is interactive (i.e. accepts and responds to input from humans), raising the priority of interactive and I/O bounded processes and lowering that of CPU bound processes, to increase the responsiveness of interactive applications. The scheduler was modified in Windows Vista to use the <b>cycle</b> <b>counter</b> register of modern processors {{to keep track of}} exactly how many CPU cycles a thread has executed, rather than just using an interval-timer interrupt routine. Vista also uses a priority scheduler for the I/O queue so that disk defragmenters and other such programs do not interfere with foreground operations.|$|E
50|$|In {{part due}} to {{investment}} into new cycleway infrastructure (both path upgrades as well as cycleways linked to the Northwestern Cycleway like the Grafton Gully Cycleway and the Nelson Street Cycleway, cycle numbers have in recent years (~2015-2016) started to increase at a faster rate, as shown by Auckland Transport automatic <b>cycle</b> <b>counters.</b>|$|R
40|$|Global {{liquidity}} {{has become}} a key focus of international policy debates over recent years. The concept of global liquidity, however continues {{to be used in}} a variety of ways and this ambiguity can lead to potentially undesirable policy responses. This feature attempts to further the understanding of the global liquidity concept, its measurement and policy implications. It argues that policy responses to global liquidity call for a consistent framework that considers all phases of global liquidity <b>cycles,</b> <b>countering</b> both surges and shortages. ...|$|R
40|$|Assessing global {{liquidity}} 1 Global liquidity {{has become}} a key focus of international policy debates, yet the term continues {{to be used in}} a variety of ways. This lack of precision can lead to potentially undesirable policy responses. In this feature, we attempt to clarify the concept of global liquidity, its measurement and policy implications. We argue that policy responses to global liquidity call for a consistent framework that takes into account all phases of global liquidity <b>cycles,</b> <b>countering</b> both surges and shortages. JEL classification: E 50, F 30, G 15...|$|R
30|$|Record best solution. All PN/ 2 {{solutions}} after modification {{are ranked}} {{according to their}} fitness, and best solution of current cycle is reserved. The termination conditions are then checked. When <b>cycle</b> <b>counter</b> reach the MCN or an ideal solution is found (reach IFT), the algorithm is over.|$|E
30|$|The barectf_get_clock and barectf_init_clock {{functions}} {{should use}} a proper 64 -bit counter. Usually, a <b>cycle</b> <b>counter</b> is used, and when not available, special {{care must be}} taken to ensure the coherency of timestamps through time. For instance, some platforms (like the Parallella board) might only offer one 32 -bit counter which can be reset after hitting its maximum value, in which case a custom-made counter should be incremented at each reset to simulate a 64 -bit counter.|$|E
40|$|Time-based {{transactional}} memories typically rely on {{a shared}} memory counter to ensure consistency. Unfortunately, such a counter can become a bottleneck. In this paper, we identify properties of hardware cycle counters that allow their use {{in place of a}} shared memory counter. We then devise algorithms that exploit the x 86 <b>cycle</b> <b>counter</b> to enable bottleneck-free transactional memory runtime systems. We also consider the impact of privatization safety and hardware ordering constraints on the correctness, performance, and generality of our algorithms...|$|E
5000|$|His accomplishments {{include the}} {{completion}} of the skill development programs for more than 3000 students under NSDC STAR program in coordination with Telecom Sector Skill Council ( [...] TSSC), and has filed a patent application for development of low <b>cycle</b> fatigue <b>counter</b> for cumulative fatigue life assessment of aero engine components.|$|R
3000|$|... is the {{probability}} that the channel is found to be busy. Its mathematical definition is given in (8). The last two expressions correspond to the events that a random slot is selected for initiating the backoff procedure upon completing the previous backoff <b>cycle</b> (backoff <b>counter</b> reached zero) and upon resetting the backoff counter (channel is detected to be busy), respectively. The transition probabilities are equal in those last two expressions.|$|R
5000|$|This {{can be done}} by {{supplying}} a row address and pulsing [...] low; {{it is not necessary to}} perform any [...] <b>cycles.</b> An external <b>counter</b> is needed to iterate over the row addresses in turn.|$|R
40|$|A chip {{for digital}} {{intermediate}} frequency filtering is introduced. The filter is intended move {{most of the}} analog intermediate frequency filtering to the digital domain in systems like the American mobile radio system (IS- 54). It is a wave digital lattice filter realized with bit-serial arithmetic. Furthermore, a technique for local clocks on chip is presented. The method {{is based on a}} ring oscillator and a <b>cycle</b> <b>counter</b> which is controlled from outside the chip. A 0. 8 micron technology custom test chip has been fabricated and tested...|$|E
30|$|Synchronization is an {{essential}} part of the analysis. Since traces are generated on multiple machines by different instances of tracers, we have no guaranty that a time stamp for an event in a first trace will have any sense in the context of a second trace. Each machine may have its own timing sources, from the software interrupt timer to the <b>cycle</b> <b>counter.</b> When tracing the operating system kernel, each system instance (i.e., host, VM, container, etc.) uses its own internal clock to specify the events time stamps. But, in order to have a common sense of all systems behaviors, which are recorded as trace events separately in each system, it is essential to properly measure the differences and drifts between these machines.|$|E
40|$|Abstract—Multi-core {{processors}} {{are commonly}} available now, but most traditional computer architectural simulators still use single-thread execution. In this paper we use parallel discrete event simulation (PDES) to speedup a cycle-accurate event-driven many-core processor simulator. Evaluation against the sequential version {{shows that the}} parallelized one achieves an average speedup of 10. 9 × (up to 13. 6 ×) running SPLASH- 2 kernel on a 16 -core host machine, with <b>cycle</b> <b>counter</b> differences of less than 0. 1 %. Moreover, super-linear speedups are achieved between running 1 thread and 8 threads due to reduced overhead of insert-event-to-queue time and increased cache size in parallel processing. We conclude that PDES could be an attractive option for achieving fast cycle-accurate many-core processor simulation. I...|$|E
40|$|Abstract—Virtualized environments {{are widely}} thought to cause {{problems}} for software-based random number generators (RNGs), due {{to use of}} virtual machine (VM) snapshots as well as fewer and believed-to-be lower quality entropy sources. Despite this, we are unaware of any published analysis of the security of critical RNGs when running in VMs. We fill this gap, using measurements of Linux’s RNG systems (without the aid of hardware RNGs, the most common use case today) on Xen, VMware, and Amazon EC 2. Despite CPU <b>cycle</b> <b>counters</b> providing {{a significant source of}} entropy, various deficiencies {{in the design of the}} Linux RNG makes its first output vulnerable during VM boots and, more critically, makes it suffer from catastrophic reset vulnerabilities. We show cases in which the RNG will output the exact same sequence of bits each time it is resumed from the same snapshot. This can compromise, for example, cryptographic secrets generated after resumption. We explore legacy-compatible countermeasures, as well as a clean-slate solution. The latter is a new RNG called Whirlwind that provides a simpler, more-secure solution for providing system randomness. Keywords-random number generator; virtualization I...|$|R
30|$|Second, the {{requirement}} to freeze the backoff counter upon sensing the channel to be busy is relaxed. In other words, if the channel is detected to be busy during an ongoing backoff <b>cycle,</b> the backoff <b>counter</b> is reset, and the next backoff cycle is initiated.|$|R
3000|$|After the {{redistribution}} of parking time, a mobile sink starts a new moving cycle {{according to the}} allocated parking. Before {{the start of a}} new moving <b>cycle,</b> all the <b>counters</b> of a mobile sink are set to zero. After the mobile sink completes Num [...]...|$|R
40|$|June 2011 My {{first task}} in the Real World was to read and {{understand}} a 200, 000 line Fortran program, then speed it up {{by a factor of}} two. - Ed Post, Real programmers don’t use PascalTools • oprofile • perf • perf wrappers: ocperf, perf+libpfm etc. • simple-pmuBasics • Sampling: oprofile, perf top, perf record/report • Counting: perf stat, simple-pmuBasic operation of a PMU • Number of counters in the CPU • or other devices like GPU, NIC, Uncore • Event code to enable counting for an event • Interrupt when threshold reached: allows sampling • Modern PMUs have additional featuresClassic profiling • Follow the Pareto principle 80 - 20 (or 90 - 10 according to Knuth) • Use sampling with <b>cycle</b> <b>counter</b> • Identify hottest cod...|$|E
30|$|The {{control logic}} {{takes care of}} multiplexing, the correct data pixels from the memory {{locations}} to the floating point pixel calculation module. In addition, this module includes a clock <b>cycle</b> <b>counter.</b> The following floating point pixel calculation module and memory access stages of the design are all pipelined. Each block in Figure[*] 3 - memory accesses and writes, the resizing frame, compare with low-resolution frame, resize error, and adjust hypothesis frame with error frame - are stages of the pipeline. We found that the longest latency of all the pipelined stages is 12 clock cycles at 103.15 and 122.25 MHz for the Cyclone II FPGA and Stratix III FPGA, respectively. Thus, every stage of the pipeline is 12 clock cycles. The counter helps ensure that the correct pixel data from the M 4 k memory blocks are flopped into the floating point pixel calculation module at the correct time.|$|E
40|$|International audienceDigital {{control is}} {{becoming}} a new trend in Switching Mode Power Supply (SMPS) development. This paper described a prototype implementation of a digital control solution prior to monolithic integration. An original algorithm, called RST, is used to obtain a better rejection of load variations and PWM noises than PID algorithms while keeping a good robustness. Sensitivity functions have been introduced that help tuning the algorithm coefficients. An FPGA implementation has been performed for the control of a 1 MHz step-down voltage regulator. One challenge in design is to meet the output voltage accuracy, avoid the limit cycle phenomenon and reduce the high-frequency clock requirement. The choice and impact of fixed-point representation for the computation has been discussed. A 9 -bit resolution DPWM is obtained using DLL function modules in FPGA and a half <b>cycle</b> <b>counter.</b> Experimental results proved {{the performance of the}} proposed digitally control SMP...|$|E
5000|$|This form of {{coevolution}} can be complex but {{is essential}} to understanding the vast biological diversity among organisms today. Out of the many forms of coevolution, escape and radiate is most likely responsible for providing the most diversity. This {{is due to the}} nature of the [...] "evolutionary arms race" [...] and the continuous <b>cycle</b> of <b>counter</b> adaptations. It is a relatively new field of study and is rapidly gaining credibility. To date, there has not been a formal study published specifically for escape and radiate coevolution.|$|R
40|$|Goodwin´s predator-prey model predicts {{clockwise}} cycles in the employment-distribution space. Qualitative {{evidence is}} provided in favour of nonlinear dynamic behaviour for a sample of 67 countries, {{some of which have}} cycles similar to those predicted by the model. Predicted centres lie outside actual circles. The kind of <b>cycle</b> (clockwise, <b>counter</b> clockwise or atypical) appears {{to be related to the}} kind of capitalism of the country. Countries with Market or European capitalism, as well as transition economies, do not tend to have demand cycles; developing countries with a Mediterranean capitalism do not tend to have Goodwin cycles...|$|R
5000|$|For adults, the {{standard}} advice in the vehicular cycling philosophy for handling roundabouts {{is to try}} to maintain a prominent position while circulating. The use of <b>cycle</b> lanes runs <b>counter</b> to this vehicular cycling approach and places cyclists outside the main [...] "zone of observation" [...] of entering motorists, who represent the major source risk.|$|R
40|$|Abstract. Recently a new {{software}} clock and synchronisation algorithm {{based on the}} TSC register (clock <b>cycle</b> <b>counter)</b> was developed, with several advantages over the existing system clock. However, as it uses a modified kernel to support driver timestamping, installation is non-trivial, limiting its use. We present a modified TSC clock {{without the need for}} kernel modifications, using only user-level timestamps and existing system kernel timestamps exploited in a careful way. Using weeks of test data, we show how the system performance is virtually identical to that of a kernel implementation. Compared against a GPS synchronised DAG card reference, it performs very well under both BSD and Linux. We also show how the system can replace ntpd to improve the existing system clock. The software allows for significantly improved timestamping for both packet and internal system events, and is trivial to install. It is publicly available. ...|$|E
40|$|As current {{computers}} become faster, {{and more}} applications require very tight time constraints and optimizations, {{there is a}} growing need for a simple and robust manner to evaluate performance with extremely low overhead. The best way to this is to directly measure the CPU cycles. The standard method of evaluation is by extracting the system time using operating system calls. This method incures a very substantial overhead since it implicitly includes two context switches - to the system context and back - and thus can only be used in a very coarse grained methodolgy. Intel, makers of the most popular workstation CPUs, has incorporated into its P 5 processors family (Pentium and up) an opcode which allows to read the CPU's <b>cycle</b> <b>counter</b> from user level. Our library enables the user to use this opcode and to take these coveted cycle measurements, {{that can be used for}} ne grained performance evaluation. These cycles measurements can be easily converted, using the CPU speed, in [...] ...|$|E
40|$|The FlexRay {{controller}} {{supports a}} single communication channel, {{and can be}} configured for either Channel A or Channel B. The Cyclic Redundancy Check (CRC) seed used to generate the Header CRC is different for Channel A and for Channel B. Therefore, connecting the FlexRay controller that is configured for Channel A to Channel B in the cluster (or vice-versa) is not allowed. Configurable Payload Length The Max Payload that can be supported by the controller during synchronous or aysnchronous transmission is user-configurable, depending upon specific design requirements. Configurable number of Transmit Buffers The number of transmit buffers in the FlexRay controller can be user-configured from {{a minimum of two}} to a maximum of 128 in powers of two. The block RAM resource utilization varies, {{based on the number of}} Transmit buffers and the configurable payload length. Configurable number of Receive Buffers The number of Receive buffers in the FlexRay controller can be user-configured from a minimum of two to a maximum of 128 in powers of two. The block RAM resource utilization varies, based on the number of Receive buffers and the configurable payload length. Configurable Receive FIFO depth The depth of the Receive FIFO in the FlexRay controller can be user-configured from a minimum of two to a maximum of 128 in powers of two. The block RAM resource utilization varies, based on the depth of the Receive FIFO and the configurable payload length. Frame ID, <b>Cycle</b> <b>Counter</b> and Message ID based Receive Filtering The FlexRay controller supports filtering of receive messages based on Frame ID, <b>cycle</b> <b>counter</b> and message ID. Any or all of these combinations can be used for filtering the receive messages. Applications The FlexRay controller is typically used in automotive networked applications, offering high fault tolerant synchronous and asynchronous transfer capabilities. It can function as a stand-alone FlexRay controller or it can be integrated with other Xilinx LogiCORE and EDK cores to build a variety of embedded systems. The FlexRay solution allows for flexible partioning between software and hardware functions by providing a customized, scalable controller that off loads network specific overhead from the host processor. This is ideal for applications demanding maximum host application performance...|$|E
40|$|Many {{experimental}} performance evaluations {{depend on}} accurate {{measurements of the}} cost of executing a piece of code. Often these measurements are conducted using infras-tructures to access hardware performance counters. Most modern processors provide such counters to count micro-architectural events such as retired instructions or clock <b>cycles.</b> These <b>counters</b> can be difficult to configure, may not be programmable or readable from user-level code, and can not discriminate between events caused by different software threads. Various software infrastructures address this problem, providing access to per-thread counters from application code. This paper constitutes the first comparative study of the accuracy of three commonly used measurement infrastructures (perfctr, perfmon 2, and PAPI) on three com-mon processors (Pentium D, Core 2 Duo, and AMD ATHLON 64 X 2). 1...|$|R
40|$|This paper {{presents}} a scalable method for parallel symbolic on-thefly model checking on a distributed-memory environment of workstations. Our method combines a parallel {{version of an}} on-the-fly model checker for safety properties with a scalable scheme for reachability analysis. The extra load of storage required for counter example generation is evenly distributed among the processes by our memory balancing. For the sake of scalability, at no point during computation {{the memory of a}} single process contains all the data from any of the <b>cycles.</b> The <b>counter</b> example generation is thus performed through collaboration of the parallel processes. We develop a method for the counter example generation keeping a low peak memory requirement during the backward step and the computation of the inverse transition relation. We implemente...|$|R
40|$|Global {{liquidity}} {{has become}} a key focus of international policy debates over recent years. This reflects the view that global liquidity and its drivers are of major importance for international financial stability. The concept of global liquidity, however continues {{to be used in}} a variety of ways and this ambiguity can lead to unfounded and potentially destabilising policy initiatives. This report analyses global liquidity from a financial stability perspective, using two distinct liquidity concepts. One is official liquidity, which can be used to settle claims through monetary authorities and is ultimately provided by central banks. The other concept is private (or private sector) liquidity, which is created to a large degree through cross-border operations of banks and other financial institutions. Understanding the determinants of private liquidity is of particular importance. As many financial institutions provide liquidity both domestically and in other countries, globally, private liquidity is linked to the dynamics of gross international capital flows, including cross-border banking or portfolio movements. This international component of liquidity can be a potential source of instability because of its own dynamics or because it amplifies cyclical movements in domestic financial conditions and intensifies domestic imbalances. Policy responses to global liquidity call for a consistent framework that considers all phases of global liquidity <b>cycles,</b> <b>countering</b> both surges and shortages. Measures to prevent unsustainable booms in private liquidity are linked with micro- and macroprudential policies as well as the financial reform agenda. Country-specific or regional liquidity shocks, in turn, may effectively be addressed through self-insurance in the form of precautionary foreign exchange reserves holdings and existing arrangements which essentially redistribute liquidity. However, truly global liquidity shocks necessitate direct interventions in amounts large enough to break downward liquidity spirals. Only central banks have this ability. ...|$|R
40|$|Most {{computers}} have several high-resolution timing sources, from the programmable interrupt timer to the <b>cycle</b> <b>counter.</b> Yet, {{even at a}} precision of one cycle in ten millions, clocks may drift significantly in a single second at a clock frequency of several GHz. When tracing the low-level system events in computer clusters, such as packet sending or reception, each computer system records its own events using an internal clock. In order to properly understand the global system behavior and performance, {{as reported by the}} events recorded on each computer, it is important to estimate precisely the clock differences and drift between the different computers in the system. This article studies the clock precision and stability of several computer systems, with different architectures. It also studies the typical network delay characteristics, since time synchronization algorithms rely on the exchange of network packets and are dependent on the symmetry of the delays. A very precise clock, based on the atomic time provided by the GPS satellite network, was used as a reference to measure clock drifts and network delays. The results obtained are of immediate use to all applications which depend on computer clocks or network time synchronization accuracy...|$|E
40|$|Random {{numbers with}} high {{cryptographic}} quality {{are needed to}} enhance the security of cryptography applications. Software heuristics for generating empirically strong random number sequences rely on entropy gathering by measuring unpredictable external events. These generators only deliver a few bits per event. This limits them to being used as seeds for pseudorandom generators. General-purpose processors feature {{a large number of}} hardware mechanisms that aim to improve performance: caches, branch predictors, [...] The state of these components is not architectural (i. e., the result of an ordinary application does not depend on it). It is also volatile and cannot be directly monitored by the user. On the other hand, every operating system interrupt modifies thousands of these binary volatile states. In this article, we present and analyze HAVEGE (HArdware Volatile Entropy Gathering and Expansion), a new user-level software heuristic to generate practically strong random numbers on general-purpose computers. The hardware clock <b>cycle</b> <b>counter</b> of the processor can be used to gather part of the entropy/uncertainty introduced by operating system interrupts in the internal states of the processor. Then, we show how this entropy gathering technique can be combined with pseudorandom number generation in HAVEGE. Since the internal state of HAVEGE includes thousands of internal volatile hardware states, it seems impossible even for the user itself to reproduce the generated sequences...|$|E
40|$|The {{availability}} of a random number generator with high cryptographic qualities on a computer {{is one of the}} central issues of cryptographic implementations. HAVEGE (HArdware Volatile Entropy Gathering and Expansion) is a new software heuristic for generating unpredictable random numbers on PC s and workstations. PCs and workstations are built around modern superscalar microprocessors. These processors feature complex hardware mechanisms that aim to increase performance. A significant part of the global state of the microprocessor is not architecturally visible through the instruction set (e. g. caches, branch predictors and buffers). HAVEGE leverages the uncertainty introduced in the internal states of the processor by external events. HAVEGE combines entropy/uncertainty gathering from the architecturally invisible states of a modern superscalar microprocessor with pseudo-random number generation. First we show that the hardware clock <b>cycle</b> <b>counter</b> of the processor can be used to gather part of the uncertainty introduced by operating system interruptions in the internal state of the processor. Tens of thousands of unpredictable bits can be gathered per operating system interruption in average. Then, we show how this entropy gathering technique can be combined with pseudo-random number generation in HAVEGE. Since the internal state of HAVEGE includes thousands of internal volatile hardware states, HAVEGE features a very high security level. HAVEGE also reaches an unprecedented throughput for a software unpredictable random number generator: more than 100 Mbits/s with off-the-shelf workstations and PCs...|$|E
40|$|Synchronously growing staphylococci {{were treated}} with "lytic" {{concentrations}} of penicillin {{at different stages of}} their division <b>cycle.</b> Coulter <b>Counter</b> measurements and light microscopy were used to determine the onset of bacteriolysis. Independent of the stage of the division cycle at which penicillin was added, (i) the cells were always able to perform the next cell division; (ii) the following division, however, did not take place; and (iii) instead, at this time, when the onset of the subsequent cell separation was observed in control cultures, lysis of the penicillin-treated cells occurred. These results support a recent model (P. Giesbrecht, H. Labischinski, and J. Wecke, Arch. Microbiol. 141 : 315 - 324, 1985) explaining penicillin-induced bacteriolysis of staphylococci {{as the result of a}} special morphogenetic mistake during cross wall formation...|$|R
40|$|An {{open loop}} digital {{frequency}} multiplier is described {{which has a}} multiplied output synchronized to low frequency clock pulse. The system includes a multistage digital counter which provides a pulse output {{as a function of}} an integer divisor. The integer divisor and the timing or counting <b>cycle</b> of the <b>counter</b> are interrelated to the frequency of a clock input. The counting cycle is controlled by a one shot multivibrator which, in turn, is driven by a reference frequency input...|$|R
40|$|Many {{workload}} characterization studies {{depend on}} accurate {{measurements of the}} cost of executing a piece of code. Often these measurements are conducted using infrastructures to access hardware performance counters. Most modern processors provide such counters to count micro-architectural events such as retired instructions or clock <b>cycles.</b> These <b>counters</b> can be difficult to configure, may not be programmable or readable from user-level code, and can not discriminate between events caused by different software threads. Various software infrastructures address this problem, providing access to per-thread counters from application code. This paper constitutes the first comparative study of the accuracy of three commonly used measurement infrastructures (perfctr, perfmon 2, and PAPI) on three common processors (Pentium D, Core 2 Duo, and AMD ATHLON 64 X 2). We find significant differences in accuracy of various usage patterns for the different infrastructures and processors. Based on these results we provide guidelines for finding the best measurement approach. 1...|$|R
