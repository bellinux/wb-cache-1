102|1276|Public
2500|$|The {{subroutine}} {{establishes a}} call frame using register A6 as the frame pointer. This kind of <b>calling</b> <b>convention</b> supports reentrant and recursive code and is typically used by languages like C and C++. The subroutine then retrieves the parameters passed to it ( [...] and [...] ) from the stack. It then loops, reading an ASCII character (a single byte) from the [...] string, checking {{whether it is}} an alphabetic character, and if so, converting it into a lower-case character, then writing the character into the [...] string. Finally, it checks whether the character was a null character; if not, it repeats the loop, otherwise it restores the previous stack frame (and A6 register) and returns. Note that the string pointers (registers A0 and A1) are auto-incremented in each iteration of the loop.|$|E
50|$|The stdcall <b>calling</b> <b>convention</b> is a {{variation}} on the Pascal <b>calling</b> <b>convention</b> in which the callee is responsible for cleaning up the stack, but the parameters are pushed onto the stack in right-to-left order, as in the _cdecl <b>calling</b> <b>convention.</b> Registers EAX, ECX, and EDX are designated for use within the function. Return values are stored in the EAX register.|$|E
5000|$|The cdecl <b>calling</b> <b>convention</b> {{is usually}} the default <b>calling</b> <b>convention</b> for x86 C compilers, {{although}} many compilers provide options to automatically change the calling conventions used. To manually define a function to be cdecl, some support the following syntax: ...|$|E
5000|$|... x86-64 <b>calling</b> <b>conventions</b> take {{advantage}} of the additional register space to pass more arguments in registers. Also, the number of incompatible <b>calling</b> <b>conventions</b> has been reduced. There are two in common use.|$|R
50|$|This article {{describes}} the <b>calling</b> <b>conventions</b> used when programming x86 architecture microprocessors.|$|R
5000|$|The {{routines}} {{have different}} <b>calling</b> <b>conventions</b> or use different representations for arguments.|$|R
50|$|CPU {{architectures}} {{always have}} more than one possible <b>calling</b> <b>convention.</b> With many general-purpose registers and other features, the potential number of calling conventions is large, although some architectures are formally specified to use only one <b>calling</b> <b>convention,</b> supplied by the architect.|$|E
50|$|The ARM <b>calling</b> <b>convention</b> {{mandates}} using a full-descending stack.|$|E
50|$|Variadic {{functions}} {{fall back}} to the Watcom stack based <b>calling</b> <b>convention.</b>|$|E
40|$|We present staged allocation, a new {{technique}} for specifying <b>calling</b> <b>conventions.</b> A specification written using staged allocation has a precise, formal semantics, {{and it can be}} executed directly inside a compiler. An implementation takes about 250 lines of ML or 650 lines of C++. Descriptions of nine <b>calling</b> <b>conventions</b> range in size from 15 to 30 lines each...|$|R
50|$|Threaded code passes all {{arguments}} on the stack. All return values are returned on the stack. This makes naive implementations slower than <b>calling</b> <b>conventions</b> that keep more values in registers. However, threaded code implementations that cache {{several of the}} top stack values in registers—in particular, the return address—are usually faster than subroutine <b>calling</b> <b>conventions</b> that always push and pop the return address to the stack.|$|R
5000|$|Depending on the {{compiler}} and architecture, it {{also may}} be the case that <b>calling</b> <b>conventions</b> differ between the two languages.|$|R
50|$|Syscall is the {{standard}} <b>calling</b> <b>convention</b> for 32 bit OS/2 API.|$|E
5000|$|The {{most common}} <b>calling</b> <b>convention</b> for the Motorola 68000 series is: ...|$|E
5000|$|Hessian Web Service Protocol: Binary {{alternative}} to the XINS Standard <b>Calling</b> <b>Convention.</b>|$|E
50|$|The x86 {{architecture}} is used with many different <b>calling</b> <b>conventions.</b> Due {{to the small}} number of architectural registers, the x86 <b>calling</b> <b>conventions</b> mostly pass arguments on the stack, while the return value (or a pointer to it) is passed in a register. Some conventions use registers for the first few parameters, which may improve performance for short and simple leaf-routines very frequently invoked (i.e. routines that do not call other routines and {{do not have to be}} reentrant).|$|R
50|$|This {{variability}} must {{be considered}} when combining modules written in multiple languages, or when calling operating system or library APIs from a language {{other than the one}} in which they are written; in these cases, special care must be taken to coordinate the <b>calling</b> <b>conventions</b> used by caller and callee. Even a program using a single programming language may use multiple <b>calling</b> <b>conventions,</b> either chosen by the compiler, for code optimization, or specified by the programmer.|$|R
50|$|The National <b>Convention</b> <b>called</b> {{for state}} <b>conventions.</b>|$|R
5000|$|The 64-bit ARM (AArch64) <b>calling</b> <b>convention</b> allocates the 32 ARM {{registers}} as: ...|$|E
5000|$|The {{standard}} 32-bit ARM <b>calling</b> <b>convention</b> allocates the 16 ARM registers as: ...|$|E
5000|$|The safecall <b>calling</b> <b>convention</b> is {{the same}} as the stdcall <b>calling</b> <b>convention,</b> except that {{exceptions}} are passed back to the caller in EAX as a HResult (instead of in FS:0), while the function result is passed by reference on the stack as though it were a final [...] "out" [...] parameter. When calling a Delphi function from Delphi this <b>calling</b> <b>convention</b> will appear just like any other <b>calling</b> <b>convention,</b> because although exceptions are passed back in EAX, they are automatically converted back to proper exceptions by the caller. When using COM objects created in other languages, the HResults will be automatically raised as exceptions, and the result for Get functions is in the result rather than a parameter. When creating COM objects in Delphi with safecall, there is no need to worry about HResults, as exceptions can be raised as normal but will be seen as HResults in other languages.|$|E
5000|$|Dynamic {{language}}s, such as Python, Perl, Tcl, and Ruby, all provide {{easy access}} to native code written in C/C++ (or any other language obeying C/C++ <b>calling</b> <b>conventions).</b>|$|R
50|$|Although name {{mangling}} is {{not generally}} required or used by languages {{that do not}} support function overloading (such as C and classic Pascal), they use it {{in some cases to}} provide additional information about a function.For example, compilers targeted at Microsoft Windows platforms support a variety of <b>calling</b> <b>conventions,</b> which determine the manner in which parameters are sent to subroutines and results returned. Because the different <b>calling</b> <b>conventions</b> are not compatible with one another, compilers mangle symbols with codes detailing which convention should be used to call the specific routine.|$|R
50|$|Prior to microcomputers, {{the machine}} {{manufacturer}} generally provided an operating system and compilers for several programming languages. The <b>calling</b> <b>convention(s)</b> for each platform were those {{defined by the}} manufacturer's programming tools.|$|R
50|$|Starting with Visual Studio 2013, Microsoft {{introduced}} the __vectorcall <b>calling</b> <b>convention</b> which extends the x64 convention.|$|E
5000|$|... stdcall is the {{standard}} <b>calling</b> <b>convention</b> for the Microsoft Win32 API and for Open Watcom C++.|$|E
5000|$|A POX-style RPC {{protocol}} (called the XINS Standard <b>Calling</b> <b>Convention),</b> {{compatible with}} web browsers (HTTP parameters in, XML out).|$|E
50|$|As at 1 July 2013, {{there were}} 145 {{parties to the}} 1951 Refugee Convention and 146 to the 1967 Protocol. These states are bound by an {{obligation}} under international law to grant asylum to people who fall within the definition of Convention and Protocol. The refugee definitions of 1951 and 1967 are the strictest and most exclusive and persons who fall within this definition are <b>called</b> <b>Convention</b> refugees and their status is <b>called</b> <b>Convention</b> refugee status. Persons who do not fall within this definition may still be granted complementary forms of protection, if they fall within other refugee definitions.|$|R
5000|$|While {{the input}} (parameter n) is loaded from the stack, its precise {{position}} on the stack is not specified. The C compiler calculates this based on the <b>calling</b> <b>conventions</b> of the target architecture.|$|R
50|$|PIR {{provides}} {{a set of}} abstractions that allow the programmer to ignore certain redundancies in the Parrot bytecode and quickly write code that adheres to the complexities of Parrot, such as the <b>calling</b> <b>conventions.</b>|$|R
5000|$|How local {{variables}} are allocated can sometimes also {{be part of}} the <b>calling</b> <b>convention</b> (when the caller allocates for the callee) ...|$|E
50|$|Evaluating {{arguments}} {{from left to}} right, it passes three arguments via EAX, EDX, ECX. Remaining arguments are pushed onto the stack, also left to right. It is the default <b>calling</b> <b>convention</b> of the 32-bit compiler of Delphi, where it is known as register. Some versions of Linux kernel use this convention on i386.. This <b>calling</b> <b>convention</b> is also used by Embarcadero's C++Builder, where it is called __fastcall. In this compiler, Microsoft's fastcall {{can be used as}} __msfastcall.|$|E
5000|$|The <b>calling</b> <b>convention</b> for C code in {{particular}} was to pass parameters in [...] "reverse order" [...] on the stack and return values on the stack {{rather than in a}} processor register. There were other programming rules to make all the languages work together, but this particular rule persisted through the cross language development that continued throughout Windows 16 and 32 bit versions and in the development of programs for OS/2, and which persists to this day. It is known as the Pascal <b>calling</b> <b>convention.</b>|$|E
50|$|This {{is a list}} of x86 <b>calling</b> <b>{{conventions}}.</b> These are conventions primarily {{intended for}} C/C++ compilers (especially the 64-bit part below), and thus largely special cases. Other languages may use other formats and conventions in their implementations.|$|R
50|$|When a {{subroutine}} {{is ready}} to return, it executes an epilogue that undoes {{the steps of the}} prologue. This will typically restore saved register values (such as the frame pointer value) from the stack frame, pop the entire stack frame off the stack by changing the stack pointer value, and finally branch to the instruction at the return address. Under many <b>calling</b> <b>conventions</b> the items popped off the stack by the epilogue include the original argument values, in which case there usually are no further stack manipulations that need to be done by the caller. With some <b>calling</b> <b>conventions,</b> however, it is the caller's responsibility to remove the arguments from the stack after the return.|$|R
5000|$|Differences between C and C++ linkage and <b>calling</b> <b>conventions</b> {{can also}} have subtle {{implications}} for code that uses function pointers. Some compilers will produce non-working code if a function pointer declared [...] points to a C++ function that is not declared [...]|$|R
