27|43|Public
25|$|Conditional {{statements}} can be {{and often}} are nested inside other conditional statements. Some languages allow ELSE and IF to be combined into ELSEIF, avoiding {{the need to have}} a series of ENDIF or other final statements {{at the end of a}} <b>compound</b> <b>statement.</b>|$|E
2500|$|To {{obtain a}} non-Euclidean geometry, the {{parallel}} postulate (or its equivalent) {{must be replaced}} by its negation. Negating the Playfair's axiom form, since it is a <b>compound</b> <b>statement</b> (... there exists one and only one ...), {{can be done in}} two ways: ...|$|E
50|$|In logic, a truth {{function}} {{is a function}} that accepts truth values as input and produces a truth value as output, i.e., the input and output are all truth values. The typical example is in propositional logic, wherein a <b>compound</b> <b>statement</b> is constructed by one or two statements connected by a logical connective; if the truth value of the <b>compound</b> <b>statement</b> {{is determined by the}} truth value(s) of the constituent statement(s), the <b>compound</b> <b>statement</b> is called a truth function, and the logical connective is said to be truth functional.|$|E
2500|$|<b>Compound</b> <b>statements</b> are all {{terminated}} by distinctive (and somewhat reverent) closing brackets: ...|$|R
5000|$|TOOL code is case-insensitive. A {{statement}} is always terminated by the semicolon. <b>Compound</b> <b>statements</b> are enclosed by the keywords [...] and [...] Comments are indicated by // or -- (remainder of line becomes a comment), /* .../.|$|R
30|$|Tang and Cai (2010) {{presented}} the domain ontology construction from unstructured texts. The approach started from pre-processing {{of the text}} to extract keywords or preserved terms and composed simple and <b>compound</b> <b>statements.</b> The descriptive logic (DL) was used to represent the knowledge. At last, the ontology was generated.|$|R
50|$|A pair of curly {{brackets}} { } and {{an enclosed}} sequence of statements constitute a <b>compound</b> <b>statement,</b> {{which can be}} used wherever a statement can be used.|$|E
5000|$|... "Not" [...] is a unary operator, {{it takes}} a single term (¬P). The rest are binary operators, taking two terms to make a <b>compound</b> <b>statement</b> (P &and; Q, P &or; Q, P → Q, P ↔ Q).|$|E
50|$|Another {{solution}} is implemented in a folding editor, which can hide or reveal blocks of code via their indent level or <b>compound</b> <b>statement</b> structure. Many editors will also highlight matching brackets or braces when the cursor is positioned next to one.|$|E
40|$|Logic <b>Statements,</b> Negation, and <b>Compound</b> <b>Statements</b> Truth Tables and Logical Equivalences Conditional and Biconditional Statements Logical Arguments Open Statements and Quantifiers Chapter Review Deductive Mathematical Systems and Proofs Deductive Mathematical Systems Mathematical Proofs Chapter Review Set Theory Sets and Subsets Set Operations Additional Set Operations Generalized Set Union and Intersection Chapter ReviewRelations Relations The Order Relations, Reflexive, Symmetric, Transitive, and Equivalence Relations Equivalence Relations, Equivalence Classes, and Partitions Chapter Revi...|$|R
50|$|Some {{languages}} which {{support blocks}} with variable declarations {{do not fully}} support all declarations; for instance many C-derived languages do not permit a function definition within a block (nested functions). And unlike its ancestor Algol, Pascal {{does not support the}} use of blocks with their own declarations inside the begin and end of an existing block, only <b>compound</b> <b>statements</b> enabling sequences of statements to be grouped together in if, while, repeat and other control statements.|$|R
40|$|Modern Mathematics: Made Simple {{presents}} {{topics in}} modern mathematics, from elementary mathematical logic and switching circuits to multibase arithmetic and finite systems. Sets and relations, vectors and matrices, tesselations, and linear programming are also discussed. Comprised of 12 chapters, this book {{begins with an}} introduction to sets and basic operations on sets, as well as solving problems with Venn diagrams. The discussion then turns to elementary mathematical logic, with emphasis on inductive and deductive reasoning; conjunctions and disjunctions; <b>compound</b> <b>statements</b> and conditiona...|$|R
5000|$|To {{obtain a}} non-Euclidean geometry, the {{parallel}} postulate (or its equivalent) {{must be replaced}} by its negation. Negating the Playfair's axiom form, since it is a <b>compound</b> <b>statement</b> (... there exists one and only one ...), {{can be done in}} two ways: ...|$|E
5000|$|Conditional {{statements}} can be {{and often}} are nested inside other conditional statements. Some languages allow [...] and [...] to be combined into , avoiding {{the need to have}} a series of [...] or other final statements {{at the end of a}} <b>compound</b> <b>statement.</b>|$|E
50|$|Classical {{propositional logic}} is a truth-functional propositional logic, in that every {{statement}} has exactly one truth value which is either true or false, and every logical connective is truth functional (with a correspondent truth table), thus every <b>compound</b> <b>statement</b> is a truth function. On the contrary, modal logic is non-truth-functional.|$|E
5000|$|Because a {{function}} may be {{expressed as a}} composition, a truth-functional logical calculus {{does not need to}} have dedicated symbols for all of the above-mentioned functions to be functionally complete. This is expressed in a propositional calculus as logical equivalence of certain <b>compound</b> <b>statements.</b> For example, classical logic has [...] equivalent to [...] The conditional operator [...] "→" [...] is therefore not necessary for a classical-based logical system if [...] "¬" [...] (not) and [...] "∨" [...] (or) are already in use.|$|R
40|$|We {{demonstrate}} how {{to model the}} following common programmingsconstructs {{in terms of an}} applicative order language similar to LISP: Simple Recursion, Iteration, <b>Compound</b> <b>Statements</b> and Expressions, GO TO and Assignment, Continuation-Passing, Escape Expressions, Fluid Variables, Call by Name, Call by Need, and Call by Reference. The models require only (possibly self-referent) lambda application, conditionals, and (rarely) assignment. No complex data structures such as stacks are used. The models are transparent, involving only local syntactic transformations. This paper is partly tutorial in intent, gathering all the models together for purposes of context...|$|R
50|$|In some situations, {{there is}} a risk of losing track of block boundaries. This is often seen in large {{sections}} of code containing many <b>compound</b> <b>statements</b> nested to many levels of indents. By the time the programmer scrolls to the bottom of a huge set of nested statements, he or she may have lost track of which control statements go where. However, overly long code could have other causes, such as being too complex, and a programmer facing this problem might instead consider whether code refactoring would help in the longer term.|$|R
5000|$|Another, more subtle, {{difference}} {{is the role of}} the semicolon. In Pascal semicolons separate individual statements within a <b>compound</b> <b>statement</b> whereas they terminate the statement in C. They are also syntactically part of the statement itself in C (transforming an expression into a statement). This difference manifests itself primarily in two situations: ...|$|E
50|$|The {{advantages}} of this style {{are similar to}} those of the Allman style. Blocks are clearly set apart from control statements. The alignment of the braces with the block emphasizes that the full block is conceptually, and programmatically, one <b>compound</b> <b>statement.</b> Indenting the braces emphasizes that they are subordinate to the control statement. The ending brace no longer lines up with the statement, but instead with the opening brace.|$|E
5000|$|The main {{difference}} between indent styles {{lies in the}} placing of the braces of the <b>compound</b> <b>statement</b> (...) that often follows a control statement ( [...] , , ...). The table below shows this placement for the style of statements discussed in this article; function declaration style is another case. The style for brace placement in statements may differ from the style for brace placement of a function definition. For consistency, the indent depth has been kept constant at 4 spaces, regardless of the preferred indent depth of each style.|$|E
5000|$|Operator {{overloading}} and user-defined casts {{are separate}} features that both aim to allow new types to become first-class {{citizens in the}} type system. By using these features in C#, types such as Complex and decimal have been integrated so that the usual operators like addition and multiplication work with the new types. Unlike C++, C# does restrict the use of operator overloading, prohibiting it for the operators new, ( [...] ), ||, &&, =, and any variations of <b>compound</b> <b>statements</b> like +=. But compound operators will call overloaded simple operators, like -= calling - and =.|$|R
40|$|Programming - ALGOL {{describes}} {{the basics of}} computer programming using Algol. Commands that could be added to Algol and could increase its scope are described, including multiplication and division {{and the use of}} brackets. The idea of labeling or naming a command is also explained, along with a command allowing two alternative results. Most of the important features of Algol syntax are discussed, and examples of <b>compound</b> <b>statements</b> (that is, sets of commands enclosed by a begin [...] . end command) are given. Comprised of 11 chapters, this book begins with an introduction to the digital computer a...|$|R
5000|$|Such {{a logical}} {{connective}} as converse implication [...] "←" [...] {{is actually the}} same as material conditional with swapped arguments; thus, the symbol for converse implication is redundant. In some logical calculi (notably, in classical logic) certain essentially different <b>compound</b> <b>statements</b> are logically equivalent. A less trivial example of a redundancy is the classical equivalence between [...] and [...] Therefore, a classical-based logical system does not need the conditional operator [...] "→" [...] if [...] "¬" [...] (not) and [...] "∨" [...] (or) are already in use, or may use the [...] "→" [...] only as a syntactic sugar for a compound having one negation and one disjunction.|$|R
50|$|ALGOL 58, {{originally}} {{known as}} IAL, {{is one of}} the family of ALGOL computer programming languages. It was an early compromise design soon superseded by ALGOL 60. According to John Backus"The Zurich ACM-GAMM Conference had two principal motives in proposing the IAL: (a) To provide a means of communicating numerical methods and other procedures between people, and (b) To provide a means of realizing a stated process on a variety of machines..."ALGOL 58 introduced the fundamental notion of the <b>compound</b> <b>statement,</b> but it was restricted to control flow only, and it was not tied to identifier scope in the way that Algol 60's blocks were.|$|E
5000|$|Relaxed {{specification}} of the [...] {{statement in the}} language's definition. At {{the time of the}} device's invention this was the first edition of The C Programming Language which requires only that the body of the [...] be a syntactically valid (<b>compound)</b> <b>statement</b> within which [...] labels can appear prefixing any sub-statement. In conjunction with the fact that, {{in the absence of a}} [...] statement, the flow of control will fall through from a statement controlled by one [...] label to that controlled by the next, this means that the code specifies a succession of [...] copies from sequential source addresses to the memory-mapped output port.|$|E
5000|$|The kernel style uses tabs (with tab stops set at 8 characters) for indenting. Opening curly braces of a {{function}} {{go to the}} start of the line following the function header. Any other opening curly braces go on the same line as the corresponding statement, separated by a space. Labels in a [...] statement are aligned with the enclosing block (there is only one level of indents). A single-statement body of a <b>compound</b> <b>statement</b> (such as if, while, and do-while) need not be surrounded by curly braces. If, however, one or more of the substatements in an [...] statement require braces, then both substatements should be wrapped inside curly braces. Line length is limited to 80 characters.|$|E
5000|$|Since {{the limited}} {{size of the}} LGP-30 precluded a full {{implementation}} of ALGOL 60, certain of its features (arrays called by value, own arrays, strings, variable array bounds, and recursion) were omitted; but the implementers did include parameters called by name, using [...] "thunks", and integer labels. They dubbed their work ALGOL 30, since {{it was for the}} LGP-30. From this project emerged a small group of undergraduate students who were well equipped to perform further work in the development of computer languages. For instance, one student (Stephen J. Garland) discovered that <b>compound</b> <b>statements</b> and blocks could be included in the Samelson and Bauer scanning algorithm. This simple fact was not published until some years later.|$|R
5000|$|Visual Basic [...]NET 2008 {{introduced}} anonymous functions {{through the}} lambda form. Combined with implicit typing, VB provides an economical syntax for anonymous functions. As with Python, in VB.NET, anonymous functions must be defined on one line; they cannot be <b>compound</b> <b>statements.</b> Further, an anonymous function in VB.NET must truly be a VB.NET [...] - it must return a value. Dim foo = Function(x) x * xConsole.WriteLine(foo(10))Visual Basic.NET 2010 added support for multiline lambda expressions and anonymous functions without a return value. For example, a function {{for use in}} a Thread.Dim t As New System.Threading.Thread(Sub (...) For n as Integer = 0 to 10 'Count to 10 Console.WriteLine(n) 'Print each number Next End Sub)t.Start (...) ...|$|R
40|$|This paper gives a {{tutorial}} {{summary of}} the syntax and interpretation rules of the proposed international algebraic language put forward by the Zurich ACM-GAMM Conference, followed by a formal, complete presentation of the same information. Notations are presented for number a, numerical variables, Boolean variables, relations, n-dirnen-sional arrays, functi ons, operators and algebraic expressions. Means are provided in the language for specifying assignment of values to variables, conditional execution of statements, iterative procedures, formation of <b>compound</b> <b>statements</b> from sequences of statements, definition of new statements for arbitrary procedures, reuse and alteration of program segments. The proposed language is intended to provide convenient and concise means for expressing virtually all procedures of numerical compu-tation while employing relatively few syntactical rules and statement types...|$|R
5000|$|The {{simplest}} possible {{statement in}} C that behaves like a NOP {{is the so-called}} null statement, {{which is just a}} semi-colon in a context requiring a statement. (A compiler is not required to generate a NOP instruction in this case; typically, no instructions whatsoever would be generated.)Alternatively, an empty block (<b>compound</b> <b>statement)</b> may be used, and may be more legible: {}In some cases, such as the body of a function, a block must be used, but this can be empty. In C, statements cannot be empty - simple statements must end with a (semicolon) while compound statements are enclosed in {} (braces), which does not itself need a following semicolon. Thus in contexts where a statement is grammatically required, some such null statement can be used.|$|E
5000|$|Outside of mathematics, it is {{a matter}} of some {{controversy}} as to whether the truth function for material implication provides an adequate treatment of conditional statements in a natural language such as English, i.e., indicative conditionals and counterfactual conditionals. An indicative conditional is a sentence in the indicative mood with a conditional clause attached. A counterfactual conditional is a false-to-fact sentence in the subjunctive mood. [...] That is to say, critics argue that in some non-mathematical cases, the truth value of a <b>compound</b> <b>statement,</b> [...] "if p then q", is not adequately determined by the truth values of p and q. [...] Examples of non-truth-functional statements include: [...] "q because p", [...] "p before q" [...] and [...] "it is possible that p".|$|E
5000|$|To {{obtain a}} non-Euclidean geometry, the {{parallel}} postulate (or its equivalent) {{must be replaced}} by its negation. Negating the Playfair's axiom form, since it is a <b>compound</b> <b>statement</b> (... there exists one and only one ...), {{can be done in}} two ways. Either there will exist more than one line through the point parallel to the given line or there will exist no lines through the point parallel to the given line. In the first case, replacing the parallel postulate (or its equivalent) with the statement [...] "In a plane, given a point P and a line ℓ not passing through P, there exist two lines through P which do not meet ℓ" [...] and keeping all the other axioms, yields hyperbolic geometry. The second case is not dealt with as easily. Simply replacing the parallel postulate with the statement, [...] "In a plane, given a point P and a line ℓ not passing through P, all the lines through P meet ℓ", does not give a consistent set of axioms. This follows since parallel lines exist in absolute geometry, but this statement would say that there are no parallel lines. This problem was known (in a different guise) to Khayyam, Saccheri and Lambert and was the basis for their rejecting what was known as the [...] "obtuse angle case". In order to obtain a consistent set of axioms which includes this axiom about having no parallel lines, some of the other axioms must be tweaked. The adjustments to be made depend upon the axiom system being used. Amongst others these tweaks will have the effect of modifying Euclid's second postulate from the statement that line segments can be extended indefinitely to the statement that lines are unbounded. Riemann's elliptic geometry emerges as the most natural geometry satisfying this axiom.|$|E
40|$|Introduction to Modal Logic 2. Basic Modal Logic: Correspondence Theory 3. Basic Modal Logic: Completeness and Decidability 4. Hintikka's Logic of Knowledge 5. The {{problem of}} logical omniscience 6. Knowledge and time 7. Common Knowledge 8. Probabilistic Knowledge 9. Nonmonotonic {{reasoning}} 1 1 Introduction to Modal Logic In this lecture, we rst recall {{the basics of}} classical propositional logic and then introduce the basic modal logic of necessity. 1. 1 Propositional Logic The propositional calculus studies the logical structure of arguments. Assuming the truth of atomic propositional statements, the calculus {{involves the use of}} logical connectives to derive the truth or falsity of <b>compound</b> <b>statements.</b> Formally, we assume a countable set of propositional letters P = fp 0; p 1; : : :g, and the syntax of formulas is given by:<F 11. ...|$|R
5000|$|The various bracket {{characters}} are frequently {{used in many}} computer languages as operators or for other syntax markup. For instance, in C-like languages, [...] and [...] are often used to delimit a code block, and the parameters of method calls are generally enclosed by [...] and [...]In C, C++, Java and other C-derived languages—as well as in Scheme-influenced languages that have adopted C/Java syntax, such as JavaScript—the [...] "{}" [...] symbols {{are referred to as}} [...] "braces" [...] or [...] "curly braces" [...] and never as brackets. Since the term [...] "brace" [...] is documented in the definitive programming specifications for these languages, it is preferable to use the correct term brace so there is no confusion between the brace (used to denote <b>compound</b> <b>statements)</b> and the bracket, used to denote arrays.|$|R
40|$|In {{patent law}} {{most of the}} crucial legal {{questions}} such as patentability and infringement {{are linked to the}} patent claims. The European Patent Office regards patent claims as a set of independent features which are examined separately in a more or less formal way. The author has found that this approach allows for developing a simple logic model which treats patent claim features as logical statements and patent claims as <b>compound</b> <b>statements</b> wherein the individual logical statements are connected by logical connectives. The proposed logic model provides a uniform system for examining various legal questions that are dealt with separately under current case-law, moreover, it allows for examining the logical coherence between the different case-law decisions as well as detecting any hidden logical inconsistencies. The present paper offers an overview of the different legal questions linked to the patent claim and demonstrates the practical application of the proposed model...|$|R
