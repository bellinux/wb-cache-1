1|26|Public
50|$|The antenna {{couplers}} {{provide the}} proper impedance for radio frequency and {{ground support equipment}} commands. The command receivers are tuned to RSS command frequencies and provide the input signal to the distributors when an RSS command is sent. The command decoders use a <b>code</b> <b>plug</b> to prevent any command signal other than the proper command signal from getting into the distributors. The distributors contain the logic to supply valid destruct commands to the RSS pyrotechnics.|$|E
50|$|The Filesystem in Userspace (FUSE) {{mechanism}} allows userland <b>code</b> to <b>plug</b> {{into the}} virtual file system mechanism in Linux, NetBSD, FreeBSD, OpenSolaris, and macOS.|$|R
50|$|On November 8, 2007, SlySoft {{announced}} that BD+ discs can be copied with their AnyDVD HD software. This was possible because first generation BD+ titles did not check if AACS was present. This allowed a user to copy a BD to the harddrive and play {{it back from}} there using only a specific version of Cyberlink's PowerDVD (3319a), but not to transcode, otherwise manipulate the content or play it back from a burned BD-R or BD-RE. Updated versions of BD+ security <b>code</b> <b>plugged</b> this hole.|$|R
5000|$|The {{technology}} {{at the heart of}} Merchant Server originated at a company named eShop, which Microsoft acquired in June 1996. [...] It was primarily built using Python, with additional C++ <b>code</b> to <b>plug</b> into IIS and to run the primary server code as an NT Service.|$|R
5000|$|The CD-based {{parts catalog}} (known as [...] "ETKA") used by Volkswagen Group since 2000 {{requires}} a <b>coded</b> dongle be <b>plugged</b> into a host computer's port {{in order to}} run.|$|R
5000|$|The {{standard}} covers two TAE types: F ("Fernsprechgerät": for telephones) and N ("Nebengerät" [...] or [...] "Nichtfernsprechgerät": {{for other}} {{devices such as}} answering machines and modems). U <b>coded</b> sockets and <b>plugs</b> are universal connectors that are suitable for both device types.|$|R
50|$|Q {{has been}} touted as an ‘in house’ {{solution}} for games studios as it allows original <b>code</b> to be <b>plugged</b> {{into the system}} offering licensees the freedom to focus on creating specific tools and features for games projects without having to build an entire engine to accommodate them.|$|R
50|$|Django's {{configuration}} {{system allows}} third party <b>code</b> to be <b>plugged</b> into a regular project, provided that it follows the reusable app conventions. More than 2500 packages {{are available to}} extend the framework's original behavior, providing solutions to issues the original tool didn't tackle: registration, search, API provision and consumption, CMS, etc.|$|R
40|$|Autonomic {{computing}} systems aim {{to reduce}} the configuration, operational, and maintenance costs of distributed applications by enabling them to self-manage, selfheal, and self-optimize. This paper provides two contributions to the Model-Driven Development (MDD) of autonomic computing systems using Enterprise Java Beans (EJBs). First, we describe the structure and functionality of an MDD tool that visually captures the design of EJB applications, their quality of service (QoS) requirements, and the autonomic properties applied to their EJBs. Second, the paper describes how MDD tools can generate <b>code</b> to <b>plug</b> EJBs into a Java component framework that provides autonomic capabilities...|$|R
40|$|This paper extends {{and fully}} formalizes some {{previous}} results by developing an analytical method {{to account for}} the general chip pulse for DS-CDMA systems in an asynchronous environment with an integrate-and-dump receiver, applying it to commonly used pulses. Given the pulse, such a formal method allows us to define the optimum spreading code autocorrelation to be used and the relative signal-to-interference ratio performance. A chaos-based spreading <b>code</b> is <b>plugged</b> into this model to show that such an optimum performance can be very well approximated by practical sequence generators. This is shown by analyzing some typical bandlimited and substantially bandlimited pulses and determining the optimum spreading for each of them. These results prove that the gain of chaos-based spreading over conventional i. i. d. -like spreading can reach 75 % when practical bandlimited pulses are considered...|$|R
40|$|A GPU {{version of}} the {{pressure}} projection solver using OpenCL is implemented. Then it has been compared with CPU version which is accelerated with OpenMP. The GPU version shows a sensible reduction in time despite using a simple algorithm in the kernel. The nal <b>code</b> is <b>plugged</b> into a commercial uid simulator software. Dierent kinds of algorithms and data transfer methods have been investigated. Overlapping the computation and communication showed a more than 3 times speed-up versus the serial communication-computation pattern. Finally we exploit methods for partitioning data and writing kernels to use many of the bene ts of computation on a heterogeneous system. We ran all the simulations on a machine with an Intel core i 7 - 2600 cpu and 16 GB main memory coupled with a GeForce GTX 560 Ti graphic processing unit on a windows OS...|$|R
40|$|Autonomic {{computer}} systems aim {{to reduce the}} configuration, operational, and maintenance costs of distributed applications by enabling them to self-manage, self-heal, self-optimize, self-configure, and self-protect. This paper provides two contributions to the model-driven development (MDD) of autonomic computing systems using Enterprise Java Beans (EJBs). First, we describe the structure and functionality of an MDD tool that formally captures the design of EJB applications, their quality of service (QoS) requirements, and the autonomic properties applied to the EJBs to support the rapid development of autonomic EJB applications via code generation, automatic checking of model correctness, and visualization of complex QoS and autonomic properties. Second, the paper describes how MDD tools can generate <b>code</b> to <b>plug</b> EJBs into a Java component framework that provides an autonomic structure to monitor, configure, and execute EJBs and their adaptation strategies at run-time. We present a case study that evaluates how these tools and frameworks work to reduce the complexity of developing autonomic applications...|$|R
40|$|A {{workable}} {{approach for}} modernization of existing software into parallel/distributed applications is through coarse-grain restructuring. If, for instance, entire subroutines of legacy <b>code</b> can be <b>plugged</b> {{into a new}} structure, the investment required for the re-discovery {{of the details of}} what they do can be spared. The resulting renovated software can then take advantage of the improved performance offered by modern parallel/distributed computing environments, without rethinking or rewriting the bulk of their existing code. The authors discuss one of their experiments using the coordination language MANIFOLD to restructure an existing sequential numerical application written in Fortran 77, into a concurrent application...|$|R
40|$|We {{describe}} {{the methods and}} hardware that we are using to produce a real-time demonstration of an integrated Spoken Language System. We describe algorithms that greatly reduce the computation needed to compute the N-Best sentence hypotheses. To avoid grammar coverage problems we use a fully-connected first-order statistical class grammar. The speech-search algorithm is implemented on a board with a single Intel i 860 chip, which provides a factor of 5 speedup over a SUN 4 for straight C <b>code.</b> The board <b>plugs</b> directly into the VME bus of the SUN 4, which controls the system and contains the natural language system and application back end. 1...|$|R
50|$|Voltage {{and other}} {{characteristics}} {{are represented by}} a colour <b>code</b> (in three-phase <b>plugs</b> the stated voltage is the phase-phase voltage, not the phase-neutral voltage). The different voltages have the earth pin of a larger diameter than the others, and located in different places depending on the voltage rating, {{making it impossible to}} mate, for instance, a blue plug with a yellow socket. Since the different current ratings have different overall sizes, it is also not possible to mate different pin configurations or current ratings. For example, a 16 A 3P+E 400 V plug will not mate with a 16 A 3P+N+E 400 V socket and a 16 A P+N+E 230 V plug will not mate with a 32 A P+N+E 230 V socket.|$|R
40|$|Autonomic {{computer}} systems aim {{to reduce the}} configuration, operational, and maintenance costs of distributed enterprise applications. In theory, autonomic systems can minimize the impact of human error in system development and management. In practice, however, {{it is hard to}} develop the monitoring, analysis, planning, and execution aspects required for highly complex autonomic software systems reliably within short timeframes. This paper provides two contributions to the development of autonomic computing systems using Enterprise Java Beans (EJBs). First, we describe the structure and functionality of a model-driven development (MDD) tool that can formally capture the design of EJB systems, their quality of service (QoS) requirements, and the autonomic properties that will be applied to the EJBs to support the rapid development of autonomic EJB applications via code generation, automatic checking of model correctness, and visualization of complex QoS and autonomic properties. Second, the paper describes how MDD tools can generate <b>code</b> to <b>plug</b> EJBs into a Java component framework that provides an autonomic structure to monitor, configure, and execute EJBs and their adaptation strategies at run-time. We present a case study that shows how these tools and frameworks help manage autonomic distributed applications at the EJB level, thereby allowing developers to incorporate adaptive properties at a finer granularity than simply restarting or cloning entire EJB applications...|$|R
2500|$|However, checked {{exceptions}} {{can either}} require extensive [...] declarations, revealing implementation details and reducing encapsulation, or encourage coding poorly considered [...] blocks that can hide legitimate exceptions from their appropriate handlers. [...] Consider a growing codebase over time. An interface may be declared to throw exceptions X and Y. In a later {{version of the}} code, if one wants to throw exception Z, {{it would make the}} new code incompatible with the earlier uses. Furthermore, with the adapter pattern, in which one body of code declares an interface that is then implemented by a different body of code so that <b>code</b> can be <b>plugged</b> in and called by the first, the adapter code may have a rich set of exceptions to describe problems, but is forced to use the exception types declared in the interface.|$|R
50|$|Depth Analysis has {{developed}} a tools pipeline for game customers and CG productions. A plug-in for Autodesk 3ds Max, Motion Builder allows CG customers to build cut scenes for games or for CGI films to visualize captured heads of actors in real time within MotionBuilder. This means that CGI teams can quickly light their shots using close approximations of final dialogue and performance. For game teams, Depth Analysis provide a server infrastructure that allows designers and artists to visualize lines of dialogue and types of performance and mix, match and trim these lines for in game use. Depth Analysis captured 50 hours worth of raw data for L.A. Noire and used over 21 hours of final dialogue in the game.MotionScan is played back in game using <b>code</b> that can <b>plug</b> into any game engine and is compressed and decompressed using a video codec.|$|R
40|$|A {{workable}} {{approach for}} modernization of existing software into parallel/distributed applications is through coarse-grain restructuring. If, for instance, entire subroutines of legacy <b>code</b> can be <b>plugged</b> {{into a new}} structure, the investment required for the re-discovery {{of the details of}} what they do can be spared. The resulting renovated software can then take advantage of the improved performance offered by modern parallel/distributed computing environments, without rethinking or rewriting the bulk of their existing code. Our approach is simple and is in fact a cut-and-paste method. First we try to identify and isolate components in the legacy source code (the cut). Second, we glue them together by writing coordinator modules (glue modules) {{with the help of a}} coordination language (the paste). We have used Manifold as the glue language. Manifold is a general purpose coordination language developed at CWI (Centrum voor Wiskunde en Informatica) in the Netherlands and is specially desig [...] ...|$|R
40|$|Configuration {{of network}} {{services}} {{is a difficult}} problem requiring considerable human involvement. Recently, the hardware configuration of a personal computer has been simplified by the Plug and Play specification {{and the addition of}} the universal serial bus. Also recent developments in the CORBA framework, the Java language, mobile agent facilities, and Jini, have provided new tools that facilitate the movement of code from device to device, and help to provide a framework for service subscription and utilization on demand. This paper brings together the principles of the Plug and Play specification, CORBA, and mobile code in a design for plug and play network services that should provide more interoperability and language independence than the Java-centric approach. Keywords: Network service configuration, mobile <b>code,</b> mobile agents, <b>plug</b> and play 1 Plug-and-Play Network Service Configuration Using CORBA Syed Kamran Raza, Bernard Pagurek, Tony White Systems and Compu [...] ...|$|R
40|$|The {{configuration}} of network services {{is a hard}} problem requiring considerable human involvement. Recently, the hardware {{configuration of}} a personal computer has been simplified by the Plug and Play specification {{and the addition of}} the universal serial bus. The Java language has facilitated the movement of code from device to device, and most recently, the addition of Jini has provided a framework for service subscription and utilization on demand. This paper brings together the principles of the Plug and Play specification, Java, mobile code and Jini in a design for plug and play network services. Keywords: Network service configuration, mobile <b>code,</b> mobile agents, <b>plug</b> and play 1 Network Service Configuration with Jini: A Plug-and-Play Approach Syed Kamran Raza, Tony White, Bernard Pagurek Systems and Computer Engineering, Carleton University {skraza, tony, bernie}@sce. carleton. ca Abstract The configuration of network services is a hard problem requiring considerable human in [...] ...|$|R
40|$|The Transmission Control Protocol/lnternet Protocol (TCP/IP) [11 suite {{is widely}} {{employed}} to interconnect computing facilities in today‘s network environments However, there exist several security vulnerabilities in the TCP specification and additional weaknesses {{in a number}} of its implementations. These vulnerabilities may allow an intruder to “attack “ TCP-based systems, enabling him/her to ”hijack” a TCP connection or cause denial of service to legitimate users. The authors ana-lyze TCP code via a “reverse engineering ” technique called “program slicing ” to identify several of these vulnerabilities, especially those that are related to the TCP state-transition diagram. They discuss many of the flaws present in the TCP imple-mentation of many widely used operating systems, such as SUNOS 4. 1. 3, SVR 4, and ULTRlX 4. 3. The corresponding TCP attack “signatures “ (including the well-known 1 994 Christmas Day Mitnick Attack) are described, and recommendations are provided to improve the security state of a TCP-based system (e. g., incorpora-tion of a “timer escape route ” from every TCP state). Also, it is anticipated that wide dissemination of this article‘s results may not only lead to vendor patches to TCP <b>code</b> to <b>plug</b> security holes, but also raise awareness of how program slicing may be used to analyze other networking software and how future designs of TCP and other software can be improved. nteriietworking is an approach that allows dissimilar com-puters on dissimilar networks to communicate with one another in a seamless fashion by hiding the details of the underlying network hardware. The most widely used form of internetworking is provided by the Transmission Control Protocol/Internet Protocol (TCPIIP) suite. There are some inherent security problems in the TCP/IP suite [2] which makes the situation conducive to intruders. TCP sequence number prediction, IP address spoofing [3], misuse of IP’s source routing principle, and use of Internet Control Message Protocol (ICMP) messages for denial of ser...|$|R
40|$|Exploiting {{parallelism}} {{in modern}} machines increases the di culty of developing applications. Thus, new abstractions are needed that facilitate parallel programming {{and at the}} same time allow the programmer to control performance. Tiling is a very important primitive for controlling both parallelism and locality, but many traditional approaches to tiling are only applicable to computations on dense arrays. This thesis makes several contributions, all in the general area of data parallel operators for the programming of multiprocessors and their current most popular incarnation, multicores. It accomplishes this through the development of Ravenna, a library of data parallel operators for shared-memory systems. Ravenna extends previous work on a data type for dense arrays called the Hierarchically Tiled Array, or HTA. Ravenna supports arbitrary data types, enabling programmers to write data parallel computations based on other data types such as sets or graphs. Ravenna provides programmers with several mechanisms for tiling data types. In particular for data structures other than dense arrays, it provides a generalized approach called functional tiling. Functional tiling provides programmers with a separation of concerns between implementing a computation and how to tile it. Functional tiling in this way also acts as a tuning mechanism that allows programmers to tune the performance of their <b>codes</b> by <b>plugging</b> in di erent tiling strategies. This thesis evaluates the programming model of expressing programs as a sequence of higher level data parallel operators through examining several applications from di erent domains written in Ravenna. These applications include simple microbenchmarks used to compare against another shared-memory programming library, a solver for banded linear systems called SPIKE, n-body simulation, clustering, and discrete optimization. The evaluation shows that these programs can be elegantly expressed by the programming model, and that the model's applicability is not limited to computations based on dense arrays. Particularly, it shows that the resulting programs resemble conventional, sequential programs, simplifying programmer e ort and that the available abstractions provided by Ravenna allow programmers to tune in order to obtain good parallel performance...|$|R
40|$|We {{describe}} how the Production Code Control System (pCCS), written in Perl, {{has been used}} to control and monitor the execution of a large hydrodynamics simulation code in a production environment. We have been able to integrate new, disparate, and often independent, applications into the PCCS framework without the need to modify any of our existing application codes. Both users and code developers see a consistent interface to the simulation code and associated applications regardless of the physical platform, whether an MPP, SMP, server, or desktop workstation. We will also describe our use of Perl to develop a configuration management system for the simulation code, as well as a code usage database and report generator. We used Perl to write a backplane that allows us plug in preprocessors, the hydrocode, postprocessors, visualization tools, persistent storage requests, and other codes. We need only teach PCCS a minimal amount about any new tool or <b>code</b> to essentially <b>plug</b> it in and make it usable to the hydrocode. PCCS has made it easier to link together disparate codes, since using Perl has removed the need to learn the idiosyncrasies of system or RPC programming. The text handling in Perl makes it easy to teach PCCS about new codes, or changes to existing codes...|$|R
40|$|Several {{numerical}} landscape evolution models (LEMs) {{have been}} developed to date, and many are available as open source codes. Most are written in efficient programming languages such as Fortran or C, but often require additional <b>code</b> efforts to <b>plug</b> in to more user-friendly data analysis and/or visualization tools to ease interpretation and scientific insight. In this paper, we present an effort to port a common core of accepted physical principles governing landscape evolution directly into a high-level language and data analysis environment such as Matlab. SIGNUM (acronym for Simple Integrated Geomorphological Numerical Model) is an independent and self-contained Matlab, TIN-based landscape evolution model, built to simulate topography development at various space and time scales. SIGNUM is presently capable of simulating hillslope processes such as linear and nonlinear diffusion, fluvial incision into bedrock, spatially varying surface uplift which can be used to simulate changes in base level, thrust and faulting, as well as effects of climate changes. Although based on accepted and well-known processes and algorithms in its present version, it is built with a modular structure, which allows to easily modify and upgrade the simulated physical processes to suite virtually any user needs. The code is conceived as an open-source project, and is thus an ideal tool for both research and didactic purposes, thanks to the high-level nature of the Matlab environment and its popularity among the scientific community. In this paper the simulation code is presented together with some simple examples of surface evolution, and guidelines for development of new modules and algorithms are proposed. © 2011 Elsevier Ltd...|$|R
40|$|The Kinetic Tandem {{fusion plasma}} {{confinement}} concept {{is a member}} of the class of open magnetic confinement systems whose magnetic topology is that of a tube of magnetic flux open at both ends. In open-ended systems the central problem is that of limiting the rate of plasma losses out the ends. In a conventional tandem mirror system end-plugging is accomplished by the generation of positive potential barriers within special short mirror cells located at each end of a long central confinement cell. The kinetic tandem concept accomplishes the same end result by employing dynamic effects, but without the necessity of special end cells. The field employed in the kinetic tandem is a simple axially symmetric solenoidal field whose intensity tapers to low values at the ends. Since the field line curvature is everywhere positive such a field is stabilizing for MHD interchange modes. Into each end are injected ion beams that are aimed nearly parallel to the field line direction. The ions from these beams then are radially compressed, stopped, and reflected back by magnetic mirror action in climbing up the magnetic gradient. In this way ion density peaks are formed between which the plasma is to be confined. As in the original tandem mirror concept, a localized ambipolar potential arises to maintain quasi-neutrality between the ions and the electrons. provided the plasma density in the plugs is higher than that of the plasma contained between them the ions of the central plasma will be confined between the plugs by the positive potential barriers represented by the plugs. The plasma electrons will at the same time be confined by the overall positive potential of the plasma with respect to the ends. In this report some analytical calculations of the formation of the plugs will be given. These calculations were then confirmed and extended by computer simulations, using the LLNL code ICEPIC. Within the assumptions made in the theoretical calculations and in the <b>code</b> representation, fusion-relevant <b>plug</b> plasma parameters were achieved, and no evidence of unstable behavior was detected in the simulations...|$|R

