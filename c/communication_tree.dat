26|96|Public
5000|$|The Tree 2PC {{protocol}} (also called Nested 2PC, or Recursive 2PC) is {{a common}} variant of 2PC in a computer network, which better utilizes the underlying communication infrastructure. The participants in a distributed transaction are typically invoked in an order which defines a tree structure, the invocation tree, where the participants are the nodes and the edges are the invocations (communication links). The same tree is commonly utilized to complete the transaction by a 2PC protocol, but also another <b>communication</b> <b>tree</b> can be utilized for this, in principle. In a tree 2PC the coordinator is considered the root ("top") of a <b>communication</b> <b>tree</b> (inverted tree), while the cohorts are the other nodes. The coordinator can be the node that originated the transaction (invoked recursively (transitively) the other participants), but also another node in the same tree can take the coordinator role instead. 2PC messages from the coordinator are propagated [...] "down" [...] the tree, while messages to the coordinator are [...] "collected" [...] by a cohort from all the cohorts below it, before it sends the appropriate message [...] "up" [...] the tree (except an abort message, which is propagated [...] "up" [...] immediately upon receiving it or if the current cohort initiates the abort).|$|E
40|$|The general <b>communication</b> <b>tree</b> {{embedding}} {{problem is}} the problem of mapping a set of communicating terminals, represented by a graph G, into the set of vertices of some physical network represented by a tree T. In the case where the vertices of G are mapped into the leaves of the host tree T the underlying tree is called a routing tree and if the internal vertices of T are forced to have degree 3, the host tree is known as layout tree. Different optimization problems have been studied in the class of <b>communication</b> <b>tree</b> problems such as well-known minimum edge dilation and minimum edge congestion problems. In this report we study the less investigate measure i. e. tree length, which is a representative for average edge dilation (communication delay) measure and also for average edge congestion measure. We show that finding a routing tree T for an arbitrary graph G with minimum tree length is an NP-Hard problem. 1 Definitions and Introductory Points Consider a group of terminals communicating via a finite network G = (V,E), where the set of vertices (finite set V) and edges (finite setE), respectively represent the collection of terminals and their direct communication paths. We show ∣V ∣ by n and ∣E ∣ as m. The general <b>communication</b> <b>tree</b> embedding {{problem is the}} problem of mapping the set of terminals into th...|$|E
40|$|The owner-computes {{strategy}} {{has been used for}} evaluation of Fortran- 90 array expressions on distributed memory machines. This strategy simplifies code generation but is often expensive in terms of the total communication cost and size of temporary memory required for its implementation. In this paper, we propose the relaxing of the owner computes strategy, to reduce the total communication and temporary storage cost. We develop cost metrics for measuring the communication and memory cost associated with the evaluation of Fortran- 90 array expressions on distributed memory machines. The <b>communication</b> <b>tree</b> is introduced as a useful representation for array expressions involving associative and commutative operators of one kind. Procedures for estimating communication and temporary memory costs for a <b>communication</b> <b>tree</b> are described. An efficient polynomial-time algorithm to determine an evaluation order which minimizes the communication cost is presented. We also present an efficient pol [...] ...|$|E
40|$|Abstract. In {{this work}} we present two {{algorithms}} of irregular scat-ter/gather operations {{based on the}} binomial tree and Träff algorithms. We use the prediction provided by heterogeneous communication performance models when constructing <b>communication</b> <b>trees</b> for these operations. The experiments show that the model-based algorithms out-perform the traditional ones on heterogeneous platforms...|$|R
40|$|AbstractIn this paper, we {{deal with}} the problem of {{constructing}} optimal <b>communication</b> <b>trees</b> satisfying given <b>communication</b> requirements. We consider two constant degree <b>tree</b> <b>communication</b> models and several cost measures. First, we analyze whether a tree selected at random provides a good randomized approximation algorithm, and we show that such a construction fails for some of the measures. Secondly, we provide approximation algorithms for the case in which the communication requirements are given by a random graph in two different random models, namely the classical Gn,p and random geometric graphs. Finally, we conclude with some open problems...|$|R
40|$|This paper {{studies the}} {{complexity}} of finding cost-optimal <b>communication</b> <b>trees</b> for rooted, irregular gather and scatter collective communication operations in fully connected, one-ported communication networks under a linear, but not necessarily homogeneous transmission cost model. In the irregular gather and scatter problems, different processors may specify data blocks of possibly different sizes. Processors are numbered consecutively, and data blocks shall be collected or distributed from some (given) root processor. Data blocks from and to processors can be combined into larger segments consisting of multiple blocks; but individual data blocks cannot be split. We distinguish between ordered and unordered problems and algorithms. In an ordered, irregular gather tree algorithm all non-leaf processors receive segments of data blocks for consecutively numbered ranges of processors. An unordered tree algorithm permits received segments to consist of blocks for processors in any order. We show that the ordered problems can be solved in polynomial time, and give simple dynamic programming algorithms to construct optimal <b>communication</b> <b>trees</b> for both gather and scatter problems. In contrast, we show that the unordered problems are NP-complete. We have implemented the dynamic programming algorithms to experimentally evaluate {{the quality of a}} recent, simple, distributed algorithm which constructs close to optimal trees. Our experiments show that it is indeed very close to the optimum for a selection of data block distributions, and likely sufficient for all practical purposes...|$|R
40|$|Abstract: A new {{solution}} is presented for transferable utility games with graph communication where the cooperation possibilities {{are represented by}} a graph. Players are only able to cooperate and obtain some worth in a coalition if they form a connected set in the given graph. To determine the payoff for each player, a single-valued solution, the <b>communication</b> <b>tree</b> value, is proposed for this class of games. The idea is that to form the grand coalition of all players a player can join a set of players only if this player is connected in the graph {{to at least one}} of the players in the set. To a set of players, starting with an arbitrary single player, from each maximally connected subset of remaining players one player joins who is connected to one or more of the players in that set. In this way a (rooted) tree on the set of players is obtained, called a <b>communication</b> <b>tree.</b> For a given game each <b>communication</b> <b>tree</b> of the graph induces a marginal contribution vector, in which any player receives a payoff equal to what he contributes in worth when he joins his subordinates in the tree. The average payoff over all communication trees of the graph determines the value. In case the underlying graph is cycle-complete the value coincides with the average tree solution. When there is complete communication between all players, which is the special case of cycle-completeness, players join one by one, yielding the Shapley value. A weak form of convexity is introduced, under which the value is guaranteed to be an element of the core. For games with complete graph communication the condition coincides with convexity and in case the underlying graph is cycle-free it is weaker than super-additivity. ...|$|E
40|$|In this paper, we {{describe}} some new visualization methods for email threads. The methods concatenate initial message texts, or full texts shorn of extraneous material, into logical groupings embedded in, or closely aligned with, thread structure representations. The results {{are intended to}} provide useful thread overviews, and to enable coherent, efficient reading of thread content. Keywords Email archives, email threads, computer mediated <b>communication,</b> <b>tree</b> visualization, trees, narrow trees, treetables, email message analysis, threading, overview + detail, focus + contex...|$|E
40|$|A new load-balancing {{strategy}} for the solution of dynamical large-treesearch problems using a hierarchical approach We describe a new load-balancing strategy, applied here to the protein structure prediction problem, for improving {{the efficiency of the}} hierarchical approach when dealing with coarse-grained problems associated with large tree searches. Unlike other load-balancing strategies that reassign load from the heavily loaded processors to the lightly loaded or idle ones, the proposed strategy changes the virtual <b>communication</b> <b>tree</b> among the processors as the computational tree changes. The strategy incurs minimal overhead and is scalable. 1...|$|E
50|$|The {{documentary}} film Intelligent Trees features several of Wohlleben's observations. It portrays him alongside Suzanne Simard, {{a professor of}} forest ecology at the University of British Columbia, whose research supports most of Wohlleben's observations about <b>communication</b> among <b>trees.</b>|$|R
40|$|In {{this paper}} we address the Optimum <b>Communication</b> Spanning <b>Tree</b> Problem. We present a {{formulation}} that uses three index variables and we propose several families of inequalities, {{which can be used}} to reinforce the formulation. Preliminary computational experiments are very promising. Peer ReviewedPostprint (published version...|$|R
40|$|This paper {{studies the}} {{collective}} {{communication in the}} grid computing environment, which {{is characterized by the}} combination of distributed heterogeneous networks as well as uneven, long communication delay. Effi-cient collective communication requires communication schedule, which in turn requires network information. When the network information is not accurate or net-work faults occur, the performance of collective commu-nication can be significantly degraded. This paper pro-poses TTCC (Two-Tree Collective Communication) for scheduling collective communication in the grid. It pro-vides an efficient and reliable schedule even in this un-favorable network condition by maintaining two disjoint <b>communication</b> <b>trees.</b> Benefits of the proposed method are manifested via simulation, where the performance degradation with TTCC is much slower than those using conventional scheduling algorithms. Key Words: collective communication, grid computing, heterogeneous computing, network information, NWS...|$|R
40|$|An SPMD {{parallel}} implementation schema for divide-and-conquer specifications {{is proposed}} and derived b y formal refinement (transformation) of the specifica-tion. The specification {{is in the}} form of a mutually recursive functional definition. In a first phase, a par-allel functional program schema is constructed which consists of a <b>communication</b> <b>tree</b> and a functional pro-gram that is shared by all nodes of the tree. The fact that this phase proceeds b y semantics-preserving trans-formations in the Bird-Meertens formalism of higher-order junctions guarantees the correctness of the re-sulting functional implementation. A second phase yields an imperative distributed SPMD implementa-tion of this schema. The derivation process is illus-trated with an example: a two-dimensional numerical integration algorithm. ...|$|E
40|$|Sensor nodes, {{charged with}} battery power {{and capable of}} {{wireless}} communications, are distributed around to survey the environments and to send the needed data to the base station. The limited energy resources of sensor nodes are consumed in computation and especially in communication. To reduce power consumption for the sensor network, this paper presents a new data gathering scheme based on the hypercube topology. The hy-percube-based data gathering scheme collects data from all sensor nodes to the base sta-tion through the <b>communication</b> <b>tree</b> of the constructed hypercube. It shortens commu-nication delay by parallel transmission and replaces dead nodes through reconfiguration. Data gathering by the distributed hypercube and binary tree is also provided...|$|E
40|$|Abstract — The Spanning Tree Algorithm is {{the base}} of the link layer {{protocols}} like STP or RSTP. These are used in Ethernet bridges networks to eliminate loops by building a logical <b>communication</b> <b>tree</b> on top of the physical network. Even though it is an automatic and robust algorithm, its recovery time is too large. And as Ethernet is being extended to provider networks applications, very strict requirements on network recovery are imposed. This paper presents an analysis of the STA behavior in order to identify the theoretical limits of its convergence. An expression of its lowest bound and further simulation analysis to validate it are given. With a detailed and concrete analysis a final conclusion that identifies the key elements that determines the tree creation time is provided. I...|$|E
40|$|In this paper, {{we present}} a new linear time {{algorithm}} for scheduling uect (Unit Execution and <b>Communication</b> Time) <b>trees</b> on two identical processors: CBoS (clusters based on subtrees). The chosen criterion is the makespan. The used strategy is based on clustering of tasks. We show that this algorithm builds optimal schedules. Some extensions are discussed for non uet tasks...|$|R
40|$|We {{consider}} {{a model of}} communication in a network, where multiple sources have messages to disseminate among the network membership. We propose that all the messages (one from each source) be disseminated along the same spanning tree of the network and consider the problem of constructing such a tree. One evaluative measure for suitability of the construction {{is the sum of}} distances from each source for each vertex. We show that finding the exact solution in this case is NP-hard, for any selection of the sources. We therefore investigate this problem for some restricted classes of graphs and give efficient solution algorithms for those. We also {{consider a}}lternative measures of goodness of spanning <b>communication</b> <b>trees.</b> 1. Introduction In computer networks (e. g., the Internet), an increasingly prominent communication paradigm is multicast, whereby any of a set of network vertices called senders broadcasts its message to the set of (multicast group) members. In current Internet practi [...] ...|$|R
40|$|This paper {{proposes a}} new genetic {{algorithm}} {{to solve the}} Optimal <b>Communication</b> Spanning <b>Tree</b> problem. The proposed algorithm works on a tree chromosome without intermediate encoding and decoding, and uses crossovers and mutations which manipulate directly trees, while a traditional genetic algorithm generally works on linear chromosomes. Usually, an initial population is constructed by the standard uniform sampling procedure. But, our algorithm employs a simple heuristic based on Prim's algorithm to randomly generate an initial population...|$|R
40|$|We {{consider}} an efficient {{realization of the}} all-reduce operation with large data sizes in cluster environments, {{under the assumption that}} the reduce operator is associative and commutative. We derive a tight lower bound of the amount of data that must be communicated in order to complete this operation and propose a ring-based algorithm that only requires tree connectivity to achieve bandwidth optimality. Unlike the widely used butterfly-like all-reduce algorithm that incurs network contention in SMP/multi-core clusters, the proposed algorithm can achieve contention-free communication in almost all contemporary clusters including SMP/multi-core clusters and Ethernet switched clusters with multiple switches. We demonstrate that the proposed algorithm is more efficient than other algorithms on clusters with different nodal architectures and networking technologies when the data size is sufficiently large. Keywords: All-reduce, collective <b>communication,</b> <b>tree</b> topology, cluster of workstations...|$|E
40|$|A local {{reconfiguration}} algorithm (INP) for reliable routing in wireless sensor {{networks that}} consist of many static (fixed) energy-constrained nodes is introduced in the dissertation. For routing around crash fault nodes, a <b>communication</b> <b>tree</b> structure connecting sensor nodes to the base station (sink or root) is dynamically reconfigured during information dissemination. Unlike other location based routing approaches, INP does not take any support from a high costing system that gives position information such as GPS. For reconfigurations, INP uses only local relational information in the tree structure among nearby nodes by collaboration between the nodes that does not need global maintenance, so that INP is energy efficient and it scales to large sensor networks. The performance of the algorithm is compared to the single path with repair routing scheme (SWR) that uses a global metric and the modified GRAdient broadcast scheme (GRAB-F) that uses interleaving multiple paths by computation and by simulations. The comparisons demonstrate that using local relative information is mostly enough for reconfigurations, and it consumes less energy and mostly better delivery rates than other algorithms especially in dense environments. For the control observer to know the network health status, two new diagnosis algorithms (Repre and Local) that deal with crash faults for {{wireless sensor networks}} are also introduced in the dissertation. The control observer knows not only the static faults found by periodic testing but also the dynamic faults found by a path reconfiguration algorithm like INP that is invoked from evidence during information dissemination. With based on this information, the control observer properly treats the network without lateness. Local algorithm is introduced for providing scalability to reduce communication energy consumption when the network size grows. The performance of these algorithms is computationally compared with other crash faults identification algorithm (WSNDiag). The comparisons demonstrate that maintaining the <b>communication</b> <b>tree</b> with local reconfigurations in Repre and Local needs less energy than making a tree per each diagnosis procedure in WSNDiag. They also demonstrate that providing scalability in Local needs less energy than other approaches...|$|E
40|$|A <b>communication</b> <b>tree</b> is a {{binomial}} tree {{embedded in}} a hypercube, whose communication direction is from its leaves to its root. If a problem to be solved is first divided into independent subproblems, then each subproblem can be solved {{by one of the}} hypercube processors, and all the subresults can be merged into the final results through tree communication. This paper uses two random search techniques, the genetic algorithm (GA) and simulated annealing (SA), to construct fault-tolerant communication trees with the minimum data transmission time. Experimental evaluation shows that, with reasonably low search time, the proposed GA and SA approaches are able to find more desirable communication trees (i. e., trees with less data transmission time) than the minimal cost approach can. A distributed approach which applies parallel search to communication subtrees in disjoint subcubes is also provided to reduce the search time of the proposed approaches...|$|E
40|$|Metaheuristics, such as {{evolutionary}} algorithms or simulated annealing, {{are widely}} applicable heuristic optimization strategies that have shown encouraging results {{for a large}} number of difficult optimization problems. To show high performance, metaheuristics need to be adapted to the properties of the problem at hand. This paper illustrates how efficient metaheuristics can be developed for communication network problems by utilizing problem-specific knowledge for the design of a high-quality problem representation. The minimum <b>communication</b> spanning <b>tree</b> (MCST) problem finds a <b>communication</b> spanning <b>tree</b> that connects all nodes and satisfies their communication requirements for a minimum total cost. An investigation into the properties of the problem reveals that optimum solutions are similar to the minimum spanning tree (MST). Consequently, a problem-specific representation, the link biased (LB) encoding, is developed, which represents trees as a list of floats. The LB encoding makes use of the knowledge that optimum solutions are similar to the MST, and encodes trees that are similar to the MST with a higher probability. Experimental results for different types of metaheuristics show that metaheuristics using the LB-encoding efficiently solve existing MCST problem instances from the literature, as well as randomly generated MCST problems of different sizes and types...|$|R
40|$|In our research, {{context is}} defined as a {{situation}} a user has at hand. The focus in our study is on modelling contexts in cross-cultural communication environments. These environments can be physical, virtual or hybrid. Crosscultural communication environment – user – situation is the key triplet in our context research. In our paper we discuss context as a key to situation-specific computing. We introduce our cross-cultural <b>communication</b> context <b>tree</b> and context flow architecture and an example of implementation i. e. Context-Based eAssistant for Cross-Cultural Communication (CeACCC) ...|$|R
40|$|A recent {{means for}} {{enabling}} multicast in the Internet involves deploying network overlays where end-systems {{participate in the}} forwarding of data to other end-systems. The use of overlays not only permits individual sessions to simultaneously structure their <b>communication</b> <b>trees</b> atop unicast-only networks, but also gives the session greater flexibility when forming the topology of the forwarding tree. Even though multiple sessions are often expected {{to compete for the}} same network overlay resources, most work to date assumes that overlay protocols operate as though each session has isolated access to the available overlay resources. We consider two algorithms that build depth-bounded overlay trees where each node’s outgoing bandwidth constrains the number of nodes to which it can directly forward data. One algorithm tries to cluster a node’s available bandwidth within a single tree, the other tries to disperse the available bandwidth among multiple trees. When node capacities are identical and session requirements are identical, a clustering approach will increase the number of sessions that can co-exist [6]. However, we show via simulation that in heterogeneous networking environments or in environments where session participants vary with time, the dispersing algorithm outperforms the clustering algorithm. These results can be used to guide future development of overlay protocols that must partition resources among multiple sessions. 1...|$|R
40|$|Let T be a {{symmetric}} directed tree, i. e., a {{tree with}} each edge viewed as two opposite directed links. We consider the problem of routing arbitrary sets of connection requests in T. In all-optical <b>communication</b> <b>tree</b> networks with WDM (wavelength-division multiplexing) this is equivalent to color (assign wavelengths to) a given set of directed paths so that no two directed paths of the same color use the same link of T. Let W be the number of available wavelengths. The load, that is, {{the maximum number of}} directed paths passing through a link of T cannot exceed W. If there is no wavelength conversion available then each request (directed path) is restricted to a single wavelength and it is known that the minimum number of colors needed to color any set of directed paths in a tree is lower bounded away from the load L of the paths on the tree; moreover, no algori [...] ...|$|E
40|$|Abstract—An {{important}} use of unmanned aerial vehicles is {{surveillance of}} distant targets, where sensor information must quickly be transmitted {{back to a}} base station. In many cases, high uninterrupted bandwidth requires line-of-sight between sender and transmitter to minimize quality degradation. Communication range is typically limited, especially when smaller UAVs are used. Both problems can be solved to creating relay chains for surveillance of a single target, and relay trees for simultaneous surveillance of multiple targets. In this paper we show how such chains and trees can be calculated. For relay chains we create a set of chains offering different trade-offs {{between the number of}} UAVs in the chain and the chain’s cost. We also show new results on how relay trees can be quickly calculated and then incrementally improved if necessary. Encouraging empirical results for improvement of relay trees are presented. Index Terms—Unmanned aerial vehicles, UAV surveillance, relay, <b>communication,</b> <b>tree</b> optimization I...|$|E
40|$|Abstract — Many {{applications}} of wireless ad–hoc sensor networks involve collaboration among sensor nodes {{to achieve a}} common task. Moreover, such collaboration is often dynamic in nature. For instance, in an multi–object tracking application, sensor nodes that are tracking various moving objects must share information {{in order to improve}} the tracking quality. Thus, {{it is important to have}} a protocol that maintains group connectivity in such a setting. In this paper, we study the problem of maintaining communication paths among a group of moving agents that have interacted with one another. As its solution, we propose a data structure called the Distributed Collaboration Graph (DCG), which is a communication graph obtained from the agent trajectories. DCG can be constructed in a purely distributed fashion with very little cost and can be used for group discovery and for multicasting/broadcasting among agents. We also propose a distributed protocol which maintains a <b>communication</b> <b>tree</b> among the agents within the DCG while the agents are moving. This allows us to maintain group connectivity and provides the infrastructure for routing among the moving agents. I...|$|E
40|$|AbstractThe Eclipse Parallel Tools Platform (PTP) is an {{open source}} Integrated Development Environment (IDE) aiding the {{development}} of Supercomputer applications. The PTP parallel debugger is used by a growing community of developers in scientific and engineering fields. This paper proposes a method of improving the communication infrastructure of the PTP debugger {{by taking advantage of}} a Scalable Parallel Debugging Library (SPDL). Unlike the present communication framework of PTP, the Scalable Debug Manager (SDM), SPDL provides a pluggable architecture that allows developers to select a communication protocol suitable for a targeted supercomputer. It currently supports a number of scalable protocols, including MRNet and SCI. The advanced features provided by these <b>communication</b> <b>trees,</b> like programmable filters and configurable topologies, allow developers to create more flexible solutions of efficient reduction and aggregation operations for parallel debugging. In particular, they allow parallel debuggers to handle the large amounts of back-end messages in peta-scale environments with better efficiency. The architecture of the PTP debugger is extended to support SPDL. The extended architecture combines the advantages of the PTP debugger at the front-end and SPDL at the back-end. It improves the scalability and performance of the PTP debugger. Consequently, it provides a flexible option of utilizing the PTP debugger with pluggable communication protocols to address the debugging challenges in peta-scale environments...|$|R
40|$|This paper {{presents}} an application layer active networking infrastructure for distributed virtual reality. It will assess the efficiency for group <b>communication</b> of multicast <b>trees</b> over n-way distribution. The analysis of clock synchronisation and event routing is also performed. The viability of this infrastructure is assessed by simulation. ...|$|R
40|$|The secret keys of {{critical}} network authorities - such as time, name, certificate, and software update services - represent high-value targets for hackers, criminals, and spy agencies wishing {{to use these}} keys secretly to compromise other hosts. To protect authorities and their clients proactively from undetected exploits and misuse, we introduce CoSi, a scalable witness cosigning protocol ensuring that every authoritative statement is validated and publicly logged by {{a diverse group of}} witnesses before any client will accept it. A statement S collectively signed by W witnesses assures clients that S has been seen, and not immediately found erroneous, by those W observers. Even if S is compromised in a fashion not readily detectable by the witnesses, CoSi still guarantees S's exposure to public scrutiny, forcing secrecy-minded attackers to risk that the compromise will soon be detected by one of the W witnesses. Because clients can verify collective signatures efficiently without communication, CoSi protects clients' privacy, and offers the first transparency mechanism effective against persistent man-in-the-middle attackers who control a victim's Internet access, the authority's secret key, and several witnesses' secret keys. CoSi builds on existing cryptographic multisignature methods, scaling them to support thousands of witnesses via signature aggregation over efficient <b>communication</b> <b>trees.</b> A working prototype demonstrates CoSi in the context of timestamping and logging authorities, enabling groups of over 8, 000 distributed witnesses to cosign authoritative statements in under two seconds. Comment: 20 pages, 7 figure...|$|R
40|$|AbstractWe {{consider}} the following complete optimal stars-clustering-tree problem: Given a complete graph G=(V,E) with a weight on every edge {{and a collection of}} subsets of V, we want to find a minimum weight spanning tree T such that each subset of the vertices in the collection induces a complete star in T. One motivation for this problem is to construct a minimum cost (weight) <b>communication</b> <b>tree</b> network for a collection of (not necessarily disjoint) groups of customers such that each group induces a complete star. As a result the network will provide a “group broadcast” property, “group fault tolerance” and “group privacy”. We present another motivation from database systems with replications. For the case where the intersection graph of the subsets is connected we present a structure theorem that describes all feasible solutions. Based on it we provide a polynomial algorithm for finding an optimal solution. For the case where each subset induces a complete star minus at most k leaves we prove that the problem is NP-hard...|$|E
40|$|Given the {{topology}} of a network, {{characterized by}} an undirected graph, we consider the following game situation: a network manager is choosing (as communication infrastructure) a spanning tree of the graph, and an attacker is trying to disrupt the <b>communication</b> <b>tree</b> by attacking one link of the network. Attacking a link has a certain cost for the attacker who also has the option of not attacking. We model {{the interaction between the}} network manager and the attacker as a bimatrix game and study the set of mixed strategy Nash equilibria. We define the notion of critical subset of links and determine the structure of a particular set of Nash equilibria when the attack cost is non-zero. In each NE of this set, the attacker targets edges in critical subsets and all edges in the same critical subset are attacked with the same probability. For the game of zero cost of attack considered in [8], we characterize the set of all Nash equilibria. Some implications of the results are discussed and a detailed proof of the NE theorem is provided...|$|E
40|$|In a densely {{connected}} communication network, {{represented by}} a graph G with non-negative edge weights, it is often advantageous to route all communication on a sparse spanning subnetwork, typically a spanning tree of G. We consider a tree spanner T of G which guarantees that for any two nodes, their distance in T is at most k times their distance in G, where k, called the stretch, is as small as possible. When an edge of the <b>communication</b> <b>tree</b> T fails, network functionality may be restored byre-connecting the two separated parts of the tree with a swap edge. In situations where the failure can be repaired rapidly, such a quickfix is preferred over the recomputation of an entirely new minimum-stretch tree, because it is {{much closer to the}} previous solution and hence requires far fewer adjustments in the routing scheme. We are therefore interested in the problem of finding for any possibly failing edge in the spanner T, a best swap edge that minimizes the stretch of the new tree. We show how all these best swap edge...|$|E
40|$|Although {{efficient}} {{support for}} data-parallel applications is relatively well established, it remains open how well to support irregular and dynamic problems {{where there are}} no regular data structures and <b>communication</b> patterns. <b>Tree</b> search is central to solving a variety of problems in artificial intelligence and an important subset of the irregular applications where tasks are frequently created and terminated. In this paper, we introduce the design of a multithreaded distributed runtime system. Efficiency and ease of parallel programming are the two primary goals. In our system, multithreading is used to specify the asynchronous behavior in parallel game tree search, and dynamic load balancing is employed for efficient performance...|$|R
30|$|Another lack in this {{solution}} {{is that the}} keys are distributed in a tree manner. Then, to have a communication between a set of nodes, we do not certainly have a direct secure link between them. Then, a group communication is difficult to be proceeded in this schemes {{because it will be}} done as many separate secured connections in a <b>tree</b> <b>communication</b> manner.|$|R
40|$|The optimal <b>communication</b> {{spanning}} <b>tree</b> (OCT) {{problem is}} defined as follows. Let G = (V, E, w) be an undirected graph with nonnegative edge length function w. We are also given the requirements λ(u, v) for each pair of vertices. For any spanning tree T of G, the communication cost between two vertices is defined to be the requirement multiplied by the path length of the two vertices on T, and the communication cost of T is the total communication cost summed over all pairs of vertices. Our goal is to construct a spanning <b>tree</b> with minimum <b>communication</b> cost. That is, {{we want to find}} a spanning tree T such that � u,v∈V λ(u, v) dT (u, v) is minimized. The requirements in the OCT problem are arbitrary nonnegative values. By restricting the requirements, several special cases of the problem were defined in the literature. We list the problems in the following, in which r: V → Z + 0 is a given vertex weight function and S ⊂ V is a set of k vertices given as sources. • λ(u, v) = 1 for each u, v ∈ V: This version is the Minimum Routing Cost Spanning Tree (MRCT) problem discussed in the previous chapter. • λ(u, v) = r(u) r(v) for each u, v ∈ V: This version is called the Optimal Product-Requirement <b>Communication</b> Spanning <b>Tree</b> (PROCT) problem. • λ(u, v) = r(u) +r(v) for each u, v ∈ V: This version is called the Optimal Sum-Requiremen...|$|R
