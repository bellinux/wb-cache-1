0|20|Public
50|$|Performance Analyzer is {{available}} {{as part of}} Oracle Developer Studio. It has visualization capabilities, can read out hardware performance <b>counters,</b> <b>thread</b> synchronization, memory allocations and I/O, and specifically supports Java, OpenMP, MPI, and the Solaris kernel.|$|R
40|$|This thesis {{presents}} {{the design of}} the Configuration and Diagnostic units of the MAP chip. The MAP chip is a new microprocessor being developed for the M-Machine project. The Configuration units allow for the storage and access to various <b>counters,</b> <b>thread</b> state, and cluster data needed for thread swap. The diagnostics unit is responsible for booting the processor and is used as the interface between the external pins and the DIP and SCAN chains...|$|R
25|$|Typhoons from 1 Squadron {{were based}} at Lympne from March 1942 to February 1944 to <b>counter</b> the <b>thread</b> {{posed by the}} Luftwaffe's newly {{introduced}} Focke-Wulf Fw 190s. A runway was extended across Otterpool Lane to accommodate the Typhoons.|$|R
40|$|Abstract. We present Boom, a {{comprehensive}} analysis tool for Bool-ean programs. We focus {{in this paper}} on model-checking non-recursive concurrent programs. Boom implements a recent variant of <b>counter</b> ab-straction, where <b>thread</b> <b>counters</b> are used in a program-context aware way. While designed for bounded counters, this method also integrates well with the Karp-Miller tree construction for vector addition systems, resulting in a reachability engine for programs with unbounded thread cre-ation. The concurrent version of Boom is implemented using BDDs and includes partial order reduction methods. Boom is intended for model checking system-level code via predicate abstraction. We present exper-imental results for the verification of Boolean device driver models. ...|$|R
50|$|In some games, {{miniature}} {{figures are}} used to determine line of sight. Many wargames use counters to represent units and determine line of sight. A common technique is to hold a length of <b>thread</b> between two <b>counters.</b> If the <b>thread,</b> held straight, doesn't encounter any obstacles, the line of sight is valid.|$|R
5000|$|Robert-Houdin {{even made}} the test difficult. He placed {{a glass of}} water into his son's hands, and Emile {{proceeded}} to drink from it. He was able to perceive the taste of the liquids that spectators from the audience merely thought of. [...] Even then, the audiences were not entirely convinced, they tried to trip up Emile by bringing in books written in Greek, or odd tools such as a <b>thread</b> <b>counter.</b>|$|R
50|$|The {{simplest}} hardware implementation uses dedicated {{wires to}} transmit signal to implement barrier. This dedicated wire performs OR/AND operation {{to act as}} the pass/block flags and <b>thread</b> <b>counter.</b> For small systems, such a model works and communication speed {{is not a major}} concern. In large multiprocessor systems this hardware design can make barrier implementation have high latency. The network connection among processors is one implementation to lower the latency, which is analogous to Combining Tree Barrier.|$|R
40|$|In {{this paper}} we {{investigate}} {{the merits of}} combining tracing and profiling {{with the goal of}} limiting data volume and enabling a manual interpretation, while retaining some temporal information about the program execution characteristics. We discuss the general dimensions of performance data and which new kind of performance displays can be derived by adding a temporal dimension to profiling-type data. Among the most useful new displays are overheads over time which allows the location of when overheads such as synchronization arise in the target application and performance counter heatmaps that show performance <b>counters</b> for each <b>thread</b> over time. ...|$|R
40|$|This papers revisits non-deferred {{reference}} counting, {{a common}} technique {{to ensure that}} potentially shared large heap objects can be reused safely when they are both input and output to computations. Traditionally, thread-safe reference counting exploit implicit memory-based communication of counter data and require means to achieve a globally consistent memory state, either using barriers or locks. Acknowledgeing the distributed nature of upcoming many-core chips, we have developed a novel approach that keeps reference counters at single physical locations and ships the counting operations asynchronously to these locations using hardware primitives, rather than implicitely moving the <b>counter</b> data between <b>threads.</b> Compared to previous methods, our approach does not require full cache coherency...|$|R
40|$|The snowy plover is a shorebird {{endemic to}} the Americas. It {{consists}} of three subspecies. In South America the subspecies occidentalis is found {{along the coast of}} the Pacific ocean. Although breeding behaviour,population demography and reproductive success are well established in North America, little is known about these ecological parameters for occidentalis snowy plovers. In October 2008 we studied breeding ecology of snowy plovers in the National Reserve Paracas, Ica, Peru. Snowy plovers were found at all nine sandy beaches and coastal wetlands visited. Based on counts we estimate the population in Paracas to consist of a minimum of 500 snowy plovers. Evidence for breeding activity was found at six of nine sites. Most breeding activity was observed at Playón/Mendieta, surrounding a temporal salt lagoon. Two nests and ten families were found in the entire reserve. In total 24 chicks, eight males and seven females were captured and marked. Families were tended by both parents. Twenty-one of the chicks had perished {{by the end of the}} study. During the intense study period none of the marked chicks reached the fledgling age of 25 days and only one chick was confirmed to have fledged during a subsequent visit. Our observations highlight threads during the snowy plover reproduc- tive period that need to be addressed through conservation management and we suggest direct actions to <b>counter</b> the <b>threads</b> identified...|$|R
40|$|Abstract. In {{this paper}} {{we present a}} {{framework}} for automatic detection and application of the best binding between threads of a running parallel application and processor cores in a shared memory system, by making use of hardware performance counters. This is especially important {{within the scope of}} multicore architectures with shared cache levels. We demonstrate that many applications from the SPEC OMP benchmark show quite sensitive runtime behavior depending on the thread/core binding used. In our tests, the proposed framework is able to find the best binding in nearly all cases. The proposed framework is intended to supplement job scheduling systems for better automatic exploitation of systems with multicore processors, as well as making programmers aware of this issue by providing measurement logs. Key words: Multicore, CMP, automatic performance optimization, hardware performance <b>counters,</b> CPU binding, <b>thread</b> placement...|$|R
40|$|Abstract. The {{trend towards}} {{multi-core}} computing has made concurrent software an important target of computer-aided verification. Unfortunately, Model Checkers for such software suffer tremendously from combinatorial state space explosion. We show {{how to apply}} counter abstraction to real-world concurrent programs to factor out redundancy due to thread replication. The traditional global state representation as a vector of local states {{is replaced by a}} vector of <b>thread</b> <b>counters,</b> one per local state. In practice, straightforward implementations of this idea are unfavorably sensitive to the number of local states. We present a novel symbolic exploration algorithm that avoids this problem by carefully scheduling which counters to track at any moment during the search. Our experiments are carried out on Boolean programs, an abstraction promoted by the Slam project. To our knowledge, this marks the first application of counter abstraction to programs with non-trivial local state spaces, and results in the first scalable Model Checker for concurrent Boolean programs. ...|$|R
40|$|Cyber {{criminality}} {{activities are}} changing and {{becoming more and}} more professional. With the growth of financial flows through the Internet and the Information System (IS), new kinds of thread arise involving complex scenarios spread within multiple IS components. The IS information modeling and Behavioral Analysis are becoming new solutions to normalize the IS information and <b>counter</b> these new <b>threads.</b> This paper presents a framework which details the principal and necessary steps for monitoring an IS. We present the architecture of the framework, i. e. an ontology of activities carried out within an IS to model security information and User Behavioral analysis. The results of the performed experiments on real data show that the modeling is effective {{to reduce the amount of}} events by 91 %. The User Behavioral Analysis on uniform modeled data is also effective, detecting more than 80 % of legitimate actions of attack scenarios. Comment: International Journal of Computer Science Issues (IJCSI), Volume 1, pp 18 - 32, August 200...|$|R
40|$|Abstract The {{trend towards}} {{multi-core}} computing has made concurrent software an im-portant target of computer-aided verification. Unfortunately, Model Checkers for such soft-ware suffer tremendously from combinatorial state space explosion. We show how to ap-ply counter abstraction to real-world concurrent programs to factor out redundancy due to thread replication. The traditional global state representation as a vector of local states {{is replaced by}} a vector of <b>thread</b> <b>counters,</b> one per local state. In practice, straightforward im-plementations of this idea are unfavorably sensitive to the number of local states. We present a novel symbolic exploration algorithm that avoids this problem by carefully scheduling which counters to track at any moment during the search. We have carried out experiments on Boolean programs, an abstraction promoted by the success of the SLAM project. The ex-periments give evidence of the applicability of our method to realistic programs, and of the often huge savings obtained in comparison to plain symbolic state space exploration, and to exploration optimized by partial-order methods. To our knowledge, our tool marks the first implementation of counter abstraction to programs with non-trivial local state spaces, resulting in a Model Checker for concurrent Boolean programs that promises true scalability...|$|R
40|$|VeriFast is a {{verifier}} for single-threaded and multithreaded C and Java programs. It takes a C or Java program annotated with preconditions and postconditions in {{a separation}} logic notation, and verifies statically that these preconditions and postconditions hold, using symbolic execution. In plain separation logic, a thread either has full {{ownership of a}} memory location and knows the value at the location, or it has no ownership and {{no knowledge of the}} value of the location. Existing work proposes a marriage of rely-guarantee reasoning and separation logic to address this. In this document, we describe the shared boxes mechanism, which marries separation logic and rely-guarantee reasoning in VeriFast. We introduce and motivate the shared boxes mechanism using a minimalistic example and a realistic example. The minimalistic example is a counter program where one thread continuously increments a <b>counter</b> and other <b>threads</b> check that the counter does not decrease. For the realistic example, we verify functional correctness of the Michael-Scott queue, a lock-free concurrent data structure. We define the syntax and semantics of a simple C-like programming language, and we define a separation logic with shared boxes and prove its soundness. We discuss the implementation in VeriFast and the examples we verified using our VeriFast implementation. nrpages: 19 status: publishe...|$|R
40|$|The {{trend towards}} {{multi-core}} computing has made concurrent software an important target of computer-aided verification. Unfortunately, Model Checkers for such software suffer tremendously from combinatorial state space explosion. We show {{how to apply}} counter abstraction to real-world concurrent programs to factor out redundancy due to thread replication. The traditional global state representation as a vector of local states {{is replaced by a}} vector of <b>thread</b> <b>counters,</b> one per local state. In practice, straightforward implementations of this idea are unfavorably sensitive to the number of local states. We present a novel symbolic exploration algorithm that avoids this problem by carefully scheduling which counters to track at any moment during the search. We have carried out experiments on Boolean programs, an abstraction promoted by the success of the Slam project. The experiments give evidence of the applicability of our method to realistic programs, and of the often huge savings obtained in comparison to plain symbolic state space exploration, and to exploration optimized by partial-order methods. To our knowledge, our tool marks the first implementation of counter abstraction to programs with non-trivial local state spaces, resulting in a Model Checker for concurrent Boolean programs that promises true scalability. © 2010 Springer Science+Business Media, LLC...|$|R
40|$|This {{research}} project {{was conducted to}} increase weld gap tolerance in Friction Stir Welding (FSW) of 8 mm thick aluminum alloy 6082 – T 6. Investigation was done on I-STIR PDS platform and a Johnford milling machine. The {{research project}} involved tool-pin design with varying re-entrant features and varying parameters {{as a method of}} weld gap closing to produce successful welds. Direction of spindle rotation and dwell time were established as part of a preliminary study. Clockwise spindle rotation with 20 seconds dwell time allows sufficient plasticity and improved material flow which assisted in achieving welds with prior 30 percent weld gap of the plate thickness. Final welds were made using three rotational speeds and feed rates with sufficient plunging to prevent root defects. Analysis of the results were detailed which include vickers microhardness test, tensile test and metallographic observation to access the suitability of the weld structure. From the set of tool-pins designed, the flare tool-pin gave a well-defined weld nugget with improved stirring at the weld root. Also, with a concave shoulder, right hand threaded tool-pin and counterclockwise flutes undergoing a clockwise spindle rotation, plasticized material flow was upward which was beneficial in reducing the amount of plate thinning. The right hand <b>thread</b> <b>counter</b> clockwise flute with a flute machined in the foot exhibited superior tensile strength for welds containing 30 percent weld gap...|$|R
40|$|A lifting fixture {{has been}} {{designed}} to handle the Samus counters. These counters are being removed from the D-zero area and will be transported off site for further use at another facility. This fixture is designed specifically for this particular application and will be transferred along with the counters. The future use of these counters may entail installation at a facility without access to a crane and therefore a lift fixture suitable for both crane and/or fork lift usage has been created The counters weigh approximately 3000 lbs. and have threaded rods extended through the counter at the top comers for lifting. When these counters were first handled/installed these rods were used in conjunction with appropriate slings and handled by crane. The rods are secured with nuts tightened against the face of the <b>counter.</b> The rod <b>thread</b> is M 16 x 2 ({approx}. 625 -inch dia.) and extends 2 -inch (on average) {{from the face of the}} counter. It is this cantilevered rod that the lift fixture engages with 'C' style plates at the four top comers. The strongback portion of the lift fixture is a steel rectangular tube 8 -inch (vertical) x 4 -inch x. 25 -inch wall, 130 -inch long. 1. 5 -inch square bars are welded perpendicular to the long axis of the rectangular tube at the appropriate lift points and the 'C' plates are fastened to these bars with 3 / 4 - 10 high strength bolts -grade 8. Two short channel sections are positioned-welded-to the bottom of the rectangular tube on 40 feet centers, which are used as locators for fork lift tines. On the top are lifting eyes for sling/crane usage and are rated at 3500 lbs. safe working load each - vertical lift only...|$|R
40|$|Subject of {{this thesis}} are {{the design and}} {{implementation}} of an ad hoc Grid infrastructure. The vision of an ad hoc Grid further evolves conventional service-oriented Grid systems into a more robust, more flexible and more usable environment that is still standards compliant and interoperable with other Grid systems. A {{lot of work in}} current Grid middleware systems is focused on providing transparent access to high performance computing (HPC) resources (e. g. clusters) in virtual organizations spanning multiple institutions. The ad hoc Grid vision presented in this thesis exceeds this view in combining classical Grid components with more flexible components and usage models, allowing to form an environment combining dedicated HPC-resources with a large number of personal computers forming a "Desktop Grid". Three examples from medical research, media research and mechanical engineering are presented as application scenarios for a service-oriented ad hoc Grid infrastructure. These sample applications are also used to derive requirements for the runtime environment as well as development tools for such an ad hoc Grid environment. These requirements form the basis for the design and implementation of the Marburg ad hoc Grid Environment (MAGE) and the Grid Development Tools for Eclipse (GDT). MAGE is an implementation of a WSRF-compliant Grid middleware, that satisfies the criteria for an ad hoc Grid middleware presented in the introduction to this thesis. GDT extends the popular Eclipse integrated development environment by components that support application development both for traditional service-oriented Grid middleware systems as well as ad hoc Grid infrastructures such as MAGE. These development tools represent the first fully model driven approach to Grid service development integrated with infrastructure management components in service-oriented Grid computing. This thesis is concluded by a quantitative discussion of the performance overhead imposed by the presented extensions to a service-oriented Grid middleware as well as a discussion of the qualitative improvements gained by the overall solution. The conclusion of this thesis also gives an outlook on future developments and areas for further research. One of these qualitative improvements is "hot deployment" the ability to install and remove Grid services in a running node without interrupt to other active services on the same node. Hot deployment has been introduced as a novelty in service-oriented Grid systems {{as a result of the}} research conducted for this thesis. It extends service-oriented Grid computing with a new paradigm, making installation of individual application components a functional aspect of the application. This thesis further explores the idea of using peer-to-peer (P 2 P networking for Grid computing by combining a general purpose P 2 P framework with a standard compliant Grid middleware. In previous work the application of P 2 P systems has been limited to replica location and use of P 2 P index structures for discovery purposes. The work presented in this thesis also uses P 2 P networking to realize seamless communication accross network barriers. Even though the web service standards have been designed for the internet, the two-way communication requirement introduced by the WSRF-standards and particularly the notification pattern is not well supported by the web service standards. This defficiency can be answered by mechanisms that are part of such general purpose P 2 P communication frameworks. Existing security infrastructures for Grid systems focus on protection of data during transmission and access control to individual resources or the overall Grid environment. This thesis focuses on security issues within a single node of a dynamically changing service-oriented Grid environment. To <b>counter</b> the security <b>threads</b> arising from the new capabilities of an ad hoc Grid, a number of novel isolation solutions are presented. These solutions address security issues and isolation on a fine-grained level providing a range of applicable basic mechanisms for isolation, ranging from lightweight system call interposition to complete para-virtualization of the operating systems...|$|R

