28|10000|Public
5000|$|Example {{the call}} by address that simulates <b>call</b> <b>by</b> <b>reference</b> in C: ...|$|E
5000|$|Many {{languages}} support <b>call</b> <b>by</b> <b>reference</b> in {{some form}} or another, but comparatively few use it as a default. FORTRAN II is an early example of a call-by-reference language. A few languages, such as C++, PHP, Visual Basic [...]NET, C# and REALbasic, default to call by value, but offer special syntax for call-by-reference parameters. C++ additionally offers <b>call</b> <b>by</b> <b>reference</b> to const.|$|E
5000|$|It {{eliminates}} {{having to}} pass references and then dereference them, when using <b>call</b> <b>by</b> <b>reference</b> (or call by address, or call by sharing).|$|E
5000|$|... {{provides}} named parameter inheritance in nested routine <b>calls,</b> <b>by</b> <b>reference</b> or value.|$|R
5000|$|In the Standard Generalized Markup Language (SGML), {{an entity}} is a {{primitive}} data type, which associates a string {{with either a}} unique alias (such as a user-specified name) or an SGML reserved word (such as [...] ). Entities are foundational to the organizational structure and definition of SGML documents. The SGML specification defines numerous entity types, which are distinguished by keyword qualifiers and context. An entity string value may variously consist of plain text, SGML tags, and/or references to previously-defined entities. Certain entity types may also invoke external documents. Entities are <b>called</b> <b>by</b> <b>reference.</b>|$|R
50|$|Undefined or {{imported}} {{symbols are}} functions or variables that are <b>called</b> or <b>referenced</b> <b>by</b> this object, but not internally defined.|$|R
5000|$|Block structure, with {{underlying}} semantics (including recursion), à la Algol 60. Arguments {{are passed}} using <b>call</b> <b>by</b> <b>reference,</b> using dummy variables for values where needed (call by value).|$|E
5000|$|The {{semantics}} of call by copy-restore {{also differ}} from those of <b>call</b> <b>by</b> <b>reference</b> where two or more function arguments alias one another; that is, point to the same variable in the caller's environment. Under <b>call</b> <b>by</b> <b>reference,</b> writing to one will affect the other; call by copy-restore avoids this by giving the function distinct copies, but leaves the result in the caller's environment undefined depending on which of the aliased arguments is copied back first—will the copies be made in left-to-right order both on entry and on return? ...|$|E
50|$|<b>Call</b> <b>by</b> <b>reference</b> (also {{referred}} to as pass by reference) is an evaluation strategy where a function receives an implicit reference to a variable used as argument, rather than a copy of its value.This typically means that the function can modify (i.e. assign to) the variable used as argument—something that will be seen by its caller. <b>Call</b> <b>by</b> <b>reference</b> can therefore be used to provide an additional channel of communication between the called function and the calling function. A call-by-reference language {{makes it more difficult}} for a programmer to track the effects of a function call, and may introduce subtle bugs.|$|E
50|$|Programming {{languages}} use evaluation {{strategies to}} determine when to evaluate the argument(s) of a function call (for function, also read: operation, method, or relation) {{and what kind of}} value to pass to the function. For example, <b>call</b> <b>by</b> value/call <b>by</b> <b>reference</b> specifies that a function application evaluates the argument before it proceeds to the evaluation of the function's body and that it passes two capabilities to the function, namely, the ability to look up the current value of the argument and to modify it via an assignment statement. The notion of reduction strategy in lambda calculus is similar but distinct.|$|R
40|$|We {{define a}} new type of wavelet frame adapted to the study of wave equations, that we <b>call</b> Minkowski curvelets, <b>by</b> <b>reference</b> to the curvelets {{introduced}} by Candès, Demanet and Donoho. These space-time, strongly anisotropic, directional wavelets have a Fourier support which does not intersect the light-cone; their maximal size is proportional to the inverse of the distance to the light-cone. We show that the matrix of the Green kernel of the Klein-Gordon operator on Minkowski space-time has a nearly exponential off-diagonal decay in this basis. Comment: 20 pages, 2 figures - typos correcte...|$|R
50|$|Tables {{are always}} passed <b>by</b> <b>reference</b> (see <b>Call</b> <b>by</b> sharing).|$|R
50|$|<b>Call</b> <b>by</b> <b>reference</b> can be {{simulated}} in languages {{that use}} {{call by value}} and don't exactly support <b>call</b> <b>by</b> <b>reference,</b> by making use of references (objects that refer to other objects), such as pointers (objects representing the memory addresses of other objects). Languages such as C and ML use this technique. It is not a separate evaluation strategy—the language calls by value—but sometimes it {{is referred to as}} call by address (also referred to as pass by address). In an unsafe language like C this may cause memory safety errors such as null pointer dereferences, and also may be confusing. In ML references are type- and memory- safe.|$|E
50|$|In purely {{functional}} languages {{there is}} typically no semantic {{difference between the}} two strategies (since their data structures are immutable, so there is no possibility for a function to modify any of its arguments), so they are typically described as call by value even though implementations frequently use <b>call</b> <b>by</b> <b>reference</b> internally for the efficiency benefits.|$|E
50|$|The {{mechanism}} of references, if varying in implementation, {{is a fundamental}} programming language feature common to nearly all modern programming languages. Even some languages that support no direct use of references have some internal or implicit use. For example, the <b>call</b> <b>by</b> <b>reference</b> calling convention can be implemented with either explicit or implicit use of references.|$|E
5000|$|In May 2006, the Ontario {{wing of the}} Canadian Union of Public Employees (CUPE) voted {{unanimously}} to pass a resolution to support the “international campaign of boycott, divestment and sanctions against Israel until that state recognizes the Palestinian right to self-determination.” The three-point resolution continued on to call for action to develop an education campaign about the “apartheid nature of the Israeli state”, and for CUPE National to conduct research into Canadian involvement in the occupation. The Canadian Labour Congress was also enjoined to add its voice [...] "against the apartheid-like practices of the Israeli state ...". The resolution summarized its reasons for making this <b>call</b> <b>by</b> directly <b>referencing</b> the “Israeli Apartheid Wall”, and by recognizing the 170 Palestinian groups that have called for the global campaign. It further noted the voice of its sister union, CUPE BC, and its opposition to the occupation of Palestine.|$|R
50|$|In {{object-oriented}} programming, when a {{derived class}} inherits from a base class, {{an object of}} the derived class may be referred to via a pointer or reference of the base class type instead of the derived class type. If there are base class methods overridden by the derived class, the method actually <b>called</b> <b>by</b> such a <b>reference</b> or pointer can be bound either 'early' (by the compiler), according to the declared type of the pointer or reference, or 'late' (i.e., by the runtime system of the language), according to the actual type of the object referred to.|$|R
40|$|A meaning-preserving program {{restructuring}} tool {{can be used}} by {{a software}} engineer to change a program's structure to better support modifications during maintenance. Our implementation of such a tool performs restructuring transformations on code fragments that are selected using a text-based interface. However, a text representation does not represent program structure well because some component relationships that we conceptualize as structure are not readily observable in the program text. For example, structural properties such as module uses or procedure <b>calls</b> are represented <b>by</b> <b>references</b> to names rather than by proximity or direct linkage. Since restructuring is primarily a design-oriented activity, this design information must be readily available. Although the program text may be the wrong representation to manipulate, we still want transformations to directly affect the implementation. To solve both these problems, we use a graphical representation of the program design th [...] ...|$|R
50|$|ECL was an {{interactive}} system where programs were represented within the system; {{there was a}} compatible compiler and interpreter. It had an ALGOL-like syntax and an extensible data type system, with data types as first-class citizens. Data objects were values, not references, and the calling conventions gave a choice between call by value and <b>call</b> <b>by</b> <b>reference</b> for each argument.|$|E
5000|$|Another use is as a micro-optimization, {{to avoid}} {{assigning}} a local variable in a function and then needing to copy it when returning. This {{can be done}} when output parameters are implemented by <b>call</b> <b>by</b> <b>reference.</b> For example, in C++, instead of the more usual:LargeObject obj = f(x);one might instead write:LargeObject obj;f(x, &obj);so the function [...] {{does not need to}} assign space for the object or copy it on returning.|$|E
50|$|Programming {{languages}} {{that employ}} {{call by value}} semantics provide a called subroutine with its own local copy of the arguments passed to it. In most languages, these local parameters are treated the same as other local variables within the subroutine. In contrast, <b>call</b> <b>by</b> <b>reference</b> and call by name semantics allow the parameters to act as aliases of the values passed as arguments, allowing the subroutine to modify variables outside its own scope.|$|E
40|$|This paper {{describes}} an open C-like interpreter Clif. The main {{goal of the}} development is to prepare a syntactic and semantic framework which can be easily enriched with application directed syntactic and semantic subsystems. The interpreter contains an implementation of basic atomary types. A further data abstraction mechanism allows a use of n-dimensional arrays of atomary type elements. The functional abstraction allows a use of recursive function calls. Parameters in function <b>calls</b> are passed <b>by</b> <b>reference</b> and the interpreter architecture is optimized for manipulation with large objects. The interpreter contains also well-defined slots for client-server paradigm as well as user interfaces on various levels. 1. Introduction There are many situations when it is needed to prepare large programs for computer intensive information processing and for control of technological processes. Usually, to do this task efficiently the most appropriate way {{is to develop a}} language. The interprete [...] ...|$|R
5000|$|An IN OUT {{parameter}} {{may or may}} {{not have}} an initial value. That initial value {{may or may not}} be modified <b>by</b> the <b>called</b> program. Any changes made to the parameter are returned to the <b>calling</b> program <b>by</b> default by copying but - with the NOCOPY hint - may be passed <b>by</b> <b>reference.</b>|$|R
40|$|Are Kantian {{philosophy}} and its principle {{of respect for}} persons inadequate {{to the protection of}} environmental values? This paper answers this question by elucidating how Kantian ethics can take environmental values seriously. In the period that starts with the Critique of Judgment in 1790 and ends with the Metaphysics of Morals in 1797, the subject would have been approached by Kant in a different manner; although the respect that we may owe to non-human nature is still grounded in our duties to mankind, the basis for such respect stems from nature’s aesthetic properties, and the duty to preserve nature lies in our duties to ourselves. Compared to the “market paradigm”, as it is <b>called</b> <b>by</b> Gillroy (the <b>reference</b> is to a conception of a public policy based on a criterion of economic efficiency or utility), Kantian philosophy can offer a better explanation of the relationship between environmental policy and the theory of justice. Kantian justice defines the “just state” as the one that protects the moral capacities of its “active” citizens, as presented in the first Part of the Metaphysics of Morals. In the Kantian paradigm, the environmental risk becomes a “public” concern. That means it is not subsumed under an individual decision, based on a calculus...|$|R
5000|$|In some cases, {{the term}} [...] "call by value" [...] is problematic, as the value which is passed {{is not the}} value of the {{variable}} as understood by the ordinary meaning of value, but an implementation-specific reference to the value. The effect is that what syntactically looks like call by value may end up rather behaving like <b>call</b> <b>by</b> <b>reference</b> or call by sharing, often depending on very subtle aspects of the language semantics.|$|E
5000|$|Languages with <b>call</b> <b>by</b> <b>reference</b> - or equivalents, such as call by address using {{pointers}} - {{can allow}} for multivalued return by designating some parameters as output parameters. In this case, the function could just return the error value, with a variable intended {{to store the}} actual result being passed to the function. This {{is analogous to the}} use of an exit status to store an error code, and streams for returning content.|$|E
50|$|In {{practical}} terms, {{many modern}} programming languages have converged on a call-by-value/call-by-reference evaluation strategy for function calls (C#, Java). Some languages, especially lower-level languages such as C++, combine several notions of parameter passing. Historically, {{call by value}} and call by name date back to ALGOL 60, a language designed in the late 1950s. <b>Call</b> <b>by</b> <b>reference</b> is used by PL/I and some Fortran systems. Purely functional languages like Haskell, as well as non-purely functional languages like R, use call by need.|$|E
40|$|The Director of the Federal Register has {{approved}} under 5 U. S. C. 552 (a) and 1 CFR part 51 the incorporation <b>by</b> <b>reference</b> {{of the following}} publications. This list contains only those incorporations <b>by</b> <b>reference</b> effective as of the revision date of this volume. Incorporations <b>by</b> <b>reference</b> found within a regulation are effective upon the effective date of that regulation. For more information on incorporation <b>by</b> <b>reference,</b> see the preliminary pages of this volume. 49 CFR (PARTS 100 – 185...|$|R
40|$|<b>By</b> <b>Reference,</b> {{to clarify}} the purpose. In addition, the Department is proposing to update the federal {{regulations}} incorporated <b>by</b> <b>reference</b> in Appendix Q. The existing Appendix Q will be revoked and a new Appendix Q will be adopted. These proposals {{are part of the}} annual review of Title 40, Code of Federal Regulations (40 CFR) incorporations <b>by</b> <b>reference.</b> 2. CLASSES OF PERSONS AFFECTED: The classes of persons affected are the owners and operators of facilities that are subject to the regulations incorporated <b>by</b> <b>reference.</b> 3. CLASSES OF PERSONS WHO WILL BEAR COSTS: The classes of persons who will bear costs are the owners and operators of facilities that are subject to the regulations incorporated <b>by</b> <b>reference</b> which include New Source Performance Standards in 40 CF...|$|R
40|$|Background: Vancomycin {{has been}} widely used in the {{treatment}} of infections caused by Methicillin-Resistant Staphylococcus Aureus (MRSA). The emergence of Vancomycin-Intermediate and-Resistant Staphylococcus Aureus (VISA and VRSA, respectively) {{in various parts of the}} world has been of great concern in clinical settings. Objective: This study was performed to evaluate the possible presence of VISA and VRSA in Zarqa, Jordan. Setting: This study was done at Prince Hashem Hospital laboratory and clinical wards. Patients and Methods: The Minimum Inhibitory Concentration (MIC) of vancomycin for 139 Staphylococcus aureus strains isolated between April 2002 and August 2004 was carried out according to the standards of the National Committee for Clinical Laboratory Standards (NCCLS) using the agar dilution method. Resistance of VRSA to vancomycin was checked by E-test. Disk diffusion method was also used to determine the susceptibility of strains to common antibiotics. Determination of oxacillin MIC was performed for VRSA with the agar dilution method according to the guidelines of NCCLS and the E-test. Results: Using the disk diffusion test, most isolates (91. 7 %) were resistant to penicillin while the lowest resistance (10. 9 %) was to imipenem. Five of the 139 isolates had a vancomycin MI Cof e” 128 by agar dilution and E-test methods. All VRSA isolates were MRSA (MIC e ” 256) and the majority were also highly resistant to other antibiotics tested. Conclusion: This is the first report of isolation of VRSA in Zarqa, which <b>calls</b> for confirmation <b>by</b> <b>reference</b> laboratories and further epidemiological studies...|$|R
5000|$|In {{the most}} common case, call by value, a {{parameter}} acts within the subroutine as a variable initialized {{to the value of}} the argument (a local (isolated) copy of the argument if the argument is a variable), but in other cases, e.g. <b>call</b> <b>by</b> <b>reference,</b> the argument supplied by the caller can be affected by actions within the called subroutine (as discussed in evaluation strategy). In call by value, one can thus think of arguments as values (properly, think of the value of arguments as the [...] "arguments" [...] themselves), but in general arguments are not simply values.|$|E
5000|$|An output {{parameter}}, {{also known}} as an out parameter or return parameter, is a parameter used for output, rather than the more usual use for input. Using <b>call</b> <b>by</b> <b>reference</b> parameters, or call by value parameters where the value is a reference, as output parameters is an idiom in some languages, notably C and C++, while other languages have built-in support for output parameters. Languages with built-in support for output parameters include Ada (see Ada subprograms), Fortran (since Fortran 90; see Fortran [...] "intent"), various procedural extensions to SQL, such as PL/SQL (see PL/SQL functions) and Transact-SQL, C# and the [...]NET Framework, and the scripting language TScript (see TScript function declarations).|$|E
5000|$|Call by copy-restore (also {{referred}} to as copy-in copy-out, call by value result or call by value return—as termed in the Fortran community) is a special case of <b>call</b> <b>by</b> <b>reference</b> where the provided reference is unique to the caller. This variant has gained attention in multiprocessing contexts and Remote procedure call : if a parameter to a function call is a reference that might be accessible by another thread of execution, its contents may be copied to a new reference that is not; when the function call returns, the updated contents of this new reference are copied {{back to the original}} reference ("restored").|$|E
40|$|We {{offer an}} {{explicit}} comparison of referential processes in two most contrasting language types – spoken and signed languages. We compare referential processes of Russian Sign Language (RSL) {{with those of}} Russian. Like spoken languages, RSL demonstrates a fundamental difference between deixis and anaphora. Deictic <b>reference</b> is performed <b>by</b> pointing signs (similar to demonstratives of spoken languages), and anaphora by zero expressions and full NPs. The choice between anaphoric devices is guided by activation factors similar to those operating in spoken languages. RSL puts strong emphasis on zero anaphora, similarly to languages like Chinese. In contrast to spoken languages, a third important type of referential devices is found in RSL, <b>called</b> quasi-deictic <b>reference.</b> <b>By</b> this process the signer employs pointing signs (like in deixis) for making reference to entities that are not present in the surrounding physical space, but have been placed by the signer in an artificial constructed space {{in his or her}} signing arena. The signer thus projects his/her inner conceptual space onto the external constructed space...|$|R
50|$|A player foul is any foul, but {{typically}} personal and flagrant fouls, <b>by</b> <b>reference</b> to {{the count of}} fouls charged against a given player. A team foul is any foul <b>by</b> <b>reference</b> to the count against a given team.|$|R
40|$|Reference, and Appendix Q, {{to update}} the federal {{regulations}} incorporated <b>by</b> <b>reference.</b> As required <b>by</b> the Administrative Rules on Rulemaking, the existing Appendix Q will be revoked and a new Appendix Q will be adopted. These proposals {{are part of the}} annual review of Title 40, Code of Federal Regulations (40 CFR) incorporations <b>by</b> <b>reference.</b> 2. CLASSES OF PERSONS AFFECTED: The classes of persons affected are the owners and operators of facilities that are subject to the regulations incorporated <b>by</b> <b>reference...</b>|$|R
