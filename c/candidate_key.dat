102|548|Public
5000|$|... {employee_id} is {{the only}} minimal superkey, which also makes it the only {{candidate}} key--given that {firstname} and {surname} do not guarantee uniqueness. Since a primary key {{is defined as a}} chosen <b>candidate</b> <b>key,</b> and only one <b>candidate</b> <b>key</b> exists in this example, {employee_id} is the minimal superkey, the only <b>candidate</b> <b>key,</b> and the only possible primary key.|$|E
50|$|In a {{relational}} database, a <b>candidate</b> <b>key</b> uniquely identifies each row of data {{values in}} a database table. A <b>candidate</b> <b>key</b> comprises a single column or {{a set of}} columns in a single database table. No two distinct rows or data records in a database table can have the same data value (or combination of data values) in those <b>candidate</b> <b>key</b> columns since NULL values are not used. Depending on its design, a database table may have many candidate keys but at most one <b>candidate</b> <b>key</b> may be distinguished as the primary key.|$|E
5000|$|Actually we {{can detect}} every <b>candidate</b> <b>key</b> with this procedureby simply trying every {{possible}} order of removing attributes.However {{there are many}} more permutations of attributes (...) than subsets (...) [...]That is, many attribute orders will lead to the same <b>candidate</b> <b>key.</b>|$|E
50|$|These {{are indeed}} the <b>candidate</b> <b>keys</b> of relvar R.|$|R
5000|$|... #Subtitle level 3: Algorithm {{to derive}} <b>candidate</b> <b>keys</b> from {{functional}} dependencies ...|$|R
50|$|Only in {{rare cases}} does a 3NF table not meet the {{requirements}} of BCNF. A 3NF table that does not have multiple overlapping <b>candidate</b> <b>keys</b> is guaranteed to be in BCNF. Depending on what its functional dependencies are, a 3NF table with two or more overlapping <b>candidate</b> <b>keys</b> {{may or may not be}} in BCNF.|$|R
50|$|The table {{does not}} adhere to BCNF. This {{is because of}} the {{dependency}} Rate Type → Court in which the determining attribute Rate Type on which Court depends is neither a <b>candidate</b> <b>key</b> nor a superset of a <b>candidate</b> <b>key.</b>|$|E
50|$|In some {{circumstances}} the natural key that uniquely identifies a tuple in a relation may be cumbersome {{to use for}} software development. For example, it may involve multiple columns or large text fields. In such cases, a surrogate key can be used instead as the primary key. In other situations {{there may be more}} than one <b>candidate</b> <b>key</b> for a relation, and no <b>candidate</b> <b>key</b> is obviously preferred. A surrogate key may be used as the primary key to avoid giving one <b>candidate</b> <b>key</b> artificial primacy over the others.|$|E
50|$|We have to {{consider}} all the relations that might be assigned to a relvar {{to determine whether a}} certain set of attributes is a <b>candidate</b> <b>key.</b> For example, if we had considered only r1 then we would have concluded that {A,B} is a <b>candidate</b> <b>key,</b> which is incorrect. However, {{we might be able to}} conclude from such a relation that a certain set is not a <b>candidate</b> <b>key,</b> because that set does not have the uniqueness property (example {A,D} for r1). Note that the existence of a proper subset of a set that has the uniqueness property cannot in general be used as evidence that the superset is not a <b>candidate</b> <b>key.</b> In particular, note that in the case of an empty relation, every subset of the heading has the uniqueness property, including the empty set.|$|E
40|$|Abstract — Association Rule Mining {{is an area}} of {{data mining}} that focuses on pruning <b>candidate</b> <b>keys.</b> An Apriori {{algorithm}} is the most commonly used Association Rule Mining. This algorithm somehow has limitation and thus, giving the opportunity to do this research. This paper introduces a new way in which the Apriori algorithm can be improved. The modified algorithm introduces factors such as set size and set size frequency which in turn are being used to eliminate non significant <b>candidate</b> <b>keys.</b> With the use of these factors, the modified algorithm introduces a more efficient and effective way of minimizing <b>candidate</b> <b>keys.</b> Index Terms — Apriori algorithm, data mining, frequent items, set siz...|$|R
5000|$|The {{following}} algorithm actually runs in {{polynomial time}} {{in the number of}} <b>candidate</b> <b>keys</b> and functional dependencies: ...|$|R
50|$|The {{fact table}} {{contains}} business facts (or measures), and foreign keys which refer to <b>candidate</b> <b>keys</b> (normally primary keys) in the dimension tables.|$|R
5000|$|Primary keys: The <b>candidate</b> <b>key</b> {{selected}} as the unique identifier of an entity.|$|E
5000|$|Prime implicant is the {{corresponding}} {{notion of a}} <b>candidate</b> <b>key</b> in boolean logic ...|$|E
50|$|A {{relation}} that is {{in first}} normal form (1NF) must meet additional criteria {{if it is to}} qualify for second normal form. Specifically: a relation is in 2NF if it is in 1NF and no non-prime attribute is dependent on any proper subset of any <b>candidate</b> <b>key</b> of the relation. A non-prime attribute of a relation is an attribute that is not a part of any <b>candidate</b> <b>key</b> of the relation.|$|E
5000|$|The <b>candidate</b> <b>keys</b> for the Rate Types {{table are}} {Rate Type} and {Court, Member Flag}; the <b>candidate</b> <b>keys</b> for the Today's Bookings table are {Court, Start Time} and {Court, End Time}. Both tables are in BCNF. When {Rate Type} {{is a key}} in the Rate Types table, having one Rate Type {{associated}} with two different Courts is impossible, so by using {Rate Type} as a key in the Rate Types table, the anomaly affecting the original table has been eliminated.|$|R
5000|$|... which yields [...] {{candidate}} keys:.That is, {{the best}} we can expect is an algorithm that is efficient with respect to the number of <b>candidate</b> <b>keys.</b>|$|R
5000|$|INPUT: a set S of FDs {{that contain}} only subsets of a header H OUTPUT: the set C of superkeys that hold as <b>candidate</b> <b>keys</b> in all {{relation}} universes over H {{in which all}} FDs in S hold begin C := ∅; // found <b>candidate</b> <b>keys</b> Q := { H }; // superkeys that contain <b>candidate</b> <b>keys</b> while Q <> ∅ do let K be some element from Q; Q := Q - { K }; minimal := true; for each X->Y in S do K' := (K - Y) ∪ X; // derive new superkey if K' ⊂ K then minimal := false; Q := Q ∪ { K' }; end if end for if minimal {{and there is not}} a subset of K in C then remove all supersets of K from C; C := C ∪ { K }; end if end while end ...|$|R
5000|$|In this revised design, the [...] "Shop Near Person" [...] table has a <b>candidate</b> <b>key</b> of {Person, Shop}, and the [...] "Shop" [...] table has a <b>candidate</b> <b>key</b> of {Shop}. Unfortunately, {{although}} this design adheres to BCNF, it is unacceptable on different grounds: {{it allows us}} to record multiple shops of the same type against the same person. In other words, its candidate keys do not guarantee that the functional dependency {Person, Shop Type} → {Shop} will be respected.|$|E
50|$|The {{constituent}} attributes {{are called}} prime attributes. Conversely, an attribute {{that does not}} occur in ANY <b>candidate</b> <b>key</b> is called a non-prime attribute.|$|E
5000|$|Keys: An attribute, or {{combination}} of attributes, of an entity whose values uniquely identify each entity instance. Each such set constitutes a <b>candidate</b> <b>key.</b>|$|E
50|$|The <b>candidate</b> <b>keys</b> of a {{relation}} {{tell us all}} the possible ways we can identify its tuples. As such they are an important concept {{for the design of}} database schema.|$|R
50|$|In {{this design}} we have six relvars: Customer, Order, Order Line, Invoice, Invoice Line and Product. The bold, {{underlined}} attributes are <b>candidate</b> <b>keys.</b> The non-bold, underlined attributes are foreign keys.|$|R
50|$|Some {{database}} designers use surrogate keys systematically {{regardless of}} the suitability of other <b>candidate</b> <b>keys,</b> while others will use a key already present in the data, if there is one.|$|R
50|$|This {{table is}} in 5NF because each join {{dependency}} is {{implied by the}} <b>candidate</b> <b>key.</b> More specific, the only possible join dependencies are: {username, status}, {username,department}.|$|E
5000|$|Every {{element of}} A-X, the set {{difference}} between A and X, {{is a prime}} attribute (i.e., each attribute in A-X is contained in some <b>candidate</b> <b>key)</b> ...|$|E
5000|$|There is a {{fundamental}} difficulty for efficient algorithms for <b>candidate</b> <b>key</b> computation:Certain sets of functional dependencies lead to exponentially many candidate keys.Consider the [...] functional dependencies ...|$|E
50|$|A join {{dependency}} *{A, B, … Z} on R {{is implied}} by the <b>candidate</b> <b>key(s)</b> of R {{if and only if}} each of A, B, …, Z is a superkey for R.|$|R
5000|$|The {{definition}} of <b>candidate</b> <b>keys</b> can be illustrated {{with the following}} (abstract) example. Consider a relation variable (relvar) R with attributes (A, B, C, D) that has only the following two legal values r1 and r2: ...|$|R
50|$|Because {{all three}} {{attributes}} are prime attributes (i.e. belong to <b>candidate</b> <b>keys),</b> {{the table is}} in 3NF. The table is not in BCNF, however, as the Shop Type attribute is functionally dependent on a non-superkey: Nearest Shop.|$|R
50|$|Usually one <b>candidate</b> <b>key</b> {{is chosen}} {{to be called the}} primary key and used in {{preference}} over the other candidate keys, which are then called alternate keys.|$|E
5000|$|In the {{relational}} model of databases, a <b>candidate</b> <b>key</b> of a relation is a minimal superkey for that relation; that is, {{a set of}} attributes such that: ...|$|E
50|$|In Today's Court Bookings table, {{there are}} no non-prime {{attributes}}: that is, all attributes belong to some <b>candidate</b> <b>key.</b> Therefore the table adheres to both 2NF and 3NF.|$|E
5000|$|The set of all <b>candidate</b> <b>keys</b> can be computede.g. {{from the}} set of {{functional}} dependencies.To this end we need to define the attribute closure [...] for an attribute set [...]The set [...] contains all attributes that are functionally implied by [...]|$|R
40|$|When {{an attempt}} {{is made to}} modify tables {{that have not been}} {{sufficiently}} normalized undesirable side-effects may follow. This can be further specified as an update, insertion or deletion anomaly depending on whether the action that causes the error is a row update, insertion or deletion respectively. Most of the recent works on database normalization use a restricted definition of normal forms where only the primary key is taken into account and ignoring the rest of <b>candidate</b> <b>keys.</b> In this paper, we propose an algorithmic approach for database normalization up to third normal form by taking into account all <b>candidate</b> <b>keys,</b> including the primary key. The effectiveness of the proposed approach is evaluated on many real world examples...|$|R
40|$|The {{normalization}} of relational databases {{is a topic}} of ongoing interest. We present a graphical normalization algorithm for relational databases that is lossless, functional-dependency preserving, and able to normalize relations with multiple <b>candidate</b> <b>keys.</b> Applications of this algorithm and future research directions are discussed...|$|R
