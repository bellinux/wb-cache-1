56|44|Public
25|$|Some programmers write {{software}} with error reporting {{features that}} collect details {{that may be}} helpful in fixing the problem, and display those details on the screen, or store them to a file such as a <b>core</b> <b>dump,</b> {{or in some cases}} an automatic error reporting system such as Windows Error Reporting can automatically phone home and email those details to the programmers.|$|E
25|$|Post-mortem {{debugging}} is debugging of {{the program}} after it has already crashed. Related techniques often include various tracing techniques (for example,) and/or analysis of memory dump (or <b>core</b> <b>dump)</b> of the crashed process. The dump of the process could be obtained automatically by the system (for example, when process has terminated due to an unhandled exception), or by a programmer-inserted instruction, or manually by the interactive user.|$|E
50|$|Space Mission <b>core</b> <b>dump</b> {{systems are}} mostly based on {{existing}} toolkits for the target CPU or subsystem. However, over {{the duration of}} a mission the <b>core</b> <b>dump</b> subsystem may be substantially modified or enhanced for {{the specific needs of}} the mission.|$|E
50|$|<b>Core</b> <b>dumps</b> {{can serve}} as useful {{debugging}} aids in several situations. On early standalone or batch-processing systems, <b>core</b> <b>dumps</b> allowed a user to debug a program without monopolizing the (very expensive) computing facility for debugging; a printout could also be more convenient than debugging using switches and lights.|$|R
5000|$|In Unix-like systems, <b>core</b> <b>dumps</b> {{generally}} use {{the standard}} executable image-format: ...|$|R
5000|$|... program: program.c:5: main: Assertion `a != 1' failed. Abort (<b>core</b> <b>dumped)</b> ...|$|R
5000|$|Non-interactive breakpointsProgrammers {{have used}} machine code patches to {{implement}} single destructive breakpoints {{to cause a}} <b>core</b> <b>dump</b> {{since the early days}} of computers. The <b>core</b> <b>dump</b> provided the state of the registers and memory at the exact moment of the deliberate [...] "crash".|$|E
50|$|Introspector is a <b>core</b> <b>dump</b> {{analyzer}} for a compiler.|$|E
50|$|The NASA Voyager {{program were}} {{probably}} the first craft to routinely utilize the <b>core</b> <b>dump</b> feature in the Deep Space segment. The <b>core</b> <b>dump</b> feature is a mandatory telemetry feature for the Deep Space segment {{as it has been}} proven to minimize system diagnostic costs. The Voyager craft uses routine core dumps to spot memory damage from cosmic ray events.|$|E
5000|$|... {{an on-line}} printer, used mainly for <b>core</b> <b>dumps</b> of failed programs.|$|R
5000|$|Systems such as Microsoft Windows, {{which use}} {{filename}} extensions, may use extension for example, <b>core</b> <b>dumps</b> may be named [...] or [...]|$|R
50|$|<b>Core</b> <b>dumps</b> allow a user {{to save a}} crash {{for later}} or {{off-site}} analysis, or comparison with other crashes. For embedded computers, it may be impractical to support debugging on the computer itself, so analysis of a dump may take place on a different computer. Some operating systems such as early versions of Unix did not support attaching debuggers to running processes, so <b>core</b> <b>dumps</b> were necessary to run a debugger on a process's memory contents.|$|R
50|$|The BFD library {{can be used}} to {{read the}} {{structured}} data out of a <b>core</b> <b>dump.</b>|$|E
50|$|A dump {{analyzer}} is a {{programming tool}} {{which is used}} for understanding a machine readable <b>core</b> <b>dump.</b>|$|E
5000|$|Although {{its purpose}} is different, a [...] "system image" [...] is often similar in {{structure}} to a <b>core</b> <b>dump.</b>|$|E
5000|$|Although few {{programs}} {{are written in}} machine language, programmers often become adept at reading it through working with <b>core</b> <b>dumps</b> or debugging from the front panel.|$|R
50|$|On shared computers, whether time-sharing, batch processing, or server systems, <b>core</b> <b>dumps</b> allow {{off-line}} debugging of {{the operating}} system, so that the system can go back into operation immediately.|$|R
50|$|In {{computer}} software, strings is {{a program}} in Unix-like operating systems that finds and prints text strings embedded in binary files such as executables. It {{can be used on}} object files and <b>core</b> <b>dumps.</b>|$|R
50|$|Modern <b>core</b> <b>dump</b> {{files and}} error {{messages}} typically use hexadecimal encoding, as decimal and octal representations are less convenient to the programmer.|$|E
5000|$|Terminate (<b>core</b> <b>dump)</b> — Abnormal {{termination}} of the process. Additionally, implementation-defined abnormal termination actions, such as creation of a core file, may occur.|$|E
5000|$|The SIGQUIT {{signal is}} sent to a process by its {{controlling}} terminal when the user requests that the process quit and perform a <b>core</b> <b>dump.</b>|$|E
5000|$|Distro-independent while [...] {{deployed}} only on Fedora and Red Hat Enterprise Linux distributions. ABRT intercepts <b>core</b> <b>dumps</b> from {{applications and}} (after user-confirmation) sends bug reports to various bug-tracking systems, such as Fedora Bugzilla https://github.com/abrt/abrt/blob/master/README.md.|$|R
5000|$|Automatic service restart after failure. Works in {{conjunction}} with the Solaris Fault Manager, allowing software recovery in the event of hardware faults (cpu, memory), admin error such as accidental kills, and software <b>core</b> <b>dumps.</b>|$|R
50|$|Mach-O, {{short for}} Mach object file format, is a file format for executables, object code, shared libraries, dynamically-loaded code, and <b>core</b> <b>dumps.</b> A {{replacement}} for the a.out format, Mach-O offers more extensibility and faster access to information in the symbol table.|$|R
5000|$|In certain {{versions}} of the Linux kernel {{it was possible to}} write a program that would set its current directory to , request that a <b>core</b> <b>dump</b> be performed in case it crashes and then have itself killed by another process. The <b>core</b> <b>dump</b> file would have been placed at the program's current directory, that is, , and [...] would have treated it as a text file instructing it to run programs on schedule. Because the contents of the file would be under attacker’s control, the attacker would be able to execute any program with root privileges.|$|E
50|$|Under most UNIX based {{operating}} systems control-\ {{is used to}} terminate a running process from a command shell and have it produce a memory <b>core</b> <b>dump</b> by sending it a SIGQUIT signal.|$|E
50|$|Ubuntu host {{a public}} error tracker at errors.ubuntu.com which {{collects}} {{hundreds of thousands}} of error reports daily from millions of machines. If a program crashes on Ubuntu, a crash handler (such as Apport) will notify the user and offer to report the crash. If the user chooses to report the crash, the details (possibly including a <b>core</b> <b>dump)</b> will be uploaded to an Ubuntu server (daisy.ubuntu.com) for analysis. A <b>core</b> <b>dump</b> is automatically processed to create a stack trace and crash signature. The crash signature is used to classify subsequent crash reports caused by the same error.|$|E
50|$|One {{nice thing}} about the stack {{structure}} {{is that if a}} program does happen to fail, a stack dump is taken and it is very easy for a programmer {{to find out exactly what}} the state of a running program was. Compare that to <b>core</b> <b>dumps</b> and exchange packages of other systems.|$|R
5000|$|Before {{the advent}} of disk {{operating}} systems {{and the ability to}} record large data files, <b>core</b> <b>dumps</b> were paper printouts [...] of the contents of memory, typically arranged in columns of octal or hexadecimal numbers (a [...] "hex dump"), sometimes accompanied by their interpretations as machine language instructions, text strings, or decimal or floating-point numbers (cf. disassembler).|$|R
5000|$|Features include: {{the ability}} to disable ELF <b>core</b> <b>dumps,</b> {{reduce the number of}} swap files, use of the SLOB memory allocator, ability to disable BUG (...) [...] For {{measuring}} and accounting features include: ability for kmalloc/kfree allocations to be monitored through /proc/kmalloc; and measurement of inline usage during kernel compiling. TinyLinux requires Intel 80386 or better to run.|$|R
50|$|In some systems, such as Mac OS X and Microsoft Windows, a {{fatal error}} causes the {{operating}} system to create a log entry or to save an image (<b>core</b> <b>dump)</b> of the process.|$|E
5000|$|Although {{core memory}} is obsolete, any {{computer}} memory is still occasionally called [...] "core"; in particular, a file recording {{the contents of}} memory after a system error is usually called a <b>core</b> <b>dump.</b>|$|E
5000|$|... jmap Oracle jmap - Memory Map - [...] This utility outputs {{the memory}} map for Java and can print shared object memory maps or heap memory {{details of a}} given process or <b>core</b> <b>dump.</b> (experimental) ...|$|E
50|$|Some shell scripts need {{to query}} the user for {{sensitive}} {{information such as}} passwords, private digital keys, PIN codes or other confidential information. Sensitive input should not be echoed back to the screen/input device where it could be gleaned by unauthorized persons. Plaintext memory representation of sensitive information should also be avoided as it could allow the information to be compromised, e.g., through swap files, <b>core</b> <b>dumps</b> etc.|$|R
50|$|<b>CORE</b> Data <b>Dumps,</b> {{enables the}} {{accessibility}} of the data aggregated from repositories by CORE and allows their further manipulation.|$|R
50|$|Smalltalk {{images are}} similar to (restartable) <b>core</b> <b>dumps</b> and can provide the same {{functionality}} as <b>core</b> <b>dumps,</b> such as delayed or remote debugging with full access to the program state {{at the time of}} error. Other languages that model application code as a form of data, such as Lisp, often use image-based persistence as well. This method of persistence is powerful for rapid development because all the development information (e.g. parse trees of the program) is saved which facilitates debugging. However, it also has serious drawbacks as a true persistence mechanism. For one thing, developers may often want to hide implementation details and not make them available in a run time environment. For legal reasons as well as for maintenance reasons, allowing anyone to modify the program at run time inevitably introduces complexity and potential errors that would not be possible with a compiled system that does not expose source code in the run time environment. Also, while the persistence mechanism is easy to use it lacks the true persistence capabilities needed for most multi-user systems. The most obvious is the ability to do transactions with multiple users accessing the same database in parallel.|$|R
