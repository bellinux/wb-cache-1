112|260|Public
500|$|On 8 June 2009, {{four days}} {{short of the}} 91st anniversary of their murders, both Michael and Johnson were officially rehabilitated. Russian State Prosecutors stated, [...] "The {{analysis}} of the archive material shows that these individuals were subject to repression through arrest, exile and scrutiny... without being charged of committing <b>concrete</b> <b>class</b> and social-related crimes." ...|$|E
6000|$|... 'Doctrina sed vim promovet insitam;' and it {{was well}} that Darwin took up at Cambridge with the study of geology as his first love. For geology was then the living and moving science, as {{astronomy}} {{had been in the}} sixteenth century, and as biology is at the present day--the growing-point, so to speak, of European development, whence all great things might naturally be expected. Moreover, it was and is the central science of the <b>concrete</b> <b>class,</b> having relations with astronomy on the one hand, and with biology on the other; concerned alike with cosmical chances or changes on this side, and with the minutest facts of organic nature on that; the meeting-place and border-land of all the separate branches of study that finally bear upon the complex problems of our human life. No other subject of investigation was so well calculated to rouse Darwin's interest in the ultimate questions of evolution or creation, of sudden cataclysm or gradual growth, of miraculous intervention or slow development. Here, if anywhere, his enigmas were all clearly propounded to him by the inarticulate stony sphinxes; he had only to riddle them out for himself as he went along in after years with the aid of the successive side-lights thrown upon the world by the unconnected lanterns of Lamarck and of Malthus.|$|E
60|$|It may be {{objected to}} our {{definition}} of an abstract name, that not only the names which we have called abstract, but adjectives, which we have placed in the <b>concrete</b> <b>class,</b> are names of attributes; that white, for example, is as much {{the name of the}} color as whiteness is. But (as before remarked) a word ought to be considered as the name of that which we intend to be understood by it when we put it to its principal use, that is, when we employ it in predication. When we say snow is white, milk is white, linen is white, we do not mean it to be understood that snow, or linen, or milk, is a color. We mean that they are things having the color. The reverse is the case with the word whiteness; what we affirm to be whiteness is not snow, but the color of snow. Whiteness, therefore, {{is the name of the}} color exclusively: white is a name of all things whatever having the color; a name, not of the quality whiteness, but of every white object. It is true, this name was given to all those various objects on account of the quality; and we may therefore say, without impropriety, that the quality forms part of its signification; but a name can only be said to stand for, or to be a name of, the things of which it can be predicated. We shall presently see that all names which can be said to have any signification, all names by applying which to an individual we give any information respecting that individual, may be said to imply an attribute of some sort; but they are not names of the attribute; it has its own proper abstract name.|$|E
50|$|Creational design {{patterns}} {{are composed of}} two dominant ideas. One is encapsulating knowledge about which <b>concrete</b> <b>classes</b> the system uses. Another is hiding how instances of these <b>concrete</b> <b>classes</b> are created and combined.|$|R
5000|$|DynamicProxy, {{a popular}} {{lightweight}} proxy generator for interfaces and <b>concrete</b> <b>classes.</b>|$|R
40|$|Description logics have {{powerful}} deductive capabilities but {{rely on a}} weakly structured model. Databases provide storage optimization {{and offer}} better structuring capacities, especially within the object-oriented paradigm. We propose a model which offers the deductive capabilities of description logics and the structuring possibilities of the object approach. We distinguish between three types of <b>classes</b> : <b>concrete</b> <b>classes,</b> where objects are instantiated, virtual classes, which are subsets of <b>concrete</b> <b>classes,</b> corresponding to database objectpreserving views, and abstract classes, which factor common properties of objects from different <b>concrete</b> <b>classes.</b> A schema in this model can be translated into a description logics schema and into a database schema. The former represents the deductive part and the latter deals with the storage aspect...|$|R
50|$|A {{special case}} occurs in {{object-oriented}} programming, when a <b>concrete</b> <b>class</b> deploys an interface; {{in this case}} the <b>concrete</b> <b>class</b> is an deployment of the interface and it includes methods which are deployments of those methods specified by the interface.|$|E
5000|$|Includes {{horizontal}} mapping strategy (one table per <b>concrete</b> <b>class)</b> ...|$|E
5000|$|All <b>concrete</b> <b>class</b> {{packages}} {{must connect}} only through interface or abstract class packages.|$|E
40|$|Frameworks are {{a common}} {{object-oriented}} code-structuring technique that is used design; a framework instance {{is a set of}} <b>concrete</b> <b>classes</b> that subclass abstract classes to provide an executable subsystem. Frameworks are designed for reuse: abstract classes encapsulate common code and <b>concrete</b> <b>classes</b> encapsulate instance-specific code. Unfortunately, this delineation of reusable v. s. instance-specific code is problematic. <b>Concrete</b> <b>classes</b> of different framework instances can have much in common and there can be variations in abstract classes, all of which lead to unnecessary code replication. In this paper, we show how to overcome these limitations by decomposing frameworks and framework instances into primitive and reusable components. Doing so reduces code replication and creates a component-based product-line of frameworks and framework instances. ...|$|R
5000|$|Abstract factory pattern, which {{provides}} an interface for creating related or dependent objects without specifying the objects' <b>concrete</b> <b>classes.</b>|$|R
50|$|In an {{object-oriented}} environment, {{a framework}} consists of abstract and <b>concrete</b> <b>classes.</b> Instantiation {{of such a}} framework consists of composing and subclassing the existing classes.|$|R
5000|$|A <b>concrete</b> <b>class</b> is a {{class that}} can be instantiated, as opposed to {{abstract}} classes, which cannot.|$|E
5000|$|... we [...] "lose" [...] the <b>concrete</b> <b>class</b> {{as soon as}} we invoke a {{function}} of the base: ...|$|E
50|$|A {{class is}} a program-code-template of an object. It {{provides}} initial values and implementations of an SSDM object. A class {{can be defined}} as either abstract or concrete. A <b>concrete</b> <b>class</b> can be directly used to create an object. Concrete classes {{can be thought of as}} the feature classes or object classes in the ESRI geodatabase. On the other hand, an abstract class must be inherited to create a <b>concrete</b> <b>class.</b> SSDM abstract classes such as Feature, Feature Archive, and the SSDMSurveyObject describes the core attributes of an SSDM object.|$|E
5000|$|This is a UML diagram {{illustrating}} {{an example}} of loose coupling between a dependent class {{and a set of}} <b>concrete</b> <b>classes,</b> which provide the required behavior: ...|$|R
50|$|Because Map and ConcurrentMap are interfaces, {{new methods}} cannot {{be added to}} them without {{breaking}} implementations. However, Java 1.8 added the capability for default interface implementationsand it added to the Map interface default implementations of some new methods getOrDefault(Object, V), forEach(BiConsumer), replaceAll(BiFunction), computeIfAbsent(K, Function), computeIfPresent(K, BiFunction), compute(K,BiFunction), and merge(K, V, BiFunction). The default implementations in Map do not guarantee atomicity, but in the ConcurrentMap overriding defaults these use Lock free techniques to achieve atomicity, and existing ConcurrentMap implementations will automatically be atomic. The lock-free techniques may be slower than overrides in the <b>concrete</b> <b>classes,</b> so <b>concrete</b> <b>classes</b> may choose to implement them atomically or not and document the concurrency properties.|$|R
40|$|Linear {{expansions}} of minimum dynamic {{systems and}} linear almost periodical differential equations are {{considered in the}} paper aiming at the investigation of linear expansions with a non-empty set of non-trivial bounded movements and its application to the investigation of <b>concrete</b> <b>classes</b> of linear non-autonomous dynamic systems. As a result the structure of linear expansions with conditions of the movement separability has been investigated {{as well as the}} structure of linear almost periodical systems with conditions of Favar's type. The structural theorems obtained have been used for the investigation of <b>concrete</b> <b>classes</b> of evolution equationsAvailable from VNTIC / VNTIC - Scientific & Technical Information Centre of RussiaSIGLERURussian Federatio...|$|R
5000|$|This pattern {{creates the}} kind of object using its prototype. In other words, while {{creating}} the object of Prototype object, the class actually creates a clone of it and returns it as prototype.You can see here, we have used MemberwiseClone method to clone the prototype when required.public abstract class Prototype{\\ // normal implementation public abstract Prototype Clone (...)}public class ConcretePrototype1 : Prototype{ public override Prototype Clone (...) { return (Prototype)this.MemberwiseClone (...) // Clones the <b>concrete</b> <b>class.</b> }}public class ConcretePrototype2 : Prototype{ public override Prototype Clone (...) { return (Prototype)this.MemberwiseClone (...) // Clones the <b>concrete</b> <b>class.</b> }} ...|$|E
5000|$|The {{following}} NullObject pattern implementation {{demonstrates the}} <b>concrete</b> <b>class</b> providing its corresponding NullObject in a static field [...] This approach is frequently {{used in the}} [...]NET Framework ( [...] , , , etc.).|$|E
5000|$|Concrete {{classes have}} to {{explicitly}} declare they implement the immutable interface. This {{may not be}} possible if the <b>concrete</b> <b>class</b> [...] "belongs to" [...] third-party code, for instance, if it is contained within a library.|$|E
40|$|Abstract. A {{resonance}} type theorem is proved, where {{conditions are}} given, which imply the non-compactness {{and a certain}} estimation of {{the measure of the}} non-compactness of operators in weighted ideal and symmetric function spaces. The application of the theorem to some <b>concrete</b> <b>classes</b> of operators is discussed...|$|R
50|$|Interface-based {{programming}} {{defines the}} application {{as a collection}} of components, in which Application Programming Interface (API) calls between components may only be made through abstract interfaces, not <b>concrete</b> <b>classes.</b> Instances of classes will generally be obtained through other interfaces using techniques such as the Factory pattern.|$|R
50|$|This makes a class {{independent}} of how its objects are created (which <b>concrete</b> <b>classes</b> are instantiated).A class can be configured with a factory object, which it uses to create objects, and even more, the factory object can be exchanged at run-time.See also the UML class and sequence diagram below.|$|R
50|$|Object role {{refers to}} an {{exterior}} view of what general service is offered by the object. It {{is a set of}} related responsibilities. It can be implemented as a class or an interface. Interface, however, is the preferred implementation as it increases flexibility by hiding the <b>concrete</b> <b>class</b> which ultimately does the work.|$|E
50|$|Each {{object and}} link on an object diagram is {{represented}} by an InstanceSpecification. This can show an object's classifier (e.g. an abstract or <b>concrete</b> <b>class)</b> and instance name, as well as attributes and other structural features using slots. Each slot corresponds to a single attribute or feature, and may include a value for that entity.|$|E
5000|$|On 8 June 2009, {{four days}} {{short of the}} 91st anniversary of their murders, both Michael and Johnson were officially rehabilitated. Russian State Prosecutors stated, [...] "The {{analysis}} of the archive material shows that these individuals were subject to repression through arrest, exile and scrutiny ... without being charged of committing <b>concrete</b> <b>class</b> and social-related crimes." ...|$|E
5000|$|In {{the above}} UML class diagram, the [...] class that {{requires}} [...] and [...] objects doesn't instantiate the [...] and [...] classes directly.Instead, an [...] class creates the objects and injects theminto the , {{which makes the}} [...] independent of how the objects are created (which <b>concrete</b> <b>classes</b> are instantiated).|$|R
5000|$|... it is {{concrete}} - most upper ontologies {{start with}} abstract philosophical concepts that users must commit {{to in order}} to use the ontology. Gist starts with <b>concrete</b> <b>classes</b> that most people already do, or reasonably could agree with, such as Person, Organization, Document, Time, UnitOfMeasure and the like) ...|$|R
5000|$|Lists are {{implemented}} in the JCF via the [...] interface. It defines a list as essentially a more flexible version of an array. Elements have a specific order, and duplicate elements are allowed. Elements can {{be placed in a}} specific position. They can also be searched for within the list. Two examples for <b>concrete</b> <b>classes</b> that implement List are: ...|$|R
5000|$|Part : A part {{represents}} a role played at runtime by one instance of a classifier or by {{a collection of}} instances. The part may only name the role, it may name an abstract superclass, or it may name a specific <b>concrete</b> <b>class.</b> The part can include a multiplicity factor, such as the 0..* shown for Viewer in the diagram.|$|E
5000|$|In {{the above}} UML class diagram, the [...] class that {{requires}} a [...] object doesn't instantiate the [...] class directly.Instead, the [...] refers to a separate [...] to create a product object,which makes the [...] independent of which <b>concrete</b> <b>class</b> is instantiated.Subclasses of [...] can redefine which class to instantiate. In this example, the [...] subclass implements the abstract [...] by instantiating the [...] class.|$|E
50|$|A {{factory is}} the {{location}} of a <b>concrete</b> <b>class</b> in the code at which objects are constructed. The intent in employing the pattern is to insulate the creation of objects from their usage and to create families of related objects without having to depend on their concrete classes. This allows for new derived types to be introduced with no change to the code that uses the base class.|$|E
5000|$|This makes a class {{independent}} of how its objects are created (which <b>concrete</b> <b>classes</b> are instantiated).A class {{is no longer}} responsible for creating the objects it requires, and it doesn't have to delegate instantiation to a factory object as in the Abstract Factory [...] design pattern.This greatly simplifies a classand {{makes it easier to}} implement, change, test, and reuse.|$|R
5000|$|In {{the above}} UML class diagram, the [...] class that {{requires}} [...] and [...] objects doesn't instantiate the [...] and [...] classes directly.Instead, the [...] {{refers to the}} [...] interface for creating objects,which makes the [...] independent of how the objects are created (which <b>concrete</b> <b>classes</b> are instantiated).The [...] class implements the [...] interface by instantiating the [...] and [...] classes.|$|R
40|$|AbstractNew {{notions of}} amenability and contractability are introduced. Examples {{are given to}} show that {{for most of the}} new notions, the {{corresponding}} class of Banach algebras is larger than that for the classical amenable algebras introduced by Johnson. General theory is developed for these notions, and studied for several <b>concrete</b> <b>classes</b> of Banach algebras; special consideration is given to Banach algebras defined on locally compact groups...|$|R
