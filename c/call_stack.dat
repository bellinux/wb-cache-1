334|379|Public
25|$|The {{techniques}} to exploit a buffer overflow vulnerability vary by architecture, by operating system and by memory region. For example, exploitation on the heap (used for dynamically allocated memory), differs markedly from exploitation on the <b>call</b> <b>stack.</b>|$|E
25|$|Divide-and-conquer {{algorithms}} {{are naturally}} implemented as recursive procedures. In that case, the partial sub-problems {{leading to the}} one currently being solved are automatically stored in the procedure <b>call</b> <b>stack.</b> A recursive function is a function that calls itself within its definition.|$|E
25|$|The {{worst-case}} time {{complexity of}} Shell sort largely {{depends on the}} gap sequence used, and can range from O(n2) to O(n log2 n). Also, unlike efficient sorting algorithms, Shellsort does not require use of the <b>call</b> <b>stack,</b> making it useful in embedded systems where memory is at a premium.|$|E
5000|$|... #Subtitle level 2: Computers using <b>call</b> <b>stacks</b> and stack frames ...|$|R
40|$|Re-occurrence of {{the same}} problem is very common in many large {{software}} products. By matching the symptoms of a new problem to those in a database of known problems, automated diagnosis and even selfhealing for re-occurrences can be (partially) realized. This paper exploits function <b>call</b> <b>stacks</b> as highly structured symptoms of a certain class of problems, including crashes, hangs, and traps. We propose and evaluate algorithms for efficiently and accurately matching <b>call</b> <b>stacks</b> by a weighted metric of the similarity of their function names, after first removing redundant recursion and uninformative (poor discriminator) functions from those stacks. We also describe a new indexing scheme to speed queries to the repository of known problems, without compromising the quality of matches returned. Experiments conducted using <b>call</b> <b>stacks</b> from actual product problem reports demonstrate the improved accuracy (both precision and recall) resulting from our new stack-matching algorithms and removal of uninformative or redundant function names, {{as well as the}} performance and scalability improvements realized by indexing <b>call</b> <b>stacks.</b> We also discuss how call-stack matching can be used in both self-managing (or autonomic systems) and human “help desk” applications. 1...|$|R
5000|$|... 0-operand (zero-address machines), so <b>called</b> <b>stack</b> machines: All {{arithmetic}} operations {{take place}} using {{the top one}} or two positions on the stack: , , add, [...]|$|R
25|$|After {{the test}} case is {{sufficiently}} simplified, a programmer {{can use a}} debugger tool to examine program states (values of variables, plus the <b>call</b> <b>stack)</b> and track down {{the origin of the}} problem(s). Alternatively, tracing can be used. In simple cases, tracing is just a few print statements, which output the values of variables at certain points of program execution.|$|E
25|$|Any mutual {{recursion}} {{between two}} procedures {{can be converted}} to direct recursion by inlining the code of one procedure into the other. If there is only one site where one procedure calls the other, this is straightforward, though if there are several it can involve code duplication. In terms of the <b>call</b> <b>stack,</b> two mutually recursive procedures yield a stack ABABAB..., and inlining B into A yields the direct recursion (AB)(AB)(AB)...|$|E
2500|$|...NET Framework {{has its own}} {{security}} mechanism with two general features: Code Access Security (CAS), and validation and verification. CAS is based on evidence {{that is associated with}} a specific assembly. Typically the evidence {{is the source of the}} assembly (whether it is installed on the local machine or has been downloaded from the Internet). CAS uses evidence to determine the permissions granted to the code. Other code can demand that calling code be granted a specified permission. The demand causes CLR to perform a <b>call</b> <b>stack</b> walk: every assembly of each method in the <b>call</b> <b>stack</b> is checked for the required permission; if any assembly is not granted the permission a security exception is thrown.|$|E
5000|$|Since April 2015, {{there is}} ongoing work on porting kGraft {{to the common}} live {{patching}} core provided by the Linux kernel mainline. [...] However, implementation of the required function-level consistency mechanisms has been delayed because the <b>call</b> <b>stacks</b> provided by the Linux kernel may be unreliable in situations that involve assembly code without proper stack frames; as a result, the porting work remains in progress [...] In an attempt to improve the reliability of kernel's <b>call</b> <b>stacks,</b> a specialized sanity-check [...] userspace utility has also been developed.|$|R
25|$|No {{theoretical}} resolution limit. When multiple LCD {{panels are}} used {{together to create}} a single canvas, each additional panel increases the total resolution of the display, which is commonly <b>called</b> <b>stacked</b> resolution.|$|R
60|$|The auncient heroes gash an' bauld In {{the uncanny}} days of auld, The task ance fo(u)nd to which th'were <b>called,</b> <b>Stack</b> stenchly to it. His life sic noble lives recalled, Little's he knew it.|$|R
2500|$|JavaScript {{processes}} {{messages from}} a queue {{one at a}} time. Upon loading a new message, JavaScript calls a function associated with that message, which creates a <b>call</b> <b>stack</b> frame (the function's arguments and local variables). The <b>call</b> <b>stack</b> shrinks and grows based on the function's needs. Upon function completion, when the stack is empty, JavaScript proceeds to the next message in the queue. This is called the event loop, described as [...] "run to completion" [...] because each message is fully processed before the next message is considered. However, the language's concurrency model describes the event loop as non-blocking: program input/output is performed using events and callback functions. This means, for instance, that JavaScript can process a mouse click while waiting for a database query to return information.|$|E
2500|$|After {{partition}}ing, {{the partition}} with the fewest elements is (recursively) sorted first, requiring at most [...] space. Then the other partition is sorted using tail recursion or iteration, which doesn't {{add to the}} <b>call</b> <b>stack.</b> This idea, as discussed above, was described by R. Sedgewick, and keeps the stack depth bounded by [...]|$|E
2500|$|In runtime engine environments such as Java or [...]NET, {{there exist}} tools that {{attach to the}} runtime engine and every time that an {{exception}} of interest occurs, they record debugging information that existed in memory {{at the time the}} exception was thrown (<b>call</b> <b>stack</b> and heap values). These tools are called automated exception handling or error interception tools and provide 'root-cause' information for exceptions.|$|E
40|$|There {{exists a}} class of {{widespread}} languages that use stack machines for interpretation of programs, the so <b>called</b> <b>stack</b> based languages (Java virtual machine language, Forth, Postscript, several intermediate program representation languages and low level languages in some embedded systems). Semantics of stack operations determines the language of correct programs in sense of parameter passing through the stack. This is one alternative method to de ne the syntax of a stack based language, the so <b>called</b> <b>stack</b> eect calculus. The other method is based on systems of syntactic equations (general rewriting rules for terminal sequences) on sequences of stack operations. Both methods seem to have better expression power for the stack based languages than traditional context free grammars...|$|R
5000|$|On September 26, 2011, Delicious {{launched}} its completely new version 3.0 design in beta. Delicious {{added a new}} feature <b>called</b> <b>Stacks</b> that allows users to group multiple related links into a single page, and customize the Stack by adding title, description and a featured image.|$|R
40|$|Software {{systems are}} often modeled using {{infinite}} {{structures such as}} unbounded integers, infinite message queues and <b>call</b> <b>stacks,</b> and unbounded number of processes. This makes verification of these systems hard- in fact, for most common classes of infinite state systems, the verification problem can shown to be undecidable...|$|R
2500|$|Both {{the server}} {{and the client}} {{software}} for Eve Online are developed in Stackless Python, {{a variant of the}} Python programming language. Stackless Python allows a relatively large number of players to perform tasks without the overhead of using the <b>call</b> <b>stack</b> used in the standard Python distribution. This frees the game developers from performing some routine work and allows them to apply changes to the game universe without resetting the server. [...] However, the Eve cluster is taken offline daily for database and server maintenance.|$|E
2500|$|If no [...] block {{matches the}} type of the thrown exception, the {{execution}} of the outer block (or method) containing the [...] statement is discontinued, and the exception is passed up and outside the containing block or method. The exception is propagated upwards through the <b>call</b> <b>stack</b> until a matching [...] block is found within one of the currently active methods. If the exception propagates {{all the way up to}} the top-most [...] method without a matching [...] block being found, the entire program is terminated and a textual description of the exception is written to the standard output stream.|$|E
50|$|The CLI code {{can also}} perform Linked Demand {{for getting the}} {{permission}} from the <b>call</b> <b>stack.</b> In this case the CLR will look at only one method in the <b>call</b> <b>stack</b> in the TOP position for the specified permission. Here the stack walk-through is bound to one method in the <b>call</b> <b>stack</b> by which the CLR assumes that all the other methods in the <b>CALL</b> <b>STACK</b> have the specified permission. The Assembly {{is a combination of}} METADATA and MSIL file.|$|E
40|$|In many cases, {{recursion}} removal {{improves the}} efficiency of recursive algorithms, especially algorithms with large formal parameters, such as All Pair Shortest path (APSP) algorithms. In this article, a recursion removal of the Seidel's APSP [14] is presented, and a general method of recursion removal, <b>called</b> <b>stack</b> indexation is introduced...|$|R
50|$|A diagram {{like this}} can be drawn in either {{direction}} {{as long as the}} placement of the top, and so direction of stack growth, is understood. Furthermore, independently of this, architectures differ as to whether <b>call</b> <b>stacks</b> grow towards higher addresses or towards lower addresses. The logic of the diagram is independent of the addressing choice.|$|R
5000|$|Entelo {{launched}} its Diversity product in April 2014, allowing recruiters to source candidates from underrepresented {{groups based on}} gender, ethnicity, and veteran status. Its email tracking and outreach tool, Track, was released in January 2015. The company launched a candidate-ranking analytics solution <b>called</b> <b>Stack</b> in October 2015 and followed up with a mobile companion to Stack in October 2016.|$|R
5000|$|Since the <b>call</b> <b>stack</b> is {{organized}} as a stack, the caller pushes the return address onto the stack, and the called subroutine, when it finishes, pulls or pops the return address off the <b>call</b> <b>stack</b> and transfers control to that address. If a called subroutine calls {{on yet another}} subroutine, it will push another return address onto the <b>call</b> <b>stack,</b> and so on, with the information stacking up and unstacking as the program dictates. If the pushing consumes all of the space allocated for the <b>call</b> <b>stack,</b> an error called a stack overflow occurs, generally causing the program to crash. Adding a subroutine's entry to the <b>call</b> <b>stack</b> is sometimes called [...] "winding"; conversely, removing entries is [...] "unwinding".|$|E
50|$|In software, a stack {{overflow}} occurs if the <b>call</b> <b>stack</b> pointer exceeds the stack bound. The <b>call</b> <b>stack</b> may {{consist of a}} limited amount of address space, often determined {{at the start of the}} program. The size of the <b>call</b> <b>stack</b> depends on many factors, including the programming language, machine architecture, multi-threading, and amount of available memory. When a program attempts to use more space than is available on the <b>call</b> <b>stack</b> (that is, when it attempts to access memory beyond the call stack's bounds, which is essentially a buffer overflow), the stack is said to overflow, typically resulting in a program crash.|$|E
50|$|Taking regular-time {{samples of}} the <b>call</b> <b>stack</b> {{can be useful in}} {{profiling}} the performance of programs, because if a subroutine's pointer appears on the <b>call</b> <b>stack</b> sampling data many times, it is likely a code bottleneck and should be inspected for performance problems.|$|E
50|$|Ravioli code is a pejorative {{phrase for}} source code {{with lots of}} tiny, tightly-coupled objects. The tangled but {{explicit}} control structure of Spaghetti code is replaced with equally tangled but now implicit control flow using polymorphism. Overzealous separation and encapsulation of code can bloat <b>call</b> <b>stacks</b> and make navigation through the code for maintenance purposes more difficult.|$|R
5000|$|A stack {{hardware}} optimization is {{the provision}} of D (or [...] "display") registers. These are registers that point {{to the start of}} each <b>called</b> <b>stack</b> frame. These registers are updated automatically as procedures are entered and exited and are not accessible by any software. There are 32 D registers, which is what limits to 32 levels of lexical nesting.|$|R
5000|$|New Desktop, {{comprises}} a redesigned 3-D {{dock with}} a new grouping feature <b>called</b> <b>Stacks,</b> which displays files in either a [...] "fan" [...] style, [...] "grid" [...] style, or (since 10.5.2) a [...] "list" [...] style. Rory Prior, on the ThinkMac blog, criticized the shelf-like Dock along {{with a number of}} other changes to the user interface.|$|R
5000|$|In INTERCAL-72, {{the main}} control {{structures}} are NEXT, RESUME, and FORGET. [...] branches {{to the line}} specified, remembering the next line that would be executed if it weren't for the NEXT on a <b>call</b> <b>stack</b> (other identifiers than DO {{can be used on}} any statement, DO is given as an example); [...] removes expression entries {{from the top of the}} <b>call</b> <b>stack</b> (this is useful to avoid the error that otherwise happens when there are more than 80 entries), and [...] removes expression entries from the <b>call</b> <b>stack</b> and jumps to the last line remembered.|$|E
5000|$|The Scheme {{programming}} language reifies continuations (approximately, the <b>call</b> <b>stack).</b>|$|E
5000|$|Integrated {{debugger}} with stepping, persistent breakpoints, and <b>call</b> <b>stack</b> visibility.|$|E
40|$|Test suite {{reduction}} {{is an important}} test maintenance activity that attempts {{to reduce the size}} of a test suite with respect to some criteria. Emerging trends in software development such as component reuse, multi-language implementations, and stringent performance requirements present new challenges for existing reduction techniques that may limit their applicability. A test suite reduction technique that is not affected by these challenges is presented; it is based on dynamically generated language-independent information that can be collected with little run-time overhead. Specifically, test cases from the suite being reduced are executed on the application under test and the <b>call</b> <b>stacks</b> produced during execution are recorded. These <b>call</b> <b>stacks</b> are then used as a coverage requirement in a test suite reduction algorithm. Results of experiments on test suites for the space antenna-steering application show significant reduction in test suite size at the cost of a moderate loss in fault detection effectiveness. 1...|$|R
2500|$|Differentiable {{push and}} pop actions for {{alternative}} memory networks <b>called</b> neural <b>stack</b> machines ...|$|R
5000|$|If the [...] "étale" [...] is {{weakened}} to [...] "smooth", then such a <b>stack</b> is <b>called</b> an algebraic <b>stack</b> (also <b>called</b> an Artin <b>stack).</b> An algebraic {{space is}} Deligne-Mumford.|$|R
