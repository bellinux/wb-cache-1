909|192|Public
5|$|Cycle detection, {{the problem}} of {{following}} a path in a functional graph to find a cycle in it, has applications in cryptography and computational number theory, as part of Pollard's rho algorithm for integer factorization and as a method for finding collisions in <b>cryptographic</b> <b>hash</b> functions. In these applications, ƒ is expected to behave randomly; Flajolet and Odlyzko study the graph-theoretic properties of the functional graphs arising from randomly chosen mappings. In particular, a form of the birthday paradox implies that, in a random functional graph with n vertices, the path starting from a randomly selected vertex will typically loop back on itself to form a cycle within O(√n) steps. Konyagin et al. have made analytical and computational progress on graph statistics.|$|E
25|$|The {{applications}} of cycle detection include testing {{the quality of}} pseudorandom number generators and <b>cryptographic</b> <b>hash</b> functions, computational number theory algorithms, detection of infinite loops in computer programs and periodic configurations in cellular automata, and the automated shape analysis of linked list data structures.|$|E
25|$|Message {{authentication}} codes (MACs) {{are much}} like <b>cryptographic</b> <b>hash</b> functions, except that a secret key {{can be used}} to authenticate the hash value upon receipt; this additional complication blocks an attack scheme against bare digest algorithms, and so has been thought worth the effort.|$|E
5000|$|... those {{based on}} {{cryptographic}} primitives such as ciphers and <b>cryptographic</b> <b>hashes,</b> ...|$|R
3000|$|... [...]) {{between the}} {{descriptors}} corresponding to perceptually different signals {{must be kept}} low. Differently than in <b>cryptographic</b> <b>hashing,</b> signals that are perceptually close must lead to similar robust hashes. Despite this difference with respect to <b>cryptographic</b> <b>hashing,</b> the probability of collision remains the parameter that determines the [...] "resolution" [...] of a method for identification purposes.|$|R
3000|$|Bob verifies the {{signature}} of the hashes signed by Alice and returns the <b>cryptographic</b> <b>hashes</b> signed by him: (h(n [...]...|$|R
25|$|A secure {{digital camera}} (SDC) was {{proposed}} by Saraju Mohanty, et al. in 2003 {{and published in}} January 2004. This {{was not the first}} time this was proposed. Blythe and Fridrich also have worked on SDC in 2004 for a digital camera that would use lossless watermarking to embed a biometric identifier together with a <b>cryptographic</b> <b>hash.</b>|$|E
25|$|The {{birthday}} {{problem in}} this more generic sense applies to hash functions: the expected number of N-bit hashes that can be generated before getting a collision is not 2N, but rather only 2N/2. This is exploited by birthday attacks on <b>cryptographic</b> <b>hash</b> functions and {{is the reason why}} a small number of collisions in a hash table are, for all practical purposes, inevitable.|$|E
25|$|Systems {{that use}} {{passwords}} for authentication {{must have some}} way to check any password entered to gain access. If the valid passwords are simply stored in a system file or database, an attacker who gains sufficient access to the system will obtain all user passwords, giving the attacker access to all accounts on the attacked system, and possibly other systems where users employ the same or similar passwords. One way to reduce this risk is to store only a <b>cryptographic</b> <b>hash</b> of each password instead of the password itself. Standard cryptographic hashes, such as the Secure Hash Algorithm (SHA) series, are very hard to reverse, so an attacker who gets hold of the hash value cannot directly recover the password. However, knowledge of the hash value lets the attacker quickly test guesses offline. Password cracking programs are widely available that will test {{a large number of}} trial passwords against a purloined <b>cryptographic</b> <b>hash.</b>|$|E
50|$|Some secure environments employ <b>cryptographic</b> <b>hashing,</b> {{simply to}} verify that the {{information}} has not been altered since it was last modified.|$|R
25|$|Technically, digest {{authentication}} is {{an application}} of MD5 <b>cryptographic</b> <b>hashing</b> with usage of nonce values to prevent replay attacks. It uses the HTTP protocol.|$|R
40|$|Over {{the recent}} months {{it has become}} clear that the current {{generation}} of <b>cryptographic</b> <b>hashing</b> algorithms are insufficient to meet future needs. The ASH family of algorithms provides modifications to the existing SHA- 2 family. These modifications are designed with two main goals: 1) Providing increased collision resistance. 2) Increasing mitigation of security risks post-collision. The unique public/private sections and salt/pepper design elements provide increased flexibility for a broad range of applications. The ASH family is a new generation of <b>cryptographic</b> <b>hashing</b> algorithms. Comment: 5 page...|$|R
25|$|Differential {{cryptanalysis}} is {{a general}} form of cryptanalysis applicable primarily to block ciphers, but also to stream ciphers and <b>cryptographic</b> <b>hash</b> functions. In the broadest sense, it {{is the study of}} how differences in information input can affect the resultant difference at the output. In the case of a block cipher, it refers to a set of techniques for tracing differences through the network of transformation, discovering where the cipher exhibits non-random behavior, and exploiting such properties to recover the secret key (cryptography key).|$|E
25|$|In {{cryptographic}} applications, {{the ability}} to find two distinct values xμ-1 and xλ+μ-1 mapped by some cryptographic function ƒ to the same value xμ may indicate a weakness in ƒ. For instance, Quisquater and Delescaille apply cycle detection algorithms {{in the search for}} a message and a pair of Data Encryption Standard keys that map that message to the same encrypted value; Kaliski, Rivest, and Sherman also use cycle detection algorithms to attack DES. The technique may also be used to find a collision in a <b>cryptographic</b> <b>hash</b> function.|$|E
500|$|For most {{applications}} of hashing, {{it is necessary}} to compute the hash function for each value every time that it is hashed, rather than once when its object is created. In such applications, random or pseudorandom numbers cannot be used as hash values, because then different objects with the same value would have different hashes. And <b>cryptographic</b> <b>hash</b> functions (which are designed to be computationally indistinguishable from truly random functions) are usually too slow to be used in hash tables. Instead, other methods for constructing hash functions have been devised. These methods compute the hash function quickly, and can be proven to work well with linear probing. In particular, linear probing has been analyzed from the framework of -independent hashing, a class of hash functions that are initialized from a small random seed and that are equally likely to map any -tuple of distinct keys to any -tuple of indexes. The parameter [...] {{can be thought of as}} a measure of hash function quality: the larger [...] is, the more time it will take to compute the hash function but it will behave more similarly to completely random functions.|$|E
40|$|This {{research}} aims {{to examine}} the effectiveness and efficiency of fuzzing hashing algorithm {{in the identification of}} similarities in Malware Analysis. More precisely, it will present the benefit of using fuzzy hashing algorithms, such as ssdeep, sdhash, mvHash and mrsh – v 2, in identifying similarities in Malware domain. The obtained results will be compared with the traditional and most common <b>Cryptographic</b> <b>Hashes,</b> such as the MD 5, SHA- 1 and SHA- 256. Furthermore, it will highlight {{the pros and cons of}} fuzzy and <b>cryptographic</b> <b>hashing,</b> as well as their adoption in real world applications...|$|R
50|$|Ralph C. Merkle (born February 2, 1952) is a {{computer}} scientist. He {{is one of the}} inventors of public key cryptography, the inventor of <b>cryptographic</b> <b>hashing,</b> and more recently a researcher and speaker of cryonics.|$|R
50|$|Using <b>cryptographic</b> <b>hashes</b> {{inside the}} port knock {{sequence}} defends against packet sniffing between {{the source and}} target machines, preventing discovery of the port knock sequence or using the information to create traffic replay attacks to repeat prior port knock sequences.|$|R
2500|$|Removing {{support for}} MD5 and SHA-224 <b>cryptographic</b> <b>hash</b> {{functions}} ...|$|E
2500|$|Alice {{immediately}} computes a <b>cryptographic</b> <b>hash</b> of {{the string}} [...] "tail ljngjkrjgnfdudiudd gfdgdfjkherfsfsd", which is 59dea408d43183a3937957e71a4bcacc616d9cbc and sends it to Bob ...|$|E
2500|$|The Magnet URI scheme {{defines the}} format of magnet links, a de facto {{standard}} for identifying files by their content, via <b>cryptographic</b> <b>hash</b> value rather than by their location.|$|E
40|$|This {{document}} specifies Metalink/HTTP: Mirrors and <b>Cryptographic</b> <b>Hashes</b> in HTTP header fields, {{a different}} way to get information that is usually contained in the Metalink XML-based download description format. Metalink/HTTP describes multiple download locations (mirrors), Peer-to-Peer, <b>cryptographic</b> <b>hashes,</b> digital signatures, and other information using existing standards for HTTP header fields. Metalink clients can use this information to make file transfers more robust and reliable. Normative requirements for Metalink/HTTP clients and servers are described here. Status of This Memo This is an Internet Standards Track document. This document {{is a product of the}} Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by th...|$|R
50|$|Despite the {{weaknesses}} of the SFV format, it is popular due to the relatively small amount of time taken by SFV utilities to calculate the CRC32 checksums {{when compared to the}} time taken to calculate <b>cryptographic</b> <b>hashes</b> such as MD5 or SHA-1.|$|R
50|$|The Verisys agent {{examines}} {{a number}} of properties and attributes of each file to ascertain whether any changes have been made. Rather than simply check basic object properties, Verisys performs a <b>cryptographic</b> <b>hashing</b> algorithm on the actual data contained within each file.|$|R
2500|$|Also, As of October 2016, the Bitcoin Network had {{computing}} power {{claimed to be}} equivalent to 21,247,253.65 PFLOPS (Floating-point Operations Per Second). However, the elements of that network can perform only one specific <b>cryptographic</b> <b>hash</b> computation required by the bitcoin protocol. [...] They cannot perform general floating-point arithmetic operations, therefore their {{computing power}} cannot be measured in FLOPS.|$|E
2500|$|<b>Cryptographic</b> <b>hash</b> {{functions}} are a third type of cryptographic algorithm. They take {{a message of}} any length as input, and output a short, fixed length hash, {{which can be used}} in (for example) a digital signature. For good hash functions, an attacker cannot find two messages that produce the same hash. MD4 is a long-used hash function that is now broken; MD5, a strengthened variant of MD4, is also widely used but broken in practice. The US National Security Agency developed the Secure Hash Algorithm series of MD5-like hash functions: SHA-0 was a flawed algorithm that the agency withdrew; SHA-1 is widely deployed and more secure than MD5, but cryptanalysts have identified attacks against it; the SHA-2 family improves on SHA-1, but it isn't yet widely deployed; and the US standards authority thought it [...] "prudent" [...] from a security perspective to develop a new standard to [...] "significantly improve the robustness of NIST's overall hash algorithm toolkit." [...] Thus, a hash function design competition was meant to select a new U.S. national standard, to be called SHA-3, by 2012. The competition ended on October 2, 2012 when the NIST announced that Keccak would be the new SHA-3 hash algorithm. Unlike block and stream ciphers that are invertible, <b>cryptographic</b> <b>hash</b> functions produce a hashed output that cannot be used to retrieve the original input data. <b>Cryptographic</b> <b>hash</b> {{functions are}} used to verify the authenticity of data retrieved from an untrusted source or to add a layer of security.|$|E
2500|$|Public-key {{algorithms}} {{are most}} often based on the computational complexity of [...] "hard" [...] problems, often from number theory. For example, the hardness of RSA {{is related to the}} integer factorization problem, while Diffie–Hellman and DSA are related to the discrete logarithm problem. More recently, elliptic curve cryptography has developed, a system in which security is based on number theoretic problems involving elliptic curves. Because of the difficulty of the underlying problems, most public-key algorithms involve operations such as modular multiplication and exponentiation, which are much more computationally expensive than the techniques used in most block ciphers, especially with typical key sizes. As a result, public-key cryptosystems are commonly hybrid cryptosystems, in which a fast high-quality symmetric-key encryption algorithm is used for the message itself, while the relevant symmetric key is sent with the message, but encrypted using a public-key algorithm. Similarly, hybrid signature schemes are often used, in which a <b>cryptographic</b> <b>hash</b> function is computed, and only the resulting hash is digitally signed.|$|E
2500|$|... <b>cryptographic</b> <b>hashing</b> as {{the problem}} of finding a pre-image that hashes to a given value must be {{difficult}} to be useful, and ideally should require exponential time. However, if P=NP, then finding a pre-image M {{can be done in}} polynomial time, through reduction to SAT.|$|R
50|$|Theoretical {{model was}} {{published}} in early 2015 by Maciej A. Czyzewski. It was designed specifically to combine the benefits of hash function and pseudo-random function. However, {{it can be used}} to implement many cryptographic primitives, including <b>cryptographic</b> <b>hashes,</b> message authentication codes and randomness extractors.|$|R
40|$|A secure <b>cryptographic</b> <b>hashing</b> {{function}} {{should be}} resistant to three different scenarios: First, a <b>cryptographic</b> <b>hashing</b> function must be preimage resistant, that is, {{it should be}} infeasible for an attacker to construct a message such that it produces a known hash output value. Second, a <b>cryptographic</b> <b>hashing</b> function must be second preimage resistant, or it should be infeasible for an attacker to construct a message such that {{it has the same}} hash output value as another known message. Third, a <b>cryptographic</b> <b>hashing</b> function must be collision resistant, which means that it should be infeasible for an attacker to find any two different messages such that their hash output values are the same. The current Secure Hash Algorithm (SHA) family, namely SHA- 1 and SHA- 2, were designed by the National Security Agency (NSA) and published by the National Institute of Standards and Technology (NIST). Recent advances in cryptanalysis of hash functions have led to concerns about the collision resistance in the SHA family. To address these concerns, NIST has opened a public worldwide competition known as the SHA- 3 competition to find the new hash function, which will become SHA- 3. Each candidate hash function is scrutinized by the public, and candidates with found weaknesses are dropped from advancing to the next rounds of the competition. The goal is that the strongest hash function will emerge {{at the end of the}} competition, and this hash function will be free for everyone to use. This thesis implemented a generic attack against the collision resistance of small variants of one candidate in the SHA- 3 competition, CubeHash. A unique hash-chaining approach was used to find the collisions, and the parallelization of several FPGAs lead to parallelization measurements and analysis to see if a linear speedup could be obtained...|$|R
2500|$|Code signing uses public-key {{infrastructure}} to check if a file has been modified since being digitally signed by its publisher. Alternatively, a system owner or administrator {{can use a}} <b>cryptographic</b> <b>hash</b> function to compute a [...] "fingerprint" [...] at installation time that can help to detect subsequent unauthorized changes to on-disk code libraries. However, unsophisticated schemes check only whether the code has been modified since installation time; subversion prior to that time is not detectable. The fingerprint must be re-established each time changes are made to the system: for example, after installing security updates or a service pack. The hash function creates a message digest, a relatively short code calculated from each bit in the file using an algorithm that creates large changes in the message digest with even smaller changes to the original file. By recalculating and comparing the message digest of the installed files at regular intervals against a trusted list of message digests, changes in the system can be detected and monitored—as long as the original baseline was created before the malware was added.|$|E
5000|$|... 2001:20::/28 — ORCHIDv2 (Overlay Routable <b>Cryptographic</b> <b>Hash</b> Identifiers). These are non-routed IPv6 {{addresses}} {{used for}} <b>Cryptographic</b> <b>Hash</b> Identifiers.|$|E
50|$|In cryptography, a {{preimage}} {{attack on}} <b>cryptographic</b> <b>hash</b> functions {{tries to find}} a message that has a specific hash value. A <b>cryptographic</b> <b>hash</b> function should resist attacks on its preimage.|$|E
5000|$|Current collision-resistant hash {{algorithms}} {{that have}} provable security reductions are too inefficient {{to be used}} in practice. In comparison to classical hash functions, they tend to be relatively slow and do not always meet all of criteria traditionally expected of <b>cryptographic</b> <b>hashes.</b> Very smooth hash is an example.|$|R
5000|$|... one-way {{functions}} used in <b>cryptographic</b> <b>hashing.</b> The {{problem of}} finding a pre-image that hashes to a given value must be difficult to be useful, and ideally should require exponential time. However, if P=NP, then finding a pre-image M {{can be done in}} polynomial time, through reduction to SAT.|$|R
5000|$|In some {{distributed}} content systems, parties compare <b>cryptographic</b> <b>hashes</b> {{of files}} {{in order to}} make sure they have the same version. An attacker who could produce two files with the same hash could trick users into believing they had the same version of a file when they in fact did not.|$|R
