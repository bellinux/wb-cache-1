28|2126|Public
50|$|The {{term was}} coined {{to provide a}} {{distinction}} from higher level third-generation programming languages (3GL) such as COBOL and earlier first-generation programming language (machine <b>code</b> <b>languages).</b>|$|E
50|$|This {{strategy}} of compiling to multiple source <b>code</b> <b>languages</b> {{is inspired by}} the write once, run anywhere paradigm. It also allows the programmer to choose the best platform for the job.|$|E
50|$|System Engineering is {{supported}} with SysML 1.4 modeling {{which can be}} coupled with executable code generation.SysML supports modeling from requirement definition and system composition using SysML Blocks and Parts, through to parametric model simulation. The executable code generation supports embedded HDL system languages (Ada, VHDL and Verilog), {{or it can be}} coupled with behavioral code generation of the standard <b>code</b> <b>languages</b> defined above.|$|E
50|$|Manual {{communication}} is employed in sign languages and in {{systems that are}} <b>codes</b> for oral <b>languages</b> (see Manually <b>Coded</b> <b>Language).</b>|$|R
30|$|Private {{information}} {{external storage}} contents, location, country <b>code,</b> <b>language.</b>|$|R
5000|$|Soumini (wife of GS Pradeep) {{visited her}} husband on their 16th wedding anniversary. A <b>code</b> <b>language</b> was used between them. The <b>code</b> <b>language</b> called 'sa language' can be decoded if one removes the 'sa' from each word and joins them together. E.g. for the word 'Rahul', GS used 'sara' - 'sahul'. He also asked [...] "Chance Strongelle" [...] (is my chance strong?). In turn his wife advised him [...] "appi chettan cheyandayirinu" [...] (something GS was not {{supposed}} to carry out). [...] "arem kuttam parayaruthu." [...] Basically GS used the <b>code</b> <b>language</b> to know the status of himself in MH.|$|R
5000|$|Line {{numbers are}} an {{alternative}} to a named label (and used in some languages such as Fortran and BASIC), that are whole numbers placed {{at the start of}} each line of text in the source <b>code.</b> <b>Languages</b> which use these often impose the constraint that the line numbers must increase in value in each following line, but may not require that they be consecutive. For example, in BASIC: ...|$|E
50|$|In {{systems with}} {{explicit}} memory allocation, {{it is possible}} to create a dangling pointer by deallocating the memory region it points into. This type of pointer is dangerous and subtle because a deallocated memory region may contain the same data as it did before it was deallocated but may be then reallocated and overwritten by unrelated code, unknown to the earlier <b>code.</b> <b>Languages</b> with garbage collection prevent this type of error because deallocation is performed automatically when there are no more references in scope.|$|E
5000|$|Windows Runtime (WinRT), is a platform-agnostic {{application}} architecture first introduced in Windows 8 and Windows Server 2012 in 2012. WinRT supports development in C++/CX (Component Extensions, a language based on C++), JavaScript-TypeScript, and the managed <b>code</b> <b>languages</b> C# and Visual Basic [...]NET (VB.NET). WinRT applications natively support both the x86 and ARM processors, and run inside a sandboxed environment to allow greater security and stability. WinRT components {{are designed with}} interoperability between multiple languages and APIs in mind, including native, managed and scripting languages.|$|E
2500|$|... the {{presentation}} source <b>code</b> <b>language</b> {{may differ from}} other code assets ...|$|R
5000|$|<b>CODE,</b> <b>language</b> {{to compose}} {{sequential}} programs into parallel programs, to 2002.|$|R
5000|$|... the {{presentation}} source <b>code</b> <b>language</b> {{may differ from}} other code assets ...|$|R
5000|$|The terms [...] "first generation" [...] and [...] "second generation" [...] {{programming}} language {{were not used}} prior to the coining of the term [...] "third-generation"; none of these three terms are mentioned in early compendiums of {{programming language}}s. The introduction of a third generation of computer technology coincided {{with the creation of}} a new generation of programming languages. The marketing for this generational shift in machines correlated with several important changes in what were called high level programming languages, discussed below, giving technical content to the second/third-generation distinction among high level programming languages as well, and reflexively renaming machine <b>code</b> <b>languages</b> as first generation, and assembly languages as second generation.|$|E
40|$|This paper {{develops}} a proof theory for low-level <b>code</b> <b>languages.</b> We first define a proof system, which {{we refer to}} as the sequential sequent calculus, and show that it enjoys the cut elimination property and that its expressive power is {{the same as that of}} the natural deduction proof system. We then establish the Curry-Howard isomorphism between this proof system and a low-level code language by showing the following properties: (1) the set of proofs and the set of typed codes is in one-to-one correspondence, (2) the operational semantics of the code language is directly derived from the cut elimination procedure of the proof system, and (3) compilation and de-compilation algorithms between the code language and the typed lambda calculus are extracted from the proof transformations between the sequential sequent calculus and the natural deduction proof system. This logical framework serves as a basis for the development of type systems of various low-level <b>code</b> <b>languages,</b> type-preserving compilation, and static code analysis...|$|E
40|$|Expressive and {{efficient}} mobile <b>code</b> <b>languages</b> {{are essential for}} the rapid construction of mobile systems. This paper provides a qualitative and quantitative comparative evaluation of three mobile code languages: Java Voyager, JoCaml and mHaskell. The languages evaluated represent a spectrum, having different programming paradigms and supporting different classes of mobility. The comparison {{is based on a}} non-trivial meeting scheduler case study that uses two common patterns of mobile computation: distributed information retrieval and multicast. Illustrated by the meeting scheduler, the languages are compared for programming model, security, language interoperability and performance on networks of 2, 4, 6 and 8 locations. 1...|$|E
5000|$|An {{attestation}} clause {{modeled on the}} Model Probate <b>Code's</b> <b>language</b> might provide: ...|$|R
5000|$|Samuel F. B. Morse (1791-1872), invented Morse <b>code,</b> <b>language</b> of the {{telegraph}} ...|$|R
5000|$|Programming language: The <b>coding</b> <b>language</b> {{in which}} the {{application}} is being developed ...|$|R
40|$|KLAIM is an {{experimental}} programming language that supports a programming paradigm where both processes and {{data can be}} moved across different computing environments. The language relies {{on the use of}} explicit localities. This paper presents a temporal logic for specifying properties of Klaim programs. The logic is inspired by Hennessy-Milner Logic (HML) and the calculus, but has novel features that permit dealing with state properties and impact of actions and movements over the different sites. The logic is equipped with a complete proof system that enables one to prove properties of mobile systems. Keywords: Mobile <b>Code</b> <b>Languages,</b> Temporal Logics of Programs, Coordination Models, Proof Systems. ...|$|E
40|$|This study defines code-switching as any {{mixing of}} two {{languages}} {{within a single}} conversation: a continuum of phenomena from code-alternation (intentional switching of languages) to mixed <b>code</b> (<b>languages</b> blended together). I have chosen to narrow the approach and focus on a qualitative analysis of individual code-switching patterns. The general aim {{of this research is}} to study the code-switching functions of Russian-speaking Tallinn University students living in the Estonian capital city of Tallinn. This publication {{is the result of the}} conference “Language, diversity and integration in the Enlarged EU: challenges and opportunities” sponsored by The Ministry of Education and Science of The Republic of Lithuani...|$|E
40|$|We {{define a}} new {{subclass}} of regular languages, called uniquely terminating regular languages, {{which can be}} inferred from positive data. The class of uniquely terminating regular languages and the previously known subclasses of regular languages inferable from positive data are incomparable. Key Words and Phrases: regular language, grammatical inference, identification in the limit. 1. Introduction Regular languages cannot be inferred from positive data only [5]. This negative result has initiated a search for subclasses of regular languages having the desirable inference property. The found subclasses include, among others, k-reversible languages [1], strictly regular languages [10], locally testable languages {{in the strict sense}} [4], Szilard languages of regular grammars [7], and regular <b>code</b> <b>languages</b> [3]. This paper introduces still another subclass of regular languages inferable from positive data. The new class of languages is called uniquely terminating regular languages. Th [...] ...|$|E
5000|$|Platform : The {{platform}} (<b>Coding</b> <b>Language)</b> {{on which}} the tool was developed/written.|$|R
5000|$|... #Subtitle level 3: Nucleic acid - lipid interactions and <b>coding.</b> <b>Language</b> of genome ...|$|R
25|$|The US Army again used Choctaw {{speakers}} for <b>coded</b> <b>language</b> during World War II.|$|R
40|$|Imperative {{programming}} {{has largely}} dominated both aspects of Web programming: adding sophisticated interactive behaviours to the Web and constructing programs which {{interact with the}} Web. Most mobile <b>code</b> <b>languages</b> such as Java {{are based on the}} imperative programming paradigm. Imperative languages are widely used for building Web browsers and information gathering tools. The focus of much programming language research has been on raising the level of abstraction. Logic programming languages, which view computation as deduction from a set of axioms, is at a higher level of abstraction than imperative programming languages enabling a problem or subject domain to be modelled without focusing on the computer's Von Neumann architecture. Logic programming with program structuring abstractions has shown its utility in a variety of applications including expert systems, Artificial Intelligence problem solving, and deductive databases. Implementations of logic programming such as Prolog have f [...] ...|$|E
40|$|Interpreter Using an {{abstract}} interpreter {{has been a}} very popular way of implementing safe and portable computation. Mobile <b>code</b> <b>languages</b> like Java [53], Safe Tcl [84], Scheme 48 [91], and Telescript [124], all involve the interpretation of some source or intermediate languages. The interpreter approach can achieve memory protection in two ways: 1. A safe intermediate representation can be defined for mobile code units. Due to language restrictions, certain unsafe operations cannot be expressed, while others can be statically checked for. Take the JVM bytecode representation [67] as example. Privileged native instructions cannot be expressed; there is no pointer arithmetic; the language is strictly typed; interactions with the host's resources are performed through public application programming interface (API) [19]. As a result, memory interference can be avoided. 2. The execution unit interacts with the host's CPU only through the arbitration of the interpreter. Consequently, the in [...] ...|$|E
40|$|Part 2 : Short PapersInternational audienceSource code metrics help to {{evaluate}} {{the quality of the}} code, for example, to detect the most complex parts of the program. When writing a system which calculates metrics, especially when it has to support multiple source <b>code</b> <b>languages,</b> the biggest problem which arises is the creation of parsers for each supported language. In this paper we suggest an unusual Open Source solution, that avoids creating such parsers from scratch. We suggest and explain how to use parsers contained in the Eclipse IDE as parsers that support contemporary language features, are actively maintained, can recover from errors, and provide not just the abstract syntax tree, but the whole type information of the source program. The findings described in this paper provide to practitioners a way to use Open Source parsers without the need to deal with parser generators, or to write a parser from scratch...|$|E
50|$|See Australian Aboriginal sign {{languages}} {{for traditional}} manually <b>coded</b> <b>languages</b> such as Warlpiri Sign Language.|$|R
50|$|Back slang is an English <b>coded</b> <b>language</b> {{in which}} the written word is spoken phonemically backwards.|$|R
5000|$|... 2007. Essential {{properties}} of language, or why {{language is not}} a <b>code.</b> <b>Language</b> Sciences 29(5). 650-671.|$|R
40|$|Large scale {{distributed}} systems are becoming of paramount importance, {{due to the}} evolution of technology and to the interest of market. Their development, however, is not yet supported by a sound technological and methodological background, as the results developed for small size {{distributed systems}} often do not scale up. Recently, mobile <b>code</b> <b>languages</b> (MCLs) have been proposed as a technological answer to the problem. In this work, we abstract away from the details of these languages by deriving design paradigms exploiting code mobility that are independent of any particular technology. We present such design paradigms, together with a discussion of their features, their application domain, and some hints about the selection of the correct paradigm for a given distributed application. Keywords Mobile code, design paradigms, distributed applications. INTRODUCTION Distributed systems have been investigated for years, but recently research on this subject has gained a new impetus, [...] ...|$|E
40|$|Klaim is an {{experimental}} programming language that supports a programming paradigm where both processes and {{data can be}} moved across dierent computing environments. The language relies {{on the use of}} explicit localities, and on allocation environments that associate logical localities to physical sites. This paper presents a temporal logic for specifying properties of Klaim programs. The logic is inspired by Hennessy-Milner Logic (HML) and the calculus, but has novel features that permit dealing with state properties to describe the eect of actions over the dierent sites. The logic is equipped with a consistent and complete proof system that enables one to prove properties of mobile systems. Keywords: Mobile <b>Code</b> <b>Languages,</b> Temporal Logics of Programs, Coordination Models. 1 Introduction The increasing use of wide area networks, especially the World Wide Web, is calling for new programming paradigms and for new programming languages that model interactions among clients and serv [...] ...|$|E
40|$|The growing {{importance}} of telecommunication networks has stimulated research {{on a new}} generation of programming languages. Such languages view the network and its resources as a global environment in which computations take place. In particular, they support the notion of code mobility. To understand, discuss, evaluate, and compare such languages, it is necessary to develop a new set of programming language concepts and/or extend the concepts that are used to deal with conventional languages. The {{purpose of this paper is}} to provide such framework. This is done hand-in-hand with a survey of a number of existing new languages. Keywords. Mobile <b>code</b> <b>languages,</b> distributed programming languages, process migration, run-time model. 1 Introduction Advances in telecommunication networks have given new impetus to research on distributed systems. This research is based on a long term vision where computers are no more viewed as mainly autonomous and self-contained computing devices accessing l [...] ...|$|E
40|$|Computer {{programs}} {{for the analysis of}} human behaviour captured in multimedia data format commonly provide mechanisms to describe the behaviour recorded. Yet these programs do not satisfactorily fulfil the need for a description mechanism which allows the production of rich descriptions of behaviour in a flexible way and which facilitates the correct and complete retrieval of descriptions according to their meaning. In this paper a new <b>coding</b> <b>language</b> for the natural language like description of human behaviour, the Flexible Structured <b>Coding</b> <b>Language</b> (FSCL) is introduced. This <b>coding</b> <b>language</b> supports the rich description of behaviour, it is flexible in its use, and it allows the correct and complete retrieval of behavioural descriptions according to their meaning...|$|R
5000|$|... zap is the ISO 639-3 <b>language</b> <b>code</b> for Zapotec <b>language.</b> There are 57 {{individual}} <b>language</b> <b>codes</b> assigned.|$|R
50|$|South African Sign Language is {{understood}} across the country, though sometimes sign-language interpreters use manually <b>coded</b> <b>language.</b>|$|R
