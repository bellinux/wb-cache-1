23|1924|Public
50|$|A {{skeleton}} acts as gateway {{for server}} side objects and all incoming <b>clients</b> <b>requests</b> are routed through it. The skeletonwraps server object functionality and exposes {{it to the}} clients, moreover by adding the network logic ensures the reliable communication channel between clients and server. Skeletons can be written up manually or generated automatically depending on chosen communication protocol.|$|E
5000|$|... inetd (internet service daemon) is a super-server daemon on many Unix {{systems that}} {{provides}} Internet services. For each configured service, it listens for requests from connecting <b>clients.</b> <b>Requests</b> {{are served by}} spawning a process which runs the appropriate executable, but simple services such as echo are served by inetd itself. External executables, which are run on request, can be single- or multi-threaded. First appearing in 4.3BSD, it is generally located at [...]|$|E
50|$|By default, Elliptics forms a {{distributed}} {{hash table}} in single group (a replica). Group may contains one or many servers {{as well as}} physical server can contain multiple elliptics groups (replicas) stored on different backends. Groups can live in different physical locations thus allowing to server <b>clients</b> <b>requests</b> when other locations are not accessible. A peer-to-peer (P2P) protocol can be used to access data directly from storage servers without proxying. Elliptics supports server-side scripting in C++, JavaScript, Python, based on the Cocaine technology, SLRU cache and multiple plugable backends (eblob is the fastest for medium and large data and the most popular one).|$|E
40|$|Web servers, {{overloaded}} conditions, DTOC strategy, performance analysis, optimization, timed-out <b>client</b> <b>requests</b> A Web server's listen queue {{capacity is}} often set {{to a large}} value to accommodate bursts of traffic and to accept as many <b>client</b> <b>requests</b> as possible. We show that, under certain overload conditions, {{this results in a}} significant loss of server performance due to the processing of so-called "dead requests": timed-out <b>client</b> <b>requests</b> whose associated connection has bee...|$|R
40|$|Abstract: The aim of {{the project}} is to provide various {{services}} from different servers based on the <b>client</b> <b>request,</b> when the server is busy. If one server is busy then the <b>client</b> <b>request</b> is forwarded to the adjacent server. The adjacent server processes the <b>client</b> <b>request</b> and it sends response to the client. This approach can be used while more clients are accessing the same web server {{at the same time}} and the web server struck by responding more clients. In that time, the adjacent server takes care of the <b>client</b> side <b>requests</b> and it provides corresponding services to those clients...|$|R
25|$|Domain {{controllers}} responding {{slowly to}} <b>client</b> <b>requests.</b>|$|R
30|$|We {{conclude}} that our proposed load balancing and QoSLocVSDP protocol succeeds in balancing the load {{between the different}} components of the vehicular networks (RRs and service providers) and satisfies <b>clients</b> <b>requests</b> with different QoS requirements, while guaranteeing a good response time and appropriate bandwidth usage.|$|E
40|$|Content Distribution Networks (CDN) are overlay {{networks}} used {{to place}} content near end clients {{with the aim}} at reducing delay, servers load and network congestion, hence improving the service quality perceived by end clients. In traditional CDN architectures, <b>clients</b> <b>requests</b> are initially received by a central server and then redirected to another server that {{is close to the}} client and that is able to handle the request. However, in some cases, <b>clients</b> <b>requests</b> will not be served by the closest server. It may be advantageous to use a server that is a further away but that is not as loaded as the closest one. Contents in CDN are replicated, in many cases, according to contractual clauses, because of the costs involved in the maintenance of such replicated contents. Therefore, some contents are not replicated through the entire overlay network of the CDN provider. In this work a exact and heuristic approaches are presented in order to solve an optimization problem related to CDN management, called the Replica Placement Problem. This problem consists in findin...|$|E
30|$|In this article, we {{proposed}} an efficient load balancing and QoS-based location-based service discovery protocol for vehicular networks. We presented its {{proof of correctness}} and we computed its message complexity and its bandwidth usage. We presented our simulation experiments and performance evaluation {{in comparison to the}} original LocVSDP. Our proposed protocol succeeds in balancing the load between the different components of the vehicular network, including RRs and service providers. Moreover, it showed high performances, in terms of response time and bandwidth usage while satisfying <b>clients</b> <b>requests</b> with different QoS requirements.|$|E
5000|$|Receive <b>client</b> <b>requests,</b> {{interpreted}} as Inputs to the State Machine.|$|R
40|$|Two recent {{techniques}} for multicast or broadcast delivery of streaming media can provide immediate service to each <b>client</b> <b>request,</b> yet achieve considerable client stream sharing {{which leads to}} significant server and network bandwidth savings. This paper considers (1) how well these recently proposed techniques perform relative to each other, and (2) whether there are new practical delivery techniques that can achieve better bandwidth savings than the previous techniques {{over a wide range}} of <b>client</b> <b>request</b> rates. The principal results are as follows. First, the recent partitioned dynamic skyscraper technique is adapted to provide immediate service to each <b>client</b> <b>request</b> more simply and directly than the original dynamic skyscraper method. Second, at moderate to high <b>client</b> <b>request</b> rates, the dynamic skyscraper method has required server bandwidth that is significantly lower than the recent optimized stream tapping/patching/controlled multicast technique. Third, the minimum required ser [...] ...|$|R
2500|$|Ensure {{centralization}} of <b>client</b> <b>requests</b> (incoming and data) to reduce network traffic ...|$|R
40|$|Abstract—Most Byzantine {{fault-tolerant}} {{state machine}} replication (BFT) algorithms have a primary replica {{that is in}} charge of ordering the <b>clients</b> <b>requests.</b> Recently it was shown that this dependence allows a faulty primary to degrade the performance of the system to a small fraction of what the environment allows. In this paper we present Spinning, a novel BFT algorithm that mitigates such performance attacks by changing the primary after every batch of pending requests is accepted for execution. This novel mode of operation deals with those attacks at a much lower cost than previous solutions, maintaining a throughput equal or better to the algorithm that is usually consider to be the baseline in the area, Castro and Liskov’s PBFT. I...|$|E
40|$|In this paper, {{we present}} a novel hybrid push–pull {{algorithm}} which combines broadcasting of push data items, with dissemination upon request of pull items in asymmetric communication environments. These environments are made up only of one database server and many <b>clients.</b> <b>Requests</b> made by the clients are queued up for the pull items. The (pull) item {{with the number of}} pending requests is the one selected to be pulled. We present a performance analysis of our scheme, and determine the individual response time for each item disseminated and the overall time for the pull queue to be flushed. Next, we extend our algorithm by incorporating quality of service (QoS) factors, and then, study its performance analytically. © 2004 Published by Elsevier B. V...|$|E
40|$|Reviewed by Hans ReiserMost Byzantine {{fault-tolerant}} {{state machine}} replication (BFT) algorithms have a primary replica {{that is in}} charge of ordering the <b>clients</b> <b>requests.</b> Recently it was shown that this dependence allows a faulty primary to degrade the performance of the system to a small fraction of what the environment allows. In this paper we present Spinning, a novel BFT algorithm that mitigates such performance attacks by changing the primary after every batch of pending requests is accepted for execution. This novel mode of operation deals with those attacks at a much lower cost than previous solutions, maintaining a throughput equal or better to the algorithm that is usually considered to be the baseline in the area, Castro and Liskov’s PBFT...|$|E
5000|$|The <b>client</b> <b>requests</b> {{the window}} [...] to be mapped (shown on the screen) ...|$|R
30|$|ClientReq: An input/output {{bidirectional}} use interface {{responsible for}} processing the <b>client</b> <b>requests</b> and responses.|$|R
30|$|The {{secondary}} server(s) processes the <b>client</b> <b>requests</b> {{and sends}} {{the response to}} the Dispatcher.|$|R
40|$|International audienceService Oriented Computing (SOC) is a {{programming}} paradigm {{aiming at}} characterising Service Networks. Services are entities waiting for <b>clients</b> <b>requests</b> {{and they often}} result from the composition of many services. We address here the problem of statically guaranteeing security of open services, i. e. services with unknown components. Security constraints are expressed by local policies that service components must obey. We present here a type and effect system that safely over-approximates, {{in the form of}} history expressions, the possible run-time behaviour of open services, collecting partial information on the behaviours of their components. From a history expression, we then extract a plan that drives executions that never rise security violations. Finally, we show how partial plans satisfying security requirements can be put together to obtain a safe orchestration plan...|$|E
30|$|To earn these requirements, {{specific}} design {{strategies have}} been developed. In particular, a hierarchical {{organization of the}} architectural components allowing to separately manage a high-level intelligence, achieving the abstraction of data and the fulfillment of <b>clients</b> <b>requests.</b> Furthermore, a strong interaction of the system with sensors has been accomplished through a peripheral decision-maker {{who is able to}} analyze, filter and aggregate sensed information. The data abstraction layer of our architecture has been developed according to the Sensor Web Enablement (SWE) standard defined by the Open Geospatial Consortium [4]. Nevertheless, our solution overcomes the limitations of SWE, only conceived for the Web use of sensors. The layer for the interaction with the SIs makes use of Contiki [5], an Operating System designed for sensors and embedded systems. It gives a uniform platform for communicating with heterogeneous sensors.|$|E
30|$|Recently, we {{have noticed}} an {{increasing}} {{interest in the}} study of service discovery protocols in vehicular networks. To the best of authors' knowledge, most of the proposed service discovery schemes [1, 2] do {{not take into account the}} load balancing and the QoS requirements features. In this article, we propose a load balancing, QoS-aware and location-based service discovery protocol for vehicular networks. The location-based service discovery protocol (LocVSDP) [3] permits the discovery of location-aware and time-sensitive services in Vehicular Networks. It integrates service information into the network layer and uses diverse channels. Our proposed load balancing and QoS-based location aware discovery protocol (QoSLocVSDP) would permit to a service requester to connect to the appropriate less congested service provider through the less congested routing path. It permits also to satisfy some QoS requirements specified in <b>clients</b> <b>requests.</b>|$|E
5000|$|A <b>client</b> <b>requests</b> a {{connection}} to that named port by sending a connect message.|$|R
5000|$|An actagenic phase {{during which}} a <b>client</b> <b>requests</b> a fact form the {{supplier}} agent.|$|R
5000|$|The <b>client</b> <b>requests</b> a {{connection}} {{by sending a}} [...] (synchronize) message to the server.|$|R
40|$|Abstract-Information {{distribution}} {{centers are}} customarily revived in an intermittent way, regularly every day. Accordingly, {{there is some}} deferral between a business exchange and its appearance in the information stockroom. The latest information is caught in the operational sources where it is occupied for examination. For opportune choice making, today's business <b>clients</b> <b>requests</b> ever fresher information. Close continuous information warehousing addresses this test by shortening the information stockroom refreshment interims and thus, conveying source information to the information stockroom with lower idleness. One result is that information stockroom refreshment can never again be performed in o®-top hours just. Specifically, the source information may be changed simultaneously to information stockroom refreshment. In this paper we demonstrate that peculiarities may emerge under these circumstances prompting a conflicting condition of the information stockroom and we propose methodologies to maintain a strategic distance from refreshment oddities...|$|E
30|$|For the CitySDK platform’s database, the {{open-source}} {{high performance}} document database mongoDB 8 was {{used instead of}} a traditional relational SQL based database. The choice of this database was mainly related to the high performance required to handle the foreseen database request load {{and its ability to}} process geographical queries (i.e. search for elements within a polygon or within a distance from a specified geographical point), as required by the CitySDK Tourism API. This document database stores both the platform’s data models and some minor administrative data (e.g. access credentials). The data models are stored in an optimal format, taking advantage of the characteristics inherited {{from the fact that the}} database in use is a document database: minimal effort for the platform’s engine to adapt the retrieved data elements to the replies for the <b>clients</b> <b>requests.</b> Although the used database is not a relational database, it also provides the possibility to index any of the stored document’s attributes to enable the possibility of performing quicker indexed searches.|$|E
40|$|Abstract. In this paper, {{we address}} some {{problems}} related to server placement in Grid environments. Given a hierarchical network with requests from clients and constraints on server capability, the minimum server placement problem attempts to place the minimum number of servers that satisfy <b>clients</b> <b>requests.</b> Instead of using a heuristic approach, we propose an optimal algorithm based on dynamic programming to solve the problem. We also consider the balanced server placement problem, which tries to place a given number of servers appropriately so that their workloads are as balanced as possible. We prove that an optimal server placement {{can be achieved by}} combining the above algorithm with a binary search of workloads. We extend this approach to deal with constrains on network capability. The simulation results clearly show an improvement in the number of servers and the maximum workload. Furthermore, as the maximum workload is reduced, the waiting times are reduced accordingly. ...|$|E
40|$|Client puzzles are computable {{cryptographic}} problems used {{to defend}} against connection depletion attacks [6]. These are constructed using time, secret information held by the server and additional <b>client</b> <b>request</b> information. When under attack, the server issues puzzles to the <b>client</b> <b>requesting</b> service. The <b>client</b> must solve the puzzle correctly and return {{the solution to the}} server in a certain time limit...|$|R
50|$|Request: The <b>client</b> <b>requests</b> {{information}} from the server or requests it to perform an action.|$|R
5000|$|Polipo will upgrade <b>client</b> <b>requests</b> to HTTP/1.1 even if {{they come}} in as old HTTP/1.0.|$|R
40|$|The image {{diagnosis}} area is {{the most}} propense medical field to Telemedicine, {{because it does not}} obligate a direct contact of the patient with the responsible radiologist during the building of the report. The persistent lack of specialists on places distant from urban centers makes the Telemedicine an important tool for improvement of healthcare services. In this work we present a framework, called CyclopsDistMedDB, for the integration of distributed DICOM medical record databases over wide areas. The present system has a central module that is responsible for receiving the <b>clients</b> <b>requests</b> about patient data (images, waveforms), performing the querying and retrieval of images, patient records etc. from the specific DICOM databases containing the data requested and delivering them to the clients. The data communication protocols adopted are DICOM, for retrieval of objects directly from DICOM data servers and CORBA (Common Object Request Broker) for the delivery of DICOM data to client applications...|$|E
30|$|In Figure 5, we depict {{that the}} success rate of the {{different}} scenarios is quite high (more than 90 %) except for the QP LocVSDP Scenario. This latter have a success rate {{in the order of}} 50 %. QP LocVSDP corresponds to the execution of the basic LocVSDP when 50 % {{of the total number of}} requests have QoS requirement in the requested service provider. Since the basic LocVSDP does not take into consideration any QoS requirement and that the closest service provider to the origin of the RI is the provider with ID 116, almost 50 % of the service requests in this scenario cannot be satisfied. This explains the low success rate of in the QP LocVSDP scenario. However for the QoSQP LocVSDP, which corresponds to the execution of the QoSLocVSDP when 50 % of the total number of requests have QoS requirement in the requested service provider, have high success rate. This is because our proposed QoSLocVSDP mechanism takes into account the QoS requirements specified in the <b>clients</b> <b>requests.</b> The success rate in the other scenarios (QR LocVSDP and QoSQR LocVSDP) is not affected when the requester specifies a QoS requirement in the requested service provider.|$|E
40|$|In {{this study}} the authors present the ‘fictitiously starred {{optimised}} balancing’ (FSOB), a novel algorithm for load balancing in a {{content delivery network}} (CDN) scenario. FSOB exploits the multiple redirection mechanism of the HTTP protocol to optimally redistribute <b>clients</b> <b>requests</b> among the servers which build up the CDN. Load redistribution is aimed at equalising the level of occupancy of the server queues and is achieved through the periodical exchange of information computed locally at each node. The algorithm initially makes a fictitious assumption about the local topology of the network, as it is seen by each single server node, which looks at itself as the centre (i. e. the master) of a star made up of all of its neighbours (i. e. the slaves). Load redistribution is performed by the master which, if needed, appropriately redirects incoming requests to its slaves. The authors show how FSOB outperforms most of its competitors under a number of fundamental aspects, {{at the price of}} an increased overhead owing to the adoption of the multiple redirections mechanism for the redistribution phase. Finally, they study the scalability properties of FSOB and perform a comparative evaluation of its performance with respect to the most interesting existing solutions...|$|E
5000|$|Request: the <b>client</b> <b>requests</b> {{information}} from the server or requests it to perform an action.|$|R
5000|$|... "server": An error {{occurred}} on the server side after the <b>client</b> <b>request</b> has been successfully consumed.|$|R
40|$|Replication {{is widely}} used in {{application}} server products to tolerate faults. An important challenge is to correctly coordinate replication and transaction execution for stateful application servers. Many current solutions assume that a single <b>client</b> <b>request</b> generates exactly one transaction at the server. However, it is quite common that several <b>client</b> <b>requests</b> are encapsulated within one server transaction or that a single <b>client</b> <b>request</b> can initiate several server transactions. In this paper, we propose a replication tool that is able to handle these variations in request/transaction association. We have integrated our approach into the J 2 EE application server JBoss. Our evaluation using the ECPerf benchmark shows a low overhead of the approach. ...|$|R
