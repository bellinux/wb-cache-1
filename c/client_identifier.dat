9|21|Public
50|$|Each data {{consumer}} is assigned a special <b>Client</b> <b>Identifier</b> that names the {{out of band}} data stream in the DCD.|$|E
5000|$|... it stores the {{specification}} {{of how it}} has to be started again in the [...] property; this property must contain the <b>client</b> <b>identifier</b> because: ...|$|E
5000|$|... eMule {{is one of}} {{the clients}} which {{implements}} the eDonkey network. The eMule protocol consists of more than 75 types of messages. When an eMule client connects to the network, it first gets a list of known eMule servers which can be obtained from the Internet. Despite {{the fact that there are}} millions of eMule clients, there are only several hundred servers. The client connects to a server with TCP connection. That stays open as long as the client is connected to the network. Upon connecting, the client sends a list of its shared files to the server. By this the server builds a database with the files that reside on this client. The server also returns a list of other known servers. The server returns an ID to the client, which is a unique <b>client</b> <b>identifier</b> within the system. The server can only generate query replies to clients which are directly connected to it. The download is done by dividing the file into parts and asking each client a part.|$|E
5000|$|RFC 4361, Node-specific <b>Client</b> <b>Identifiers</b> for Dynamic Host Configuration Protocol Version Four (DHCPv4) ...|$|R
40|$|This {{document}} specifies an Internet standards track {{protocol for}} the Internet community, and requests discussion {{and suggestions for}} improvements. Please refer to the current edition of the "Internet Official Protocol Standards " (STD 1) for the standardization state and status of this protocol. Distribution of this memo is unlimited. Copyright Notice Copyright (C) The Internet Society (2006). This document specifies the format {{that is to be}} used for encoding Dynamic Host Configuration Protocol Version Four (DHCPv 4) <b>client</b> <b>identifiers,</b> so that those identifiers will be interchangeable with identifiers used in the DHCPv 6 protocol. This document also addresses and corrects some problems in RFC 2131 and RFC 2132 with respect to the handling of DHCP <b>client</b> <b>identifiers...</b>|$|R
50|$|Because the DHCP server has no secure {{mechanism}} for authenticating the client, clients can gain unauthorized access to IP addresses by presenting credentials, such as <b>client</b> <b>identifiers,</b> {{that belong to}} other DHCP clients. This also allows DHCP clients to exhaust the DHCP server's store of IP addresses—by presenting new credentials each time it asks for an address, the client can consume all the available IP addresses on a particular network link, preventing other DHCP clients from getting service.|$|R
30|$|When {{the broker}} {{receives}} the request, from the <b>client</b> <b>identifier,</b> the broker obtains the keys the client used to cipher and symmetrically sign the message. For this purpose, the broker {{uses the same}} master keys that were used during the client registration. If the message is correctly deciphered and the signature is valid, the broker mints the different e-coins requested.|$|E
30|$|Each e-coin is {{protected}} by using a symmetric key {{that depends on the}} <b>client</b> <b>identifier.</b> If we suppose perfect cryptography, an (internal or external) attacker cannot obtain the key associated to generate e-coins for a particular client. As an additional control measure, the broker could control the serial numbers generated for the different clients in order to detect a possible attack on the key used to generate e-coins for a client. In this case, the identifier will be drawn.|$|E
30|$|In this paper, {{we shall}} discuss HTTPS-HTTP over SSL/TLS, {{the most common}} {{encrypted}} network traffic protocols. In a communication encrypted by SSL/TLS, the hosts have to first agree on encryption methods and their parameters. Therefore, the initial packets contain unencrypted messages with information about the client and server. This information varies among different clients and their versions. The similar <b>client</b> <b>identifier</b> is a User-Agent value in a HTTP header, which is commonly used for identifying the client and classifying traffic. However, only the SSL/TLS handshake {{can be observed in}} a HTTPS connection without decrypting the payload. Therefore, we approach the problem of identifying the SSL/TLS client and classifying HTTPS traffic by building up a dictionary of SSL/TLS handshake fingerprints and their corresponding User-Agents.|$|E
40|$|Online {{services}} {{often use}} IP addresses as <b>client</b> <b>identifiers</b> when enforcing access-control decisions. The academic community has typically eschewed this approach, however, {{due to the}} effect that NATs, proxies, and dynamic addressing have on a server’s ability to identify individual clients. Yet, it is unclear to what extent these edge technologies actually impact the utility of using IP addresses as <b>client</b> <b>identifiers.</b> This paper provides some insights into this phenomenon. We do so by mapping out the size and extent of NATs and proxies, as well as characterizing the behavior of dynamic addressing. Using novel measurement techniques based on active web content, we present results gathered from 7 million clients over seven months. We find that most NATs are small, consisting of only a few hosts, while proxies {{are much more likely to}} serve many geographicallydistributed clients. Further, we find that a server can generally detect if a client is connecting through a NAT or proxy, or from a prefix using rapid DHCP reallocation. From our measurement experiences, we have developed and implemented a methodology by which a server can make a more informed decision on whether to rely on IP addresses for client identification or to use more heavyweight forms of client authentication. ...|$|R
40|$|Abstract Online {{services}} {{often use}} IP addresses as client identifierswhen enforcing access-control decisions. The academic community has typically eschewed this approach, how-ever, {{due to the}} effect that NATs, proxies, and dynamic addressing have on a server's ability to identify individualclients. Yet, it is unclear to what extent these edge technolo-gies actually impact the utility of using IP addresses as <b>client</b> <b>identifiers.</b> This paper provides some insights intothis phenomenon. We do so by mapping out the size and extent of NATs and proxies, as well as characterizing thebehavior of dynamic addressing...|$|R
5000|$|... {{the session}} manager replies by sending the <b>client</b> its unique <b>identifier,</b> say ...|$|R
40|$|This {{specification}} defines {{mechanisms for}} dynamically registering OAuth 2. 0 clients with authorization servers. Registration requests send {{a set of}} desired client metadata values to the authorization server. The resulting registration responses return a <b>client</b> <b>identifier</b> to use at the authorization server and the client metadata values registered for the client. The client can then use this registration information {{to communicate with the}} authorization server using the OAuth 2. 0 protocol. This specification also defines a set of common client metadata fields and values for clients to use during registration. Status of This Memo This is an Internet Standards Track document. This document {{is a product of the}} Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by th...|$|E
30|$|Second, {{we studied}} the {{relationship}} between cipher suite lists and HTTP User-Agents. The User-Agent is a common <b>client</b> <b>identifier</b> in HTTP. However, in HTTPS, it is not directly accessible without decrypting the transferred data. We deployed two methods for monitoring SSL/TLS handshakes and HTTP headers simultaneously in order to pair cipher suite lists and User-Agents. The host-based method, i.e., measurement on the server side, provided accurate results. However, this method was limited by the set of clients accessing the monitoring server and we obtained {{a smaller number of}} pairs. The flow-based method used network monitoring and was not limited to a single server. We were looking for clients communicating on HTTP and HTTPS protocols over {{a short period of time}} and paired the observed cipher suite lists and User-Agents from both connections. We gained a large dictionary of more than 12, 000 pairs. However, this method was less accurate compared to the host-based method.|$|E
30|$|Third, we {{assigned}} the corresponding User-Agents from the dictionary {{to the results}} from monitoring the SSL/TLS connections and discussed the required size and accuracy of the dictionary. We found {{that we need a}} dictionary of about 300 cipher suite lists with assigned User-Agents. Therefore, the dictionary which was created using the host-based method was not sufficient to cover all the distinct cipher suite lists which appeared in network traffic. On the other hand, only a 1 -h sample of the HTTPS traffic contained almost all the cipher suite lists which were observed over the week-long measurement. Therefore, we used the dictionary obtained using the flow-based method. However, many cipher suite lists were paired with more than one User-Agent. We were able to assign a User-Agent to almost every observed cipher suite list with a certain level of probability. Fortunately, in many cases, a lot of User-Agents which corresponded to a single cipher suite list shared the same <b>client</b> <b>identifier</b> and differed only in their version or a similarly attainable value.|$|E
3000|$|CRID (<b>Client</b> Registration <b>Identifier).</b> CRID {{identifies}} the registration {{process that is}} being performed between client and broker. For the generation of this identifier or label we have followed the same approach as explained in the vendor registration process, i.e., CIRD=H(C, B, H(K [...]...|$|R
50|$|The name, type, {{and value}} of a {{property}} are strings; more precisely, they are atoms, that is, strings stored in the server and accessible to the <b>clients</b> via <b>identifiers.</b> A <b>client</b> application can access a given property by using the identifier of the atom containing {{the name of the}} property.|$|R
40|$|Abstract It is very {{important}} issues to protect many system resources using authorized client authentication in distributed client server systems. So {{it is not enough}} to prevent unauthorized opponents from attacking our systems that client authentication is performed using only the <b>client's</b> <b>identifier</b> and password. In this paper, we propose a secure authentication database modeling with two authentication keys such as a client authentication key and a server authentication key. The proposed authentication model can be used making high quality of computer security using two authentication keys during transaction processing. The two authentication keys are created by client and server, and are used in every request transaction without user's extra input. Using the proposed authentication keys, we can detect intrusion during authorized client's transaction processing because we can know intrusion immediately through comparing stored authentication keys in client server systems when hackers attack our network or computer systems...|$|R
40|$|The {{chapter on}} {{globalization}} {{is derived from}} the Oracle Database Express Edition 2 Day Plus PHP Developer Guide. The chapter on connection pooling {{is derived from the}} Oracle white paper PHP Scalability and High Availability. The discussion on <b>Client</b> <b>Identifiers</b> is from an OTN article PHP Web Auditing, Authorization and Monitoring. The foundation for the chapter on the NetBeans IDE was contributed by Jeffrey Rubinoff. The Oracle Solaris content was contributed by Craig Mohrman. We gratefully acknowledge all the people who contributed to the creation of this book. Trademark Notice Oracle and Java are registered trademarks of Oracle and/or its affiliates. Other names may be trademarks of their respective owners. Intel and Intel Xeon are trademarks or registered trademarks of Intel Corporation. All SPARC trademarks are used under license and are trademarks or registered trademarks of SPARC International, Inc. AMD, Opteron, the AMD logo, and the AMD Opteron logo are trademarks or registered trademarks of Advanced Micro Devices. UNIX is a registered trademark of The Open Group. License Restrictions Warranty/Consequential Damages Disclaime...|$|R
50|$|Modern email <b>clients</b> use unique <b>identifiers</b> in email headers {{to locate}} the parent and root message in the hierarchy. When {{non-compliant}} clients participate in discussions, they can confuse message threading as it depends on all clients respecting these optional mail standards when composing replies to messages.|$|R
50|$|Identifiers are 32-bit {{integers}} {{with their}} three most significant bits equal to zero. Every client {{has its own}} set of identifiers it can use for creating new resources. This set is specified by the server as two integers included in the acceptance packet (the packet it sends to the client to inform it that the connection is accepted). <b>Clients</b> choose <b>identifiers</b> that are in this set in such a way they do not clash: two objects among windows, pixmaps, fonts, colormaps, and graphic contexts cannot have the same identifier.|$|R
5000|$|All {{data about}} windows, pixmaps, fonts, etc. {{are stored in}} the server. The <b>client</b> knows <b>identifiers</b> of these objects—integers it uses as names for them when {{interacting}} with the server. For example, if a client wishes a window to be created, it requests the server to create a window with a given identifier. The identifier can be later used by the client to request, for example, a string to be drawn in the window. The following objects reside in the server and are known by the client via a numerical identifier: ...|$|R
5000|$|The X server stores {{all data}} about windows, fonts, etc. The <b>client</b> knows <b>identifiers</b> {{of these objects}} [...] - [...] {{integers}} it can use as names for them when interacting with the server. For example, if a client wishes a window to be created, it requests the server to create one and (in case of success) gets in return an identifier the server associated with the newly created window. The identifier can be later used by the client to request, for example, a string to be drawn in the window.|$|R
50|$|Secure Bank deletes “blind spots” in online-payments {{security}} through diagnosing {{signs of}} infection, remote controlling of <b>client’s</b> machine or <b>identifiers</b> being compromised during authorization. Secure Portal prevents unauthorized access to personal accounts, personal data, web users’ bonus accounts and various fraudulent scenarios from using bots to competitor’s offers displays on a portal site.|$|R
5000|$|GIB Intelligence service uses {{personalized}} {{information for}} security strategy planning, making time-sensitive decisions and tweaking protection tools. It gives time for incidents prevention allowing to urgently discover theft of <b>clients</b> and employees’ <b>identifiers,</b> to track modifications of tactics and tools used by criminal groups potentially {{interested in a}} company and to prioritize threats based on expert forecasts.|$|R
40|$|Objective: Clinical studies {{consistently}} identify alcohol- and drug-related treatment populations as {{more likely}} to die prematurely compared with an age-matched general population. However, demographic characteristics and primary drug of concern as predictors of mortality risk following treatment have not been adequately explored. This paper examines relationships between substance use, demographic factors and mortality among alcohol and drug treatment clients. Method: A retrospective cohort incorporating 7 years of data was utilised to examine mortality outcomes in the 2 years following treatment among Victorian clients recorded on the Alcohol and Drug Information Service (ADIS) database by linking partial <b>client</b> <b>identifiers</b> with the National Death Index (NDI). A cohort of 18, 686 clients engaged in at least one course of treatment over a 12 -month period was included. Analysis was of crude and standardised mortality rates across client groups in terms of the presenting drug of concern for treatment and demographic characteristics. Results: A higher risk of premature death was associated with older age, being male, not being employed, living alone, medical and psychiatric comorbidity, recent injecting, and a history of intensive drug treatment access. Alcohol treatment clients had the worst prognosis. After adjustment for client characteristics, alcohol treatment clients experienced a significantly higher rate of death compared with other clients. Conclusions: Findings from these previously unexplored data highlight the need to increase awareness of the range and magnitude of risks associated with harmful alcohol use, and to identify approaches to enhance treatment effectiveness to reduce negative outcomes following treatment for populations at elevated risk of harm...|$|R
40|$|The recent {{proliferation}} of wireless local area networks (WLAN) has introduced new location privacy risks. An adversary controlling several access points could triangulate a client’s position. In addition, interface identifiers uniquely identify each client, allowing tracking of location over time. We enhance location privacy through frequent disposal of a <b>client’s</b> interface <b>identifier.</b> The described system curbs the adversary’s ability to continuously track a client’s position. Design challenges include selecting new interface identifiers, detecting address collisions at the MAC layer, and timing identifier switches to balance network disruptions against privacy protection. Using a modified authentication protocol, network operators can still control {{access to their}} network. An analysis of a public WLAN usage trace shows that disposing addresses before reassociation already yields significant privacy improvements...|$|R
40|$|The {{principle}} of reporting appropriately {{is essential to}} effective communication. Where possible SEPA proformas should be used. Summary reports not containing raw data may be adequate in some instances. Technical reports should however include relevant raw data and basic statistics usually as appendices. These should include details of methods and sub-sampling procedures if used. Simple graphical or tabular presentations {{should be used to}} summarise major trends. B. 1 United Kingdom Accreditation Service Requirements and Reporting Details of the various scientific reporting styles can be obtained from the notes to authors, usually found {{at the end of each}} volume of any scientific journal. A useful reference for general writing is Fletcher & Gowing (1987) and many interesting ideas for the graphical presentation of data can be obtained from Crothers (1981). For all United Kingdom Accreditation Service (UKAS) and/or ISO 9002 accredited laboratories, reports must adhere to the UKAS reporting standard as a minimum and it is therefore recommended that all laboratories should adopt this standard. These requirements include: appropriate laboratory and <b>client</b> address, unique <b>identifiers</b> fo...|$|R
50|$|This technique, used by Cbox {{and other}} chat applications, {{makes use of}} the XMLSocket object in a single-pixel Adobe Flash movie. Under the control of JavaScript, the client {{establishes}} a TCP connection to a unidirectional relay on the server. The relay server does not read anything from this socket; instead it immediately sends the <b>client</b> a unique <b>identifier.</b> Next, the <b>client</b> makes an HTTP request to the web server, including with it this identifier. The web application can then push messages addressed to the client to a local interface of the relay server, which relays them over the Flash socket. The advantage {{of this approach is}} that it appreciates the natural read-write asymmetry that is typical of many web applications, including chat, and as a consequence it offers high efficiency. Since it does not accept data on outgoing sockets, the relay server does not need to poll outgoing TCP connections at all, making it possible to hold open tens of thousands of concurrent connections. In this model, the limit to scale is the TCP stack of the underlying server operating system.|$|R
40|$|Abstract: This paper {{focus on}} device aware context {{delivery}} with middleware based support for heterogeneous client devices. Data networks are increased tremendously to support heterogeneous devices. There are myriad of new portable computing devices that each have different capabilities {{with regard to}} communication platform, communication protocol, computing power, display capabilities etc. Middleware based provisioning of various services based on the device context is proposed in this paper. Our work focuses on identifying different type of handheld devices based on {{the context of the}} device. Based on the device context (DC), the necessary services are served from the dynamic web server to the <b>clients.</b> The device <b>identifier</b> object provides the necessary information related to the context of the heterogeneous device (clients). This enables the server to provide the required information as per the context of the device. Our approach is generic in nature to support any kind of device context in an efficient way for different kind of application in a heterogeneous platform. The experimental results provide best solution for the forth-coming devices based on its context. This paper overcomes the deficiencies and limitation of existing device-aware computing by providing a suitable system and mechanism for device aware content delivery. 1...|$|R

