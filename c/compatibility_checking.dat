55|145|Public
50|$|A small {{subset of}} code was {{programmed}} in 8086 assembly language. The assembler used had a preprocessor that imported identifiers from the COMPOOL, allowing type <b>compatibility</b> <b>checking</b> between PASCAL and assembly.|$|E
40|$|International audienceIn {{distributed}} systems, {{asynchronous communication}} is {{often viewed as}} a whole whereas there are actually many different interaction protocols whose properties {{are involved in the}} compatibility of peer compositions. A hierarchy of asynchronous communication models, based on refinements, is established and proven with the TLA+ Proof System. The work serves as a first step {{in the study of the}} substituability of the communication models when it comes to <b>compatibility</b> <b>checking...</b>|$|E
40|$|Web service {{policies}} {{capture the}} capabilities and requirements of Web services from both functional and nonfunctional perspectives. Policies of a Web service govern and ensure the runtime {{consistency of the}} service, i. e., people or services interacting with this service are only allowed to perform legitimate actions. When composing Web services, policies of the participated Web services have to be compatible {{in order to make}} sensible compositions. Unfortunately, due to heterogeneity of policy specification languages, it is difficult to compare policies of different Web services directly. In this paper, we propose an approach for <b>compatibility</b> <b>checking</b> of Web service policies specified in difference languages. In particular, our approach applies the model-oriented specification from the Vienna Development Method (VDM++). An executable formal model of policy languages is represented in VDM++ and different policies are then translated to this VDM++ model for <b>compatibility</b> <b>checking.</b> Our approach has been validated by a prototype with different Web service policy languages such as WSPL and WS-Policy. Quan Z. Sheng, Jian Yu, Zakaria Maamar, Wei Jiang, and Xitong Li[URL]...|$|E
5000|$|... #Subtitle level 3: M855A1 Familiarization Shoot and <b>Compatibility</b> <b>Check</b> ...|$|R
5000|$|Dangerous goods {{data base}} (IBC, CHRIS Code) {{printout}} of substance information page, cargo segregation and <b>compatibility</b> <b>check</b> ...|$|R
50|$|Extensions contain XML files bearing {{metadata}} {{utilized by}} the mechanism which controls add-on installation. Among other things, this file identifies maximum and minimum {{versions of a}} Mozilla project application on which the add-on may be used. If an attempt is made to install the add-on on a version outside of this range, it will install but will be disabled. The success of a formal <b>compatibility</b> <b>check</b> is no guarantee the add-on will work, however. It is even possible to override the <b>compatibility</b> <b>check</b> using various extensions.|$|R
30|$|The {{component}} models {{described above}} offer runtime support for introspection and reconfiguration. However, while the introspection {{services provided by}} these models may expose functional details, they do not provide a semantic description of the services offered by components, {{making it difficult to}} discover, reconfigure or reuse third-party components on the fly. In addition, these component models provide no support for <b>compatibility</b> <b>checking</b> between interfaces, which increases the burden on the developer and the scope for errors in application composition.|$|E
40|$|Abstract. This {{paper is}} meant to motivate tools and methods {{research}} in the field of model-based embedded software development. In particular, we include usage scenarios to describe how an automated model assembler called a model compiler could support automotive embedded control systems development. We describe some desired characteristics and features of the envisioned model compiler and place particular emphasis on support for model <b>compatibility</b> <b>checking.</b> Finally, we describe characteristics of model components that are commonly used in practice. ...|$|E
40|$|This article {{extends the}} inverse Bayes {{formulae}} (IBF) {{in the product}} measurable space (PMS) to the non-product measurable space (NPMS) and focuses on their applications in <b>compatibility</b> <b>checking</b> and Bayesian computation. We show that IBF hold only in PMS and derive the modified IBF in NPMS. The potential of using IBF in obtaining exact solution is demonstrated via problems in distribution theory and several Bayesian missing data models. © 2003 Elsevier Science B. V. All rights reserved. link_to_subscribed_fulltex...|$|E
50|$|JavaScript editor {{features}} comprise syntax highlighting, refactoring, code completion {{for native}} objects and functions, generation of JavaScript class skeletons, generation of Ajax callbacks from a template; and automatic browser <b>compatibility</b> <b>checks.</b>|$|R
25|$|The Airbus A380 first {{landed at}} Logan International Airport for <b>compatibility</b> <b>checks</b> on February 8, 2010. On March 26, 2017, British Airways began flying the A380 to Logan, {{operating}} the aircraft {{three times per}} week.|$|R
40|$|Embedded {{software}} {{systems are}} highly configurable and consist of many software components in different variants and versions. However, component updates or upgrades often result in unpredictable incompatibilities with its environment. Existing research addresses this challenge by employing formal methods with a fixed set of encoded static <b>compatibility</b> <b>checks,</b> making {{it nearly impossible}} for engineers to add new or modify existing ones. This paper presents a highly adaptable infrastructure to define constraints for <b>compatibility</b> <b>checks.</b> The underlying approach transforms software components into instances of a C&C meta-model, enriched with OCL compatibility constraints at runtime, then evaluated by a solver. The result is transformed back into a C&C model showing compatibility or incompatibility. The easy to integrate infrastructure is based on industrial requirements and allows to add, modify or delete constraints without restarting the tool infrastructure...|$|R
40|$|Abstract Conflict {{problem is}} one of the major issues in Collaborative CAD systems. Based on a {{flexible}} multi-user interaction framework for replicated Collaborative Solid Modeling (CSM) systems, typical conflict issues are researched. The casualty conflict was discussed at first. Then, the name conflict was analyzed. Finally, <b>compatibility</b> <b>checking</b> for operations that may result in possible conflicts is studied. Based the analysis, some interesting results are discovered. The results will be helpful to utilize the potential advantages of replicated CSM systems in future...|$|E
40|$|Abstract. Reuse of high {{confidence}} subsystems {{depends on}} their appropriate modelling and documentation. This paper discusses the different aspects {{that have to be}} considered when modelling a system and its subsystems. We propose a concrete artefact model for integrated reuse from requirements to technical architecture, which satisfies documentation demands with respect to functionality and the context assumed by the subsystem. Based on the artefact model, we describe the steps for conformity and <b>compatibility</b> <b>checking</b> at the development stage of subsystem integration and/or reuse. ...|$|E
40|$|Abstract. Surveying {{results from}} [5] and [6], we motivate and {{introduce}} {{the theory behind}} formalizing rich interfaces for software and hardware components. Rich interfaces specify the protocol aspects of component interaction. Their formalization, called interface automata, permits a compiler to check the compatibility of component interaction protocols. Interface automata support incremental design and independent implementability. Incremental design means that the <b>compatibility</b> <b>checking</b> of interfaces can proceed for partial system descriptions, without knowing the interfaces of all components. Independent implementability means that compatible interfaces can be refined separately, while still maintaining compatibility. ...|$|E
40|$|Identification of the {{aerodynamic}} {{characteristics of}} an aircraft requires accurate {{information about the}} actual flow properties like airspeed, angle of attack, angle of sideslip, static pressure and temperature. This report contains {{the results of a}} data <b>compatibility</b> <b>check</b> being applied to flight test data from DLR’s research aircraft A 320 -ATRA...|$|R
40|$|International audienceThe {{methodology}} presented {{can improve}} {{safe and secure}} software development. The SNG Router case study extends aeronautical network capabilities. Additional tool chains to complete formal checking toolkit is also presented. A <b>compatibility</b> <b>check</b> is performed between methodology and D 0178 C. An extension of network security requirements for router SNG is presented...|$|R
40|$|Software {{components}} {{can give}} rise to several kinds of architectural mismatches when assembled together in order to form a software system. A formal description of {{the architecture of the}} resulting component based software system may help to detect such architectural mismatches and to single out the components that cause the mismatches. In this paper we concentrate on deadlock related architectural mismatches arising from three different causes that we identify: incompatibility between two components due to a single interaction, incompatibility between two components due to the combination of several interactions, and lack of interoperability among a set of components forming a cyclic topology. We develop a process algebra based architectural description language called PADL, which deals with all the three causes through an architectural <b>compatibility</b> <b>check</b> and an architectural interoperability check relying on standard observational equivalences. The adequacy of the architectural <b>compatibility</b> <b>check</b> is assessed on a compressing proxy system, while the adequacy of the architectural interoperability check is assessed on a cruise control system. We then address the issue of scaling the architectural <b>compatibility</b> and interoperability <b>checks</b> to architectural styles through an extension of PADL. The formalization of an architectural style is complicated by the presence of two degrees of freedom within the se...|$|R
40|$|Abstract. Whether two web {{services}} are compatible depends {{not only on}} static properties like the correct typing of their message parameters, but also on their dynamic behaviour. Providing a simple description of the service behaviour based on process-algebraic or automata-based formalisms can help detecting many subtle incompatibilities in their in-teraction. Moreover, this <b>compatibility</b> <b>checking</b> can {{to a large extent}} be automated if we dene the notion of compatibility in a suciently formal way. Based on a simple behavioural representation, we survey, propose and compare a number of formal denitions of the compatibility notion, and we illustrate them on simple examples. ...|$|E
40|$|Common to Grid services, Web Services, {{software}} {{agents and}} software components {{is that they}} are independently built and provide services aimed for composition. A key issue {{is whether or not the}} services in a composite system can interact with each other sensibly and as orchestrated by the enclosing composition. In this paper, we introduce an approach where we can specify individual services interaction intentions, and check their compatibility in a composite system. We discuss the use of the approach, the specification language, and the <b>compatibility</b> <b>checking</b> tool in the context of software components. They are equally applicable to other service frameworks mentioned above...|$|E
40|$|Service-Oriented Computing {{promotes}} {{the development of}} new systems from existingserviceswhichareusuallyaccessedthroughtheirpublicinterfaces. In this context, interfaces must be compatible in order to avoid interoperability issues. In this article, we propose a new framework for checking the compatibility of n service interfaces. Our framework is generic, {{in the sense that it}} implements several compatibility notions useful for different application areas, and extensible since new further notions can easily be incorporated. We consider a service interface model which takes behavioural descriptions with value-passing and non-observable actions into account. Our <b>compatibility</b> <b>checking</b> framework has been fully implemented into a prototype tool which relies on the rewriting logic-based system Maude...|$|E
5000|$|Brower <b>Compatibility</b> - <b>check</b> {{cross-browser}} <b>compatibility</b> of HTML, CSS and JavaScript (i.e. find {{code that}} doesn't work in all browsers) ...|$|R
30|$|In Kane et al.’s review, {{the issues}} that require {{additional}} attention included dose adjustment for decreased kidney and liver function, prevention and monitoring of ADRs, drug interactions caused by complex drug regimens, nutritional assessment due to poor oral intake and change in calorie needs, <b>compatibility</b> <b>checks</b> due to a patient’s extensive list of intravenous medications, and treatment and prevention of life-threatening infections, which {{are the same as}} the intervention issues encountered in the present study (Kane et al. 2003).|$|R
30|$|The {{property}} of global <b>compatibility</b> is <b>checked</b> between the spaces Y_δ^* and M_δ. This {{results in the}} existence of an Inf-Sup condition on the form b_δ^*(·,·).|$|R
30|$|As {{shown in}} Table 1, for all devices {{used in this}} scenario, the average-case time {{required}} for compatibility testing is {{a fraction of a}} millisecond and <b>compatibility</b> <b>checking</b> adds between 0.18 and 9.93  % overhead on binding operations. We believe that this limited overhead is {{a small price to pay}} for type safety at bind time. The higher overhead of compatibility testing on the Raven may be attributed to the lack of hardware support for division on its Atmel 1284 p microcontroller. We have furthermore evaluated the performance of multi-byte division on SPOT and Raven for growing GUIDs up to 8 bytes. This resulted in an acceptable worst-case processing time of 0.88 ms on the Raven.|$|E
40|$|International audienceService-Oriented Computing {{promotes}} {{the development of}} new systems from existing services which are usually accessed through their public interfaces. In this context, interfaces must be compatible in order to avoid interoperability issues. In this article, we propose a new framework for checking the compatibility of n service interfaces. Our framework is generic, {{in the sense that it}} implements several compatibility notions useful for different application areas, and extensible since new further notions can easily be incorporated. We consider a service interface model which takes behavioural descriptions with value-passing and non-observable actions into account. Our <b>compatibility</b> <b>checking</b> framework has been fully implemented into a prototype tool which relies on the rewriting logic-based system Maude...|$|E
40|$|Abstract In the Web of Data, {{licenses}} {{specifying the}} terms of use and reuse are associated not only to datasets but also to vocabularies. However, even less support is provided for taking the licenses of vocabularies into account than for datasets, which says it all. In particular, this paper addresses the following issue: checking the compatibility among the set of licenses assigned to the vocabularies used to constitute a dataset, and the license that {{is intended to be}} associated to the dataset itself. We provide a framework called LIVE able to support data publishers in such <b>compatibility</b> <b>checking</b> step, taking into consideration both the licenses associated to the vocabularies and those assigned to the data. ...|$|E
40|$|The {{process of}} {{component}} integration for distributed application sofrware development requires identifying the candidate components and performing <b>compatibility</b> <b>checks</b> {{based on the}} functional as well as non-functional requirements of the target application sofhvare. Since these requirements vary, {{it is important that}} distributed components themselves provide a set of specific services to facilitate component integration. In this paper, an approach to component integration for distributed application software is given. An object-oriented distributed component framework and a distributed connector model are presented to facilitate component integration...|$|R
40|$|Preliminary {{estimates}} of aerodynamic parameters of an advanced fighter aircraft {{were obtained from}} flight data of different values of the angle of attack from 8 to 54 deg. The data were analyzed by a stepwise regression with the ordinary least squares technique. The estimated stability and control derivatives are plotted against the angle of attack and compared with wind tunnel measurement and previous flight results. Also included is the data <b>compatibility</b> <b>check</b> of measured data. The effect of various input forms on the estimates is demonstrated in two examples using simulated data...|$|R
5000|$|The X1541 cables allow (full {{emulation}} of? /) copying to {{and from}} the Commodore 1541 disk drive. The realtime requirements for emulating the 1541 disk drive are exceptionally hard, and a variety of cable flavors have been constructed to improve compatibility with multi-tasking systems and faster PCs than the Pentium to some degree. For <b>compatibility,</b> <b>check</b> the documentation of each application, or confer the reference. The X1541 cable is available through both building instructions and shops. The original X1541 cable was designed in 1992 by Leopoldo Ghielmetti for use with the X1541 software.|$|R
40|$|We {{present a}} theory of timed interfaces, which is capable of specifying both {{the timing of the}} inputs a {{component}} expects from the environment, and the timing of the outputs it can produce. Two timed interfaces are compatible if {{there is a way to}} use them together such that their timing expectations are met. Our theory provides algorithms for checking the compatibility between two interfaces and for deriving the composite interface; the theory can thus be viewed as a type system for real-time interaction. Technically, a timed interface is encoded as a timed game between two players, representing the inputs and outputs of the component. The algorithms for <b>compatibility</b> <b>checking</b> and interface composition are thus derived from algorithms for solving timed games...|$|E
40|$|International audienceWe propose {{synchronous}} interfaces, a new interface {{theory for}} discrete-time systems. We use an application to time-triggered scheduling {{to drive the}} design choices for our formalism; in particular, additionally to deriving useful mathematical properties, we focus on providing a syntax which is adapted to natural high-level system modeling. As a result, we develop an interface model that relies on a guarded-command based language and is equipped with shared variables and explicit discrete-time clocks. We define all standard interface operations: <b>compatibility</b> <b>checking,</b> composition, refinement, and shared refinement. Apart from the synchronous interface model, the contribution {{of this paper is}} the establishment of a formal relation between interface theories and real-time scheduling, where we demonstrate a fully automatic framework for the incremental computation of time-triggered schedules...|$|E
40|$|AbstractLinda is a {{coordination}} language, originally {{presented as}} a set of inter-agent communication primitives which can virtually be added to any programming language. In this paper, we analyse the use of Linda to specify the interactive behaviour of software components. We first introduce a process algebra for Linda and we define a notion of process compatibility that ensures the safe composition of components. In particular, we prove that compatibility implies successful computation. We also argue that Linda features some advantages with respect to similar proposals in the context of dynamic <b>compatibility</b> <b>checking.</b> In this perspective, we propose an alternative definition of compatibility that takes into account the state of a global store, which gives some relevant information about the current execution of the system...|$|E
40|$|Abstract. Composing {{services}} {{makes sense}} {{only if they}} are compatible, i. e. composition does not lead to problems such as livelocks or deadlocks. In general, <b>compatibility</b> can be <b>checked</b> using state space explorations on any kind of formal models of services. Petri nets, one of the formal models in use, offer a rich theory for reasoning without exploring a state space. Among the techniques is the so-called state equation which forms a linear algebraic necessary condition for reachability of states. In this article, we show how the state equation can be applied for a necessary condition for compatibility. This way, the number of expensive state space based <b>compatibility</b> <b>checks</b> can be drastically reduced. The condition can be applied even if compatibility is achieved through the construction of a behavioral adapter (mediator). ...|$|R
40|$|International audienceIn {{this paper}} a new {{methodology}} {{to support the}} development process of safety-critical systems with contracts is described. The meta-model of Heterogeneous Rich Component (HRC) is extended to a Common System Meta-Model (CSM) that benefits from the semantic foundation of HRC and provides analysis techniques such as <b>compatibility</b> <b>checks</b> or refinement analyses. The idea of viewpoints, perspectives, and abstraction levels is discussed in detail to point out how the CSM supports separation of concerns. An example is presented to detail the transition concepts between models. From the example we conclude that our approach proves valuable and supports the development process...|$|R
40|$|A {{specific}} {{scale factor}} in Robertson-Walker metric {{with the prospect}} of giving the overall cosmic history in a unified picture roughly is considered. The corresponding energy-momentum tensor is identified as that of two scalar fields where one plays the roles of both inflaton and dark matter while the other accounts for dark energy. A preliminary phenomenological analysis gives an order of magnitude agreement with observational data. The resulting picture may be considered as a first step towards a single model for all epochs of cosmic evolution. Comment: 25 pages. The model is given in 3 pages. The rest is <b>compatibility</b> <b>check</b> with observations and supplementary materia...|$|R
