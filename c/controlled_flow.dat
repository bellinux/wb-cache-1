357|10000|Public
5|$|Since its {{completion}} in 1968, the Oroville Dam has allocated {{the flow of}} the Feather River from the Sacramento-San Joaquin Delta into the State Water Project's California Aqueduct, which provides a major supply of water for irrigation in the San Joaquin Valley as well as municipal and industrial water supplies to coastal Southern California, and has prevented large amounts of flood damage to the area — more than $1.3 billion between the years of 1987 and 1999. The dam has confined fish migration up the Feather River and the <b>controlled</b> <b>flow</b> of the river {{as a result of the}} Oroville Dam has affected riparian habitat. Multiple attempts at trying to counter the dam's impacts on fish migration have included the construction of a salmon/steelhead fish incubator on the river, which began shortly after the dam was completed.|$|E
25|$|Bíró's {{innovation}} successfully coupled ink-viscosity with a ball-socket mechanism which acted compatibly {{to prevent}} ink from drying inside the reservoir while allowing <b>controlled</b> <b>flow.</b> Bíró filed a British patent on 15 June 1938.|$|E
25|$|Cardiac {{output is}} {{primarily}} {{controlled by the}} oxygen requirement of tissues in the body. In contrast to other pump systems, the heart is a demand pump that does not regulate its own output. When the body has a high metabolic oxygen demand, the metabolically <b>controlled</b> <b>flow</b> through the tissues is increased, leading to a greater flow of blood back to the heart, leading to higher cardiac output.|$|E
50|$|In {{computer}} science, <b>control</b> <b>flow</b> analysis (CFA) is {{a static}} code analysis technique {{for determining the}} <b>control</b> <b>flow</b> of a program. The <b>control</b> <b>flow</b> is expressed as a <b>control</b> <b>flow</b> graph (CFG). For both functional programming languages and object-oriented programming languages, the term CFA, and elaborations such as k-CFA, refer to specific algorithms that compute <b>control</b> <b>flow.</b>|$|R
40|$|Abstract. A <b>control</b> <b>flow</b> graph {{represents}} all the <b>flows</b> of <b>control</b> {{that may}} arise during program execution. Since exception mechanism in Java induces <b>flows</b> of <b>control,</b> exception induced <b>control</b> <b>flow</b> {{have to be}} incorporated in <b>control</b> <b>flow</b> graph. In the previous research to construct <b>control</b> <b>flow</b> graph, they compute exception flow and normal flow {{at the same time}} while computing <b>control</b> <b>flow</b> information. In this paper, we propose a method to construct <b>control</b> <b>flow</b> graph by computing separately normal flow and exception flow. We show that normal flow and exception flow can be safely decoupled, hence these two flows can be computed separately. We propose the analysis that estimates exception-induced <b>control</b> <b>flow,</b> and also propose exception flow graph that represents exception induced <b>control</b> <b>flows.</b> We show that a <b>control</b> <b>flow</b> graph can be constructed by merging an exception flow graph onto a normal flow graph...|$|R
5000|$|<b>Control</b> <b>flow</b> {{randomization}} (to {{protect against}} <b>control</b> <b>flow</b> diversion) ...|$|R
2500|$|Needle valves: Mass {{flow meters}} may be {{purchased}} with mass flow controllers which permit setting flow rates. [...] These are expensive, however. Respirometry research often {{will attempt to}} measure more than one animal at a time, which would necessitate one chamber per animal and thus <b>controlled</b> <b>flow</b> through each chamber. [...] An alternative and more cost-effective method to control flow would be via stainless steel or carbon steel needle valves. Needle valves plus mass flow meters provides a cost-effective means to achieve desired flow rates. The valves cost about $20.|$|E
2500|$|Her {{fine art}} won awards for {{original}} designs in scratchboard, brush and ink, and pen drawing. [...] She experimented {{in a wide}} variety of media, and developed a style that is at once abstract and lyrical. Much of her art was intended and used to illustrate her published books of poetry. Some of her art pioneered a new technique created by her, which she called wax painting. It involves a <b>controlled</b> <b>flow</b> and manipulation of poured colored molten wax onto canvas, board, or paper. She also used techniques of cut paper and collage in her art, often supplemented by India ink and acrylics. The subjects she focused on in her art were drawn from her rich, symbolic imagination and dream life. She developed a preference for [...] "primitive" [...] art, whose unassuming simplicity she felt was capable of representing the images she wished to portray.|$|E
5000|$|GPM GmbH - Electro-Hydraulic <b>Controlled</b> <b>Flow</b> (ECF) Water Pump ...|$|E
5000|$|Fork/Join : Fork {{and join}} {{correspond}} to activating all paths in the <b>control</b> <b>flow</b> concurrently. A fork may have one incoming <b>control</b> <b>flow</b> {{and two or}} more outgoing <b>control</b> <b>flows.</b> When the condition is fulfilled, a fork activates all of the outgoing <b>control</b> <b>flows</b> in parallel. A join may have two or more incoming <b>control</b> <b>flows</b> and one outgoing <b>control</b> <b>flow.</b> A join synchronizes all activated incoming <b>control</b> <b>flows.</b> In the Event-driven Process Chain diagram how the concurrency achieved is not a matter. In reality the concurrency {{can be achieved by}} true parallelism or by virtual concurrency achieved by interleaving. A fork in the EPC is represented by an opening 'AND', whereas a join is represented as a closing 'AND' connectors.|$|R
40|$|We {{introduce}} {{a technique to}} enhance the ability of dynamic ILP processors to exploit (speculatively executed) parallelism. Existing branch prediction mechanisms used to establish a dynamic window from which ILP can be extracted are limited in their abilities to: (i) create a large, accurate dynamic window, (ii) initiate {{a large number of}} instructions into this window in every cycle, and (iii) traverse multiple branches of the <b>control</b> <b>flow</b> graph per prediction. We introduce <b>control</b> <b>flow</b> prediction which uses information in the <b>control</b> <b>flow</b> graph of a program to overcome these limitations. We discuss how information present in the <b>control</b> <b>flow</b> graph can be represented using multiblocks, and conveyed to the hardware using <b>Control</b> <b>Flow</b> Tables and <b>Control</b> <b>Flow</b> Prediction Buffers. We evaluate the potential of <b>control</b> <b>flow</b> prediction on an abstract machine and on a dynamic ILP processing model. Our results indicate that <b>control</b> <b>flow</b> prediction is a powerful and effective assist to the hardwa [...] ...|$|R
40|$|Properties of {{distributed}} computations can {{be either}} on their global states or on their <b>control</b> <b>flows.</b> This paper addresses <b>control</b> <b>flow</b> properties. It first presents a simple yet powerful logic for expressing general properties on <b>control</b> <b>flows,</b> seen as sequences of local states. Among other properties, we can express invariance, sequential properties (to satisfy such a property a <b>control</b> <b>flow</b> must match a pattern described as a word on some alphabet) and non-sequential properties (these properties are on several <b>control</b> <b>flows</b> at the same time) ...|$|R
5000|$|A {{pressure}} force due <b>controlled</b> <b>flow</b> areas and supply pressure, often called line pressure ...|$|E
50|$|Bíró's {{innovation}} successfully coupled ink-viscosity with a ball-socket mechanism which acted compatibly {{to prevent}} ink from drying inside the reservoir while allowing <b>controlled</b> <b>flow.</b> Bíró filed a British patent on 15 June 1938.|$|E
50|$|Counterbalance valves {{are in fact}} {{a special}} type of pilot {{controlled}} check valve. Whereas the check valve is open or closed, the counterbalance valve acts {{a bit like a}} pilot <b>controlled</b> <b>flow</b> control.|$|E
5000|$|OR : An 'OR' {{relationship}} {{corresponds to}} activating {{one or more}} paths among <b>control</b> <b>flows.</b> An opening 'OR' connector may have one incoming <b>control</b> <b>flow</b> and two or more outgoing <b>control</b> <b>flows.</b> When the condition is fulfilled, an opening 'OR' connector activates one or more <b>control</b> <b>flows</b> and deactivates the rest of them. The counterpart {{of this is the}} closing 'OR' connector. When {{at least one of the}} incoming <b>control</b> <b>flows</b> is activated, the closing 'OR' connector will pass the control to the next element after it.|$|R
5000|$|<b>Control</b> <b>flow</b> diagram, {{a diagram}} to {{describe}} the <b>control</b> <b>flow</b> of a business process, process or program ...|$|R
40|$|We {{describe}} the design, generation and compression {{of the extended}} whole program path (eWPP) representation that not only captures the <b>control</b> <b>flow</b> history of a program execution but also its data dependence history. This representation is motivated by the observation that typically a significant fraction of data dependence history can be recovered from the <b>control</b> <b>flow</b> trace. To capture {{the remainder of the}} data dependence history we introduce disambiguation checks in the program whose <b>control</b> <b>flow</b> signatures capture the results of the checks. The resulting extended <b>control</b> <b>flow</b> trace enables the recovery of otherwise unrecoverable data dependences. The code for the checks is designed to minimize the increase in the program execution time and the extended <b>control</b> <b>flow</b> trace size when compared to directly collecting <b>control</b> <b>flow</b> and dependence traces. Our experiments show that compressed eWPPs are only of the size of combined compressed <b>control</b> <b>flow</b> and dependence traces and their collection requires more runtime overhead than overhead required for directly collecting the <b>control</b> <b>flow</b> and dependence traces. ...|$|R
50|$|Multiple failed {{attempts}} were made to close the diversion and establish a <b>controlled</b> <b>flow</b> via headgates. On January 27, 1907 the flooding was finally stopped after substantial intervention by the Southern Pacific Company.|$|E
5000|$|... gas {{generators}} - produce {{large amount of}} gas, either high volume at short time (for actuators and ejection charges, often using solid propellants) or <b>controlled</b> <b>flow</b> rate (e.g. chemical oxygen generators, often using thermite-like compositions) ...|$|E
50|$|Constant flow {{blending}} - a <b>controlled</b> <b>flow</b> of {{the constituent}} gases is mixed {{to form the}} product. Blending may occur at ambient pressure or at a pressure setting above ambient but lower than supply gas pressures.|$|E
40|$|Understanding <b>control</b> <b>flows</b> in a {{computer}} program is essential for many software engineering tasks such as testing, debugging, reverse engineering, and maintenance. In this paper, we present a <b>control</b> <b>flow</b> analysis technique to analyze the <b>control</b> <b>flow</b> in Java bytecode. To perform the analysis, we construct a <b>control</b> <b>flow</b> graph (CFG) for Java bytecode {{not only at the}} intraprocedural level but also at the interprocedural level. We also discuss some applications of a CFG in a maintenance environment for Java bytecode. some primary experimental results. Keywords <b>Control</b> <b>flow</b> analysis, Java virtual machine, software testing, software maintenance. 1 Introduction Many compiler optimizations and program analysis techniques rely on <b>control</b> <b>flow</b> information, which is topically represented by a <b>control</b> <b>flow</b> graph (CFG) [4]. The CFG, although originally proposed for compiler optimizations, has been used for various software engineering tasks such as program slicing, debugging, testing, mainte [...] ...|$|R
5000|$|A <b>control</b> <b>flow</b> diagram (CFD) is {{a diagram}} to {{describe}} the <b>control</b> <b>flow</b> of a business process, process or review ...|$|R
40|$|Abstract—This paper {{presents}} the visual <b>control</b> <b>flow</b> support of Visual Modeling and Transformation System (VMTS), which facilitates composing complex model transformations out of simple transformation steps and executing them. The VMTS Visual <b>Control</b> <b>Flow</b> Language (VCFL) uses stereotyped activity diagrams to specify <b>control</b> <b>flow</b> structures and OCL constraints {{to choose between}} different <b>control</b> <b>flow</b> branches. This work discusses the termination properties of VCFL and provides an algorithm to support the termination analysis of VCFL transformations...|$|R
50|$|Different {{manufactures}} employ {{their own}} version of dust abatement. One type uses a piezo crystal to vibrate a filter which covers the sensor. The second type moves the actual sensor—this may be supplemented by a <b>controlled</b> <b>flow</b> of air.|$|E
50|$|Tea {{is poured}} {{initially}} by a tea hostess into warmed cups from a heated teapot {{at a distance}} above the first cup so as to create a <b>controlled</b> <b>flow</b> of tea with attractive bubbles. This is done to create good luck.|$|E
5000|$|One {{of those}} {{aesthetics}} was {{the development of}} smooth, continuous <b>controlled</b> <b>flow</b> in the late 70s and early 80s, running parallel with the opposite trend of interest in conflict and unexpected responses including previously avoided eye contact and directive hand contact. Says Nancy Stark Smith, ...|$|E
40|$|The Multiscalar {{architecture}} executes {{a single}} sequential program following multiple <b>flows</b> of <b>control.</b> In the Multiscalar hardware, a global sequencer, {{with help from}} the compiler, takes large steps through the program's <b>control</b> <b>flow</b> graph (CFG) speculatively, starting a new thread of control (task) at each step. This is inter-task <b>control</b> <b>flow</b> speculation. Within a task, traditional <b>control</b> <b>flow</b> speculation is used to extract instruction level parallelism. This is intra-task <b>control</b> <b>flow</b> speculation. This pape...|$|R
40|$|Coverage metrics, which {{evaluate}} {{the ability of}} a test sequence to detect design faults, are essential to the validation process. A key source of difficulty in determining fault detection is that the <b>control</b> <b>flow</b> path traversed {{in the presence of a}} fault cannot be determined. Fault detection can only be accurately determined by exploring the set of all <b>control</b> <b>flow</b> paths, which may be traversed as a result of a fault. We present a coverage metric that determines the propagation of fault effects along all possible faulty <b>control</b> <b>flow</b> paths. The complexity of exploring multiple <b>control</b> <b>flow</b> paths is greatly alleviated by heuristically pruning infeasible <b>control</b> <b>flow</b> paths using the algorithm that we present. The proposed coverage metric provides high accuracy in designs that contain complex <b>control</b> <b>flow.</b> The results obtained are promising. 1...|$|R
40|$|Abstract. We {{propose a}} novel <b>control</b> <b>flow</b> {{analysis}} for higher-order functional programs, {{based on a}} reduction to higher-order model check-ing. The distinguished features of our <b>control</b> <b>flow</b> analysis are that, un-like most of the <b>control</b> <b>flow</b> analyses like k-CFA, it is exact for simply-typed λ-calculus with recursion and finite base types, and that, unlike Mossin’s exact flow analysis, it is indeed runnable in practice, at least for small programs. Furthermore, under certain (arguably strong) assump-tions, our <b>control</b> <b>flow</b> analysis runs in time cubic {{in the size of}} a program. We formalize the reduction of <b>control</b> <b>flow</b> analysis to higher-order model checking, prove the correctness, and report preliminary experiments. ...|$|R
50|$|A third {{style of}} {{manifold}} screwed {{directly into the}} cylinder neck thread, and provided a single valve which <b>controlled</b> <b>flow</b> from both cylinders to a single connector for a regulator. These manifolds could also include a reserve valve. From a gas management point of view they are identical to a single cylinder with the same capacity.|$|E
50|$|All of the {{interconnects}} in North America are synchronized at {{a nominal}} 60 Hz, while those of Europe run at 50 Hz. Interconnections can {{be tied to}} each other via high-voltage direct current power transmission lines (DC ties), or with variable-frequency transformers (VFTs), which permit a <b>controlled</b> <b>flow</b> of energy while also functionally isolating the independent AC frequencies of each side.|$|E
5000|$|The Gwash then {{helps to}} fill the Rutland Water {{reservoir}} which was formed by damming its valley at Empingham. [...] From the reservoir a <b>controlled</b> <b>flow</b> is released to maintain the flow around Tolethorpe Hall and Stamford and into the River Welland. The flow is enhanced by the Gwash's tributary, the North Brook, at [...] in Empingham, which significantly helps maintain riverlife.|$|E
40|$|A {{remarkable}} {{difference between}} quantum and classical programs {{is that the}} <b>control</b> <b>flow</b> of the former can be either classical or quantum. One of the key issues {{in the theory of}} quantum programming languages is defining and understanding quantum <b>control</b> <b>flow.</b> A functional language with quantum <b>control</b> <b>flow</b> was defined by Altenkirch and Grattage [Proc. LICS' 05, pp. 249 - 258]. This paper extends their work, and we introduce a general quantum control structure by defining three new quantum program constructs, namely quantum guarded command, quantum choice and quantum recursion. We clarify the relation between quantum choices and probabilistic choices. An interesting difference between quantum recursions with classical <b>control</b> <b>flows</b> and with quantum <b>control</b> <b>flows</b> is revealed...|$|R
5000|$|Branch/Merge: Branch and merge {{correspond}} to making decision of which path {{to choose among}} several <b>control</b> <b>flows.</b> A branch may have one incoming <b>control</b> <b>flow</b> and two or more outgoing <b>control</b> <b>flows.</b> When the condition is fulfilled, a branch activates exactly {{only one of the}} outgoing <b>control</b> <b>flows</b> and deactivates the others. The counterpart of a branch is a merge. A merge may have two or more incoming flows and one outgoing <b>control</b> <b>flow.</b> A merge synchronizes an activated and the deactivated alternatives. The control will then be passed to the next element after the merge. A branch in the EPC is represented by an opening XOR, whereas a merge is represented as a closing XOR connectors.|$|R
40|$|Key words: {{procedure}} blueprint; <b>control</b> <b>flow</b> diagram; <b>control</b> <b>flow</b> analyze; activity diagram. Abstract. Based on the well-defined UML 2. 0 activity diagram, a meta-model {{based on}} <b>Control</b> <b>Flow</b> Diagram is presented. And our strategy {{in this article}} is to define an OCL-based mapping in a formal and verifiable form as consistency rules between an AISD and a CFG, so as to ensure the completeness of our meta-models and allow their verification. At last, we adopt a static analyze method to transform procedure blueprint to <b>Control</b> <b>Flow</b> diagram...|$|R
