0|182|Public
5000|$|Unlike Unix system <b>calls,</b> <b>macros</b> are not {{standardized}} across {{operating systems}} though. Even {{something as simple}} as writing a [...] "sequential file" [...] is coded differently e.g. in Z/OS than in Z/VSE.|$|R
5000|$|Common Lisp is a dialect of Lisp; it uses S-expressions {{to denote}} both code and data structure. Function <b>calls,</b> <b>macro</b> forms and special forms are written as lists, {{with the name}} of the {{function}} first, as in these examples: ...|$|R
50|$|The troff {{typesetting}} system includes sets of commands <b>called</b> <b>macros</b> {{that are}} run before starting {{to process the}} document. These macros include setting up page headers and footers, defining new commands, and generally influencing how the output will be formatted.|$|R
5000|$|AutoIt [...] is a {{freeware}} automation {{language for}} Microsoft Windows. In its earliest release, the software was primarily intended to create automation scripts (sometimes <b>called</b> <b>macros)</b> for Microsoft Windows programs but has since grown to include enhancements in both programming language design and overall functionality.|$|R
50|$|Keyboard macros {{and mouse}} macros allow short {{sequences}} of keystrokes and mouse actions to transform into other, usually more time-consuming, sequences of keystrokes and mouse actions. In this way, frequently used or repetitive sequences of keystrokes and mouse movements can be automated. Separate programs for creating these <b>macros</b> are <b>called</b> <b>macro</b> recorders.|$|R
50|$|Simulations, or Missions as IMPRINT {{refers to}} them, contain a task network called a Network Diagram. The network diagram {{contains}} {{a series of}} tasks connected by paths which determine control flow. System objects called entities flow through the system to create a simulation. IMPRINT also includes more low level features such as global variables and subroutines <b>called</b> <b>macros.</b>|$|R
50|$|Phantasy Star III: Generations of Doom {{featured}} {{an innovative}} and original branching storyline, which spans {{three generations of}} characters and can be altered depending on which character the protagonist of each generation marries, leading to four possible endings. Phantasy Star IV: The End of the Millennium introduced the use of pre-programmable combat manoeuvers <b>called</b> <b>macros,</b> a means of setting up the players party AI to deliver custom attack combos.|$|R
50|$|The {{reader is}} {{responsible}} for parsing list structure, interning symbols, converting numbers to internal form, and <b>calling</b> read <b>macros.</b>|$|R
40|$|Jakarta has {{developed}} an integrated transport system and planned, <b>called</b> <b>Macro</b> Transportation System planto address transportation problems in Jakarta. Transjakarta, a Bus Rapid Transit system (BRT), is one of thepublic transportation facilities included in the Macro Transportation System plan, which was intended as aneffort to developa new urban transportation culture. This study used the concept of socio engineering toassess the Transjakarta transport service in Jakarta. The {{results indicate that the}} highest service quality relatedto the dimension of empathy and lower service quality associated with the tangible dimension...|$|R
40|$|We {{have been}} {{developing}} a domain-level knowledge representation construct in GLIF <b>called</b> <b>macro.</b> A macro is a declarative specification of a high-level concept that is mapped to a procedural pattern of primitive GLIF steps. We developed macros for (1) appropriateness criteria for radiological examinations, and (2) toxicity criteria for cancer clinical trial protocols. Authoring tools for these macros were built using a Java software library we have designed for this purpose. The authoring tools provide {{an easy way}} to encode these guidelines that can then be automatically mapped to GLIF...|$|R
50|$|Many {{developers}} use macros {{since those}} {{were introduced in}} Microsoft Office. Macros make a developer's life easier by automating repetitive tasks. Macros are available also in Visual Studio. They have their own UI within VS <b>called</b> <b>Macros</b> IDE. VS provides an automation interface where {{a great number of}} core services features are accessible through properties and methods of COM objects. These automation objects form a hierarchy in which it is possible to navigate from one object to another, for example, from the object representing a project to its project items.|$|R
5000|$|Writing <b>macros</b> <b>calling</b> R {{to perform}} {{calculations}} without exposing R {{to the user}} ...|$|R
40|$|This poster proposes {{two recent}} log file or web mining {{approaches}} (macro-mining & micro-mining of webserver log files). We {{try to bring}} together the popular method <b>called</b> <b>macro</b> analysis which aggregates common server request counts (e. g. number of downloads of a certain document) with the micro analysis method which is less known in log analysis. The micro-mining approach focuses on segmented log files which can be drilled down to transactions of single users. Both analysis methods will be explained by an example. Furthermore we try to identify new use cases and try to sketch ways of combined analysis for both web mining methods...|$|R
5000|$|Zgrass {{included}} three priorities (called levels) that allowed macros {{to be run}} normally, or in [...] "foreground" [...] or [...] "background" [...] levels. This added a simple form of multitasking which was tremendously useful in an animation-oriented language. Game authors could place joystick-reading routines in a macro set {{to run in the}} background, and then the joystick would be read automatically whenever the current drawing macro completed. Functions placed in the foreground ran before either, and was often used for timers and other [...] "low latency" [...] needs. Zgrass included a [...] function that would <b>call</b> <b>macros</b> on a timed basis, making the implementation of timers very easy.|$|R
50|$|The {{format of}} the <b>Macro</b> <b>call</b> {{depended}} upon the system it was used upon.|$|R
40|$|Abstract Document {{classes in}} LATEX provide {{automation}} to improve consistency, pro-ductivity, and accuracy in creating and maintaining documents, thereby avoiding the inefficiencies of wordprocessors. However, users {{who want to}} package their macros or applications as a document class are often {{put off by the}} apparent complexity of the sample classes in the standard distri-bution. This paper describes what the code in the article document class file does and suggests solutions to some of the popular requirements for changes. 1 Know thine enemy One of the key features of TEX systems is the extensibility offered by re-usable pieces of programming <b>called</b> <b>macros.</b> Rudimentary macros exist in many text-handling packages (in fact they were {{at the heart of the}} first editors for markup applications), and some wordprocessors make use of general-purpose program-ming languages such as Visual Basic or Java; but only typesetters have dedicated languages to doing typesetting, and TEX’s is by far the most accessible...|$|R
50|$|In {{an old-fashioned}} non-ISO C compiler, all the obstack {{functions}} are actually defined only as <b>macros.</b> You can <b>call</b> these <b>macros</b> like functions, but you cannot {{use them in}} any other way. For example, you cannot take their address.|$|R
40|$|By design, the SRC- 6 {{reconfigurable}} {{computer is}} programmed in the MAP C programming language {{within the framework}} provided by the SRC Carte ™ development environment. The functionality of the original language can be extended via third party subroutines, <b>called</b> <b>macros.</b> These macros, typically implemented in Verilog Hardware Description Language, are brought into the MAP C program via configuration files that define the interface between the macros and the MAP C language. In this paper, we describe a process of using the Verilog source for SRC macros generated from the MathWorks Simulink ® designs built using Xilinx System Generator ™ for DSP and Xilinx Blockset. We also describe an example application that takes advantage of this programming model...|$|R
5000|$|IMPRINT has {{a number}} of global {{variables}} used by the system throughout a simulation. IMPRINT provides the public global variable Clock which tracks the simulation’s current time. IMPRINT also has private variables such as operator workload values. IMPRINT allows the modeler to create custom global variables which can be accessed and modified in any task node. Variables can be of any type native to C#, but the software provides a list of suggested variable types including C# primitive data types and basic data structures. IMPRINT also provides the programmer with the functionality to create globally accessible subroutines <b>called</b> <b>macros.</b> Macros work as C# functions and can specify parameters, manipulate data, and return data.|$|R
25|$|TeX {{provides}} an unusual macro language; {{the definition of}} a macro not only includes a list of commands but also the syntax of the <b>call.</b> <b>Macros</b> are completely integrated with a full-scale interpreted compile-time language that also guides processing. TeX's macro level of operation is lexical, but it is a built-in facility of TeX, that makes use of syntax interpretation. Comparing with most widely used lexical preprocessors like M4, it differs slightly, as the body of a macro gets tokenized at definition time, that is, it is not completely raw text. Except for a few very special cases, this gives the same behaviour. The TeX macro language has been successfully used to extend TeX to, for instance, LaTeX and ConTeXt.|$|R
40|$|Webserver {{log files}} {{are a very}} {{interesting}} data source for analysing the accessibility, visibility and interlinking of any web content. This paper proposes two recent log file or web mining approaches (macro-mining & micro-mining of webserver log files). We try to bring together the popular method <b>called</b> <b>macro</b> analysis which aggregates common server request counts (e. g. number of downloads of a certain document) with the micro analysis method which is less known in log analysis. The micro-mining approach focuses on segmented log files which can be drilled down to transactions of single users. Both analysis methods will be explained by an example. Furthermore we try to identify new use cases and try to sketch ways of combined analysis for both web mining methods...|$|R
40|$|This thesis {{deals with}} the {{creation}} of an application, a so <b>called</b> <b>macro,</b> written in VBA language. This macro is supposed to save and partially automate everyday labor in the company. The main goal is to design and create the macro so that it could actually be used by the company for which it was intended and the way it was intended. The paper also analyzes the situation in the company, in terms of external as well as internal environment. The final outcome is a tool, that allows automatic email account management of a given firm, download attachment, sort them according to their file types and then send them to print. In the end of the thesis the actual contribution of the product is evaluated...|$|R
40|$|The report {{describes}} {{how to use}} the ELLPACK system through a set of terminal command procedures, <b>called</b> <b>macros,</b> designed for easy, on-line use. The macros as described are a preliminary set; an expanded set will be prepared once some experience is gained with this preliminary set. The capabilities of the preliminary set allow users at remote sites to create an ELLPACK program for solving a PDE, run a ELLPACK program, check the program output, have results mailed, display data from the ELLPACK per-formance evaluation system,send messages (trouble reports) to network members and provide on-line aid to using the macros. Information about accessing the network and Purdue's computer system is given elsewhere. CONTENTS 1. Summary of capabilities 2. Anotated example session 3. Logging on the Purdue syste...|$|R
50|$|TeX {{provides}} an unusual macro language; {{the definition of}} a macro not only includes a list of commands but also the syntax of the <b>call.</b> <b>Macros</b> are completely integrated with a full-scale interpreted compile-time language that also guides processing. TeX's macro level of operation is lexical, but it is a built-in facility of TeX, that makes use of syntax interpretation. Comparing with most widely used lexical preprocessors like M4, it differs slightly, as the body of a macro gets tokenized at definition time, that is, it is not completely raw text. Except for a few very special cases, this gives the same behaviour. The TeX macro language has been successfully used to extend TeX to, for instance, LaTeX and ConTeXt.|$|R
50|$|An {{assembly}} language SFL (System Function Language) is also available. This {{was used for}} the development of VME/K, whose designers were not confident that a high-level language could give adequate performance, and also for the IDMS database system on account of its origins as a third-party product. SFL was originally <b>called</b> <b>Macro</b> Assembler Programming LanguagE (MAPLE), but as the 2900 architecture was being positioned as consisting of high level language machines the name was changed at the request of ICL Marketing. It had been developed {{as a part of the}} toolkit for System D, which was subsequently cancelled. Related families of assemblers for other architectures (CALM-xx running under VME, PALM-xx developed in Pascal and running on various hosts) were developed for internal use.|$|R
50|$|<b>Call</b> by <b>macro</b> {{expansion}} {{is similar to}} call by name, but uses textual substitution rather than capture-avoiding substitution. With uncautious use, macro substitution may result in variable capture and lead to undesired behavior. Hygienic macros avoid this problem by checking for and replacing shadowed variables that are not parameters.|$|R
40|$|XML is {{originally}} {{designed for the}} use in document processing. Every classical document processing system supports a mechanism which is <b>called</b> <b>macro.</b> In general, a macro is a named collection of actions. These actions are executed whenever {{the name of the}} macro appears in a document instance. We describe a very small but powerful macro language for XML. The presented language supports macros with arguments. As a main result we will show that for a macro expansion H and a recognizable set R the set H- 1 (R) of trees t, whose macro expansion H(t) are in R, is recognizable. This implies that the typechecking problem for macro expansion is decidable. A major drawback of this approach is the time complexity. Therefore we designed a practical typechecking discipline. We equi...|$|R
50|$|A {{limited number}} of dynamic {{programming}} languages provide features which combine code introspection (the ability to examine classes, functions and keywords {{to know what they}} are, what they do and what they know) and eval in a feature <b>called</b> <b>macros.</b> Most programmers today who are aware of the term macro have encountered them in C or C++, where they are a static feature which are built in a small subset of the language, and are capable only of string substitutions on the text of the program. In dynamic languages, however, they provide access to {{the inner workings of the}} compiler, and full access to the interpreter, virtual machine, or runtime, allowing the definition of language-like constructs which can optimize code or modify the syntax or grammar of the language.|$|R
40|$|Uncertainty about {{national}} income growth poses significant macroeconomic risk to households {{all over the}} world. To help reduce investors' exposure, researchers have proposed a controversial new set of security markets <b>called</b> <b>macro</b> markets. These international markets would trade long-term claims on the income of an entire country or region. For example, in a macro market for the United States, an investor could buy a claim on the U. S. national income and then receive dividends equal to a fraction of national income {{for as long as}} the claim is held. Although many barriers stand in the way of the markets' development - including investors' focus on short-term portfolio performance, sizable startup costs, and contract enforcement difficulties - the potential benefits of these markets are great. Income; Securities; Investments...|$|R
40|$|During the {{execution}} of functional logic programs, particular E-unification problems must be solved quite frequently. In this paper we contribute to the efficient solution of such problems in the case where E is induced by particular term rewriting systems <b>called</b> <b>macro</b> tree transducers. We formalize {{the implementation of a}} deterministic partial E-unification algorithm on a deterministic abstract machine, called the twin unification machine. The unification algorithm is based on a particular narrowing strategy that combines leftmost outermost narrowing with a local constructor consistency check and a particular occur check. The twin unification machine uses two runtime stacks; it is an extension of an efficient leftmost outermost reduction machine for macro tree transducers. The feasibility of the presented implementation technique is proved by an implementation that has been developed on a SPARCstation SLC...|$|R
50|$|With version 6, CorelDraw {{introduced}} the automation of tasks using a Corel proprietary scripting language, COREL Script. With version 10, support for VBA (Visual Basic for Applications) was introduced for scripting by what Corel <b>calls</b> now <b>macros.</b> Corel recommends to no longer use the COREL Script language but only VBA.|$|R
50|$|In the C and C++ {{programming}} languages, an #include guard, sometimes <b>called</b> a <b>macro</b> guard or header guard, is {{a particular}} construct used to avoid the problem of double inclusion when dealing with the include directive. The addition of #include guards to a header file {{is one way to}} make that file idempotent.|$|R
40|$|The {{importance}} of production systems in artificial intelligence has been repeatedly demonstrated {{by a number}} of expert systems. Much effort has therefore been expended on finding an efficient processing mechanism to process production systems. While data-flow principles of execution offer the promise of high programmability for numerical computations, we study here variable resolution actors, <b>called</b> <b>macro</b> actors, a processing mechanism for production systems. Characteristics of the production system paradigm are identified, based on which we introduce the concept of macro tokens as a companion to macro actors. Aset of guidelines is identified in the context of production systems to derive well-formed macro actors from primitive micro actors. Parallel pattern matching is written in macro actors/tokens to be executed on our Macro Data-flow simulator. Simulation results demonstrate that the macro approach can be an efficient implementation of production systems. 1...|$|R
50|$|Keyboard {{and mouse}} macros that are created using an application's {{built-in}} macro features are sometimes <b>called</b> application <b>macros.</b> They {{are created by}} carrying out the sequence once and letting the application record the actions. An underlying macro programming language, most commonly a scripting language, with {{direct access to the}} features of the application may also exist.|$|R
5000|$|Other {{function}} key assignments {{common to all}} Microsoft Office applications are: [...] to check spelling, + to <b>call</b> the <b>macros</b> dialog, + to call the Visual Basic Editor and ++ to call the Script Editor. In Microsoft Word, + reveals formatting. In Microsoft PowerPoint, [...] starts the slide show, and [...] moves to the next pane.|$|R
40|$|There is {{a growing}} need for abstractions in logic {{specification}} languages such as FO(.) and ASP. One technique to achieve these abstractions are templates (sometimes <b>called</b> <b>macros).</b> While the semantics of templates are virtually always described through a syntactical rewriting scheme, we present an alternative view on templates as second order definitions. To extend the existing definition construct of FO(.) to second order, we introduce a powerful compositional framework for defining logics by modular integration of logic constructs specified as pairs of one syntactical and one semantical inductive rule. We use the framework to build a logic of nested second order definitions suitable to express templates. We show that under suitable restrictions, the view of templates as macros is semantically correct and that adding them does not extend the descriptive complexity of the base logic, which {{is in line with}} results of existing approaches. status: publishe...|$|R
