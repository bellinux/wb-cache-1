3|6362|Public
50|$|Without an {{explicit}} cast, arrays can't and won't {{be converted to}} pointers {{and it is a}} <b>compile</b> <b>time</b> <b>error.</b> This is a property of type-safe programming.|$|E
5000|$|Rust {{features}} type inference, {{for variables}} declared with the [...] keyword. Such variables {{do not require}} a value to be initially assigned to determine their type. A <b>compile</b> <b>time</b> <b>error</b> results if any branch of code fails to assign a value to the variable. Variables which will be assigned multiple times must be marked with the [...] keyword.|$|E
40|$|Functional {{programming}} presents {{new challenges}} {{in the design of}} programming environments. In a strongly typed functional language, such as ML, much conventional debugging of runtime errors is replaced by dealing with <b>compile</b> <b>time</b> <b>error</b> reports. On the other hand, the cleanness of functional programming opens up new possibilities for incorporating sophisticated correctness-checking techniques into such environments. C Y NTHIA is a novel editor for ML that both addresses the challenges and explores the possibilities. It uses an underlying proof system as a framework for automatically checking for semantic errors such as non-termination. In addition, C Y NTHIA embodies the idea of programming by analogy [...] - whereby users write programs by applying abstract transformations to existing programs. This paper investigates C Y NTHIA's potential as a novice ML programming environment. We report on two studies in which it was found that students using C Y NTHIA commit fewer er [...] ...|$|E
40|$|In {{this report}} we {{introduce}} the <b>compile</b> <b>time</b> constraint library of the pe physics engine. These <b>compile</b> <b>time</b> constraints are {{a valuable tool}} to detect <b>compile</b> <b>time</b> <b>errors</b> and {{in case of an}} error to abort the compilation process and report the error by emitting a comprehensible error message. Additionally, they offer the option to enforce certain design decisions. ...|$|R
5000|$|Compiler: Performs {{compilation}} of the HiveQL query, which converts the query to an execution plan. This plan contains the tasks and steps {{needed to be}} performed by the Hadoop MapReduce to get the output as translated by the query. The compiler converts the query to an abstract syntax tree (AST). After checking for compatibility and <b>compile</b> <b>time</b> <b>errors,</b> it converts the AST to a directed acyclic graph (DAG). The DAG divides operators to MapReduce stages and tasks based on the input query and data.|$|R
5000|$|In a pre-release {{version of}} the {{original}} MAD, as a reference to MAD's namesake, MAD magazine, when a program contained too many <b>compile</b> <b>time</b> <b>errors</b> the compiler would print a full-page picture of Alfred E. Neuman using ASCII art. The caption read, [...] "See this man about your program--He might want to publish it. He never worries--but {{from the looks of}} your program, you should." [...] This feature {{was not included in the}} final official version. However, it was included in the production version for the IBM 7040.|$|R
40|$|We {{study the}} {{performance}} of task graph scheduling for both regular and irregular parallel computation. We present a scheduling tool named PYRROS, which takes as an input a task graph and a <b>compile</b> <b>time</b> estimation of computation and communication weights. It then produces a schedule and a parallel code based on this schedule. We analyze the effect of <b>compile</b> <b>time</b> <b>errors</b> to run <b>time</b> scheduling performance. For coarse grain task graphs small <b>errors</b> at <b>compile</b> <b>time</b> have a minimal impact in run time performance. We use PYRROS to produce parallel code for Gauss Jordan(GJ) and Gaussian Elimination (GE), sparse matrix computation and Fast Multipole method for irregular n-body simulations. The performance for GJ and GE on dense matrix computation is comparable to optimized hand written codes. For irregular problems such as n-body, scheduling overhead could become significant, {{but because of the}} iterative nature of such problems the overhead can be amortized over many iterations. And the overall [...] ...|$|R
40|$|This paper {{describes}} how to exploit some particular rules about generic programming implementation with C++, {{to be able}} to verify at compile-time the existence of symbols such as classes, functions or methods, and the validity of expressions involving those symbols. This validation is done {{in such a way that}} the program will always compile and run, even if some expected class or function interface is missing, automatically skipping pieces of code when its compilation is not guaranteed to be successful. This techniques can be easily extended and applied to design and implement programming exercises that will precisely diagnose students errors when are executed, displaying custom run-time messages, and avoiding most <b>compile</b> <b>time</b> <b>errors.</b> This approach produces a selfcontained C++ 11 code representing a programming assignment, that requires only a standard compliant compiler to be used by the student. No other tool or instrumentation is needed. III Workshop de Innovación en Educación en Informática (WIEI...|$|R
40|$|The Semantic Web and its {{technologies}} {{become increasingly}} important. As {{more and more}} Semantic Web applications are being used, developing more stable Semantic Web applications becomes a key issue. The state-of-the-art in programming Semantic Web applications is using complex application programming interfaces of Semantic Web frameworks, where extensive tests are necessary {{for the detection of}} errors, although many types of errors could be detected already at <b>compile</b> <b>time.</b> In this paper, we propose an embedding of Semantic Web languages into the java programming language, such that Semantic Web data and queries can be transparently used, type safety is guaranteed, and already at <b>compile</b> <b>time,</b> syntax <b>errors</b> of Semantic Web data and queries are reported, unsatisfiable queries are detected and the types of query results are determined. A demonstration of our system is available online...|$|R
40|$|AbstractThe paper {{presents}} a diagnosis tool for CLP programs. It deals with partial correctness w. r. t. specifications which describe procedure calls and successes. The space of possible specifications {{is restricted to}} a kind of regular types; we propose a generalization of the concept of types used in so called descriptive typing of logic programs. In particular we distinguish ground types from those containing non-ground elements. The tool is able to automatically locate at <b>compile</b> <b>time</b> all <b>errors</b> in a program, this means all the clauses or clause prefixes responsible for the program being incorrect w. r. t. a given specification. The tool aids the user in constructing specifications incrementally; often a fragment of the specification is already sufficient to locate an error. Our prototype is specialized for the programming language CHIP, but the idea is applicable to any untyped CLP (and LP) language. We believe that the presented approach makes it possible to combine the advantages of typed and untyped programming languages...|$|R
40|$|C/C++ are the {{languages}} of choice for development of many widely used system softwares. However, these languages do not provide the strong safety guarantees that safe languages such as Java do. Programming mistakes can introduce type errors that are not caught at <b>compile</b> <b>time.</b> These <b>errors</b> may subsequently be triggered at runtime, and their sources maybe hard to detect. This thesis presents the design and implementation for a dynamic type checker for C/C++ programs. It is built using the LLVM compiler infras- tructure and provides type safety for programs that have been compiled to the LLVM IR. The thesis also discusses the design of static analysis to reduce the overhead of the dynamic type checker. We present an implementation of the static analysis and discuss how its results {{can be used to}} optimize the dynamic type checker. We also present performance evaluation on various benchmarks and system software. We present results that show that we can catch most errors with relatively low overhead...|$|R
40|$|The paper {{presents}} a diagnosis tool for CLP programs. It deals with partial correctness w. r. t. specifications which describe procedure calls and successes. The space of possible specifications {{is restricted to}} a kind of regular types; we propose a generalization of the concept of types used in so called descriptive typing of logic programs. In particular we distinguish ground types from those containing non-ground elements. The tool is able to automatically locate at <b>compile</b> <b>time</b> all <b>errors</b> in a program, this means all the clauses or clause prefixes responsible for the program being incorrect w. r. t. a given specification. The tool aids the user in constructing specifications incrementally; often a fragment of the specification is already sufficient to locate an error. Our prototype is specialized for the programming language CHIP, but the idea is applicable to any untyped CLP (and LP) language. We believe that the presented approach makes it possible to combine the advantages of typed [...] ...|$|R
40|$|This paper gives {{a partial}} {{answer to the}} question: “Can type systems detect {{modelling}} errors in scientific computing, particularly for inverse problems derived from physical models? ” by considering, in detail, the major aspects of inverse problems in Magnetic Resonance Imaging (MRI). We define a type-system that can capture all correctness properties for basic MRI in-verse problems, including many properties that are not captured with cur-rent type-systems, e. g., frames of reference. We implemented a type-system in the Haskell language that can capture the errors arising in translating a mathematical model into a linear or nonlinear system, or alternatively into an objective function. Most models are (or can be approximated by) linear transformations, and we demonstrate the feasibility of capturing their cor-rectness at the type level using a difficult case, the (discrete) Fourier trans-formation (DFT). By this, we mean {{that we are able}} to catch, at <b>compile</b> <b>time,</b> all <b>errors</b> known to us in applying the DFT. We describe the Haskell implementation of vector size, physical units, frame of reference, and so o...|$|R
40|$|Network {{management}} {{is a key}} technology for operating large heterogeneous data transmission networks. To allow deployment of equipment from different vendors, the OSI TMN (Telecommunications Management Network) framework defines the language GDMO (Guidelines for the Definition of Managed Objects). Unfortunately, the behavior of managed objects is defined in an informal manner using natural language. This results in behavior specifications which are often vague and ambiguous, increasing the possibility of different implementations not being interoperable. To achieve consistent, clear, concise, and unambiguous specifications, a formal methodology has to be utilized. This paper introduces a framework {{for the inclusion of}} formal behavior descriptions into GDMO specifications. An object-oriented logic programming language is presented, which can be used in conjunction with the framework to specify the behavior of managed objects. The language is aimed at automatically producing prototypes of the described system. It enforces strict type checking at <b>compile</b> <b>time</b> to catch <b>errors</b> as early as possible. Furthermore, it works on a rather abstract level to hide specific implementation details...|$|R
40|$|This chapter {{presents}} a static diagnosis tool that locates type errors in untyped CLP programs without executing them. The existing prototype is specialised for the programming language CHIP [4. 10], {{but the idea}} applies to any CLP language. The tool works with approximated specifications which describe types of procedure calls and successes. The specifications are expressed as {{a certain kind of}} term grammars. The tool automatically locates at <b>compile</b> <b>time</b> all the <b>errors</b> (with respect to a given specification) in a program. The located erroneous program fragments are (prefixes of) clauses. The tool aids the user in constructing specifications incrementally; often a fragment of the specification is already sufficient to locate an error. The presentation is informal. The focus is on the motivation of this work and on the functionality of the tool. Some related formal aspects are discussed in [4. 15, 4. 29]. The prototype tool is available from [URL] 2000; 20081211 (ysko...|$|R
40|$|A {{protection}} mechanism {{which may}} be embebbed in an object oriented language for real time programming permitting definition of abstract data types, is proposed in this paper. This mechanism provides support for designing highly reliable e concurrent programs; in fact it allows the detection at <b>compile</b> <b>time</b> of a large class of <b>time</b> <b>errors.</b> Ta verify the versatility of the proposed mechanism it is firstly characterized abstractly {{in terms of a}} protection model; then some linguistic features enforcing protection are defined...|$|R
5000|$|<b>Compile</b> <b>time</b> {{function}} execution: {{the evaluation}} of pure functions at <b>compile</b> <b>time</b> ...|$|R
5000|$|The LiteralExp {{must be a}} <b>compiled</b> <b>time</b> resolvable numeric expression, and {{may involve}} {{operators}}, as long as such operators involve <b>compile</b> <b>time</b> static value.|$|R
40|$|The {{development}} of web applications for desktop and mobile has surged in recent years. The most popular web scripting language is JavaScript {{because all the}} browsers support it and {{its role as a}} scripting language of the WWW. It is a powerful and flexible language. However, it also has some shortcomings. For this reason, {{over the last few years}} many different web scripting languages have appeared, they give the solutions to the shortcomings of JavaScript. In this thesis a number of emerging web scripting languages are surveyed and the most popular option, CoffeeScript, TypeScript and Dart, are evaluated in detailed level. We will explain what a scripting language is and how it works, JavaScript‘s problems in developing a web application, list of available scripting languages for web clients, the motivation behind these languages and their features that they add to JavaScript. In order to show the results, an example web application is developed in all the languages. The main conclusion extracted of this thesis is that these languages address the shortcomings of the JavaScript such as they all have the <b>compile</b> <b>time</b> checking for <b>errors,</b> CoffeeScript adds the syntactic sugar to JavaScript syntax, object-orientation, inheritance. TypeScript and Dart have the type checking, modules and generics. Dart also supports the concurrency with isolates. It is easy to develop and maintain the complex and large scale applications in these languages...|$|R
50|$|Compile-time {{function}} execution (or <b>compile</b> <b>time</b> function evaluation, or general constant expressions) {{is the ability}} of a compiler, that would normally compile a function to machine code and execute it at run time, to execute the function at <b>compile</b> <b>time.</b> This is possible if the arguments to the function are known at <b>compile</b> <b>time,</b> and the function does not make any reference to or attempt to modify any global state (is a pure function).|$|R
50|$|As {{opposed to}} macros, {{templates}} are considered type-safe; that is, they require type-checking at <b>compile</b> <b>time.</b> Hence, the compiler can determine at <b>compile</b> <b>time</b> whether the type {{associated with a}} template definition can perform all of the functions required by that template definition.|$|R
50|$|To ensure compilers cannot pre-compute {{the results}} at <b>compile</b> <b>time</b> every {{operation}} in the benchmark derives a value that is not available at <b>compile</b> <b>time.</b> Furthermore, all code used within the timed portion of the benchmark {{is part of the}} benchmark itself (no library calls).|$|R
5000|$|Package {{diagrams}} {{represent a}} <b>compile</b> <b>time</b> grouping mechanism.|$|R
5000|$|Constant folding is {{the process}} of {{recognizing}} and evaluating constant expressions at <b>compile</b> <b>time</b> rather than computing them at runtime. Terms in constant expressions are typically simple literals, such as the integer literal , but they may also be variables whose values are known at <b>compile</b> <b>time.</b> Consider the statement: ...|$|R
5000|$|The first IBM <b>Compile</b> <b>time</b> {{preprocessor}} {{was built}} by the IBM Boston Advanced Programming Center located in Cambridge, Mass, and shipped with the PL/I F compiler. The [...] statement was in the Standard, {{but the rest of}} the features were not. The DEC and Kednos PL/I compilers implemented much the same set of features as IBM, with some additions of their own. IBM has continued to add preprocessor features to its compilers. The preprocessor treats the written source program as a sequence of tokens, copying them to an output source file or acting on them. When a % token is encountered the following <b>compile</b> <b>time</b> statement is executed: when an identifier token is encountered and the identifier has been d, d, and assigned a <b>compile</b> <b>time</b> value, the identifier is replaced by this value. Tokens are added to the output stream if they do not require action (e.g. [...] ), as are the values of ACTIVATEd <b>compile</b> <b>time</b> expressions. Thus a <b>compile</b> <b>time</b> variable [...] could be declared, activated, and assigned using [...] Subsequent occurrences of [...] would be replaced by [...]|$|R
5000|$|Here's {{an example}} of <b>compile</b> <b>time</b> {{function}} evaluation in C++14: ...|$|R
5000|$|Templates {{are written}} as <b>compile</b> <b>time</b> {{functions}} with type parameters.|$|R
50|$|In programming, string {{concatenation}} generally {{occurs at}} run time, as string values {{are not in}} general known until run time. However, {{in the case of}} string literals, the values are known at <b>compile</b> <b>time,</b> and thus string concatenation can be done at <b>compile</b> <b>time,</b> either via string literal concatenation or via constant folding.|$|R
50|$|Assertions {{that are}} checked at <b>compile</b> <b>time</b> are called static assertions.|$|R
5000|$|Execute {{parts of}} a program at <b>compile</b> <b>time</b> rather than runtime ...|$|R
5000|$|Java: Lightwolf javaflow (Requires {{bytecode}} manipulation at runtime or <b>compile</b> <b>time)</b> ...|$|R
40|$|Many keyword pattern {{matching}} algorithms use precomputation subroutines to produce lookup tables, {{which in turn}} are used to improve performance during the search phase. If the keywords to be matched are known at <b>compile</b> <b>time,</b> the precomputation subroutines can be implemented to be evaluated at <b>compile</b> <b>time</b> versus at run time. This will provide a performance boost to run time operations. We have started {{an investigation into the}} use of metaprogramming techniques to implement such <b>compile</b> <b>time</b> evaluation, initially for the Knuth-Morris-Pratt (KMP) algorithm. We present an initial experimental comparison of the performance of the traditional KMP algorithm to that of an optimised version that uses <b>compile</b> <b>time</b> precomputation. During implementation and benchmarking, it was discovered that C++ is not well suited to metaprogramming when dealing with strings, while the related D language is. We therefore ported our implementation to the latter and performed the benchmarking with that version. We discuss the design of the benchmarks, the experience in implementing the benchmarks in C++ and D, and the results of the D benchmarks. The results show that under certain circumstances, the use of <b>compile</b> <b>time</b> precomputation may significantly improve performance of the KMP algorithm...|$|R
50|$|It allows full checks at <b>compile</b> <b>time</b> between {{actual and}} dummy arguments.|$|R
5000|$|This example {{specifies}} a valid D function called [...] "factorial" [...] {{which would}} typically be evaluated at run time. The use of [...] tells the compiler that the initializer for the variables must be computed at <b>compile</b> <b>time.</b> Note that the arguments to the function {{must be able}} to be resolved at <b>compile</b> <b>time</b> as well.|$|R
500|$|Most of {{what happens}} in Perl's compile phase is compilation, and most {{of what happens}} in Perl's run phase is execution, but there are {{significant}} exceptions. Perl makes important use of its capability to execute Perl code during the compile phase. Perl will also delay compilation into the run phase. The terms that indicate the kind of processing that is actually occurring at any moment are <b>compile</b> <b>time</b> and run time. [...] Perl is in <b>compile</b> <b>time</b> at most points during the compile phase, but <b>compile</b> <b>time</b> may also be entered during the run phase. The <b>compile</b> <b>time</b> for code in a string argument passed to the eval built-in occurs during the run phase. Perl is often in run <b>time</b> during the <b>compile</b> phase and spends most of the run phase in run time. [...] Code in BEGIN blocks executes at run time but in the compile phase.|$|R
5000|$|A few {{languages}} provide string literal concatenation, where adjacent string literals are implicitly joined into {{a single}} literal at <b>compile</b> <b>time.</b> This is a feature of C, C++, D, and Python, which copied it from C. Notably, this concatenation happens at <b>compile</b> <b>time,</b> during lexical analysis (as a phase following initial tokenization), and is contrasted with both run time string concatenation (generally with the [...] operator) and concatenation during constant folding, which occurs at <b>compile</b> <b>time,</b> but in a later phase (after phrase analysis or [...] "parsing"). Most languages, such as C#, Java and Perl, do not support implicit string literal concatenation, and instead require explicit concatenation, such as with the [...] operator (this is also possible in D and Python, but illegal in C/C++ - see below); in this case concatenation may happen at <b>compile</b> <b>time,</b> via constant folding, or may be deferred to run time.|$|R
