133|153|Public
5000|$|Grimp: an {{aggregated}} {{version of}} Jimple suitable for decompilation and <b>code</b> <b>inspection.</b>|$|E
50|$|After a {{successful}} design inspection as per feature activity {{to produce a}} completed client-valued function (feature) is planned. The class owners, each develop code for their classes. After unit testing and successful <b>code</b> <b>inspection,</b> the completed feature is promoted to the main build.|$|E
50|$|The Rocky Point Cantina in Tempe, Arizona, closed after a repaint {{of the bar}} {{triggered}} a <b>code</b> <b>inspection,</b> which uncovered years of modifications to the building that had been completed without building permits. The bar owner opted to close the bar rather than bring his building up to code.|$|E
50|$|The city {{provides}} police, recycling, parks, planning, zoning, floodplain management, {{and building}} <b>code</b> <b>inspections</b> among its services. The city provides fire, sanitation, and {{emergency medical services}} by contract.|$|R
5000|$|Lightweight {{code review}} {{typically}} requires less overhead than formal <b>code</b> <b>inspections,</b> {{though it can}} be equally effective when done properly. Lightweight reviews are often conducted {{as part of the}} normal development process: ...|$|R
5000|$|Inspections. One {{study found}} that the average defect {{detection}} rate of formal <b>code</b> <b>inspections</b> is 60%. Regarding the cost of finding defects, a {{study found that}} code reading detected 80% more faults per hour than testing. Another study shown that it costs six times more to detect design defects by using testing than by using inspections. A study by IBM showed that only 3.5 hours where needed to find a defect through <b>code</b> <b>inspections</b> versus 15-25 hours through testing. Microsoft has found that it takes 3 hours to find and fix a defect by using <b>code</b> <b>inspections</b> and 12 hours to find and fix a defect by using testing. In a 700 thousand lines program, it was reported that code reviews were several times as cost-effective as testing. Studies found that inspections result in 20% - 30% fewer defects per 1000 lines of code than less formal review practices and that they increase productivity by about 20%. Formal inspections will usually take 10% - 15% of the project budget and will reduce overall project cost. Researchers found that having more than 2 - 3 reviewers on a formal inspection doesn't increase the number of defects found, although the results seem to vary depending on the kind of material being inspected.|$|R
50|$|Numerous {{construction}} {{activities and}} artifacts can be measured, including code developed, code modified, code reused, code destroyed, code complexity, <b>code</b> <b>inspection</b> statistics, fault-fix and fault-find rates, effort, and scheduling. These measurements {{can be useful}} for purposes of managing construction, ensuring quality during construction, improving the construction process, {{as well as for}} other reasons.|$|E
50|$|A secure <b>code</b> <b>inspection</b> or {{walkthrough}} is {{a detailed}} examination {{of a product}} on a step-by-step or line-by-line (of source code) basis. The purpose of conducting secure code inspections or walkthroughs is to find errors. Typically, the group that does an inspection or walkthrough is composed of peers from development, security engineering and quality assurance.|$|E
40|$|The Advanced Learning Technologies Project {{developed}} a digital video course on code inspections from 1987 to 1990. The essence of {{this course is}} {{an environment in which}} a student participates in a <b>code</b> <b>inspection</b> as a contributing reviewer of the code. The student chooses an inspection role, and later assumes all the responsibilities of that role while performing in a <b>code</b> <b>inspection</b> simulation. The student is an active participant in the <b>code</b> <b>inspection,</b> and his or her contributions affect the course of the inspection dialogue and ultimately the success of the inspection. In addition, the role the student takes in the inspection is not predetermined but is selected by the student. To provide this flexibility, a rule base is used to control the <b>code</b> <b>inspection</b> simulation. To participate effectively in the <b>code</b> <b>inspection,</b> the student needs to recognize and react to the other reviewers ' comments and their emotional states. The importance of group process issues necessitates that the inspection simulation be presented as realistically as possible while still preserving the flexibility of dynami...|$|E
5000|$|... #Subtitle level 3: Secure <b>code</b> reviews, <b>inspections,</b> and walkthroughs ...|$|R
40|$|Programming is a {{difficult}} subject for many students and therefore a popular topic in computing education research, with extensive research into {{the teaching and learning}} of programming (Sheard et al., 2009). Peer code reviews (or <b>code</b> <b>inspections,)</b> have been successfully applied to the teaching of programming (Hundhausen et al., 2009, Trytten, 2005, Wang et al., 2008). Code reviews can also be applied in a individual context as in the Personal Software Process (PSP) (Humphrey, 1997). Making the review process individual eliminates the problems associated with group and pair work as the student is working alone. The aim of this research is to ascertain whether individual code reviews based on checklists (like those used in PSP (Humphrey, 1997) and during formal <b>code</b> <b>inspections</b> in industry (Sommerville, 2007),) with minimal reporting can be used to improve solo programming. The results shown an increase in performance however this is not statistically significant possibly due to the small sample size...|$|R
50|$|With {{the small}} TCB {{of a type}} 1 {{embedded}} hypervisor, the system can be made highly secure & reliable. Standard software-engineering techniques, such as <b>code</b> <b>inspections</b> and systematic testing, {{can be used to}} reduce the number of bugs in such a small code base to a tiny fraction of the defects that must be expected for a hypervisor and guest OS combination that may be 100,000-300,000 lines in total.|$|R
40|$|Given <b>code</b> <b>inspection</b> {{effectiveness}} (defects {{found during}} inspection/defects found during inspection plus those found during test) {{as a function}} of preparation rate (amount of code examined per labor hour), it is then possible to construct a simple cost model that predicts testing labor hours {{as a function of}} <b>code</b> <b>inspection</b> preparation rate. This paper develops that model and computes the optimum <b>code</b> <b>inspection</b> preparation rate to minimize total cost (inspection + test). Existing program data (with significant caveats) have been used together with certain rough approximations to show that Fagan-style code inspections obey a simple predictive cost model. The {{purpose of this paper is}} not to present actual performance data but to demonstrate how such data can be analyzed in the context of a cost model extending over multiple development processes: <b>code</b> <b>inspection,</b> <b>code</b> <b>inspection</b> rework, test, test rework, and regression testing. The purpose of the model is to demonstrate how to reduce development costs by managing the amount of time spent preparing for software inspections. All program data have been modified to protect the proprietary nature of that data. The conclusions and basic nature of the model are unaffected by these modifications. This model can be used to optimize performance of future programs using a similar Fagan-style [1, 2] <b>code</b> <b>inspection</b> process with significant cost and schedule savings as well as quality improvement – Figure 1 : Least Squares Fit of Inspection Effectiveness in effect, better, faster, and cheaper. Such performance improvements should result in improvements in profitability, competitiveness, and customer confidence in both contract performance and product quality. Further, the model is easily modified to other work products and cost drivers, e. g., design complexity. Given that <b>code</b> <b>inspection</b> may not be particularly effective in finding design and requirements defects, it may make sense to extend the model to include more development processes, such as requirements development and requirements inspection, design development and design inspection, defect repair and associated inspection, etc...|$|E
40|$|The <b>code</b> <b>inspection</b> {{process from}} the {{software}} {{world has been}} applied to Verilog HDL (hardware description language) code. This paper explains the <b>code</b> <b>inspection</b> process and the roles and responsibilities of the participants. It explores the special challenges of inspecting HDL, the types of findings made, and the lessons learned from using the process for a year. by Joseph J. Gilray The primary goal of the <b>code</b> <b>inspection</b> process is to maximize the quality of the code produced by an organization. A secondary benefit of the process is that it allows members of the development teams to share best practices. The <b>code</b> <b>inspection</b> process revolves around a formal inspection meeting. The process calls for the development of operational definitions, planning, a technical overview, preparation for the meeting, rework after the meeting, and follow-up. Fig. 1 illustrates the relationships between the steps. The steps themselves are described in the sections that follow. As shown in Fig. 1, the operational definitions affect all stages in the inspection process. Between some of the stages in the inspection process decisions whether or not to continue need to be made. These decisions are indicated on the figure by “Proceed?”...|$|E
40|$|Wrangler is a {{refactoring}} and <b>code</b> <b>inspection</b> {{tool for}} Erlang programs. Apart from providing {{a set of}} built-in refactorings and <b>code</b> <b>inspection</b> functionalities, Wrangler allows users to define refactorings, code inspections, and general program transformations for themselves to suit their particular needs. These are defined using a template- and rule-based program transformation and analysis framework built into Wrangler. This paper reports an extension to Wrangler’s extension framework, supporting the automatic generation of API migration refactorings from a user-defined adapter module...|$|E
40|$|Software project {{inspection}} {{has been}} shown to be an effective defect removal practice, leading to higher quality software with lower field failures. The use of software <b>code</b> <b>inspections,</b> design inspections, and requirements inspections, has been found to increase software quality and lower software development costs [1, 2]. Efficiency is the main attribute of reliability. Efficiency measures the performance of the software and performance of software is better if it is error free or defect free. To check the defect free software and to make it acceptable in the market, the software is inspected by the analysts on various criteria. The criteria are termed as defects classification and they are described as defect...|$|R
40|$|In {{order to}} improve the {{efficiency}} of inspections, quantitative data on defect content {{have to be the}} basis for decisions in the inspection process. An experience-based cap-ture-recapture method is proposed, which overcomes some problems with the basic pre-requisites of the original method. A C-code inspection experiment is conducted to evaluate the enhanced method and its applicability to software <b>code</b> <b>inspections.</b> It is concluded that the experience-based estimation procedure gives significantly better estimates than the maximum-likelihood method and the estimates are not very sensi-tive to changes in the inspection data...|$|R
40|$|To date most {{validation}} {{techniques are}} highly biased towards calculations involving symbolic representations of problems. These calculations are either formal (in {{the case of}} consistency and completeness checks), or informal {{in the case of}} <b>code</b> <b>inspections.</b> The authors believe that an essential type of evidence of the correctness of the formalization process must be provided by (i. e., must originate from) human-based calculation. They further believe that human calculation can by significantly amplified by shifting from symbolic representations to graphical representations. This paper describes their preliminary efforts in realizing such a representational shift...|$|R
40|$|Constraint {{modeling}} {{could be}} a very important system validation method, because its abilities are complementary to both testing and <b>code</b> <b>inspection.</b> In particular, even though the ability of constraint modeling to find errors is limited by the simplifications which are introduced when making a constraint model, constraint modeling can locate important classes of errors which are caused by non-local faults (i. e., are hard to find with <b>code</b> <b>inspection)</b> and manifest themselves as failures only in unusual situations (i. e., are hard to find with testing) ...|$|E
30|$|<b>Code</b> <b>inspection</b> in Hibernate OGM {{revealed}} that this platform extensively re-uses components from the Hibernate ORM engine, which {{may result in}} additional overhead due to architectural legacy.|$|E
40|$|Suppose a {{software}} development manager is considering {{whether or not}} to add automatic <b>code</b> <b>inspection</b> to the current development process. The paper shows what properties of the current process to measure, and how to use these measurements {{in order to make a}} rational decision. Let P 1 denote the process whose steps are {write code, test program against requirements, find faults, fix faults} and P 2 be the process P 1 augmented by the single step {test code against guidelines}. The fractional effort actually saved by adopting P 2 rather than P 1 is given by dfic, where d, f and i are measurable properties of the process P 1, and c is the efficiency of the automatic <b>code</b> <b>inspection</b> tool employed. Over a wide range of realistic values for these quantities, automatic <b>code</b> <b>inspection</b> will save more than 10 % of the effort devoted to the process P 1 defined above...|$|E
40|$|Static code {{analysis}} {{is the process}} of evaluating a system or component based on its form, structure, content, or documentation. From a software assurance perspective, static analysis addresses weaknesses in program code that might lead to vulnerabilities Such analysis may be manual, as in <b>code</b> <b>inspections,</b> or automated through the use of one or more tools Automated static code analyzers typically check source code but there is a smaller set of analyzers that check byte code and binary code, especially useful when source code in not available (e. g for COTS components) ...|$|R
40|$|In this article, we {{consider}} the problem of planning inspections and other tasks within a software development (SD) project {{with respect to the}} objectives quality (no. of defects), project duration, and costs. Based on a discrete-event simulation model of SD processes comprising the phases <b>coding,</b> <b>inspection,</b> test, and rework, we present a simplified formulation of the problem as a multiobjective optimization problem. For solving the problem (i. e. finding an approximation of the efficient set) we develop a multiobjective evolutionary algorithm. Details of the algorithm are discussed as well as results of its application to sample problems...|$|R
40|$|The {{introduction}} of software formal inspections (Fagan Inspections) at JPL for finding and fixing defects {{early in the}} software development life cycle are reviewed. It is estimated that, by the year 2000, some software efforts will rise {{to as much as}} 80 percent of the total. Software problems are especially important at NASA as critical flight software must be error-free. It is shown that formal inspections are particularly effective at finding and removing defects having to do with clarity, correctness, consistency, and completeness. A very significant discovery was that code audits were not as effective at finding defects as <b>code</b> <b>inspections...</b>|$|R
30|$|The {{developers}} {{also stated}} that not having tool support to find architectural violations {{since the beginning of}} the development as a difficulty factor to not removing them, mainly because manual <b>code</b> <b>inspection</b> for architectural violations is difficult and costly.|$|E
40|$|Software {{inspection}} is {{a proven}} methodology {{that enables the}} detection and removal of defects in software artifacts and thus contributes towards software quality assurance. It eventually leads to significant budget and time benefits. To be most effective, inspections must {{be an integral part}} of the software development life cycle and form part of the development schedule. This study considers <b>code</b> <b>inspection</b> as it is the most frequently used inspection in the software development process. For the implementation part of this research, <b>code</b> <b>inspection</b> is carried out in a selected outsourced project in a company situated in Mauritius, and the results are evaluated based on the inspection process and feedback of people involved in the inspection process...|$|E
40|$|Verifying {{concurrent}} Java {{programs is}} difficult {{due to the}} many possible interleavings of threads {{and a number of}} specific concurrency defects such as interference and deadlock. To verify concurrent Java components, the TestCon method combines <b>code</b> <b>inspection,</b> static analysis and dynamic analysis. The deadlock detection steps of TestCon include static analysis (using Jlint) that may result in false positives or false negatives; therefore <b>code</b> <b>inspection</b> is combined with Jlint, but inspection can be time-consuming and depends on the inspector 2 ̆ 7 s skills. In this paper, we evaluate the cost-effectiveness of the Java PathFinder 2 (JPF 2) model checker for the detection of deadlocks {{in the context of the}} TestCon method. The results of the study show that using JPF 2 can improve TestCon 2 ̆ 7 s effectiveness but a trade-off has to be made in terms of cost in the development of the driver and analysis of its output. General conclusions cannot be drawn since the study was exploratory and small-scale; however the observations highlight some of the strengths and weaknesses of using JPF 2 compared to static analysis and <b>code</b> <b>inspection...</b>|$|E
40|$|One of {{the major}} {{challenges}} software engineers often face in performing IV&V is developing an understanding of a system created by a development team {{they have not been}} part of. As budgets shrink and software increases in complexity, this challenge will become even greater as these software engineers face increased time and resource constraints. This research will determine which current aspects of providing this understanding (e. g., <b>code</b> <b>inspections,</b> use of control graphs, use of adjacency matrices, requirements traceability) are critical to the performing IV&V and amenable to visualization techniques. We will then develop state-of-the-art software visualization techniques to facilitate the use of these aspects to understand software and perform IV&V...|$|R
40|$|Recent {{research}} suggests that people related issues account {{for as much as}} 50 % of explained sources of variation in software <b>code</b> <b>inspections</b> and that process related issues account for less than 30 %. This paper examines the impact of two feedback mechanisms (process maturity and inspector proficiency) on software inspections. Results of a survey of thirty-one experienced software developers and follow-up interviews are presented. Key findings include that significant process variations appear to exist within relatively mature organizations and that teams own inspection processes. The paper also addresses the significance and potential of feedback mechanism research. The findings extend to other formal technical reviews and provide insights into managin...|$|R
40|$|<b>Code</b> <b>inspections</b> and {{structural}} unit testing are two common defect detection methods in software development. This paper analyses three replications {{of an experiment}} aimed at comparing which method finds more defects. The first two experiments use the same experimental design and materials, including the programs to be inspected or tested, while the third experiment replaces the programs with code for embedded systems. Participants are a mixture of graduate and undergraduate students. Our analysis shows that the both {{the differences in the}} instrumentation and the between-experiment participants themselves were larger than the differences between inspection versus unit testing, especially in terms of the time to complete the tasks...|$|R
40|$|CUCS- 008 - 95 Message-based {{architectures}} {{have typically}} {{been used for}} integrating an engineer’s set of tools as in FIELD and SoftBench. This paper presents our experience using a message-based architecture to integrate complex, multi-user environments. Where this style of control integration has been effective for encapsulating independent tools within an environment, we show that these techniques are also useful for integrating environments themselves. Our experience comes from our integration of two types of process-centered software development environments: a groupware application that implements a Fagan-style <b>code</b> <b>inspection</b> process and a software development process environment where <b>code</b> <b>inspection</b> is a single step in the overall process. We use a message-based mechanism to federate the two process engines such that the two process formalisms complement rather than compete with each other. Moreover, {{we see that the}} two process engines can provide some synergy when used in a single, integrated software process environment, Specifically, the integrated environment uses the process modeling and enactment services of one process engine to customize and extend the <b>code</b> <b>inspection</b> process implemented in a different process engine. The customization and extension of the original collaborative application was accomplished without modifying the application. This was possibl...|$|E
40|$|The Shuttle Data Systems Branch (SDSB) of the Flight Data Systems Division (FDSD) at Johnson Space Center {{contracted}} with Southwest Research Institute (SwRI) {{to validate the}} effectiveness of an interactive video course on the <b>code</b> <b>inspection</b> process. The purpose of this project {{was to determine if}} this course could be effective for teaching NASA analysts the process of <b>code</b> <b>inspection.</b> In addition, NASA was interested in the effectiveness of this unique type of instruction (Digital Video Interactive), for providing training on software processes. This study found the Carnegie Mellon course, 'A Cure for the Common Code', effective for teaching the process of <b>code</b> <b>inspection.</b> In addition, analysts prefer learning with this method of instruction, or this method in combination with other methods. As is, the course is definitely better than no course at all; however, findings indicate changes are needed. Following are conclusions of this study. (1) The course is instructionally effective. (2) The simulation has a positive effect on student's confidence in his ability to apply new knowledge. (3) Analysts like the course and prefer this method of training, or this method in combination with current methods of training in <b>code</b> <b>inspection,</b> over the way training is currently being conducted. (4) Analysts responded favorably to information presented through scenarios incorporating full motion video. (5) Some course content needs to be changed. (6) Some content needs {{to be added to the}} course. SwRI believes this study indicates interactive video instruction combined with simulation is effective for teaching software processes. Based on the conclusions of this study, SwRI has outlined seven options for NASA to consider. SwRI recommends the option which involves creation of new source code and data files, but uses much of the existing content and design from the current course. Although this option involves a significant software development effort, SwRI believes this option will produce the most effective results...|$|E
40|$|Abstract. Refactoring is {{the process}} of {{changing}} the design of a program without changing what it does. While it is possible to refactor a program by hand, tool support is considered invaluable as it allows largescale refactorings to be performed easily. However, most refactoring tools are black boxes, supporting a fixed set of ‘core ’ refactorings. This paper reports the framework built into Wrangler – a refactoring and <b>code</b> <b>inspection</b> tool for Erlang programs – that allows users to define for themselves refactorings and <b>code</b> <b>inspection</b> functions that suit their needs. These are defined using a template- and rule-based program transformation and analysis API. User-defined refactorings are no “second-class citizens”: like the existing ones supported by Wrangler, user-defined refactorings benefit from features such as results preview, layout preservation, selective refactoring, undo and so on...|$|E
50|$|Sencha’s JetBrains plugin is an Integrated Development Environment {{tool that}} creates a {{confluence}} between Sencha Frameworks and JetBrains software. This integration {{comes in the form}} of <b>code</b> completion, <b>inspection,</b> and suggestion, while cooperating with native JetBrains behavior.|$|R
40|$|Code {{review is}} the manual {{assessment}} of source code by humans, mainly intended to identify defects and quality problems. Modern Code Review (MCR), a lightweight {{variant of the}} <b>code</b> <b>inspections</b> investigated since the 1970 s, prevails today both in industry and open-source software (OSS) systems. The objective {{of this paper is}} to increase our understanding of the practical benefits that the MCR process produces on reviewed source code. To that end, we empiri-cally explore the problems fixed through MCR in OSS systems. We manually classified over 1, 400 changes taking place in reviewed code from two OSS projects into a validated categorization scheme. Surprisingly, results show that the types of changes due to the MCR process in OSS are strikingly similar to those in the industry and academic systems from literature, featuring the similar 75 : 25 ratio of maintainability-related to functional problems. We also reveal that 7 – 35 % of review comments are discarded and that 10 – 22 % of the changes are not triggered by an explicit review comment. Patterns emerged in the review data; we investigated them revealing the technical factors that influence the number of changes due to the MCR process. We found that bug-fixing tasks lead to fewer changes and tasks with more altered files and a higher code churn have more changes. Contrary to intuition, the person of the reviewer had no impact on the number of changes. Categories and Subject Descriptors D. 2. 5 [Testing and Debugging]: <b>Code</b> <b>inspections</b> and walk-through...|$|R
50|$|Waffenamt <b>codes</b> {{were the}} <b>inspection</b> marks used on {{military}} equipment by the German Third Reich.|$|R
