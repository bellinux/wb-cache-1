78|10000|Public
60|$|The {{universality}} {{of the confusion}} between perceptions and the inferences drawn from them, and the rarity of the power to discriminate the one from the other, ceases to surprise us when we consider that in the far greater number of instances the actual perceptions of our senses are of no importance or interest to us except as marks from which we infer something beyond them. It is not the color and superficial extension perceived by the eye {{that are important to}} us, but the object, of which those visible appearances testify the presence; and where the sensation itself is indifferent, as it generally is, we have no motive to attend particularly to it, but acquire a habit of passing it over without distinct consciousness, and going on at once to the inference. So that to know what the sensation actually was, is a study in itself, to which painters, for example, have to train themselves by special and long-continued discipline and application. In things farther removed from the dominion of the outward senses, no one who has not great experience in psychological analysis is competent to break this intense association; and when such analytic habits do not exist in the requisite degree, it is hardly possible to mention any of the habitual judgments of mankind on subjects of a high degree of abstraction, from the being of a God and the immortality of the soul down to the multiplication table, which are not, or have not been, considered as matter of direct intuition. So strong is the tendency to ascribe an intuitive character to judgments which are mere inferences, and often false ones. No one can doubt that many a deluded visionary has actually believed that he was directly inspired from Heaven, and that the Almighty had conversed with him face to face; which yet was only, on his part, a conclusion drawn from appearances to his senses, or feelings in his internal consciousness, which afforded no warrant for any such belief. A caution, therefore, against this <b>class</b> <b>of</b> <b>errors,</b> is not only needful but indispensable; though to determine whether, on any of the great questions of metaphysics, such errors are actually committed, belongs not to this place, but, as I have so often said, to a different science.|$|E
5000|$|With {{the minimum}} string {{distance}} error, errors that are corrected {{do not appear}} in the transcribed text. The following example will show you why this is an important <b>class</b> <b>of</b> <b>errors</b> to consider: ...|$|E
5000|$|In digital storage, a Medium Error is a <b>class</b> <b>of</b> <b>errors</b> that {{a storage}} device can experience, which imply that a {{physical}} problem was encountered {{when trying to}} access the device. The word [...] "medium" [...] refers to the physical storage layer, the medium on which the data is stored; as opposed to errors related to e.g. protocol, device/controller/driver state, etc.|$|E
50|$|R. C. Bose and D. K. Ray-Chaudhuri: On a <b>class</b> <b>of</b> <b>error</b> {{correcting}} binary group codes. Information and Control 3(1): 68-79 (March 1960).|$|R
40|$|This paper {{discusses}} the background, algorithms and implementation techniques to support programmers in 'debugging' logic programs under the answer set semantics. We first investigate what constitutes {{an error in}} such programs and which <b>classes</b> <b>of</b> <b>errors</b> exist. This is used to motivate techniques and algorithms that respectively eliminate certain <b>classes</b> <b>of</b> <b>errors</b> and explain how an error occurred and why it occurred. Finally, details of the IDEAS (Interactive Development and Evaluation tool for Answer Set Semantics) system are given, a prototype version of which implements all of the techniques described...|$|R
50|$|A {{trial balance}} only checks {{the sum of}} debits against the sum of credits. That is why it does not {{guarantee}} {{that there are no}} errors. The following are the main <b>classes</b> <b>of</b> <b>errors</b> that are not detected by the trial balance.|$|R
5000|$|There were (at least) two incarnations of Flex, {{implemented}} using hardware with writable microcode. The {{first was}} supplied by Logica to an RSRE design, {{and the second}} used an ICL PERQ. [...] The microcode alone was responsible for storage allocation, deallocation and garbage collection. This immediately precluded a whole <b>class</b> <b>of</b> <b>errors</b> arising from the misuse (deliberate or accidental) of pointers.|$|E
40|$|This {{paper will}} {{describe}} a technique for correcting ungrammatical input. The <b>class</b> <b>of</b> <b>errors</b> treated includes both genuine gramma tical errors and those resulting from "holes. " One {{of the assumptions}} tested by this work is that a significant <b>class</b> <b>of</b> <b>errors</b> can be resolved by examination of syntacti'c structure alon...|$|E
40|$|This paper {{presents}} a bug understanding system, called sniffer, which applies inspection methods {{to generate a}} deep understanding of a narrow <b>class</b> <b>of</b> <b>errors.</b> Sniffer is an interactive debugging aide. It can locate and identify error-containing implementations of typical programming cliché³¬ and it can describe them using the terminology employed by expert programmers...|$|E
40|$|Powerful {{software}} tools {{are used by}} the aerospace and power generation communities to check codes for errors. The Software Validation Project at Edge Hill University ([URL] in collaboration with SimCon Ltd ([URL] has applied these tools to WRF, {{the most widely used}} program for modeling climate and weather. Preliminary results have been generated. Although the WRF code {{has been found to be}} of a very high standard, some errors have been identified, both in the code and in the compilers used to build it. An aim of the project is to use CASE tools to correct some <b>classes</b> <b>of</b> <b>error</b> automatically. This paper discusses the <b>classes</b> <b>of</b> <b>error</b> that have been identified to date, presents the initial findings from the investigations performed by the project team. </p...|$|R
40|$|Types play an {{increasingly}} important role in program construction, software engineering, and reasoning about programs. They serve as documentation of functionality, even as partial specifications, and can help to rule out whole <b>classes</b> <b>of</b> <b>errors</b> before a program is ever run. Types thus provide qualitative guarantee...|$|R
40|$|Algorithms are {{presented}} for detecting errors and anomalies in programs which use synchronization constructs to implement concurrency. The algorithms employ data flow analysis techniques. First used in compiler object code optimization, the techniques have more recently {{been used in}} the detection <b>of</b> variable usage <b>errors</b> in single process programs. By adapting these existing algorithms the same <b>classes</b> <b>of</b> variable usage <b>error</b> can be detected in concurrent process programs. Important <b>classes</b> <b>of</b> <b>errors</b> unique to concurrent process programs are also described, and algorithms for their detection {{are presented}}...|$|R
40|$|This {{dissertation}} {{focuses on}} programming language support for interactive dialogues that exhibit the same flexibility as Web dialogues. A foundational model of Web interactions {{provides a framework}} for formally describing two classes of errors. The model suggests techniques for detecting both classes of errors. An incrementally checked record type system eectively eliminates one <b>class</b> <b>of</b> <b>errors.</b> A dynamic safety check catches the other <b>class</b> <b>of</b> <b>errors</b> relative to programmers' simple annotations. In practice, programming with continuations greatly facilitates the implementation of Web dialogues. This dissertation explores two techniques for extending programming languages with Web interaction primitives based on continuations. The first technique relies on a custom Web server {{that acts as a}} high-level operating system for Scheme servlets. Managing both server and servlets in one process results in good performance and easy communication between servlets. The second technique relies on whole-program transformations often found in compilers for functional programming languages. This results in standard CGI programs that run on any We...|$|E
40|$|We {{provide a}} full {{characterization}} of computational error states for information systems. The <b>class</b> <b>of</b> <b>errors</b> considered is general enough to include human rational processes, logical reasoning, scientific progress and data processing in some functional programming languages. The {{aim is to}} reach a full taxonomy of error states by analysing the recovery and processing of data. We conclude by presenting machine-readable checking and resolve algorithms...|$|E
40|$|Abstract. We {{devised a}} {{reachability}} analysis that exploits code annotations and implemented it {{as a component}} of the extended static checker ESC/Java 2. The component reports unchecked code and a <b>class</b> <b>of</b> <b>errors</b> previously undetected. We applied the analysis to existing annotated code and uncovered errors that were unknown to the developers. We present the algorithm performing the analysis and discuss errors that it detects. ...|$|E
40|$|Summary. Programmers {{confront a}} {{minefield}} when they design interactive Web programs. Web interactions take place via Web browsers. Browsers permit consumers to whimsically navigate {{among the various}} stages of a dialog, leading to unexpected outcomes. Furthermore, the growing diversity of browsers means the number of interactive operations users can perform continues to grow. To investigate this programming problem, we develop a foundational model of Web interactions that reduces the panoply of browser-supported user interactions to three fundamental ones. We use the model to formally describe two <b>classes</b> <b>of</b> <b>errors</b> in Web programs. The descriptions suggest techniques for detecting both <b>classes</b> <b>of</b> <b>errors.</b> For one <b>class</b> we present an incrementally-checked record type system, which effectively eliminates these errors. For the other class, we introduce a dynamic safety check that employs program annotations to detect errors. ...|$|R
40|$|Programmers {{confront a}} {{minefield}} when they design interactive Web programs. Web interactions take place via Web browsers. With browsers, consumers can whimsically navigate {{among the various}} stages of a dialog and can thus confuse the most sophisticated corporate Web sites. In turn, Web services can fault in frustrating and inexplicable ways. The quickening transition from Web scripts to Web services lends these problems immediacy. To address this programming problem, we develop a foundational model of Web interactions {{and use it to}} formally describe two <b>classes</b> <b>of</b> <b>errors.</b> The model suggests techniques for detecting both <b>classes</b> <b>of</b> <b>errors.</b> For one <b>class</b> we present an incrementally checked record type system, which effectively eliminates these errors. For the other class, we introduce a dynamic safety check, which catches the mistakes relative to programmers’ simple annotations...|$|R
40|$|Turbo coding is a {{powerful}} <b>class</b> <b>of</b> <b>error</b> correcting codes, which can achieve performances close to the Shannon limit. The turbo principle {{can be applied to}} the problem of side-information source coding, and we investigate here its application to the reconciliation problem occuring in a continuous-variable quantum key distribution protocol. 1...|$|R
40|$|Abstract We {{provide a}} full {{characterization}} of computational error states for information systems. The <b>class</b> <b>of</b> <b>errors</b> considered is general enough to include human rational processes, logical reasoning, scientific progress and data processing in some functional programming languages. The {{aim is to}} reach a full taxonomy of error states by analysing the recovery and processing of data. We conclude by presenting machine-readable checking and resolve algorithms. ...|$|E
40|$|Abstract: Most {{programming}} languages contain constructs {{producing a}} computational effect {{as well as}} yielding a result. These effects include assigning to mutable variables, raising exceptions and performing input and output. The incorrect implementation and use of these effects introduce a <b>class</b> <b>of</b> <b>errors</b> such as failing to catch an exception or performing I/O to an inappropriate device. An effect system is an augmented type system which contains additional information about computational effects. These effect systems {{can be used to}} statically analyse a program. The results of this analysis may be used to ensure the absence of a <b>class</b> <b>of</b> <b>errors</b> related to a particular computational effect or to suggest code optimisations. In this project an effect system is designed, implemented and evaluated for a single computational effect, raising and handling exceptions. The framework of this system is used to create a system considering a different computational effect, allocating, assigning and dereferencing mutable variables. These two effect systems are then combined to produce a system which can analyse both classe...|$|E
30|$|The antifragile loves {{randomness}} and uncertainty, {{which also}} means—crucially—a love of errors, a certain <b>class</b> <b>of</b> <b>errors.</b> Antifragility has a singular property of {{allowing us to}} deal with the unknown, to do things without understanding them—and do them well. Let me be more aggressive: we are largely better at doing than we are at thinking, thanks to antifragility. I’d rather be dumb and antifragile than extremely smart and fragile, any time (Taleb 2012, pp. 21 – 22).|$|E
50|$|At {{the patch}} {{validation}} step, automatic bug-fixing techniques rely on eitherformal specifications or a test suite to validate generated candidatepatches. Formal specifications specify the correct {{behavior of a}} programand are often only available for specific <b>classes</b> <b>of</b> <b>errors</b> in practice.Therefore, standard generate-and-validate techniques typically rely on the availabilityof a test suite.|$|R
5000|$|Exception {{handling}} is also provided, allowing handlers to be coded {{for specific}} or <b>classes</b> <b>of</b> <b>errors</b> or statuses {{returned from the}} execution of an SQL statement. In addition, {{it is also possible}} to define a user condition and exception handler and for the program to signal its own, special-purpose exceptions.|$|R
5000|$|Memory {{corruption}} {{is one of}} the most intractable <b>class</b> <b>of</b> programming <b>errors,</b> for two reasons: ...|$|R
40|$|Mudflap is a pointer use {{checking}} technology {{based on}} compile-time instrumentation. It transparently adds protective code {{to a variety}} of potentially unsafe C/C++ constructs that detect actual erroneous uses at run time. The <b>class</b> <b>of</b> <b>errors</b> detected includes the most common and annoying types: NULL pointer dereferencing, running off the ends of buffers and strings, leaking memory. Mudflap has heuristics that allow some degree of checking even if only a subset of a program's object modules are instrumented...|$|E
40|$|Abstract. If a subexpression in a query {{will never}} {{contribute}} {{data to the}} query answer, this {{should be regarded as}} an error. This principle has been recently accepted into mainstream XML query languages, but was still waiting for a complete treatment. We provide here a precise definition for this <b>class</b> <b>of</b> <b>errors,</b> and define a type system that is sound and complete, in its search for such errors, for a core language, under mild restrictions on the use of recursion in type definitions. ...|$|E
40|$|We {{introduce}} a visual specification language for spreadsheets {{that allows the}} definition of spreadsheet templates. A spreadsheet generator can automatically create Excel spreadsheets from these templates together with customized update operations. It can be shown that spreadsheets created in this way are free from a large <b>class</b> <b>of</b> <b>errors,</b> such as reference, omission, and type errors. We present a formal definition of the visual language for templates and describe the process of generating spreadsheets from templates. In addition, we present an editor for templates and analyze the editor using the Cognitive Dimensions framework. ...|$|E
40|$|A new finite {{settling}} time (FST) control law is presented. The {{performance and the}} flexibility of this dual-rate, sampled-data law as applied to the <b>class</b> <b>of</b> <b>error</b> driven, feedback control systems are demonstrated. A hybrid analog/digital simulation is performed in order to illustrate the practical aspects {{of this type of}} finite {{settling time}} design...|$|R
40|$|Two full-mission {{simulation}} {{studies of}} surface operations conducted at NASA Ames Research Center revealed that, in low-visibility and night conditions, pilots committed navigation errors on 17 % of trials. A post-hoc analysis <b>of</b> these navigation <b>errors</b> uncovered three distinct <b>classes</b> <b>of</b> errors: Planning <b>Errors,</b> Decision Errors, and Execution Errors. Each class {{has a unique}} set of contributing factors, and therefore demands unique solutions to mitigate error. Results from the two full-mission simulations revealed that advanced navigation and communication technologies designed specifically to address each <b>class</b> <b>of</b> <b>error</b> can mitigate pilot deviations and increase surface operations safety...|$|R
40|$|We {{survey the}} {{asymptotic}} properties of regression Lp estimators under general <b>classes</b> <b>of</b> <b>error</b> distributions. It is {{found that the}} asymptotic distributions of Lp estimators depend crucially on p and the shape <b>of</b> the <b>error</b> distribution near the origin. A number of important features arise as a result, among which are (a) use of a small p may yield accelerated convergence rates for Lp estimators under certain <b>classes</b> <b>of</b> <b>error</b> distributions; (b) for p < 1, Lp regression should, under some circumstances, be undertaken by locally maximizing, rather than minimizing, {{the sum of the}} pth powers of the absolute deviations; and (c) consistent estimation of the sampling distributions of the Lp estimators can be achieved by the m out of n bootstrap in general. Numerical examples are provided to illustrate our theoretical findings, and a computational algorithm is suggested for local maximization as may sometimes be required by the Lp procedure. © 2005 American Statistical Association. link_to_subscribed_fulltex...|$|R
40|$|Abstract. Programming errors found early are the cheapest. Tools ap-plying to {{the early}} stage of code {{development}} exist but either they suffer from false positives (“noise”) or they require strong user interaction. We propose to avoid this deficiency by defining a new <b>class</b> <b>of</b> <b>errors.</b> A pro-gram fragment is doomed if its execution will inevitably fail, in whatever state it is started. We use a formal verification method to identify such er-rors fully automatically and, most significantly, without producing noise. We report on preliminary experiments with a prototype tool. ...|$|E
40|$|Activated sludge {{models are}} used {{extensively}} {{in the study of}} wastewater treatment processes. While various commercial implementations of these models are available, {{there are many people who}} need to code models themselves using the simulation packages available to them, Quality assurance of such models is difficult. While benchmarking problems have been developed and are available, the comparison of simulation data with that of commercial models leads only to the detection, not the isolation of errors. To identify the errors in the code is time-consuming. In this paper, we address the problem by developing a systematic and largely automated approach to the isolation of coding errors. There are three steps: firstly, possible errors are classified according to their place in the model structure and a feature matrix is established for each <b>class</b> <b>of</b> <b>errors.</b> Secondly, an observer is designed to generate residuals, such that each <b>class</b> <b>of</b> <b>errors</b> imposes a subspace, spanned by its feature matrix, on the residuals. Finally. localising the residuals in a subspace isolates coding errors. The algorithm proved capable of rapidly and reliably isolating a variety of single and simultaneous errors in a case study using the ASM 1 activated sludge model. In this paper a newly coded model was verified against a known implementation. The method is also applicable to simultaneous verification of any two independent implementations, hence is useful in commercial model development...|$|E
40|$|Well-specified {{programs}} enable code reuse {{and therefore}} techniques that help programmers to annotate code correctly are valuable. We devised an automated analysis that detects unreachable code {{in the presence}} of code annotations. We implemented it as an enhancement of the extended static checker ESC/Java 2 where it serves as a check of coherency of specifications and code. In this article we define notion of semantic unreachability, describe an algorithm for checking it and demonstrate on a case study that it detects a <b>class</b> <b>of</b> <b>errors</b> previously undetected, as well as describe different scenarios of these errors. Categories and Subject Descriptor...|$|E
40|$|The {{effects that}} certain <b>classes</b> <b>of</b> <b>errors</b> have on formal {{languages}} are considered {{from the point}} of view of preservation <b>of</b> languages under <b>error</b> transformations. This approach is an expansion of an article by Hartmanis and Stearnes [9], in which only the finite error case on regular expressions was considered. An automaton that detects that errors have occurred in an input from a given language is merely a recognizer of that language. However, an automaton that determines if errors in the input are bounded in some manner is a recognizer of a larger, errormodified language. It is these latter automata with which we are primarily concerned. An error on a symbol from an alphabet is considered in this paper to be the changing of that symbol to some other symbol from the same alphabet. Thus, errors as defined here are length-preserving substitution <b>errors.</b> We define <b>classes</b> <b>of</b> <b>error</b> transformations by the manner in which errors that occur on a string are bounded. Four <b>classes</b> <b>of</b> <b>error</b> transformations are considered. The first class allows errors up to a predetermined number. The second allows up to a predetermined number <b>of</b> <b>errors</b> per substring <b>of</b> given length. The third bounds the number <b>of</b> <b>errors</b> by a constant fraction of the number of symbols between each error and the start of the string. The fourth bounds the errors by a constant fraction of the length of the string. It is found that the first two classes (called “constant” errors) yield essentially equivalent effects on properties of the automata considered, and that the same is true for the latter two classes (called “expanding” errors). Hopcroft and Ullman in an independent, but earlier work [10] have demonstrated a number of the results shown in this paper. The major new results of this paper are:o 1. The detection <b>of</b> expanding <b>errors</b> in regular laguages is normally not possible by finite-state automata, but rather require automata called 1 -counters, which are less powerful than pushdown automata. The conditions under which regular languages are not preserved by expanding errors are shown. 2. The detection <b>of</b> expanding <b>errors</b> in context-free languages requires deterministic linear-bounded automata in general. 3. Left-context-sensitive languages are preserved under constant and the first <b>class</b> <b>of</b> expanding <b>errors,</b> but require linear-bounded automata for the second <b>class</b> <b>of</b> expanding <b>errors.</b> 4. Deterministic context-sensitive languages and recursive phrase-structure languages are preserved under both constant and expanding errors...|$|R
50|$|Inborn <b>errors</b> <b>of</b> purine-pyrimidine {{metabolism}} are a <b>class</b> <b>of</b> inborn <b>error</b> <b>of</b> metabolism disorders specifically affecting purine {{metabolism and}} pyrimidine metabolism. An example is Lesch-Nyhan syndrome.|$|R
40|$|A {{universal}} and fault tolerant scheme for quantum computation is proposed which utilizes a <b>class</b> <b>of</b> <b>error</b> correcting codes {{that is based}} on the detection of spontaneous emission (of, e. g., photons, phonons, and ripplons). The scheme is compatible with a number of promising solid-state and quantum-optical proposals for quantum computer implementations, such as quantum dots in cavities and electrons on helium...|$|R
