8|17|Public
5000|$|Program animation, {{permitting}} step-by-step {{execution and}} <b>conditional</b> <b>breakpoint</b> at source level or in machine code ...|$|E
5000|$|Easier {{to debug}} (e.g. setting {{breakpoints}} on code vs. a call table, if the debugger has no <b>conditional</b> <b>breakpoint</b> capability) ...|$|E
5000|$|The {{animator}} may, or may not, combine other test/debugging features {{within it}} such as program trace, dump, <b>conditional</b> <b>breakpoint</b> and memory alteration, program flow alteration, code coverage analysis, [...] "hot spot" [...] detection, loop detection or similar.|$|E
50|$|Xcode 2.1 {{could create}} {{universal}} binary files. It supported shared precompiled headers, unit testing targets, <b>conditional</b> <b>breakpoints,</b> and watchpoints. It also had better dependency analysis.|$|R
5000|$|... an {{instruction}} set simulator can implement unconditional or <b>conditional</b> <b>breakpoints,</b> by simply embedding the appropriate condition tests {{within its own}} normal program cycle - that also naturally allows non-invasive breakpoints (on read-only programs for instance).|$|R
50|$|In computing, binary {{translation}} (or (binary) recompilation) is the emulation of one {{instruction set}} by another through translation of binary code. Sequences of instructions are {{translated from the}} source to the target instruction set. In some cases such as instruction set simulation, the target instruction set may {{be the same as}} the source instruction set, providing testing and debugging features such as instruction trace, <b>conditional</b> <b>breakpoints</b> and hot spot detection.|$|R
50|$|Other {{kinds of}} {{conditions}} {{can also be}} used, such as the reading, writing, or modification of a specific location {{in an area of}} memory. This {{is often referred to as}} a <b>conditional</b> <b>breakpoint,</b> a data breakpoint, or a watchpoint.|$|E
50|$|Although Borland's Turbo Pascal (TP) had useful {{single-stepping}} and <b>conditional</b> <b>breakpoint</b> facilities, {{the need}} for a more powerful debugger became apparent when TP started to be used for serious development. Initially a separate company, Turbopower, produced a debugger, T-Debug, and also their Turbo Analyst and Overlay Manager for Turbo Pascal for TP versions 1-3. Turbopower released T-Debug Plus 4.0 for TP 4.0 in 1988, but by then Borland's Turbo Debugger had been announced.|$|E
40|$|We {{present a}} post-compiler program {{manipulation}} tool called Dyninst {{which provides a}} C++ class library for program instrumentation. Using this library, {{it is possible to}} instrument and modify application programs during execution. A unique feature of this library is that it permits machine-independent binary instrumentation programs to be written. We describe the interface that a tool sees when using this library. We also discuss three simple tools built using this interface: a utility to count the number of times a function is called, a program to capture the output of an already running program to a file, and an implementation of conditional break points. For the <b>conditional</b> <b>breakpoint</b> example, we show that by using our interface compared with gdb we are able to execute a program with conditional breakpoints up to 900 times faster. 1. Introduction The normal cycle of developing a program is to edit source code, compile it, and then execute the resulting binary. However, sometimes t [...] ...|$|E
5000|$|Standard {{as well as}} more {{advanced}} <b>breakpoint</b> features, including <b>conditional,</b> address, data <b>breakpoints.</b>|$|R
50|$|The IDE {{provided}} several debugging facilities, including single stepping, {{examination and}} changing of variables, and <b>conditional</b> <b>breakpoints.</b> In later versions assembly-language blocks could be stepped through. The user could add breakpoints on variables and registers in an IDE window. Programs using IBM PC graphics mode could flip between graphics and text mode automatically or manually, or display both on two screens. For {{cases where the}} relatively simple debugging facilities of the IDE were insufficient, Turbopower Software produced a more powerful debugger, T-Debug. The same company produced Turbo Analyst and Overlay Manager for Turbo Pascal. T-Debug was later updated for Turbo Pascal 4, but discontinued {{with the release of}} Borland's Turbo Debugger (TD), which also allowed some hardware intervention on computers equipped with the new 80386 processor.|$|R
40|$|Debuggers allow a user to halt {{a program}} and examine its state. The {{debugger}} stops execution when some user-specified condition is satisfied: Code breakpoints halt program execution when a particular instruction is executed. Data breakpoints halt program execution when a variable is referenced. Code breakpoints are supported directly in hardware on most machines and are fast. Data breakpoints, however, are notoriously slow. This note describe how data breakpoints {{can be made}} fast. 1 Introduction Debuggers provide commands that allow the programmer to halt a program and examine it's state. The most common command is a code breakpoint, which halts the program when execution reaches a certain instruction. Some debuggers also support <b>conditional</b> <b>breakpoints</b> which evaluate an expression whenever a certain instruction is reached and halt the program only if the expression evaluates to true [Kes 90]. Some debuggers provide data breakpoints, which halt the program whenever a variable is ref [...] ...|$|R
40|$|We have {{designed}} and implemented a fast breakpoint facility. Breakpoints are usually {{thought of as}} a feature of an interactive debugger, in which case the break-points need not be particularly fast. In our environment breakpoints are often used for non-interactive informa-tion gathering: for example, procedure call count and statement execution count profiling [Swinehart, et al. ]. When used non-interactively, breakpoints should be as fast as possible, so as to perturb the execution of the program as little as possible. Even in interactive debuggers, a <b>conditional</b> <b>breakpoint</b> facility would benefit from breakpoints that could transfer to the evaluation of the condition rapidly, and continue expeditiously if the condition were not satisfied. Such conditional breakpoints could be used to check assertions, etc. Program advising could also make use of fast breakpoints [Teitelman]. Examples of advising include tracing, timing, and even animation, all of which should be part of an advanced programming environment. We have ported the Cedar environment from a machine with microcode support for breakpoints [Lampson and Pier] to commercial platforms running C code [Atkinson, et al. ]. Most of our ports run under the Unix * operating system, so one choice for implementing breakpoints for Cedar was to use the breakpoint facility provided by that system. The breakpoints provided by the Unix operating system are several orders of magnitude too slow (and also several process switches too complicated) for the applications we have in mind. * Unix is a trademark of AT&T Bell Laboratories. Permission to copy without fee all or part of this material is granted provided that the copies are not made or distributed for direct corn-mercial advantage, the ACM copyright notice and the titie of the publication and its date appear, and notice is given that copying is by permission of the Association for Computing Machinery. To copy otherwise, or to republish, requires a fee and/or specific permission...|$|E
40|$|This paper {{discusses}} debugging and runtime {{analysis of}} software and outlines its enormous benefits to software developers and testers. A debugger is usually quite helpful in tracking down many logic problems. However, {{even with the}} most advanced debugger at your disposal, it doesn't guarantee {{that it will be}} a straightforward task to rid your program of bugs. Debugging techniques might help you in your task of flushing errors out of your program. Some of these willdirectly involve the debugger but many of them won't. The hope is to add to your debugging repertoire in order to assist your personal debugging quests when things go strangely wrong. Testing is more than just debugging. Testing is not only used to locate defects and correct them. It is also used in validation, verification process, andreliability measurement. Testing is expensive. Automation is a good way to cut down cost and time. When we write software applications, we need to debug them. Software Testing provides an objective, independent view of the software to allow the business to appreciate and understand the risks at implementation of the software. Aprimary purpose for testing is to detect software failures so that defects may be uncovered and corrected. This is a non-trivial pursuit. Testing cannot establish that a product functions properly under all conditions but can only establish that it does not function properly under specific conditions. Program testing and fault detection can beaided significantly by testing tools and debuggers. Testing and debug tools include features such as program monitors, permitting full or partial monitoring of program code including instruction set simulator, permitting complete instruction level monitoring and trace facilities, program animation, permitting step-by-step execution and <b>conditional</b> <b>breakpoint</b> at source level or in machine code, code coverage reports, formatted dump or symbolic debugging tools allowing inspection of program variables on error or at chosen points. Automated functional GUI testing tools are used to repeat system-level tests through the GUI, benchmarks, allowing run-time performance comparisons to be made, performance analysis that can help to highlight hot spots and resource usage. A runtime tool will allow you to examine the application internals after the run via the recorded runtime analysis data. Runtime analysis removes the guesswork from debugging. It helps to uncover Memory corruption detection, Memory leak detection etc. Runtime analysis is an effort aimed at understanding software component behavior by using datacollection during the execution of the component. Runtimeanalysis is a topic of great interest in Computer Science. A program can take seconds, hours or even years to finish executing, depending on various parameters...|$|E
40|$|Debugging {{concurrent}} {{programs is}} difficult because concurrent programs contain both sequential errors and additional concurrent errors. It is essential to have a symbolic debugger that truly understands concurrency to improve concurrent debugging capabilities and reduce debugging time. KDB {{was designed to be}} such a concurrent debugger, however it was far from complete. This thesis presents extensions to KDB's functionality, usability, and portability. Restricted <b>conditional</b> <b>breakpoints,</b> attachment of KDB to a running application, behavioural groups, programmatic interface, and improved user interface have been added to KDB to extend its functionality. KDB has been modified to understand ¯C++ programs better so that inserted code is hidden from users improving KDB's usability. Finally, KDB has been ported to the i 486 architecture on the Linux OS, increasing portability. KDB is written in ¯C++ and is a concurrent application, so it was possible to test the extensions while debugging the [...] ...|$|R
40|$|Abstract—In {{debugging}} processes breakpoints are fre-quently used {{to inspect}} {{and understand the}} run-time pro-gram behavior. Although modern development environments provide convenient breakpoint utilities, it mostly requires considerable human effort to create useful breakpoints. Before setting a breakpoint or typing a breakpoint condition, developers usually {{have to make some}} judgements and hypotheses based on their observations and experiences. To reduce such kind of effort, we propose an approach to automatically generating breakpoints for debugging. We combine the nearest neighbor queries method, dynamic program slicing, and memory graph comparison to identify suspicious program statements and states. Based on this information, breakpoints are generated and divided into two groups, where the primary group contains <b>conditional</b> <b>breakpoints</b> and the secondary group contains unconditional ones. We implement the presented approach on top of the Eclipse JDT platform. Our objective experiments and user study indicate that the generated breakpoints can be effective in aiding debugging work. Index Terms—software debugging, breakpoint generation I...|$|R
40|$|In this paper, {{we present}} a {{semi-automatic}} approach for mining a large-scale dataset of IDE interactions to extract usage smells, i. e., inefficient IDE usage patterns exhibited by developers in the field. The approach outlined in this paper first mines frequent IDE usage patterns, filtered via a set of thresholds and by the authors, that are subsequently supported (or disputed) using a developer survey, in order to form usage smells. In contrast with conventional mining of IDE usage data, our approach identifies time-ordered sequences of developer actions that are exhibited by many developers in the field. This pattern mining workflow is resilient to the ample noise present in IDE datasets due to the mix of actions and events that these datasets typically contain. We identify usage patterns and smells {{that contribute to the}} understanding of the usability of Visual Studio for debugging, code search, and active file navigation, and, more broadly, to the understanding of developer behavior during these software development activities. Among our findings is the discovery that developers are reluctant to use <b>conditional</b> <b>breakpoints</b> when debugging, due to perceived IDE performance problems as well as due to the lack of error checking in specifying the conditional...|$|R
5000|$|Instruction Set Simulator This {{technique}} {{treats the}} compiled programs machine code as its input 'data' and fully simulates the host machine instructions, monitors the code for <b>conditional</b> or unconditional <b>breakpoints</b> or programmer requested [...] "single cycle" [...] animation requests between every step.|$|R
40|$|<b>Breakpoints,</b> watchpoints, and <b>conditional</b> {{variants}} of both are essential debugging primitives, but their natural implementations often degrade performance significantly. Slowdown arises because the debugger [...] -the tool implementing the breakpoint/watchpoint interface [...] -is implemented {{in a process}} separate from the debugged application. Since the debugger evaluates the watchpoint expressions and conditional predicates to determine whether to invoke the user, a debugging session typically requires many expensive applicationdebugger context switches, resulting in slowdowns of 40, 000 times or more in current commercial and open-source debuggers! In this paper, we present an effective and efficient implementation of (<b>conditional)</b> <b>breakpoints</b> and watchpoints that uses DISE to dynamically embed debugger logic into the running application. DISE (dynamic instruction stream editing) is a previously-proposed, programmable hardware facility for dynamically customizing applications by transforming the instruction stream as it is decoded. DISE embedding preserves the logical separation of application and debugger [...] - instructions are added dynamically and transparently, existing application code and data are not statically modified [...] - and has little startup cost. Cycle-level simulation on the SPEC 2000 integer benchmarks shows that the DISE approach eliminates all unnecessary context switching, typically limits debugging overhead to 25 % or less {{for a wide range}} of watchpoints, and outperforms alternative implementations...|$|R
40|$|Abstract—It is {{well known}} that designing, testing and debug-ging sensor {{networks}} are extremely hard. It is mainly due to limited resources and distributed natures of sensor networks. In a lab environment, it is difficult and tedious to try various network configurations and simulate various challenging environment factors. Thereafter, the sensor network community has longed for a good sensor network simulation tool allowing the philosophy of WYSIWYG: What You See Is What You Get. In this paper, we present the design and evaluation of a visualized network manipulation tool integrated with TOSSIM and TOSSIM Live, called SimX. The SimX includes the following features: (1) topology manipulation, which allows a simple mouse drag on the virtual network node to actually change the physical network topology and the link qualities; (2) timing control, which allows a user to control a simulation to run faster or slower, even to pause the simulation; (3) variable watch and <b>conditional</b> <b>breakpoints,</b> which allow a user to watch variable value changes of all network nodes concurrently and set conditional breakpoints; (4) sensor input control, which allows a user to simulate different sensor data inputs and sampling rates. Besides supporting those traditional evaluation criteria, such as throughput, energy ef-ficiency and delivery ratio, the SimX also supports a holistic evaluation methodology. The holistic evaluation methodology evaluates how well the holistic high-level spatial and temporal environmental changes have been recorded, not only those low-level engineering criteria. We also designed a XML-based sensor network visualization tool, which allows the user to illustrate any sensor network data, including data imported from TOSSIM and SimX...|$|R
40|$|Understanding how {{a program}} {{execution}} proceeds often helps debug the program. An execution {{can be seen}} as a succession of computation steps. Tracers give information about these steps and what occurs at each of them. The traceable steps are traditionally called breakpoints. An execution frequently produces several millions of breakpoint occurrences. Programmers can therefore not analyze by hand all the computation steps. Existing tracers often have <b>conditional</b> <b>breakpoints</b> to inspect only steps which satisfy certain conditions. Unfortunately, the conditions that can be specified do not meet all the needs. To palliate this problem, an execution trace {{can be seen as}} a relational database. Each breakpoint information is represented by a tuple and queries simply use the language of the database management system. The problem is then that the time to create the database is much too long. We have, therefore, proposed an improved framework for trace querying. The interrogation is processed in two distinct steps: firstly, the trace is filtered on the fly with respect to the basic conditions of the queries; secondly, the remaining part of the query is then processed. Our approach has two main advantages. Firstly, filtering is very efficient. Done on the fly, it creates very few new data structures, the trace does not even have to be stored at all. In this report, we describe how to implement trace query tools based on the above framework. We propose an architecture where a tracer driver, containing a very efficient trace filtering algorithm, is integrated in the tracer process. The implementation guidelines are based on our experience building four prototypes for different sorts of programming languages...|$|R
40|$|During {{debugging}} processes, breakpoints {{are frequently}} used to inspect and understand runtime behaviors of programs. Although most development environments oer convenient breakpoint facilities, {{the use of}} these environments usually requires considerable human eorts in order to generate use-ful breakpoints. Before setting breakpoints or typing break-point conditions, developers usually have to make some judge-ments and hypotheses {{on the basis of their}} observations and experience. To reduce this kind of eorts we present a tool, named BPGen, to automatically generate breakpoints for debugging. BPGen uses three well-known dynamic fault lo-calization techniques in tandem to identify suspicious pro-gram statements and states, through which both <b>conditional</b> and unconditional <b>breakpoints</b> are generated. BPGen is im-plemented as an Eclipse plugin for supplementing the exist-ing Eclipse JDT debugger...|$|R
40|$|Abstract. Program {{errors are}} hard to find because of the cause-effect gap between the time when an error occurs and the time when the error becomes {{apparent}} to the programmer. Although debugging techniques such as <b>conditional</b> and data <b>breakpoints</b> help to find error causes in simple cases, they fail to effectively bridge the cause-effect gap in many situations. Dynamic query-based debuggers offer programmers an effective tool that provides instant error alert by continuously checking inter-object relationships while the debugged program is running. To speed up dynamic query evaluation, our debugger (implemented in portable Java) uses a combination of program instrumentation, load-time code generation, query optimization, and incremental reevaluation. Experiments and a query cost model show that selection queries are efficient in most cases, while more costly join queries are practical when query evaluations are infrequent or query domains are small. 1...|$|R
40|$|Program {{errors are}} hard to find because of the cause-effect gap between the time when an error occurs and the time when the error becomes {{apparent}} to the programmer. Although debugging techniques such as <b>conditional</b> and data <b>breakpoints</b> help to find error causes in simple cases, they fail to effectively bridge the cause-effect gap in many situations. Dynamic query-based debuggers offer programmers an effective tool that provides instant error alert by continuously checking inter-object relationships while the debugged program is running. To speed up dynamic query evaluation, our debugger (implemented in portable Java) uses a combination of program instrumentation, load-time code generation, query optimization, and incremental reevaluation. Experiments and a query cost model show that selection queries are efficient in most cases, while more costly join queries are practical when query evaluations are infrequent or query domains are small. 1. Introduction Many program errors are har [...] ...|$|R
40|$|Program {{errors are}} hard to find because of the cause-effect gap between the time when an error occurs and the time when the error becomes {{apparent}} to the programmer. Although debugging techniques such as <b>conditional</b> and data <b>breakpoints</b> help to find error causes in simple cases, they fail to effectively bridge the cause-effect gap in many situations. Query-based debuggers offer programmers an effective tool that provides instant error alert by continuously checking inter-object relationships while the debugged program is running. To enable the query-based debugger in the middle of program execution in a portable way, we propose efficient Java class file instrumentation and discuss alternative techniques. Although the on-the-fly debugger has a higher overhead than a dynamic query-based debugger, it offers additional interactive power and flexibility while maintaining complete portability. To speed up dynamic query evaluation, our debugger implemented in portable Java uses a combination of program instrumentation, load-time code generation, query optimization, and incremental reevaluation. This paper discusses on-the-fly debugging and demonstrates the query-based debugger application for debugging Java gas tank applet as well as SPECjvm 98 suite applications. Comment: In M. Ducasse (ed), proceedings of the Fourth International Workshop on Automated Debugging (AADEBUG 2000), August 2000, Munich. cs. SE/ 0010035 14 pages, 6 figure...|$|R

