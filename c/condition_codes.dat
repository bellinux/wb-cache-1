49|810|Public
25|$|Arithmetic {{instructions}} alter <b>condition</b> <b>codes</b> {{only when}} desired.|$|E
25|$|Almost every ARM {{instruction}} has a conditional execution feature called predication, {{which is}} implemented with a 4-bit condition code selector (the predicate). To allow for unconditional execution, {{one of the}} four-bit codes causes the instruction to be always executed. Most other CPU architectures only have <b>condition</b> <b>codes</b> on branch instructions.|$|E
25|$|A 2009 {{study of}} California data {{found that the}} {{reported}} incidence of autism rose 7- to 8-fold from the early 1990s to 2007, and that changes in diagnostic criteria, inclusion of milder cases, and earlier age of diagnosis probably explain only a 4.25-fold increase; {{the study did not}} quantify the effects of wider awareness of autism, increased funding, and expanding treatment options resulting in parents' greater motivation to seek services. Another 2009 California study found that the reported increases are unlikely to be explained by changes in how qualifying <b>condition</b> <b>codes</b> for autism were recorded.|$|E
5000|$|Four <b>condition</b> <b>code</b> status flags: carry (C), {{even parity}} (P), zero (Z), and sign (S).|$|R
5000|$|... {{regulating}} {{compliance with}} the relevant legislation, licence <b>conditions,</b> <b>codes</b> of practice, standards, service guarantees and other safeguards ...|$|R
50|$|Some {{computer}} architectures have conditional instructions (such as ARM, {{but no longer}} for all instructions in 64-bit mode) or conditional load instructions (such as x86) which can in some cases make conditional branches unnecessary and avoid flushing the instruction pipeline. An instruction such as a 'compare' is used to set a <b>condition</b> <b>code,</b> and subsequent instructions include a test on that <b>condition</b> <b>code</b> {{to see whether they}} are obeyed or ignored.|$|R
25|$|The Alpha {{does not}} have <b>condition</b> <b>codes</b> for integer {{instructions}} to remove a potential bottleneck at the condition status register. Instructions resulting in an overflow, such as adding two numbers whose result does not fit in 64 bits, write the 32 or 64 least significant bits to the destination register. The carry is generated by performing an unsigned compare on the result with either operand {{to see if the}} result is smaller than either operand. If the test was true, the value one is written to the least significant bit of the destination register to indicate the condition.|$|E
2500|$|Branch: Bcc (where the [...] "cc" [...] {{specified}} one of 16 {{tests of}} the <b>condition</b> <b>codes</b> in the status register: equal, greater than, less-than, carry, and most combinations and logical inversions, available from the status register).|$|E
5000|$|Arithmetic {{instructions}} alter <b>condition</b> <b>codes</b> {{only when}} desired.|$|E
5000|$|The optimizer then {{eliminates}} common sub-expressions {{and unnecessary}} <b>condition</b> <b>code</b> operations and, potentially, applies other optimizations such as loop unrolling: ...|$|R
25|$|Mode {{register}} 'MD', {{a secondary}} <b>Condition</b> <b>Code</b> register which controls the operating mode. Only 4 bits of this register are defined.|$|R
5000|$|Contained {{within the}} PSW {{are the two}} bit <b>condition</b> <b>code,</b> {{representing}} zero, positive, negative, overflow, and similar flags of other architectures' status registers. Conditional branch instructions test this encoded as a four bit value, with each bit representing a test {{of one of the}} four <b>condition</b> <b>code</b> values, 23 + 22 + 21 + 20. (Since IBM uses big-endian bit numbering, mask value 8 selects code 0, mask value 4 selects code 1, mask value 2 selects code 2, and mask value 1 selects code 3.) ...|$|R
50|$|SCC and CCC {{respectively}} set {{and clear}} all four <b>condition</b> <b>codes.</b>|$|E
5000|$|Delivery <b>condition</b> <b>codes</b> {{are also}} {{relatively}} common, {{the most common}} being: ...|$|E
5000|$|The four <b>condition</b> <b>codes</b> in the {{processor}} status word (PSW) are ...|$|E
5000|$|... ld %r30,%esp // load from stack {{only once}} add %eax,%eax,%r30 add %ebx,%ebx,%r30 // reuse data loaded earlier ld %esi,%ebp sub.c %ecx,%ecx,5 // only this last <b>condition</b> <b>code</b> needed ...|$|R
50|$|Although the {{instruction}} LOAD register zero with register zero would appear meaningless, and was officially unsupported, it did set the <b>condition</b> <b>code</b> and was {{often used to}} determine the status of this register.|$|R
50|$|A status {{register}}, flag register, or <b>condition</b> <b>code</b> register is {{a collection}} of status flag bits for a processor. An example is the FLAGS register of the x86 architecture or flags in a program status word (PSW) register.|$|R
5000|$|Update the <b>condition</b> <b>codes</b> {{from the}} ALU status flags (negative, zero, overflow, and carry) ...|$|E
50|$|These include <b>condition</b> <b>codes</b> for {{original}} trains, for train paper, for restored trains, and for reproduction trains.|$|E
50|$|Most Branch {{instructions}} take conditional effect {{based on}} the state of the <b>condition</b> <b>codes</b> in the PSW. A Branch instruction was typically preceded by a two-operand CMP (compare) or BIT (bit test) or a one-operand TST (test) instruction. Arithmetic and logic instructions also set the <b>condition</b> <b>codes.</b> In contrast to Intel processors in the x86 architecture, MOV instructions set them too, so a Branch instruction could be used to branch depending on whether the value moved was zero or negative.|$|E
50|$|The {{first word}} is the opcode; {{the first part}} of the second word is the <b>condition</b> <b>code</b> field, the second part is the {{destination}} operand and the third part is the source operand. These instructions supported on the 990/12.|$|R
5000|$|It has a well-observed orbit {{with the}} lowest {{possible}} uncertainty - a <b>condition</b> <b>code</b> of 0 - and an observation arc that spans {{over a period of}} almost half a century, using precovery images on photographic plates from 1972.|$|R
30|$|Kok et al. [22] {{proposed}} improved general network <b>coding</b> <b>condition</b> (IGCC). However, IGCC includes five {{rules and}} rules vary under different scenarios, {{which is a}} bit complex for node to implement coding opportunity discovery procedure. Chen et al. [23] investigated the network <b>coding</b> <b>condition</b> for multi-flows. However, the <b>coding</b> <b>condition</b> is necessary, not sufficient, which means that decoding failure may occur according to the necessary <b>coding</b> <b>condition.</b>|$|R
5000|$|... ld %r30,%esp // load from stack, into {{temporary}} add.c %eax,%eax,%r30 // add to %eax, set <b>condition</b> <b>codes.</b> ld %r31,%esp add.c %ebx,%ebx,%r31 ld %esi,%ebp sub.c %ecx,%ecx,5 ...|$|E
50|$|Add, subtract, multiply, or {{divide the}} values of two registers, placing the result in a register, {{possibly}} setting one or more <b>condition</b> <b>codes</b> in a status register.|$|E
50|$|The {{instruction}} is usually {{used with the}} FCOMI instruction or the FCOM-FSTSW-SAHF idiom to set the relevant <b>condition</b> <b>codes</b> based on {{the result of a}} floating point comparison.|$|E
50|$|The R2000 {{could be}} booted either big-endian or little-endian. It had thirty-one 32-bit general purpose {{register}}s, but no <b>condition</b> <b>code</b> register (the designers {{considered it a}} potential bottleneck), a feature it shares with the AMD 29000 and the Alpha. Unlike other registers, the program counter is not directly accessible.|$|R
5000|$|... 8086 has a 16-bit flags register. Nine {{of these}} <b>condition</b> <b>code</b> flags are active, and {{indicate}} {{the current state}} of the processor: Carry flag (CF), Parity flag (PF), Auxiliary carry flag (AF), Zero flag (ZF), Sign flag (SF), Trap flag (TF), Interrupt flag (IF), Direction flag (DF), and Overflow flag (OF).|$|R
40|$|The Edinburgh Logical Framework (LF) {{extended}} to support side <b>condition</b> <b>code</b> (LFSC) is advocated {{as a foundation}} for a proof format for SMT. The flexibility of the framework is demonstrated by example encoded inference rules, notably propositional resolution. Preliminary empirical results obtained with a SAT solver producing proofs in LFSC format are presented. ...|$|R
5000|$|The PDP-10 {{architecture}} {{has a few}} instructions {{which are}} sensitive (alter or query the processor's mode) but not privileged. [...] These instructions save or restore the <b>condition</b> <b>codes</b> containing USER or IOT bits: ...|$|E
5000|$|Branch: Bcc (where the [...] "cc" [...] {{specified}} one of 16 {{tests of}} the <b>condition</b> <b>codes</b> in the status register: equal, greater than, less-than, carry, and most combinations and logical inversions, available from the status register).|$|E
50|$|RISC-V has no {{condition}} code register or carry bit. The designers believed that <b>condition</b> <b>codes</b> make fast CPUs more complex by forcing interactions between instructions in {{different stages of}} execution. This choice makes multiple-precision arithmetic more complex. Also, a few numerical tasks need more energy.|$|E
5000|$|Davidbowie orbits the Sun in {{the central}} main-belt at a {{distance}} of 2.5-3.0 AU once every 4 years and 7 months (1,665 days). The asteroid has a well-observed orbit with the lowest possible <b>condition</b> <b>code.</b> Its orbit has an eccentricity of 0.09 and an inclination of 3Â° with respect to the ecliptic[...]|$|R
5000|$|R-Rebuild through {{improving}} building <b>conditions</b> with <b>Code</b> Enforcement and Ordinance changes.|$|R
5000|$|A {{factoring}} applet {{that uses}} APR-CL on certain <b>conditions</b> (source <b>code</b> included) ...|$|R
