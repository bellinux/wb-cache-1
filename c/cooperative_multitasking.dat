95|1|Public
5|$|<b>Cooperative</b> <b>multitasking</b> {{made its}} Macintosh debut in March 1985 {{with a program}} called Switcher by Andy Hertzfeld, which allowed the user to launch {{multiple}} applications and switch between them. Many programs and features did not function correctly with Switcher. Also, Switcher did not display windows of other applications beside the selected one. It was not included with the operating system, but was available from Apple for purchase separately. Both System 5 and System 6 had a feature called MultiFinder instead, which was much more mature and widely used in System 6. MultiFinder could be enabled or disabled, with a reboot. If disabled, the Finder would quit when the user launched another application, thus freeing RAM for it. If enabled, the system behaved as in the nowadays familiar multitasking tradition, with the desktop and windows of other applications in the screen's background.|$|E
25|$|On many {{single user}} {{operating}} systems <b>cooperative</b> <b>multitasking</b> is perfectly adequate, as home computers generally run {{a small number}} of well tested programs. The AmigaOS is an exception, having preemptive multitasking from its very first version. Windows NT was the first version of Microsoft Windows which enforced preemptive multitasking, but it didn't reach the home user market until Windows XP (since Windows NT was targeted at professionals).|$|E
25|$|An early model which governed the {{allocation}} of time to programs was called <b>cooperative</b> <b>multitasking.</b> In this model, when control is passed to a program by the kernel, it may execute {{for as long as}} it wants before explicitly returning control to the kernel. This means that a malicious or malfunctioning program may not only prevent any other programs from using the CPU, but it can hang the entire system if it enters an infinite loop.|$|E
5000|$|One {{noteworthy}} {{feature of}} Dynamic C is its inclusion of language constructs to simplify multitasking. These constructs, the [...] statement and the [...] statement, implement {{a form of}} <b>cooperative</b> and preemptive <b>multitasking,</b> respectively. As an example, consider the following program which flashes two LEDs with different frequencies: ...|$|R
25|$|Mac OS is {{characterized}} by its monolithic system. From its original release through System 4, it ran only one application at a time. Even so, it was noted for its ease of use. Mac OS gained <b>cooperative</b> <b>multitasking</b> with System 5, which ran on the Macintosh SE and Macintosh II. It was criticized for its very limited memory management, lack of protected memory, no access controls, and susceptibility to conflicts among extensions that provide additional functionality such as networking or support for a particular device.|$|E
25|$|Another notable System 7 {{feature is}} {{built-in}} <b>cooperative</b> <b>multitasking.</b> In System Software 6, this function was optional through the MultiFinder. System 7 also introduced aliases, similar to symbolic links on Unix, shortcuts that {{were introduced in}} later versions of Microsoft Windows, and shadows in IBM OS/2. System extensions were enhanced by being moved to their own subfolder; a subfolder in the System Folder was also created for the control panels. In System 7.5, Apple includes the Extensions Manager, a previously third-party program which simplified the process of enabling and disabling extensions.|$|E
25|$|Mutual {{recursion}} {{can also}} implement a finite-state machine, with one function for each state, and single recursion in changing state; this requires tail call optimization {{if the number}} of state changes is large or unbounded. This {{can be used as a}} simple form of <b>cooperative</b> <b>multitasking.</b> A similar approach to multitasking is to instead use coroutines which call each other, where rather than terminating by calling another routine, one coroutine yields to another but does not terminate, and then resumes execution when it is yielded back to. This allows individual coroutines to hold state, without it needing to be passed by parameters or stored in shared variables.|$|E
25|$|With {{the return}} of Jobs, this {{rebranding}} to version 8 also allowed Apple to exploit a legal loophole to terminate third-party manufacturers' licenses to System 7 and effectively shut down the Macintosh clone market. Later, Mac OS 8.1 finally added the new filesystem and Mac OS 8.6 updated the nanokernel to handle limited support for preemptive tasks. Its interface is Multiprocessing Services 2.x and later, {{but there is no}} process separation and the system still uses <b>cooperative</b> <b>multitasking</b> between processes. Even a process that is Multiprocessing Services-aware still has a portion that runs in the Blue Box—a task that also runs all single-threaded programs and the only task that can run 68k code.|$|E
25|$|The early {{versions}} of Windows are {{often thought of}} as graphical shells, mostly because they ran on top of MS-DOS and use it for file system services. However, even the earliest Windows versions already assumed many typical operating system functions; notably, having their own executable file format and providing their own device drivers (timer, graphics, printer, mouse, keyboard and sound). Unlike MS-DOS, Windows allowed users to execute multiple graphical applications at the same time, through <b>cooperative</b> <b>multitasking.</b> Windows implemented an elaborate, segment-based, software virtual memory scheme, which allows it to run applications larger than available memory: code segments and resources are swapped in and thrown away when memory became scarce; data segments moved in memory when a given application had relinquished processor control.|$|E
25|$|A single-tasking {{system can}} only run one {{program at a}} time, while a multi-tasking {{operating}} system allows more than one program to be running in concurrency. This is achieved by time-sharing, dividing the available processor time between multiple processes that are each interrupted repeatedly in time slices by a task-scheduling subsystem of the operating system. Multi-tasking may be characterized in preemptive and co-operative types. In preemptive multitasking, the operating system slices the CPU time and dedicates a slot {{to each of the}} programs. Unix-like operating systems, e.g., Solaris, Linux, as well as AmigaOS support preemptive multitasking. <b>Cooperative</b> <b>multitasking</b> is achieved by relying on each process to provide time to the other processes in a defined manner. 16-bit versions of Microsoft Windows used cooperative multi-tasking. 32-bit versions of both Windows NT and Win9x, used preemptive multi-tasking.|$|E
25|$|Apple {{released}} the Macintosh Plus on January 10, 1986, {{for a price}} of US$2,600. It offered one megabyte of RAM, easily expandable to four megabytes {{by the use of}} socketed RAM boards. It also featured a SCSI parallel interface, allowing up to seven peripherals—such as hard drives and scanners—to be attached to the machine. Its floppy drive was increased to an 800kB capacity. The Mac Plus was an immediate success and remained in production, unchanged, until October 15, 1990; on sale for just over four years and ten months, it was the longest-lived Macintosh in Apple's history. In September 1986, Apple introduced the Macintosh Programmer's Workshop, or MPW, an application that allowed software developers to create software for Macintosh on Macintosh, rather than cross compiling from a Lisa. In August 1987, Apple unveiled HyperCard and MultiFinder, which added <b>cooperative</b> <b>multitasking</b> to the Macintosh. Apple began bundling both with every Macintosh.|$|E
500|$|Several NeXT {{executives}} replaced their Apple counterparts when Steve Jobs restructured the company's {{board of}} directors. Over {{the next five}} years the NeXTSTEP operating system was ported to the PowerPC architecture. At the same time, an Intel port and OpenStep Enterprise toolkit for Windows were both produced. The operating system was code named Rhapsody, while the toolkit for development on all platforms was called [...] "Yellow Box". For backwards compatibility Apple added the [...] "Blue Box" [...] to Rhapsody, allowing existing Mac applications to be run in a self-contained <b>cooperative</b> <b>multitasking</b> environment.|$|E
2500|$|The OS is single-user and employs <b>cooperative</b> <b>multitasking</b> (CMT). While {{most current}} desktop OSes use {{preemptive}} multitasking (PMT) and multithreading, [...] remains with a CMT system. By 2003, many users {{had called for}} the OS to migrate to PMT. The OS memory protection is not comprehensive.|$|E
2500|$|System Software 5 (also {{referred}} to as [...] "System 5") added MultiFinder, an extension which lets the system run several programs at once. The system uses a <b>cooperative</b> <b>multitasking</b> model, meaning that time {{was given to the}} background applications only when the running application yielded control. A change in system functions that applications were already calling to handle events makes many existing applications share time automatically. Users can also choose not to use MultiFinder, thereby sticking with using a single application at a time as in previous releases of the system software.|$|E
50|$|Early {{multitasking}} systems used {{applications that}} voluntarily ceded time to one another. This approach, which was eventually supported by many computer operating systems, is {{known today as}} <b>cooperative</b> <b>multitasking.</b> Although it is now rarely used in larger systems except for specific applications such as CICS or the JES2 subsystem, <b>cooperative</b> <b>multitasking</b> was once the scheduling scheme employed by Microsoft Windows (prior to Windows 95 and Windows NT) and Classic Mac OS (prior to Mac OS X) in order to enable multiple applications to be run simultaneously. Windows 9x also used <b>cooperative</b> <b>multitasking,</b> but only for 16-bit legacy applications, {{much the same way}} as pre-Leopard PowerPC versions of Mac OS X used it for Classic applications. The network operating system NetWare used <b>cooperative</b> <b>multitasking</b> up to NetWare 6.5. <b>Cooperative</b> <b>multitasking</b> is still used today on RISC OS systems.|$|E
5000|$|Although it {{is rarely}} used in modern larger systems except for {{specific}} {{applications such as}} CICS or the JES2 subsystem, <b>cooperative</b> <b>multitasking</b> was the primary scheduling scheme for 16-bit applications employed by Microsoft Windows before Windows 95 and Windows NT, and by the classic Mac OS. Windows 9x used non-preemptive multitasking for 16-bit legacy applications, as the PowerPC versions of Mac OS X prior to Leopard used it for classic applications. [...] NetWare, which is a network-oriented operating system, used <b>cooperative</b> <b>multitasking</b> up to NetWare 6.5. <b>Cooperative</b> <b>multitasking</b> is still used on RISC OS systems.|$|E
5000|$|Computer multitasking, {{including}} both <b>cooperative</b> <b>multitasking</b> and preemptive multitasking ...|$|E
5000|$|Stackless Python {{supports}} either {{preemptive multitasking}} or <b>cooperative</b> <b>multitasking</b> through microthreads (so-called tasklets).|$|E
5000|$|Call-with-current-continuation {{can also}} express other {{sophisticated}} primitives. For example, the following code performs <b>cooperative</b> <b>multitasking</b> using continuations: ...|$|E
50|$|Futures can be {{implemented}} in coroutines or generators, resulting in the same evaluation strategy (e.g., <b>cooperative</b> <b>multitasking</b> or lazy evaluation).|$|E
5000|$|The {{functions}} defined above {{allow for}} defining and executing threads through <b>cooperative</b> <b>multitasking,</b> i.e. threads that yield {{control to the}} next one in a queue: ...|$|E
50|$|Coroutines are a {{fine-grained}} concurrency primitive, {{which may}} be required to yield explicitly. They may enable specifying another function to take control. Coroutines that explicitly yield allow <b>cooperative</b> <b>multitasking.</b>|$|E
5000|$|NetWare is a {{computer}} network operating system developed by Novell, Inc. It initially used <b>cooperative</b> <b>multitasking</b> to run various services on a personal computer, using the IPX network protocol.|$|E
50|$|An {{active object}} {{framework}} is a callback-based form of multitasking for computer systems. Specifically, it {{is a form}} of <b>cooperative</b> <b>multitasking</b> and is an important feature of the Symbian operating system.|$|E
50|$|In case of <b>cooperative</b> <b>multitasking</b> {{a program}} is {{scheduled}} as one operating system process. When a cooperative thread enters {{the state of}} waiting for asynchronous input, another thread of the program may run.|$|E
50|$|Moreover, NetWare used a non-preemptive, or <b>cooperative,</b> <b>multitasking</b> model, {{meaning that}} an NLM was {{required}} to yield to the kernel regularly. An NLM executing an infinite loop, for example, could therefore not be stopped.|$|E
50|$|There are no locks. Tarantool uses Lua-style coroutines and {{asynchronous}} I/O. The {{result is}} that application programs or stored procedures must be written with <b>cooperative</b> <b>multitasking</b> in mind, rather than the more popular preemptive multitasking.|$|E
50|$|Lua {{implements}} a {{small set}} of advanced {{features such as}} first-class functions, garbage collection, closures, proper tail calls, coercion (automatic conversion between string and number values at run time), coroutines (<b>cooperative</b> <b>multitasking)</b> and dynamic module loading.|$|E
50|$|The term {{preemptive}} multitasking {{is used to}} distinguish a multitasking operating system, which permits preemption of tasks, from a <b>cooperative</b> <b>multitasking</b> system wherein processes or tasks must be explicitly programmed to yield {{when they do not}} need system resources.|$|E
50|$|This part of PowerDNS {{is single}} threaded, but is written {{as if it}} were multi-threaded, by the use of Boost and the MTasker library, which is a simple <b>cooperative</b> <b>multitasking</b> library. It is also {{available}} as a standalone package.|$|E
50|$|In Scheme, continuations {{can even}} move control from an outer context to an inner one if desired. This almost {{limitless}} {{control over what}} code is executed next makes complex control structures such as coroutines and <b>cooperative</b> <b>multitasking</b> relatively easy to write.|$|E
5000|$|A cyclic {{executive}} is {{an alternative}} to a real-time operating system. It {{is a form of}} <b>cooperative</b> <b>multitasking,</b> in which there is only one task. The sole task is typically realized as an infinite loop in main (...) , e.g. in C.|$|E
5000|$|Actor {{model of}} concurrency, for {{instance}} in video games. Each actor has its own procedures (this again logically separates the code), but they voluntarily give up control to central scheduler, which executes them sequentially (this {{is a form of}} <b>cooperative</b> <b>multitasking).</b>|$|E
50|$|The {{language}} includes features {{intended to}} help with programs that perform simple problem solving actions such as lists, dynamic memory allocation, data types, recursion, functions as arguments, generators, and <b>cooperative</b> <b>multitasking.</b> IPL invented the concept of list processing, albeit in an assembly-language style.|$|E
50|$|Arthur {{was not a}} {{multitasking}} operating system, but offered {{support for}} adding application-level <b>cooperative</b> <b>multitasking.</b> No other version of the operating system was released externally, but internally {{the development of the}} desktop and window management continued, {{with the addition of a}} <b>cooperative</b> <b>multitasking</b> system, invented by Neil Raine, which used the memory management hardware to swap-out one task, and bring in another between call-and-return from the WIMP-Poll call that applications were obliged to make to get messages under the desktop. This transformed it from a single-application-at-a-time system, to one that could operate a full multi-tasking desktop. This transformation took place at version 1.6 though it was not made public until released, with the name change from Arthur to RISC OS, as version 2.0.|$|E
50|$|The OS is single-user and employs <b>cooperative</b> <b>multitasking</b> (CMT). While {{most current}} desktop OSes use {{preemptive}} multitasking (PMT) and multithreading, RISC OS remains with a CMT system. By 2003, many users {{had called for}} the OS to migrate to PMT. The OS memory protection is not comprehensive.|$|E
