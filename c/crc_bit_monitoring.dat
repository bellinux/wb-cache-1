0|80|Public
50|$|G.706 {{standard}} {{defines the}} frame alignment, the cyclic redundancy check(CRC), multiframe alignment and <b>CRC</b> <b>bit</b> error <b>monitoring</b> procedures {{to be used}} by such equipment.|$|R
3000|$|... {{information}} bits including {{cyclic redundancy check}} (<b>CRC)</b> <b>bits</b> for error detection, is first encoded by a rate- [...]...|$|R
3000|$|... carried {{within the}} {{physical}} layer information packets. The {{price to pay}} is an increased overhead of Case-B with respect to Case-A due to the extra <b>CRC</b> <b>bits</b> appended.|$|R
3000|$|When {{dealing with}} the Variable CRC check {{approach}}, we can use an approach {{similar to the one}} {{we have seen in the}} Fixed CRC check, but now the number of <b>CRC</b> check <b>bits</b> used for each state s is variable. In fact, c(s) bits are required only if no <b>CRC</b> <b>bits</b> have been requested in the past states; hence, we can now define C [...]...|$|R
50|$|The {{encoding}} {{includes an}} eleven-bit {{cyclic redundancy check}} (CRC) to detect, but not correct, errors. Subtracting the 11 <b>CRC</b> <b>bits</b> from the 114-bit message leaves an information payload of 103 bits (the specification sets one of those bits to zero). Consequently, 27 of the 130 bits are devoted to error detection.|$|R
5000|$|BAM Contents 02: DOS Type ("H") 04-05: Disk ID 06: I/O byte (as the 1581) bit 7 set - Verify on bit 7 clear - Verify off bit 6 set - Check header <b>CRC</b> <b>bit</b> 6 clear - Don't check header CRC 08: Last {{available}} track # in partition ($19=#25) 20-FF: BAM for tracks 1-7 ...|$|R
5000|$|The CRC is {{computed}} {{using the}} polynomial [...] over all 24&times;193 = 4632 bits (framing and data) {{of the previous}} superframe, but with its <b>CRC</b> <b>bits</b> forced to 1 {{for the purpose of}} CRC computation. [...] The purpose of this small CRC is not to take any immediate action, but to keep statistics on the performance of the link.|$|R
40|$|Abstract—Cyclic {{redundancy}} check (<b>CRC)</b> <b>bits</b> that are conventionally used for error detection have recently {{found a new}} application in universal mobile telecommunications system standard for message length detection of variable-length message communications. It was anticipated that the <b>CRC</b> <b>bits,</b> when they are coworked with the inner convolutional code, {{can be used to}} detect the receiver—unaware of the message length—without much degradation in their error detection capability. This is unfortunately not true when the offset or difference between the wrong detected length and the true length is small. Two improvements, i. e., the DoCoMo’s reverse CRC method and the flip CRC method, were accordingly proposed. In this paper, we revisited the flip CRC modification by considering the impact of joint decoding of the CRC code and the convolutional code. By generalizing the condition for the selection of the flip polynomials, we found that under errorfre...|$|R
50|$|One {{southbound}} frame carries 98 payload <b>bits</b> and 22 <b>CRC</b> <b>bits.</b> Two payload bits are a frame type, and 24 bits are a command. The remaining 72 bits may {{be either}} (depending {{on the frame}} type), 72 bits of write data, two more 24-bit commands, or one more command plus 36 bits of data to be written to an AMB control register.|$|R
50|$|Zmax is {{designed}} to replace Zmodem. It uses 32 <b>bit</b> <b>CRC's</b> on file data blocks, the same as Zmodem, and 32 <b>bit</b> <b>CRC's</b> on its information blocks where Zmodem uses 16 bit.|$|R
30|$|The cyclic {{redundancy}} check (<b>CRC)</b> parity <b>bits</b> obtained for the PDCCH payload are scrambled with the SPS C-RNTI.|$|R
3000|$|At the PL, cyclic {{redundancy}} check (<b>CRC)</b> <b>bits</b> are added to each AL frame to detect any RCPC decoding errors. We use the industry-standard CRC- 8 defined by the polynomial 1 +x 2 +x 4 +x 6 +x 7 +x 8 [38]. Next, each AL frame is encoded using a UEP/EEP RCPC code. As mentioned earlier, we employ an RCPC code designed in [14] with the mother code rate of [...]...|$|R
3000|$|Fixed CRC check: {{request a}} fixed amount of <b>CRC</b> check <b>bits</b> to check the result (analysis in Section 3.1) [...]...|$|R
30|$|Since the {{reliability}} of the decoded sequence varies greatly with respect to the state s in which the decoder is, we can employ the knowledge of state s of the decoder (known at the encoder by means of the feedback) to use extra bits to perform the checking, i.e. we perform a strong check (requiring more bits) if t(s) is low but a weaker check, or even no check, (requiring fewer or no bits) if t(s) is high enough. We can perform the check using more syndromes or <b>CRC</b> <b>bits.</b>|$|R
5000|$|Some {{manufacturers}} and organizations [...] added additional {{information to the}} basic SSI protocol. It was done mainly to ensure proper data transmission. For secure transmission and to indicate the end of data transmission <b>CRC</b> <b>bits</b> or parity bits can be added. In simple words, they were used for identifying if the byte has been correctly interpreted and received. In the original specification multiple transmissions were used to ensure data integrity. In this case, two consecutive transmissions of the same data were initiated and compared for any error in transmission. But this however reduces the protocol efficiency by 50% compared to parallel data transmission.|$|R
5000|$|... 1 bit => Start {{of frame}} 11 bits => Identifier 1 bit => RTR bit 6 bits => Control field 0-8 bytes => Data field 15 <b>bits</b> => <b>CRC</b> {{sequence}} 1 <b>bit</b> => <b>CRC</b> delimiter 1 <b>bit</b> => Acknowledge 1 bit => Ack delimiter 7 bits => End of frame >2 bits => Interframe space ...|$|R
5000|$|Messages carry a 24 <b>bit</b> <b>CRC,</b> {{against which}} {{integrity}} can be checked.|$|R
3000|$|Variable CRC check: {{request a}} {{variable}} amount of <b>CRC</b> check <b>bits</b> {{to check the}} result; {{the strength of the}} CRC check is matched with the reliability of the decoded result (analysis is in the Appendix) [...]...|$|R
25|$|All {{single bit}} errors within the bitfilter period {{mentioned}} above (for even {{terms in the}} generator polynomial) can be identified uniquely by their residual. So CRC method {{can be used to}} correct single-bit errors as well (within those limits, e.g. 32767 bits with optimal generator polynomials of degree 16). Since all odd errors leave an odd residual, all even an even residual, 1-bit errors and 2-bit errors can be distinguished. However, like other SECDED techniques, CRCs cannot always distinguish between 1-bit errors and 3-bit errors. When 3 or more bit errors occur in a block, <b>CRC</b> <b>bit</b> error correction will be erroneous itself and produce more errors.|$|R
5000|$|DSP and AES256 {{accelerator}} with 128 , 192 and 256 bit AES and 32 <b>bit</b> <b>CRC</b> ...|$|R
30|$|The CU generates {{different}} command sequences {{for either}} of these modules. In card read sequence, the CRM reads the data block from the card along with the <b>CRC</b> <b>bits</b> and publish it to the I/O interfacing unit. In card write sequence, the CWM receives the data block as an input from the I/O interfacing unit and writes the received block along with CRC to the card and receives the CRC response from the card. After read/write operation, CRM/CWM issues a DONE signal and itself goes to the power saving mode. Finally after completion of entire data transfer, controller generates the ACK signal to the external world through the I/O interfacing unit to intimate that the work is successfully completed.|$|R
5000|$|The {{design of}} the CRC {{polynomial}} depends on the maximum total length of the block to be protected (data + <b>CRC</b> <b>bits),</b> the desired error protection features, {{and the type of}} resources for implementing the CRC, as well as the desired performance. A common misconception is that the [...] "best" [...] CRC polynomials are derived from either irreducible polynomials or irreducible polynomials times the factor 1 + x, which adds to the code the ability to detect all errors affecting an odd number of bits. In reality, all the factors described above should enter into the selection of the polynomial and may lead to a reducible polynomial. However, choosing a reducible polynomial will result in a certain proportion of missed errors, due to the quotient ring having zero divisors.|$|R
40|$|This paper {{presents}} a variable-length decision-feedback scheme that uses tail-biting convolutional codes and the tail-biting Reliability-Output Viterbi Algoritm (ROVA). Comparing with recent results in finite-blocklength information theory, simulation results {{for both the}} BSC and the AWGN channel show that the decision-feedback scheme using ROVA can surpass the random-coding lower bound on throughput for feedback codes at average blocklengths less than 100 symbols. This paper explores ROVA-based decision feedback both with decoding after every symbol and with decoding limited to {{a small number of}} increments. The performance of the reliability-based stopping rule with the ROVA is compared to retransmission decisions based on CRCs. For short blocklengths where the latency overhead of the <b>CRC</b> <b>bits</b> is severe, the ROVA-based approach delivers superior rates. Comment: Accepted for publication to IEEE Transactions on Communications. 15 single-spaced, double-column pages; 8 figures; 3 table...|$|R
30|$|In this design, the Nordic {{transceiver}} was configured in auto acknowledgement mode. In auto acknowledge mode, {{after receiving}} a data packet, the receiver checks the <b>CRC</b> <b>bits</b> and detects whether there was any error during the transmission of the packet. If there was any error, then it requests the transmitter to resend the data packet again. This process goes on until the packet is transmitted successfully. So, in auto acknowledgement mode, no data loss happens, though the number of retries will decrease the overall data rate or application throughput. If the receiver is unable to detect error using CRC, then depending upon which bits get corrupted, the reconstructed image will have different distortions. The image compression algorithm [32, 33] used here is line-based differential coding (i.e., works row-by-row in raster scan fashion). In some cases, one row (or part of a row) of the image pixels may get corrupted if undetectable errors occurs in data packets. In worst case, the entire image frame may get corrupted.|$|R
50|$|Data words {{consist of}} two start bits, 8 to 24 data bits {{and a single}} parity bit or {{optional}} three <b>bit</b> <b>CRC</b> (cyclic redundancy check). The bitrate is 125 kbit/s or optionally 189 kbit/s.|$|R
50|$|In Non-Stream mode (which {{can be set}} by the {{receiver}} or the sender), Zmax is a super Batch Xmodem or Ymodem depending on the block size, because it uses 32 <b>bit</b> <b>CRCs</b> instead of 16.|$|R
5000|$|To compute an n-bit binary <b>CRC,</b> {{line the}} <b>bits</b> {{representing}} the input in a row, and position the (n + 1)-bit pattern representing the CRC's divisor (called a [...] "polynomial") underneath the left-hand {{end of the}} row.|$|R
50|$|A related {{technique}} was patented in 1984. That technique uses the CRC {{to find the}} start of 50 bit frames composed of a 36 bit data payload, a 13 <b>bit</b> <b>CRC,</b> and a single 1 bit start-of-frame indicator.|$|R
5000|$|B1: <b>Bit</b> Error <b>Monitoring.</b> The B1 Byte {{contains}} {{the result of}} the parity check of the previous STM frame, after scrambling of the actual STM frame. This check is carried out with a Bit Interleaved Parity check (BIP-8).|$|R
5000|$|... "Alright...{{everything}} up here...please. And a <b>bit</b> more <b>monitor</b> if ya got it."noise"Ah?"kettle drum Ritchie Blackmore can faintly {{be heard}} saying,"You want everything louder than everything else?" [...] then Gillan saying,"Yeah, can I have everything louder than everything else...alright...ha ha" ...|$|R
30|$|Card write module (CWM): The CWM {{has been}} {{designed}} to write the data block to the SDHC card. The right branch of the flow chart in Fig. 15 describes the write operation. On the way of execution, CU transfers the control to CWM along with the DTM signal to ensure a single block data write or a multiblock data write. In this implementation, both single and multiblock write operation have been taken into consideration. For single block write operation, the controller generates the command with the starting address and then it starts writing 512 bytes of data. For multiblock write, the controller writes the data block until the CMD 12 stop command is being issued. The <b>CRC</b> <b>bits</b> are appended to each data byte for the entire write operation. The card sends back the response pattern in the MISO line of the controller, where “XXX 00101 ” means the data block is accepted, “XXX 01011 ” means the data block is rejected due to the CRC error, and “XXX 01111 ” indicates that the data block is rejected due to the flash program error (in the pattern, “XXX” means do not care bits). The multiple block write improves the throughput as a single command is generated for bulk of data blocks write procedure.|$|R
5000|$|B2 : <b>Bit</b> Error <b>Monitoring.</b> The B2 Bytes {{contains}} {{the result of}} the parity check of the previous STM frame, except the RSOH, before scrambling of the actual STM frame. This check is carried out with a Bit Interleaved Parity check (BIP24) ...|$|R
40|$|International audienceWe {{experimentally}} demonstrate an all-optical <b>bit</b> error <b>monitoring</b> scheme {{based on}} the self-phase modulation occurring during the propagation in a highly nonlinear fiber followed by an optical bandpass filter. Numerical simulations are confirmed by experimental observations performed at a repetition rate of 40 Gb/s...|$|R
40|$|International audienceThis chapter {{presents}} {{a study on}} fault detection mechanisms involved in secure devices {{in order to prevent}} faults-based attacks. We explore the solutions based on the use of error detection codes (parity <b>bits,</b> <b>CRC)</b> and we discuss the strengths and the weaknesses of these solutions with regards to error and fault detection...|$|R
40|$|Based on the foreboding {{information}} {{monitoring of}} the energy released in the developing process of rock burst, prediction system for rock burst can be established. By using microseismic method, electromagnetic radiation method, and drilling bits method, rock burst in Yangcheng Mine was monitored, and a system of multi-index monitoring and evaluation on rock burst was established. Microseismic monitoring and electromagnetic radiation monitoring were early warning method, and drilling <b>bits</b> <b>monitoring</b> was burst region identification method. There were three identifying indexes: silence period in microseismic monitoring, rising period of the intensity, and rising period of pulse count in electromagnetic radiation monitoring. If there is identified burst risk in the workface, drilling bits method was used to ascertain the burst region, and then pressure releasing methods were carried out to eliminate the disaster...|$|R
40|$|We {{propose a}} <b>bit</b> pattern <b>monitoring</b> {{technique}} which effectively mitigates the random walk clock drift between data signal and sampling source in asynchronously undersampling systems. The method is verified by measurements of 40 Gb/s NRZ and 160 Gb/s RZ data signals. Quantitative {{analysis of the}} displayed timing jitter is performed...|$|R
