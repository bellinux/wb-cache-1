63|796|Public
25|$|Mode {{register}} 'MD', {{a secondary}} <b>Condition</b> <b>Code</b> register which controls the operating mode. Only 4 bits of this register are defined.|$|E
25|$|Almost every ARM {{instruction}} has a conditional execution feature called predication, {{which is}} implemented with a 4-bit <b>condition</b> <b>code</b> selector (the predicate). To allow for unconditional execution, {{one of the}} four-bit codes causes the instruction to be always executed. Most other CPU architectures only have condition codes on branch instructions.|$|E
25|$|MIPS IV added several {{features}} to improve instruction-level parallelism. To alleviate the bottleneck {{caused by a}} single condition bit, seven <b>condition</b> <b>code</b> bits {{were added to the}} floating-point control and status register, bringing the total to eight. FP comparison and branch instructions were redefined so they could specify which condition bit was written or read (respectively); and the delay slot in between an FP branch that read the condition bit written to by a prior FP comparison was removed. Support for partial predication was added in the form of conditional move instructions for both GPRs and FPRs; and an implementation could choose between having precise or imprecise exceptions for IEEE 754 traps.|$|E
25|$|Arithmetic {{instructions}} alter <b>condition</b> <b>codes</b> {{only when}} desired.|$|R
50|$|SCC and CCC {{respectively}} set {{and clear}} all four <b>condition</b> <b>codes.</b>|$|R
5000|$|Delivery <b>condition</b> <b>codes</b> {{are also}} {{relatively}} common, {{the most common}} being: ...|$|R
5000|$|Four <b>condition</b> <b>code</b> status flags: carry (C), {{even parity}} (P), zero (Z), and sign (S).|$|E
50|$|Some {{computer}} architectures have conditional instructions (such as ARM, {{but no longer}} for all instructions in 64-bit mode) or conditional load instructions (such as x86) which can in some cases make conditional branches unnecessary and avoid flushing the instruction pipeline. An instruction such as a 'compare' is used to set a <b>condition</b> <b>code,</b> and subsequent instructions include a test on that <b>condition</b> <b>code</b> {{to see whether they}} are obeyed or ignored.|$|E
5000|$|The optimizer then {{eliminates}} common sub-expressions {{and unnecessary}} <b>condition</b> <b>code</b> operations and, potentially, applies other optimizations such as loop unrolling: ...|$|E
5000|$|The four <b>condition</b> <b>codes</b> in the {{processor}} status word (PSW) are ...|$|R
5000|$|Update the <b>condition</b> <b>codes</b> {{from the}} ALU status flags (negative, zero, overflow, and carry) ...|$|R
50|$|These include <b>condition</b> <b>codes</b> for {{original}} trains, for train paper, for restored trains, and for reproduction trains.|$|R
50|$|Mode {{register}} 'MD', {{a secondary}} <b>Condition</b> <b>Code</b> register which controls the operating mode. Only 4 bits of this register are defined.|$|E
5000|$|Contained {{within the}} PSW {{are the two}} bit <b>condition</b> <b>code,</b> {{representing}} zero, positive, negative, overflow, and similar flags of other architectures' status registers. Conditional branch instructions test this encoded as a four bit value, with each bit representing a test {{of one of the}} four <b>condition</b> <b>code</b> values, 23 + 22 + 21 + 20. (Since IBM uses big-endian bit numbering, mask value 8 selects code 0, mask value 4 selects code 1, mask value 2 selects code 2, and mask value 1 selects code 3.) ...|$|E
5000|$|... ld %r30,%esp // load from stack {{only once}} add %eax,%eax,%r30 add %ebx,%ebx,%r30 // reuse data loaded earlier ld %esi,%ebp sub.c %ecx,%ecx,5 // only this last <b>condition</b> <b>code</b> needed ...|$|E
5000|$|... {{regulating}} {{compliance with}} the relevant legislation, licence <b>conditions,</b> <b>codes</b> of practice, standards, service guarantees and other safeguards ...|$|R
50|$|Most Branch {{instructions}} take conditional effect {{based on}} the state of the <b>condition</b> <b>codes</b> in the PSW. A Branch instruction was typically preceded by a two-operand CMP (compare) or BIT (bit test) or a one-operand TST (test) instruction. Arithmetic and logic instructions also set the <b>condition</b> <b>codes.</b> In contrast to Intel processors in the x86 architecture, MOV instructions set them too, so a Branch instruction could be used to branch depending on whether the value moved was zero or negative.|$|R
40|$|Traditional {{compiler}} {{data flow}} analysis techniques {{are used to}} transform the intermediate representation of a decompiled program to a higher representation that eliminates low-level concepts such as registers and <b>condition</b> <b>codes,</b> and reintroduces the high-level concept of expression. Summary data flow information is collected on <b>condition</b> <b>codes</b> and registers, and is propagated across basic blocks and subroutine boundaries to find boolean and arithmetic expressions, register arguments, function return registers, actual arguments, and propagate data types whenever required. The elimination of <b>condition</b> <b>codes</b> is performed by an extension of a reach algorithm. The elimination of registers and intermediate instructions is performed by an extended copy propagation algorithm {{that is based on}} intra and interprocedural analysis of the program's control flow graph. The methods presented in this paper have been implemented in dcc, a prototype decompiler for the Intel i 80286 architecture. Experi [...] ...|$|R
50|$|Although the {{instruction}} LOAD register zero with register zero would appear meaningless, and was officially unsupported, it did set the <b>condition</b> <b>code</b> and was {{often used to}} determine the status of this register.|$|E
50|$|A status {{register}}, flag register, or <b>condition</b> <b>code</b> register is {{a collection}} of status flag bits for a processor. An example is the FLAGS register of the x86 architecture or flags in a program status word (PSW) register.|$|E
50|$|The {{first word}} is the opcode; {{the first part}} of the second word is the <b>condition</b> <b>code</b> field, the second part is the {{destination}} operand and the third part is the source operand. These instructions supported on the 990/12.|$|E
5000|$|... ld %r30,%esp // load from stack, into {{temporary}} add.c %eax,%eax,%r30 // add to %eax, set <b>condition</b> <b>codes.</b> ld %r31,%esp add.c %ebx,%ebx,%r31 ld %esi,%ebp sub.c %ecx,%ecx,5 ...|$|R
50|$|Add, subtract, multiply, or {{divide the}} values of two registers, placing the result in a register, {{possibly}} setting one or more <b>condition</b> <b>codes</b> in a status register.|$|R
50|$|The {{instruction}} is usually {{used with the}} FCOMI instruction or the FCOM-FSTSW-SAHF idiom to set the relevant <b>condition</b> <b>codes</b> based on {{the result of a}} floating point comparison.|$|R
5000|$|It has a well-observed orbit {{with the}} lowest {{possible}} uncertainty - a <b>condition</b> <b>code</b> of 0 - and an observation arc that spans {{over a period of}} almost half a century, using precovery images on photographic plates from 1972.|$|E
50|$|RISC-V has no <b>condition</b> <b>code</b> {{register}} or carry bit. The designers {{believed that}} condition codes make fast CPUs more complex by forcing interactions between instructions in {{different stages of}} execution. This choice makes multiple-precision arithmetic more complex. Also, a few numerical tasks need more energy.|$|E
50|$|The R2000 {{could be}} booted either big-endian or little-endian. It had thirty-one 32-bit general purpose {{register}}s, but no <b>condition</b> <b>code</b> register (the designers {{considered it a}} potential bottleneck), a feature it shares with the AMD 29000 and the Alpha. Unlike other registers, the program counter is not directly accessible.|$|E
5000|$|The PDP-10 {{architecture}} {{has a few}} instructions {{which are}} sensitive (alter or query the processor's mode) but not privileged. [...] These instructions save or restore the <b>condition</b> <b>codes</b> containing USER or IOT bits: ...|$|R
40|$|An {{implementation}} of a system level interpreter of the SPARC V 8 instruction set architecture is described. The goal is that the simulator, SimICS, should be sufficiently accurate to run an operating system {{on top of the}} simulator. The simulation is performed by direct threaded interpretation of an intermediate <b>code.</b> Simulation of <b>condition</b> <b>codes</b> is performed quickly and can handle all combinations of <b>condition</b> <b>codes.</b> The <b>condition</b> <b>codes</b> are evaluated lazily and unnecessary computations are avoided. Access to registers in a register window is as efficient as in a flat register file. To optimize instructions specialized variants are identified that can be executed faster. SimICS is tested using a comprehensive test suite. The suite exercises the instruction set using interesting combinations of input parameters and operands and compares the result to a reference implementation. A validation of the results is performed with SPEC benchmarks. The result is a stable and correct system level interpreter of SPARC Architecture Version 8 that runs 15 times slower than the real hardware. ...|$|R
2500|$|Branch: Bcc (where the [...] "cc" [...] {{specified}} one of 16 {{tests of}} the <b>condition</b> <b>codes</b> in the status register: equal, greater than, less-than, carry, and most combinations and logical inversions, available from the status register).|$|R
50|$|Almost every ARM {{instruction}} has a conditional execution feature called predication, {{which is}} implemented with a 4-bit <b>condition</b> <b>code</b> selector (the predicate). To allow for unconditional execution, {{one of the}} four-bit codes causes the instruction to be always executed. Most other CPU architectures only have condition codes on branch instructions.|$|E
5000|$|... 8086 has a 16-bit flags register. Nine {{of these}} <b>condition</b> <b>code</b> flags are active, and {{indicate}} {{the current state}} of the processor: Carry flag (CF), Parity flag (PF), Auxiliary carry flag (AF), Zero flag (ZF), Sign flag (SF), Trap flag (TF), Interrupt flag (IF), Direction flag (DF), and Overflow flag (OF).|$|E
5000|$|Davidbowie orbits the Sun in {{the central}} main-belt at a {{distance}} of 2.5-3.0 AU once every 4 years and 7 months (1,665 days). The asteroid has a well-observed orbit with the lowest possible <b>condition</b> <b>code.</b> Its orbit has an eccentricity of 0.09 and an inclination of 3Â° with respect to the ecliptic[...]|$|E
30|$|Kok et al. [22] {{proposed}} improved general network <b>coding</b> <b>condition</b> (IGCC). However, IGCC includes five {{rules and}} rules vary under different scenarios, {{which is a}} bit complex for node to implement coding opportunity discovery procedure. Chen et al. [23] investigated the network <b>coding</b> <b>condition</b> for multi-flows. However, the <b>coding</b> <b>condition</b> is necessary, not sufficient, which means that decoding failure may occur according to the necessary <b>coding</b> <b>condition.</b>|$|R
50|$|The {{meaning of}} various flag bits (such as S=1 enables setting the <b>condition</b> <b>codes)</b> is {{identical}} to the ARM instruction set. The load/store multiple instruction can only access half of the register set, depending on the H bit. If H=0, the 16 bits indicate R0-R15; if H=1, R16-R31.|$|R
40|$|Symmetric fix-free <b>codes</b> are prefix <b>condition</b> <b>codes</b> {{in which}} each {{codeword}} is required to be a palindrome. Their study is motivated by the topic of joint source-channel coding. Although they have been considered by a few communities they are not well understood. In earlier work we used a collection of instances of Boolean satisfiability problems as a tool in the generation of all optimal binary symmetric fix-free codes with n codewords and observed {{that the number of}} different optimal codelength sequences grows slowly compared with the corresponding number for prefix <b>condition</b> <b>codes.</b> We demonstrate that all optimal symmetric fix-free codes can alternatively be obtained by sequences of codes generated by simple manipulations starting from one particular code. We also discuss simplifications in the process of searching for this set of codes...|$|R
