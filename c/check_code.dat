125|1565|Public
25|$|Credit cards have {{a printed}} or {{embossed}} bank card number {{complying with the}} ISO/IEC 7812 numbering standard. The card number's prefix, called the Bank Identification Number, is the sequence of digits {{at the beginning of}} the number that determine the bank to which a credit card number belongs. This is the first six digits for MasterCard and Visa cards. The next nine digits are the individual account number, and the final digit is a validity <b>check</b> <b>code.</b>|$|E
50|$|A {{fixed rate}} erasure code, usually {{with a fairly}} high rate, is applied as a 'pre-code' or 'outer code'. This pre-code may itself be a {{concatenation}} of multiple codes, for example in the code standardized by 3GPP a high density parity <b>check</b> <b>code</b> derived from the binary Gray sequence is concatenated with a simple regular low density parity <b>check</b> <b>code.</b> Another possibility would be a concatenation of a Hamming code with a low density parity <b>check</b> <b>code.</b>|$|E
5000|$|While {{there exist}} many {{software}} tools {{that claim to}} <b>check</b> <b>code</b> for [...] "MISRA conformance", there is no MISRA certification process.|$|E
40|$|International audienceWe {{investigate}} {{the use of}} Low Rank Parity <b>Check</b> <b>Codes,</b> originally designed for cryptography applications {{in the context of}} Power Line Communication. Particularly, we propose a new code design and an efficient probabilistic decoding algorithm. The main idea of decoding Low Rank Parity <b>Check</b> <b>Codes</b> is based on calculations of vector spaces over a finite field math formula. Low Rank Parity <b>Check</b> <b>Codes</b> {{can be seen as the}} identical of Low Density Parity <b>check</b> <b>codes.</b> We compare the performance of this code against the Reed-Solomon Code through a Power Line Communication channel...|$|R
40|$|Checking {{procedures}} for processed nuclear data at Los Alamos are described. Both continuous energy and multi-group nuclear data are verified by locally developed <b>checking</b> <b>codes</b> which use basic physics knowledge and common-sense rules. A list of nuclear data problems {{which have been}} identified with help of these <b>checking</b> <b>codes</b> is also given...|$|R
40|$|Abstract—Foward error {{correction}} (FEC) {{scheme based on}} low density parity <b>check</b> <b>codes</b> (LDPC) codes is presented in this paper. We show that LDPC codes provide a significant system performance enhancement {{with respect to the}} state-of-the-art FEC schemes employed in optical communication systems. Index Terms—Forward {{error correction}}, long-haul transmis-sion, low-density parity <b>check</b> <b>codes,</b> optical communications. I...|$|R
5000|$|A {{final section}} {{containing}} user-defined auxiliary data, any necessary padding to produce uniform syncframe lengths, and a 16-bit cyclic redundancy <b>check</b> <b>code</b> for error detection.|$|E
5000|$|The <b>check</b> <b>code</b> {{for error}} {{detection}} and correction is as CRC, using polynomial division. Is uses 2 characters, or 8 bits. The generator polynomial is [...] with n=8, in binary [...] "111101001".|$|E
50|$|For case 1, {{the number}} of 0-valued bits in the {{information}} section will, by definition of the error, increase. Therefore, our Berger <b>check</b> <b>code</b> will be lower than the actual 0-bit-count for the data, and so the check will fail.|$|E
5000|$|<b>Checking</b> <b>coding</b> rules (Differences between PMD rule {{violations}} and FaultHunter rule violations) ...|$|R
5000|$|RM(1, m) <b>codes</b> are parity <b>check</b> <b>codes</b> {{of length}} N = 2m, rate [...] and minimum {{distance}} [...]|$|R
40|$|Abstract—This {{letter is}} {{concerned}} with the implementation issue of the sum-product algorithm (SPA) for decoding the low density parity <b>check</b> <b>codes.</b> It is shown that the direct implementation of the original form of SPA is sensitive to the quantization effect. We pro-pose a parity likelihood ratio technique to overcome the problem. It is shown that for comparable performance the new method can be implemented with much less quantization bits, which can lead to considerably lower decoding cost. Index Terms—Error correcting codes, low density parity <b>check</b> <b>codes,</b> turbo codes. I...|$|R
50|$|If {{the user}} has enabled it, {{the system will}} also write an entry to the system event log. The log entry {{contains}} information about the bug check (including the bug <b>check</b> <b>code</b> and its parameters) {{as well as a}} link which will report the bug and provide the user with prescriptive suggestions if the cause of the check is definitive and well-known.|$|E
50|$|On the {{transmit}} side, {{the data}} link layer generates an incrementing sequence number for each outgoing TLP. It serves as a unique identification tag for each transmitted TLP, and is inserted into the header of the outgoing TLP. A 32-bit cyclic redundancy <b>check</b> <b>code</b> (known in this context as Link CRC or LCRC) is also appended {{to the end of}} each outgoing TLP.|$|E
5000|$|Because of the {{extremely}} high density of [...] bpi tape, the RLL code {{is not sufficient}} to ensure reliable data storage. On top of the RLL code, an error-correcting code called the Optimal Rectangular Code (ORC) is applied. This code is a combination of a parity track and polynomial code similar to a CRC, but structured for error correction rather than error detection. For every seven bytes written to the tape (before RLL encoding), an eighth check byte is calculated and written to the tape. When reading, the parity is calculated on each byte and exclusive-ORed with the contents of the parity track, and the polynomial <b>check</b> <b>code</b> calculated and exclusive-ORed with the received <b>check</b> <b>code,</b> resulting in two 8-bit syndrome words. If these are both zero, the data is error free. Otherwise, error-correction logic in the tape controller corrects the data before it is forwarded to the host. The error correcting code is able to correct any number of errors in any single track, or in any two tracks if the erroneous tracks can be identified by other means.|$|E
5000|$|RM(m &minus; 1, m) {{codes are}} single parity <b>check</b> <b>codes</b> of length N = 2m, rate [...] and minimum {{distance}} [...]|$|R
30|$|Nine {{respondents}} (6 %) mentioned other tool support; {{three of}} these were again code generation as above; two mentioned custom implementations for <b>checking</b> <b>code.</b>|$|R
5000|$|Visual Expert for PowerBuilder - Visual Expert {{helps in}} sharing the {{knowledge}} of your applications. It also automates impact analysis and <b>checks</b> <b>code</b> quality.|$|R
50|$|Credit cards have {{a printed}} or {{embossed}} bank card number {{complying with the}} ISO/IEC 7812 numbering standard. The card number's prefix, called the Bank Identification Number, is the sequence of digits {{at the beginning of}} the number that determine the bank to which a credit card number belongs. This is the first six digits for MasterCard and Visa cards. The next nine digits are the individual account number, and the final digit is a validity <b>check</b> <b>code.</b>|$|E
50|$|With the {{formation}} of the Mozilla Corporation, the Mozilla Foundation delegated all their development and business-related activities to the new subsidiary. The Mozilla Foundation now focuses on its Webmaker initiative (which aims to raise the level of users' Web Literacy) as well as on governance and policy issues. The Mozilla Foundation owns the Mozilla trademarks and other intellectual property, which it licenses to the Mozilla Corporation. It also controls the Mozilla source code repository and decides who is allowed to <b>check</b> <b>code</b> in.|$|E
5000|$|The {{line printer}} {{employed}} {{a series of}} status codes, specifically ready, online, and check. If the online status was set to [...] "off" [...] and the check status was set to [...] "on," [...] the operating system would interpret this as the printer running out of paper. However, if the online code was set to [...] "on" [...] and the <b>check</b> <b>code</b> was also set to [...] "on", it meant that the printer still had paper, but was suffering an error (and may still be attempting to run). Due to the potentially hazardous conditions which could arise in early line printers, Unix displayed the message [...] "on fire" [...] to motivate any system operator viewing the message to go and check on the line printer immediately.|$|E
50|$|Walker's {{research}} is in coding theory, i.e., {{the study of}} error-correcting codes. Her primary contributions have been in algebraic geometry codes and low-density parity <b>check</b> <b>codes.</b>|$|R
40|$|We {{describe}} {{a method for}} designing fault tolerant circuits based on an extension of a Concurrent Error Detection (CED) technique. The proposed extension combines parity <b>check</b> <b>codes</b> and duplication in order to not only perform error detection but also provide diagnosis and correction capabilities. Informed selection among the outputs of the original circuit and the outputs of the duplicate with parity <b>check</b> <b>codes</b> renders a low-cost fault tolerant design. Experimental results confirm {{the efficacy of the}} proposed method as a general solution for designing fault tolerant circuits. 1...|$|R
40|$|We analyze low density parity <b>check</b> <b>codes</b> {{that correct}} both errors and erasures using a simple {{decoding}} scheme. Our framework unifies previous analyses for low density parity <b>check</b> <b>codes</b> and erasure codes. The {{result is a}} general class of codes that corrects both errors and erasures, with corresponding simple linear time encoding and decoding algorithms and provable performance guarantees. We also describe how these codes {{can be applied to}} yield a new fast algorithm for the setting of of Gaussian noise, and leave several open questions regarding the construction of these codes and the associated decoding algorithms. ...|$|R
5000|$|Terminator {{canaries}} use {{the observation}} that most buffer overflow attacks are based on certain string operations which end at string terminators. The reaction to this observation is that the canaries are built of null terminators, CR, LF, and -1. As a result, the attacker must write a null character before writing the return address to avoid altering the canary. This prevents attacks using [...] and other methods that return upon copying a null character, while the undesirable {{result is that the}} canary is known. Even with the protection, an attacker could potentially overwrite the canary with its known value, and control information with mismatched values, thus passing the canary <b>check</b> <b>code,</b> this latter being executed soon before the specific processor's return-from-call instruction.|$|E
5000|$|Forward error {{correction}} - used in high-data-rate UWB pulse systems - can provide channel performance approaching the Shannon limit.OFDM receivers typically fix most errors {{with a low}} density parity <b>check</b> <b>code</b> inner code followed by some other outer code that fixes the occasional errors (the [...] "error floor") that get past the LDPC correction inner code even at low bit-error rates.For example:The Reed-Solomon code with LDPC Coded Modulation (RS-LCM) adds a Reed-Solomon {{error correction}} outer code.The DVB-T2 standard and the DVB-C2 standard use a BCH code outer code to mop up residual errors after LDPC decoding.WiMedia over a UWB channel uses a Hybrid automatic repeat request:inner error correction using convolutional and Reed-Solomon coding,outer error correction using a frame check sequence that,when the check fails, triggers automatic repeat-request (ARQ).|$|E
5000|$|Even {{after more}} {{automation}} {{is added to}} the existing test process, managers still lack adequate insight into the level of risk associated with an application at any given point in time. Understanding these risks is critical for making the rapid go/no go decisions involved in Continuous Delivery processes. If tests are developed without an understanding of what the business considers to be an acceptable level of risk, it is possible to have a release candidate that passes all the available tests, but which the business leaders would not consider to be ready for release. For the test results to accurately indicate whether each release candidate meets business expectations, the approach to designing tests must be based on the business's tolerance for risks related to security, performance, reliability, and compliance. In addition to having unit tests that <b>check</b> <b>code</b> at a very granular bottom-up level, {{there is a need for}} a broader suite of tests to provide a top-down assessment of the release candidate's business risk.|$|E
40|$|Abstract: In {{iterative}} data-detection and channel-estimation algorithms, {{the channel}} estimator {{and the data}} detector recursively exchange the information order to improve the system performance. In this paper, maximum a posteriori based iterative data detection and pilot symbol assisted channel estimation of the single parity <b>check</b> product <b>code</b> for multiple antenna wireless communication is studied. Results show the algorithm can converge at a few iteration numbers and improve error probability performance of the system. Index Terms: multiple antennas, single-parity <b>check</b> <b>codes,</b> product code, iterative decoding, pilot symbol assisted channel estimation...|$|R
40|$|Abstract — In this paper, two {{simplified}} {{versions of}} the belief propagation algorithm for fast iterative decoding of low-density parity <b>check</b> <b>codes</b> on the additive white Gaussian noise channel are proposed. Both versions are implemented with real addi-tions only, which greatly simplifies the decoding complexity of belief propagation in which products of probabilities have to be computed. Also, these two algorithms do not require any knowl-edge about the channel characteristics. Both algorithms yield a good performance–complexity tradeoff and can be efficiently implemented in software {{as well as in}} hardware, with possibly quantized received values. Index Terms—APP decoding, belief propagation, block <b>codes,</b> four-density parity <b>check</b> <b>codes,</b> iterative decoding. I...|$|R
40|$|Abstract. Fine-grained {{software-based}} distributed {{shared memory}} (SW-DSM) systems typically maintain coherence with in-line <b>checking</b> <b>code</b> at load and store operations to shared memory. The instrumentation over-head of this added <b>checking</b> <b>code</b> can be severe. This paper (1) shows {{that most of}} the instrumentation overhead in the fine-grained SW-DSM system DSZOOM is store-related, (2) introduces a new write permission cache (WPC) technique that exploits spatial store locality and batches coherence actions at runtime, (3) evaluates WPC and (4) presents WPC results when implemented in a real SW-DSM system. On average, the WPC reduces the store instrumentation overhead in DSZOOM with 42 (67) percent for benchmarks compiled with maximum (minimum) compiler optimizations. ...|$|R
5000|$|Electronic {{questionnaires}} {{are created}} in the Form Designer module. Individual questions can be placed anywhere on a page and each form may contain multiple pages. The user is given {{a high degree of}} control over the form's appearance and function. The user defines both the question's prompt and the format of the data that is to be collected. Data types include numbers, text strings, dates, times, and Boolean. Users can also create drop-down lists, code tables, and comment legal fields. One of the more powerful features of Form Designer is the ability to program intelligence into a form through a feature called [...] "check code". <b>Check</b> <b>code</b> allows for certain events to occur depending on what action a data entry person has taken. For example, if the data entry person types [...] "Male" [...] into a question on gender, any questions relating to pregnancy might then be hidden or disabled. Skip patterns, message boxes, and math operations are also available. Relational database modeling is supported, as users may link their form to any number of other forms in their database.|$|E
3000|$|... operator. The {{simplest}} two {{designs of}} G are the repetition code {{and the single}} parity <b>check</b> <b>code.</b> In the former case, the code is [...]...|$|E
40|$|An {{improved}} Quasi Cyclic Low Density Parity <b>Check</b> <b>code</b> (QC-LDPC) {{is proposed}} {{to reduce the}} complexity of the Low Density Parity <b>Check</b> <b>code</b> (LDPC) while obtaining the similar performance. The proposed QC-LDPC presents an improved construction at high SNR with circulant sub-matrices. The proposed construction yields a performance gain of about 1 dB at a 0. 0003 bit error rate (BER) and it is tested on 4 different decoding algorithms. Proposed QC-LDPC is compared with the existing QC-LDPC and the simulation results show that the proposed approach outperforms the existing one at high SNR. Simulations are also performed varying the number of horizontal sub matrices and the results show that the parity check matrix with smaller horizontal concatenation shows better performance...|$|E
40|$|In this paper, {{we study}} {{a new class}} of Low Density Parity <b>Check</b> <b>codes,</b> {{designed}} for satellite communications, and achieving both high spectral efficiency and large coding gain. Given a constant-envelope 8 -PSK constellation, a generic linear binary code does not lead to a geometrically uniform Euclidean-space code. Low Density Parity <b>Check</b> <b>codes</b> over Z_ 8, the group of integers modulo 8, are considered. When applied to 8 -PSK, they generate geometrically uniform Euclidean space codes: distance profile and word error probability are the same for each transmitted codeword. These properties highly simplify both design and analysis. Some insights on code design, encoding, decoding, and simulated performance are provide...|$|R
40|$|In this paper, we {{investigate}} an efficient encoding approach for generalized low-density (GLD) parity <b>check</b> <b>codes,</b> a generalization of Gallager's low-density parity <b>check</b> (LDPC) <b>codes.</b> We propose a systematic approach to construct approximate upper triangular GLD parity check matrix which defines {{a class of}} efficientencoding GLD codes. It's shown that such GLD codes have equally good performance. By effectively exploiting the structure sharing in the encoding process, we also present a hardware/software codesign for the practical encoder implementation of these efficientencoding GLD codes...|$|R
40|$|Abstract—We {{consider}} {{in this paper}} decomposing quasi-cyclic low-density parity <b>check</b> <b>codes</b> (LDPC) based on difference family. The resulting codes can be encoded with low complexity and perform well when iteratively decoded with the sum-product algorithm. Index Terms—quasi-cyclic codes, difference families and low-density parity-check codes. I...|$|R
