0|44|Public
5000|$|Program animation, {{permitting}} step-by-step {{execution and}} <b>conditional</b> <b>breakpoint</b> at source level or in machine code ...|$|R
5000|$|Easier {{to debug}} (e.g. setting {{breakpoints}} on code vs. a call table, if the debugger has no <b>conditional</b> <b>breakpoint</b> capability) ...|$|R
50|$|Xcode 2.1 {{could create}} {{universal}} binary files. It supported shared precompiled headers, unit testing targets, <b>conditional</b> <b>breakpoints,</b> and watchpoints. It also had better dependency analysis.|$|R
5000|$|... an {{instruction}} set simulator can implement unconditional or <b>conditional</b> <b>breakpoints,</b> by simply embedding the appropriate condition tests {{within its own}} normal program cycle - that also naturally allows non-invasive breakpoints (on read-only programs for instance).|$|R
5000|$|The {{animator}} may, or may not, combine other test/debugging features {{within it}} such as program trace, dump, <b>conditional</b> <b>breakpoint</b> and memory alteration, program flow alteration, code coverage analysis, [...] "hot spot" [...] detection, loop detection or similar.|$|R
50|$|Other {{kinds of}} {{conditions}} {{can also be}} used, such as the reading, writing, or modification of a specific location {{in an area of}} memory. This {{is often referred to as}} a <b>conditional</b> <b>breakpoint,</b> a data breakpoint, or a watchpoint.|$|R
40|$|We {{present a}} post-compiler program {{manipulation}} tool called Dyninst {{which provides a}} C++ class library for program instrumentation. Using this library, {{it is possible to}} instrument and modify application programs during execution. A unique feature of this library is that it permits machine-independent binary instrumentation programs to be written. We describe the interface that a tool sees when using this library. We also discuss three simple tools built using this interface: a utility to count the number of times a function is called, a program to capture the output of an already running program to a file, and an implementation of conditional break points. For the <b>conditional</b> <b>breakpoint</b> example, we show that by using our interface compared with gdb we are able to execute a program with <b>conditional</b> <b>breakpoints</b> up to 900 times faster. 1. Introduction The normal cycle of developing a program is to edit source code, compile it, and then execute the resulting binary. However, sometimes t [...] ...|$|R
5000|$|Breakpoints ... Programs halt when a {{specified}} event, a breakpoint, has occurred. The event {{can be specified}} as a code execution address, or as a data access (read or write) to an address with {{a specified}} value. Nexus breakpoints can be set at any address, including flash or ROM memory; CPUs may also provide special <b>breakpoint</b> <b>instructions.</b>|$|R
50|$|In computing, binary {{translation}} (or (binary) recompilation) is the emulation of one {{instruction set}} by another through translation of binary code. Sequences of instructions are {{translated from the}} source to the target instruction set. In some cases such as instruction set simulation, the target instruction set may {{be the same as}} the source instruction set, providing testing and debugging features such as <b>instruction</b> trace, <b>conditional</b> <b>breakpoints</b> and hot spot detection.|$|R
50|$|Although Borland's Turbo Pascal (TP) had useful {{single-stepping}} and <b>conditional</b> <b>breakpoint</b> facilities, {{the need}} for a more powerful debugger became apparent when TP started to be used for serious development. Initially a separate company, Turbopower, produced a debugger, T-Debug, and also their Turbo Analyst and Overlay Manager for Turbo Pascal for TP versions 1-3. Turbopower released T-Debug Plus 4.0 for TP 4.0 in 1988, but by then Borland's Turbo Debugger had been announced.|$|R
50|$|Many {{processors}} include hardware {{support for}} <b>breakpoints</b> (typically <b>instruction</b> and data <b>breakpoints).</b> As an example, the x86 instruction set architecture provides hardware support for breakpoints with its x86 debug registers. Such hardware may include limitations, for example not allowing <b>breakpoints</b> on <b>instructions</b> located in branch delay slots. This kind of limitation is {{imposed by the}} microarchitecture of the processor and varies from processor to processor.|$|R
5000|$|The TMS9900 has an uncommon, {{and rarely}} used, {{instruction}} called [...] "X" [...] (eXecute). This instruction {{is used to}} execute another instruction at an address pointed to by a register without changing program flow, i.e. execution continues at the address following the X instruction. This instruction {{can be used for}} debugging (as a <b>breakpoint</b> <b>instruction)</b> and for creating indexed-opcode tables as used in byte-code interpreters.|$|R
5000|$|Standard {{as well as}} more {{advanced}} <b>breakpoint</b> features, including <b>conditional,</b> address, data <b>breakpoints.</b>|$|R
50|$|The IDE {{provided}} several debugging facilities, including single stepping, {{examination and}} changing of variables, and <b>conditional</b> <b>breakpoints.</b> In later versions assembly-language blocks could be stepped through. The user could add breakpoints on variables and registers in an IDE window. Programs using IBM PC graphics mode could flip between graphics and text mode automatically or manually, or display both on two screens. For {{cases where the}} relatively simple debugging facilities of the IDE were insufficient, Turbopower Software produced a more powerful debugger, T-Debug. The same company produced Turbo Analyst and Overlay Manager for Turbo Pascal. T-Debug was later updated for Turbo Pascal 4, but discontinued {{with the release of}} Borland's Turbo Debugger (TD), which also allowed some hardware intervention on computers equipped with the new 80386 processor.|$|R
40|$|We have {{designed}} and implemented a fast breakpoint facility. Breakpoints are usually {{thought of as}} a feature of an interactive debugger, in which case the break-points need not be particularly fast. In our environment breakpoints are often used for non-interactive informa-tion gathering: for example, procedure call count and statement execution count profiling [Swinehart, et al. ]. When used non-interactively, breakpoints should be as fast as possible, so as to perturb the execution of the program as little as possible. Even in interactive debuggers, a <b>conditional</b> <b>breakpoint</b> facility would benefit from breakpoints that could transfer to the evaluation of the condition rapidly, and continue expeditiously if the condition were not satisfied. Such <b>conditional</b> <b>breakpoints</b> could be used to check assertions, etc. Program advising could also make use of fast breakpoints [Teitelman]. Examples of advising include tracing, timing, and even animation, all of which should be part of an advanced programming environment. We have ported the Cedar environment from a machine with microcode support for breakpoints [Lampson and Pier] to commercial platforms running C code [Atkinson, et al. ]. Most of our ports run under the Unix * operating system, so one choice for implementing breakpoints for Cedar was to use the breakpoint facility provided by that system. The breakpoints provided by the Unix operating system are several orders of magnitude too slow (and also several process switches too complicated) for the applications we have in mind. * Unix is a trademark of AT&T Bell Laboratories. Permission to copy without fee all or part of this material is granted provided that the copies are not made or distributed for direct corn-mercial advantage, the ACM copyright notice and the titie of the publication and its date appear, and notice is given that copying is by permission of the Association for Computing Machinery. To copy otherwise, or to republish, requires a fee and/or specific permission...|$|R
50|$|Debug mode is also entered asynchronously by the debug module {{triggering}} a watchpoint or breakpoint, or by issuing a BKPT (<b>breakpoint)</b> <b>instruction</b> from the software being debugged. When {{it is not}} being used for instruction tracing, the ETM can also trigger entry to debug mode; it supports complex triggers sensitive to state and history, {{as well as the}} simple address comparisons exposed by the debug module. Asynchronous transitions to debug mode are detected by polling the DSCR register. This is how single stepping is implemented: HALT the core, set a temporary breakpoint at the next instruction or next high-level statement, RESTART, poll DSCR until you detect asynchronous entry to debug state, remove that temporary breakpoint, repeat.|$|R
40|$|Debuggers allow a user to halt {{a program}} and examine its state. The {{debugger}} stops execution when some user-specified condition is satisfied: Code breakpoints halt program execution when a particular instruction is executed. Data breakpoints halt program execution when a variable is referenced. Code breakpoints are supported directly in hardware on most machines and are fast. Data breakpoints, however, are notoriously slow. This note describe how data breakpoints {{can be made}} fast. 1 Introduction Debuggers provide commands that allow the programmer to halt a program and examine it's state. The most common command is a code breakpoint, which halts the program when execution reaches a certain instruction. Some debuggers also support <b>conditional</b> <b>breakpoints</b> which evaluate an expression whenever a certain instruction is reached and halt the program only if the expression evaluates to true [Kes 90]. Some debuggers provide data breakpoints, which halt the program whenever a variable is ref [...] ...|$|R
40|$|Debugging {{concurrent}} {{programs is}} difficult because concurrent programs contain both sequential errors and additional concurrent errors. It is essential to have a symbolic debugger that truly understands concurrency to improve concurrent debugging capabilities and reduce debugging time. KDB {{was designed to be}} such a concurrent debugger, however it was far from complete. This thesis presents extensions to KDB's functionality, usability, and portability. Restricted <b>conditional</b> <b>breakpoints,</b> attachment of KDB to a running application, behavioural groups, programmatic interface, and improved user interface have been added to KDB to extend its functionality. KDB has been modified to understand ¯C++ programs better so that inserted code is hidden from users improving KDB's usability. Finally, KDB has been ported to the i 486 architecture on the Linux OS, increasing portability. KDB is written in ¯C++ and is a concurrent application, so it was possible to test the extensions while debugging the [...] ...|$|R
40|$|Abstract—In {{debugging}} processes breakpoints are fre-quently used {{to inspect}} {{and understand the}} run-time pro-gram behavior. Although modern development environments provide convenient breakpoint utilities, it mostly requires considerable human effort to create useful breakpoints. Before setting a breakpoint or typing a breakpoint condition, developers usually {{have to make some}} judgements and hypotheses based on their observations and experiences. To reduce such kind of effort, we propose an approach to automatically generating breakpoints for debugging. We combine the nearest neighbor queries method, dynamic program slicing, and memory graph comparison to identify suspicious program statements and states. Based on this information, breakpoints are generated and divided into two groups, where the primary group contains <b>conditional</b> <b>breakpoints</b> and the secondary group contains unconditional ones. We implement the presented approach on top of the Eclipse JDT platform. Our objective experiments and user study indicate that the generated breakpoints can be effective in aiding debugging work. Index Terms—software debugging, breakpoint generation I...|$|R
50|$|Breakpoints {{are most}} {{commonly}} used to interrupt a running program immediately before the execution of a programmer-specified instruction. This {{is often referred to}} as an <b>instruction</b> <b>breakpoint.</b>|$|R
50|$|In-system {{programming}} allows {{an external}} hardware debugger to reprogram a system under test (for example, adding or removing <b>instruction</b> <b>breakpoints).</b> Many systems with such ISP support also have other hardware debug support.|$|R
40|$|Using debuggers is {{a common}} mean for {{identifying}} and analyzing malware (such as viruses, worms, spyware, rootkits, etc.). However, debuggers can be detected by malware via observing {{of the behavior of}} operating system, changes in code (such as <b>breakpoint</b> <b>instructions)</b> and non-standard behavior of the CPU, making the analysis of the malware can be hard and tedious. In this thesis we are implementing a basic debugger based on the QEMU emulator that hides its presence from the debugged application. This is accomplished by using the QEMU as virtual machine and adding context awareness to the already existing primitive debugger. The context awareness is implemented using an embedded Python scripting engine. Such setup gives us a flexible way of implementing support for various operating systems. In this thesis, we have developed two examples. One example is for the RTEMS operating system, which serves as easy to understand reference implementation. Second example is for the Linux operating system, to show the abilities of the undetectable debugger in a more real scenario...|$|R
5000|$|Without {{hardware}} support (and in multitasking environments), debuggers have {{to implement}} breakpoints in software. For <b>instruction</b> <b>breakpoints,</b> {{this is a}} comparatively simple task of replacing the instruction {{at the location of}} the breakpoint by either: ...|$|R
40|$|In this paper, {{we present}} a {{semi-automatic}} approach for mining a large-scale dataset of IDE interactions to extract usage smells, i. e., inefficient IDE usage patterns exhibited by developers in the field. The approach outlined in this paper first mines frequent IDE usage patterns, filtered via a set of thresholds and by the authors, that are subsequently supported (or disputed) using a developer survey, in order to form usage smells. In contrast with conventional mining of IDE usage data, our approach identifies time-ordered sequences of developer actions that are exhibited by many developers in the field. This pattern mining workflow is resilient to the ample noise present in IDE datasets due to the mix of actions and events that these datasets typically contain. We identify usage patterns and smells {{that contribute to the}} understanding of the usability of Visual Studio for debugging, code search, and active file navigation, and, more broadly, to the understanding of developer behavior during these software development activities. Among our findings is the discovery that developers are reluctant to use <b>conditional</b> <b>breakpoints</b> when debugging, due to perceived IDE performance problems as well as due to the lack of error checking in specifying the conditional...|$|R
5000|$|Instruction Set Simulator This {{technique}} {{treats the}} compiled programs machine code as its input 'data' and fully simulates the host machine instructions, monitors the code for <b>conditional</b> or unconditional <b>breakpoints</b> or programmer requested [...] "single cycle" [...] animation requests between every step.|$|R
40|$|<b>Breakpoints,</b> watchpoints, and <b>conditional</b> {{variants}} of both are essential debugging primitives, but their natural implementations often degrade performance significantly. Slowdown arises because the debugger [...] -the tool implementing the breakpoint/watchpoint interface [...] -is implemented {{in a process}} separate from the debugged application. Since the debugger evaluates the watchpoint expressions and conditional predicates to determine whether to invoke the user, a debugging session typically requires many expensive applicationdebugger context switches, resulting in slowdowns of 40, 000 times or more in current commercial and open-source debuggers! In this paper, we present an effective and efficient implementation of (<b>conditional)</b> <b>breakpoints</b> and watchpoints that uses DISE to dynamically embed debugger logic into the running application. DISE (dynamic instruction stream editing) is a previously-proposed, programmable hardware facility for dynamically customizing applications by transforming the instruction stream as it is decoded. DISE embedding preserves the logical separation of application and debugger [...] - instructions are added dynamically and transparently, existing application code and data are not statically modified [...] - and has little startup cost. Cycle-level simulation on the SPEC 2000 integer benchmarks shows that the DISE approach eliminates all unnecessary context switching, typically limits debugging overhead to 25 % or less {{for a wide range}} of watchpoints, and outperforms alternative implementations...|$|R
50|$|As {{multiprocessing}} {{became more}} commonplace, such techniques would have limited practicality, since many independent processes would be stopped simultaneously. This {{led to the}} development of proprietary software from several independent vendors that provided similar features but deliberately restricted <b>breakpoints</b> and <b>instruction</b> stepping to particular application programs in particular address spaces and threads. The program state (as applicable to the chosen application/thread) was saved for examination at each step and restored before resumption, giving the impression of a single user environment. This is normally sufficient for diagnosing problems at the application layer.|$|R
50|$|The INT 3 {{instruction}} is defined {{for use by}} debuggers to temporarily replace an instruction in a running program in order to set a <b>breakpoint.</b> Other INT <b>instructions</b> are encoded using two bytes. This makes them unsuitable for use in patching instructions (which can be one byte long); see SIGTRAP.|$|R
40|$|Abstract—It is {{well known}} that designing, testing and debug-ging sensor {{networks}} are extremely hard. It is mainly due to limited resources and distributed natures of sensor networks. In a lab environment, it is difficult and tedious to try various network configurations and simulate various challenging environment factors. Thereafter, the sensor network community has longed for a good sensor network simulation tool allowing the philosophy of WYSIWYG: What You See Is What You Get. In this paper, we present the design and evaluation of a visualized network manipulation tool integrated with TOSSIM and TOSSIM Live, called SimX. The SimX includes the following features: (1) topology manipulation, which allows a simple mouse drag on the virtual network node to actually change the physical network topology and the link qualities; (2) timing control, which allows a user to control a simulation to run faster or slower, even to pause the simulation; (3) variable watch and <b>conditional</b> <b>breakpoints,</b> which allow a user to watch variable value changes of all network nodes concurrently and set conditional breakpoints; (4) sensor input control, which allows a user to simulate different sensor data inputs and sampling rates. Besides supporting those traditional evaluation criteria, such as throughput, energy ef-ficiency and delivery ratio, the SimX also supports a holistic evaluation methodology. The holistic evaluation methodology evaluates how well the holistic high-level spatial and temporal environmental changes have been recorded, not only those low-level engineering criteria. We also designed a XML-based sensor network visualization tool, which allows the user to illustrate any sensor network data, including data imported from TOSSIM and SimX...|$|R
5000|$|Machine breakpointsEarly {{mainframe}} computers, {{such as the}} IBM/360, had console switches/dials {{that allowed}} <b>breakpoints</b> at specific <b>instruction</b> storage addresses and provided [...] "single cycle" [...] operation, permitting the contents of registers and memory to be observed directly on console lights. The advent of multitasking limited {{the use of this}} option since the entire machine was halted.|$|R
2500|$|The ARMv7 {{architecture}} defines basic debug {{facilities at}} an architectural level. These include <b>breakpoints,</b> watchpoints and <b>instruction</b> execution in a [...] "Debug Mode"; similar facilities were also available with EmbeddedICE. Both [...] "halt mode" [...] and [...] "monitor" [...] mode debugging are supported. The actual transport mechanism used {{to access the}} debug facilities is not architecturally specified, but implementations generally include JTAG support.|$|R
40|$|Understanding how {{a program}} {{execution}} proceeds often helps debug the program. An execution {{can be seen}} as a succession of computation steps. Tracers give information about these steps and what occurs at each of them. The traceable steps are traditionally called breakpoints. An execution frequently produces several millions of breakpoint occurrences. Programmers can therefore not analyze by hand all the computation steps. Existing tracers often have <b>conditional</b> <b>breakpoints</b> to inspect only steps which satisfy certain conditions. Unfortunately, the conditions that can be specified do not meet all the needs. To palliate this problem, an execution trace {{can be seen as}} a relational database. Each breakpoint information is represented by a tuple and queries simply use the language of the database management system. The problem is then that the time to create the database is much too long. We have, therefore, proposed an improved framework for trace querying. The interrogation is processed in two distinct steps: firstly, the trace is filtered on the fly with respect to the basic conditions of the queries; secondly, the remaining part of the query is then processed. Our approach has two main advantages. Firstly, filtering is very efficient. Done on the fly, it creates very few new data structures, the trace does not even have to be stored at all. In this report, we describe how to implement trace query tools based on the above framework. We propose an architecture where a tracer driver, containing a very efficient trace filtering algorithm, is integrated in the tracer process. The implementation guidelines are based on our experience building four prototypes for different sorts of programming languages...|$|R
50|$|The {{goal of a}} pipelined {{architecture}} is to complete an instruction every clock cycle. To maintain this rate, the pipeline must be full of instructions at all times. The branch delay slot is {{a side effect of}} {{pipelined architecture}}s due to the branch hazard, i.e. the fact that the branch would not be resolved until the instruction has worked its way through the pipeline. A simple design would insert stalls into the pipeline after a branch instruction until the new branch target address is computed and loaded into the program counter. Each cycle where a stall is inserted is considered one branch delay slot. A more sophisticated design would execute program instructions which are not dependent on the result of the branch instruction. This optimization can be performed in software at compile time by moving instructions into branch delay slots in the in-memory instruction stream, if the hardware supports this. Another side effect is that special handling is needed when managing <b>breakpoints</b> on <b>instructions</b> as well as stepping while debugging within branch delay slot.|$|R
40|$|This paper {{discusses}} debugging and runtime {{analysis of}} software and outlines its enormous benefits to software developers and testers. A debugger is usually quite helpful in tracking down many logic problems. However, {{even with the}} most advanced debugger at your disposal, it doesn't guarantee {{that it will be}} a straightforward task to rid your program of bugs. Debugging techniques might help you in your task of flushing errors out of your program. Some of these willdirectly involve the debugger but many of them won't. The hope is to add to your debugging repertoire in order to assist your personal debugging quests when things go strangely wrong. Testing is more than just debugging. Testing is not only used to locate defects and correct them. It is also used in validation, verification process, andreliability measurement. Testing is expensive. Automation is a good way to cut down cost and time. When we write software applications, we need to debug them. Software Testing provides an objective, independent view of the software to allow the business to appreciate and understand the risks at implementation of the software. Aprimary purpose for testing is to detect software failures so that defects may be uncovered and corrected. This is a non-trivial pursuit. Testing cannot establish that a product functions properly under all conditions but can only establish that it does not function properly under specific conditions. Program testing and fault detection can beaided significantly by testing tools and debuggers. Testing and debug tools include features such as program monitors, permitting full or partial monitoring of program code including instruction set simulator, permitting complete instruction level monitoring and trace facilities, program animation, permitting step-by-step execution and <b>conditional</b> <b>breakpoint</b> at source level or in machine code, code coverage reports, formatted dump or symbolic debugging tools allowing inspection of program variables on error or at chosen points. Automated functional GUI testing tools are used to repeat system-level tests through the GUI, benchmarks, allowing run-time performance comparisons to be made, performance analysis that can help to highlight hot spots and resource usage. A runtime tool will allow you to examine the application internals after the run via the recorded runtime analysis data. Runtime analysis removes the guesswork from debugging. It helps to uncover Memory corruption detection, Memory leak detection etc. Runtime analysis is an effort aimed at understanding software component behavior by using datacollection during the execution of the component. Runtimeanalysis is a topic of great interest in Computer Science. A program can take seconds, hours or even years to finish executing, depending on various parameters...|$|R
40|$|During {{debugging}} processes, breakpoints {{are frequently}} used to inspect and understand runtime behaviors of programs. Although most development environments oer convenient breakpoint facilities, {{the use of}} these environments usually requires considerable human eorts in order to generate use-ful breakpoints. Before setting breakpoints or typing break-point conditions, developers usually have to make some judge-ments and hypotheses {{on the basis of their}} observations and experience. To reduce this kind of eorts we present a tool, named BPGen, to automatically generate breakpoints for debugging. BPGen uses three well-known dynamic fault lo-calization techniques in tandem to identify suspicious pro-gram statements and states, through which both <b>conditional</b> and unconditional <b>breakpoints</b> are generated. BPGen is im-plemented as an Eclipse plugin for supplementing the exist-ing Eclipse JDT debugger...|$|R
50|$|XAP6 is a 32-bit {{processor}} and {{was launched in}} 2013. It has {{the same type of}} load-store architecture as the XAP4 and XAP5, but has 32-bit registers and 32-bit buses for Data and Address. The XAP6a implementation has a three-stage instruction pipeline. Like all the XAP processors, the XAP6 has been optimised for low-cost, low-energy and easy verification. XAP6 is tailored for small low-energy ASICs and minimises processor hardware size (the XAP6 core uses 30,000-gates). The XAP6 registers (all 32-bit) are; 8 General Purpose, Program Counter, Vector Pointer, Global Pointer, FLAGS, INFO, BRKE, 4 <b>Breakpoint.</b> The XAP6 <b>instructions</b> are 16, 32 and 48-bit. The XAP6 compile chain is based on GNU GCC and Binutils.|$|R
