198|434|Public
25|$|The Monroe Epic {{programmable}} calculator {{came on the}} market in 1967. A large, printing, desk-top unit, with an attached floor-standing logic tower, it could be programmed to perform many computer-like functions. However, the only branch instruction was an implied unconditional branch (GOTO) {{at the end of the}} operation stack, returning the program to its starting instruction. Thus, it was not possible to include any <b>conditional</b> <b>branch</b> (IF-THEN-ELSE) logic. During this era, the absence of the <b>conditional</b> <b>branch</b> was sometimes used to distinguish a {{programmable calculator}} from a computer.|$|E
25|$|If Ri and Rj {{are equal}} then {{neither of the}} SUB {{instructions}} will be executed, {{eliminating the need for}} a <b>conditional</b> <b>branch</b> to implement the while check {{at the top of the}} loop, for example had SUBLE (less than or equal) been used.|$|E
25|$|Comparison {{is often}} {{implemented}} with a dummy subtraction, where the flags in the computer's status register are checked, {{but the main}} result is ignored. The zero flag indicates if two values compared equal. If the exclusive-or of the sign and overflow flags is 1, the subtraction result was less than zero, otherwise the result was zero or greater. These checks are often implemented in computers in <b>conditional</b> <b>branch</b> instructions.|$|E
5000|$|... "fall-through" [...] {{instructions}} following some <b>conditional</b> <b>branches</b> ...|$|R
5000|$|... {{unconditional}} and <b>conditional</b> <b>branches,</b> both {{direct and}} indirect ...|$|R
5000|$|Several {{techniques}} improve speed {{by reducing}} stalls from <b>conditional</b> <b>branches.</b>|$|R
25|$|Conditional {{branches}} {{test whether}} the {{least significant bit}} of a register is set or clear, or compare a register as a signed quadword to zero, and branch if the specified condition is true. The conditions available for comparing a register to zero are equality, inequality, less than, {{less than or equal}} to, greater than or equal to, and greater than. The new address is computed by longword aligning and sign extending the 21-bit displacement and adding it to the address of the instruction following the <b>conditional</b> <b>branch.</b>|$|E
25|$|Branch {{instructions}} have a 6-bit opcode field, a 5-bit Ra {{field and}} a 21-bit displacement field. The Ra field specifies a register {{to be tested}} by a <b>conditional</b> <b>branch</b> instruction, and if the condition is met, the program counter is updated by adding {{the contents of the}} displacement field with the program counter. The displacement field contains a signed integer and if the value of the integer is positive, if the branch is taken then the program counter is incremented. If the value of the integer is negative, then program counter is decremented if the branch is taken. The range of a branch thus is ±1 Mi instructions, or ±4 MiB. The Alpha Architecture was designed with a large range as part of the architecture's forward-looking goal.|$|E
2500|$|Executing {{a set of}} {{statements}} only if some condition is met (choice - i.e., <b>conditional</b> <b>branch)</b> ...|$|E
40|$|An {{operational}} data flow analysis framework for tracking controlling expressions of <b>conditional</b> <b>branches</b> {{is defined in}} this work. The framework is based on control flow graphs and applies to various procedural languages. In this framework, environments assigned to edges and nodes of control flow graphs are basically conjunctions of certain predicate formulas. These formulas include: atomic constituents of controlling expressions of program branches and their negations; equalities originating from program assignments and their negations; equivalences between program expressions and constants and their negations; linear-ordering inequalities between program expressions and constants. Analysis is executed by a worklist-based fixpoint algorithm which interprets <b>conditional</b> <b>branches</b> and ignores some impossible paths. This analysis algorithm incorporates a simple inference procedure that derives validity or inconsistency of environment constituents by exploiting {{both positive and negative}} information. The analysis algorithm is shown to be conservative; its asymptotic time complexity is cubic. Tracking branch conditions enables such optimizations as elimination of unreachable code, elimination of redundant <b>conditional</b> <b>branches,</b> and removal of <b>conditional</b> <b>branches</b> from some execution paths. Two novel optimizations enabled by the analysis are presented. These optimizations eliminate <b>conditional</b> <b>branches</b> from some paths after replicating code. They leverage upon additional local analysis...|$|R
5000|$|Fast paths can be {{established}} for a program's execution, reducing some otherwise repetitive <b>conditional</b> <b>branches.</b>|$|R
2500|$|... <b>conditional</b> <b>branching</b> (program e selects {{between two}} results {{depending}} on the value it computes for f(i,i)), ...|$|R
2500|$|Executing {{a set of}} {{statements}} zero or more times, until some condition is met (i.e., loop - the same as <b>conditional</b> <b>branch)</b> ...|$|E
2500|$|List of labeled instructions, {{usually in}} {{sequential}} order: A finite list of instructions [...] In {{the case of}} the counter machine, random access machine (RAM) and pointer machine the instruction store is in the [...] "TABLE" [...] of the finite state machine; thus these models are example of the Harvard architecture. In {{the case of the}} RASP the program store is in the registers; thus {{this is an example of}} the von Neumann architecture. See also Random access machine and Random access stored program machine.Usually, like computer programs, the instructions are listed in sequential order; unless a jump is successful the default sequence continues in numerical order. An exception to this is the abacus (Lambek (1961), Minsky (1961)) counter machine models—every instruction has at least one [...] "next" [...] instruction identifier [...] "z", and the <b>conditional</b> <b>branch</b> has two.|$|E
2500|$|CCS (count, compare, and skip): A complex <b>conditional</b> <b>branch</b> instruction. The A {{register}} {{was loaded}} with data retrieved from the address specified by the instruction. (Because the AGC uses ones' complement notation, there are two representations of zero. When all bits are set to zero, this is called plus zero. If all bits are set to one, this is called minus zero.) The diminished absolute value (DABS) of the data was then computed and stored in the A register. If the number was greater than zero, the DABS decrements the value by 1; if the number was negative, it is complemented before the decrement is applied—this is the absolute value. Diminished means [...] "decremented but not below zero". Therefore, when the AGC performs the DABS function, positive numbers will head toward plus zero, and so will negative numbers but first revealing their negativity via the four-way skip below. The final step in CCS is a four-way skip, depending upon the data in register A before the DABS. If register A was greater than 0, CCS skips to the first instruction immediately after CCS. If register A contained plus zero, CCS skips to the second instruction after CCS. Less than zero causes a skip to the third instruction after CCS, and minus zero skips to the fourth instruction after CCS. The {{primary purpose of the}} count was to allow an ordinary loop, controlled by a positive counter, to end in a CCS and a TC {{to the beginning of the}} loop, equivalent to an IBM 360's BCT. The absolute value function was deemed important enough to be built into this instruction; when used for only this purpose, the sequence after the CCS was TC *+2, TC *+2, AD ONE. A curious side effect was the creation and use of CCS-holes when the value being tested was known to be never positive, which occurred more often than one might suppose. That left two whole words unoccupied, and a special committee was responsible for assigning data constants to these holes.|$|E
5000|$|On {{a system}} that uses <b>conditional</b> <b>branching,</b> this might {{translate}} to machine instructions looking similar to: ...|$|R
5000|$|... <b>conditional</b> <b>branching</b> (program e selects {{between two}} results {{depending}} on the value it computes for f(i,i)), ...|$|R
40|$|International audienceMultimedia {{scenarios}} have {{multimedia content}} and inter- active events associated with computer programs. Inter- active Scores (IS) is a formalism to represent such sce- narios by temporal objects, temporal relations (TRs) and interactive events. IS describe TRs, but IS cannot repre- sent TRs together with <b>conditional</b> <b>branching.</b> We propose {{a model for}} <b>conditional</b> <b>branching</b> timed IS in the Non- deterministic Timed Concurrent Constraint (ntcc) calculus...|$|R
5000|$|... 4KiB <b>conditional</b> <b>branch</b> predictor, 256-entry {{indirect}} branch predictor ...|$|E
50|$|The {{instruction}} set {{does not contain}} <b>conditional</b> <b>branch</b> instructions. Instead, it contains conditional skip instructions which cause the following instruction to be ignored. A conditional skip followed by an unconditional branch performs a <b>conditional</b> <b>branch.</b> The skip instructions test any bit of any register. The ALU status register is one possibility.|$|E
5000|$|The NZT {{instruction}} {{allows a}} <b>conditional</b> <b>branch</b> to be implemented.|$|E
50|$|There {{are three}} types of {{unconditional}} and <b>conditional</b> <b>branching</b> in the 1802, Short and Long, and Skips.|$|R
50|$|The {{following}} example demonstrates <b>conditional</b> <b>branching.</b> It requests {{the current}} temperature in Fahrenheit and {{comments on the}} answer.|$|R
40|$|Abstract. This article {{presents}} {{an approach to}} {{reducing the number of}} instructions that organize <b>conditional</b> <b>branches</b> in designing a FPGA-based 8 -bit RISC SMCore microcontroller. The logical conditions for setting the flags of the status register are defined. A method for organizing all <b>conditional</b> <b>branches</b> with only two instructions is offered, the architectural features of the microcontroller being considered. The components realizing the “Skip ” mechanism in VHDL are shown...|$|R
5000|$|Highly unusual are the <b>conditional</b> <b>branch</b> to, {{and return}} from, a subroutine: ...|$|E
5000|$|Executing {{a set of}} {{statements}} only if some condition is met (choice - i.e., <b>conditional</b> <b>branch)</b> ...|$|E
5000|$|Executing {{a set of}} {{statements}} zero or more times, until some condition is met (i.e., loop - the same as <b>conditional</b> <b>branch)</b> ...|$|E
40|$|The one way {{function}} {{based on}} Collatz problem is proposed. While Colatz ($ 3 x+ 1 $) problem {{is well known}} and undecided, the proposal is actually based on the problem's underlying <b>conditional</b> <b>branching</b> structure. The analysis shows why the $ 3 x+ 1 $ problem is so difficult and how the algorithm <b>conditional</b> <b>branching</b> structure {{can be used to}} construct an one way function. Comment: 8 pages 1 figur...|$|R
40|$|Although {{there are}} widely known {{solutions}} for dataflow-dominated resource constrained high-level synthesis (HLS) problems, optimization of hardware resources under time-constraints in controlintensive systems {{is still a}} challenge. This paper examines the case when functional pipelining is used to increase the throughput of the system. The traditional concept of mutually exclusive <b>conditional</b> <b>branches</b> must be dropped and new methods are needed to exploit the resource sharing possibilities of <b>conditional</b> <b>branches.</b> We developed new methodologies able to exploit the resource sharing possibilities under these circumstances and extended the two schedulers and the allocation module of the HLS tool PIPE to handle arbitrarily nested conditional structures and demonstrated the improved resource utilization on control-intensive benchmarks. Keywords: <b>conditional</b> <b>branches,</b> functional pipelining, time-constrained scheduling, allocation, HLS. 1...|$|R
40|$|Abstract- In its {{traditional}} form, the cyclic genetic algorithm (CGA) {{was found to}} be a successful method for evolving single loop control programs for legged robots. Its major limitation was the inability to allow for <b>conditional</b> <b>branching,</b> which is required for the integration of sensor inputs in the controller. In recent work, we extended the capabilities of CGAs to evolve multi-loop programs with <b>conditional</b> <b>branching.</b> The design proved successful for the evolution of a controller that allowed a robot to efficiently search for a static target in a square area. In this paper we increase the complexity of the experiment and demonstrate the capability of CGAs with <b>conditional</b> <b>branching</b> to generate a controller for the predator in a predator-prey scenario...|$|R
50|$|Branch target {{prediction}} {{is not the}} same as branch prediction which attempts to guess whether a <b>conditional</b> <b>branch</b> will be taken or not-taken (i.e., sequential).|$|E
50|$|An {{alternative}} to <b>conditional</b> <b>branch</b> instructions is predication. Predication is an architectural feature that enables instructions to be conditionally executed instead of modifying the control flow.|$|E
5000|$|... {{where the}} CB is the <b>conditional</b> <b>branch</b> {{instruction}} or [...] "combination card' {{used to make}} the control flow jump, in this case backwards by 11 cards.|$|E
3000|$|... (ii)transformations {{that add}} new {{conditional}} control-flow paths into the program. For example, branch optimization can introduce new <b>conditional</b> <b>branches.</b>|$|R
3000|$|... 0 [*]=[*] 510, {{the maximum}} error of the {{proposed}} estimator remains similar to other estimators that have <b>conditional</b> <b>branches.</b>|$|R
2500|$|... {{full set}} of signed & {{unsigned}} <b>conditional</b> <b>branches</b> compare between two registers (e.g. BGTUC) or a register against zero (e.g. BGTZC), ...|$|R
