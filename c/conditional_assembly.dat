10|4|Public
5000|$|In the IBM <b>conditional</b> <b>assembly</b> language, {{the most}} {{important}} statements are: ...|$|E
50|$|Unlike the Atari Assembler Editor, MAC/65 {{provides}} macro {{processing and}} <b>conditional</b> <b>assembly.</b>|$|E
50|$|A <b>conditional</b> <b>assembly</b> {{language}} {{is that part}} of an assembly language used to write macros.|$|E
5000|$|TPS was a {{structured}} document editor. That is, it internally treated a document {{as a set}} of element classes, each with its own set of properties. Classes might include common document elements such as a body, paragraphs, titles, subheadings, captions, etc. Authors were free to create any set of elements and save them as a reusable template. The properties of a class [...] - [...] its font size, for example [...] - [...] could be changed and automatically applied to every instance of that class. If this caused a change in pagination [...] - [...] increasing the font size could change where the page breaks were [...] - [...] the software would update the screen quickly enough for the author to continue typing, including altering all of the cross-references that the author may have inserted; this WYSIWYG capability was a competitive advantage for the company. The structured nature of the documents also enabled TPS to provide <b>conditional</b> document <b>assembly,</b> a feature that enabled users to [...] "tag" [...] document elements with metadata about them, and then automatically assemble versions of the document based upon those tags. For example, an aircraft manufacturer might tag paragraphs with the model number of the planes to which they applied and then assemble versions of the documentation specific to each model.|$|R
40|$|A {{widespread}} {{usage of}} new advanced high strength TWIP steels in {{the automotive industry}} is <b>conditional</b> on proper <b>assembly</b> operations by welding. Therefore, {{the effects of the}} main important process parameters on the mechanical and microstructural properties of resistance spot welded TWIP sheets are examined here. The welding parameters used were welding current, clamping force, and welding time. An L- 9 (33) orthogonally array was used to design the experimental tests. The mechanical response of the welded joints was assessed by tensile shear tests and Vickers microhardness measurements. The effect of the welding parameters on the fracture mode of the tensile shear specimens was also investigated. Some combinations of the welding process parameters guaranteed acceptable tensile shear strengths for the automotive industry. The tensile shear samples mainly failed by interfacial fracture mode, while partial thickness with pull out fractures were observed in the samples welded with the highest welding current and clamping force. Improper clamping force and welding current promoted excessive metal expulsions and, in turn, the formation of welding defects in the weld spot...|$|R
40|$|International Telemetering Conference Proceedings / October 22 - 25, 1984 / Riviera Hotel, Las Vegas, NevadaSoftware for {{real-time}} (time critical) control applications {{has been}} shown in military and industry studies to be a very expensive type of software effort. This type of software is not typically addressed in discussions of software architecture design methods and techniques, therefore the software engineer is usually left with a sparse design “tool kit” when confronted with overall system design involving time critical and/or control problems. This paper outlines the successful application of data flow and transaction analysis design methods to achieve a structured yet flexible software architecture for a fairly complex antenna controller used in automatic tracking antenna systems. Interesting adaptations of, and variations on, techniques described in the literature are discussed; as are issues of modularity, coupling, morphology, global data handling, and evolution (maintenance). Both positive and negative aspects of this choice of design method are outlined, and the importance of a capable real-time executive and <b>conditional</b> compilation and <b>assembly</b> is stressed...|$|R
50|$|COMPASS is a {{classical}} two-pass assembler with macro and <b>conditional</b> <b>assembly</b> features, and generates a full listing showing both the source assembly code and the generated machine code (in octal). CDC's operating systems were written almost entirely in COMPASS assembly language.|$|E
50|$|COMPASS is {{an acronym}} for COMPrehensive ASSembler. COMPASS is any {{of a family of}} macro {{assembly}} languages on Control Data Corporations 3000 series, and on the 60-bit CDC 6000 series, 7600 and Cyber 70 and 170 series mainframe computers. While the architectures are very different, the macro and <b>conditional</b> <b>assembly</b> facilities are similar.|$|E
50|$|Because of {{the limited}} {{capacity}} of even large processors of that era every CICS installation was required to assemble the source code {{for all of the}} CICS system modules after completing a process similar to system generation (sysgen), called CICSGEN, to establish values for <b>conditional</b> <b>assembly</b> language statements. This process allowed each customer to exclude support from CICS itself for any feature they did not intend to use, such as device support for terminal types not in use.|$|E
40|$|Complex I (NADH:ubiquinone oxidoreductase) is {{the largest}} multiprotein enzyme of the {{oxidative}} phosphorylation system. Its assembly in human cells is poorly understood and no proteins assisting this process have yet been described. A good candidate is NDUFAF 1, the human homologue of Neurospora crassa complex I chaperone CIA 30. Here, we demonstrate that NDUFAF 1 is a mitochondrial protein that {{is involved in the}} complex I assembly process. Modulating the intramitochondrial amount of NDUFAF 1 by knocking down its expression using RNA interference leads to a reduced amount and activity of complex I. NDUFAF 1 is associated to two complexes of 600 and 700 kDa in size of which the relative distribution is altered in two complex I deficient patients. Analysis of NDUFAF 1 expression in a <b>conditional</b> complex I <b>assembly</b> system shows that the 700 kDa complex may represent a key step in the complex I assembly process. Based on these data, we propose that NDUFAF 1 is an important protein for the assembly/stability of complex I...|$|R
5000|$|RT-11 {{was written}} in {{assembly}} language. Heavy use of the <b>conditional</b> <b>assembly</b> and macro programming features of the MACRO-11 assembler allowed a significant degree of configurability and allowed programmers to specify high-level instructions otherwise unprovided for in machine code. RT-11 distributions included the source code of the operating system and its device drivers with all the comments removed and a program named [...] "SYSGEN" [...] which would build the operating system and drivers according to a user-specified configuration. Developer's documentation included a kernel listing that included comments.|$|E
50|$|By {{the late}} 1950s the macro {{language}} {{was followed by}} the Macro Assemblers. This was a combination of both where one program served both functions, that of a macro pre-processor and an assembler in the same package. This allowed assembly language programmers to implement their own macro-language and allowed limited portability of code between two machines running the same CPU but different operating systems, for example, early versions of MSDOS and CPM-86. The macro library would need to be written for each target machine but not the overall assembly language program. Note that more powerful macro assemblers allowed use of <b>conditional</b> <b>assembly</b> constructs in macro instructions that could generate different code on different machines or different operating systems, reducing the need for multiple libraries.|$|E
50|$|Historically, {{bootstrapping}} also {{refers to}} an early technique for computer program development on new hardware. The technique described in this paragraph {{has been replaced by}} the use of a cross compiler executed by a pre-existing computer. Bootstrapping in program development began during the 1950s when each program was constructed on paper in decimal code or in binary code, bit by bit (1s and 0s), because there was no high-level computer language, no compiler, no assembler, and no linker. A tiny assembler program was hand-coded for a new computer (for example the IBM 650) which converted a few instructions into binary or decimal code: A1. This simple assembler program was then rewritten in its just-defined assembly language but with extensions that would enable the use of some additional mnemonics for more complex operation codes. The enhanced assembler's source program was then assembled by its predecessor's executable (A1) into binary or decimal code to give A2, and the cycle repeated (now with those enhancements available), until the entire instruction set was coded, branch addresses were automatically calculated, and other conveniences (such as <b>conditional</b> <b>assembly,</b> macros, optimisations, etc.) established. This was how the early assembly program SOAP (Symbolic Optimal Assembly Program) was developed. Compilers, linkers, loaders, and utilities were then coded in assembly language, further continuing the bootstrapping process of developing complex software systems by using simpler software.|$|E
40|$|This {{document}} {{describes the}} UT-MIX system {{used at the}} University of Texas. UT-MIX is a complete implementation of the MIX machine, as described by Knuth, and includes significant extensions This doctment describes the differences and extensions to the basic MIX system defined by Knuth. It is intended primarily as a user's reference manual. The basic configuration instruction set, assembly ianguage macro and <b>conditional</b> <b>assembly</b> instructions and input/output system are described. This document is a revision of an earlier reerence manual prepared and published by the Department of Computer Sciences at the University of Texas at Austin. The current revision was prepared and editted by Professor J L Peterson. The previous versions were not identified as to author Any comments corrections or suggestions concerning the present revision should be directed to: James L Peterson Department of Computer Sciences The University of Texas Austin, Texas 78712 (512) 471 - 4353 i TABLE OF CONNTS THE UT-MIX SYSTEM [...] 2 2. 1 Access to UT-MIX [...] 2 2. 1. 1 Control Cards and Job Parameters [...] 2 2. 1. 2 Deck Structure [...] . 3 2. 2 Central Processor and Memory [...] 3 2. 2. 1 Words [...] 3 2. 2. 2 Registers [...] 3 2. 2. 3 MIX Memory [...] . 4 2. 2. 4 Indirect Addressing [...] . 4 2. 2. 5 Instruction Timing [...] . 5 2. 3 Input-Output Devices [...] 5 2. 3. 1 Magnetic Tapes [...] Units 0, 1 [...] . 5 2. 3. 2 Magnetic Disks [...] Units 8, 9 [...] . 5 2. 3. 3 Magnetic Drum [...] Unit 10 [...] 6 2. 3. 4 Card Reader [...] Unit 16 [...] . 6 2. 3. 5 Card Punch [...] Unit 17 [...] 6 2. 3. 6 Line Primter [...] Unit 18 [...] . 6 2. 4 Clocks [...] ...|$|E

