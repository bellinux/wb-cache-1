44|65|Public
5|$|In this context, a {{dependency}} graph is a graph {{that has}} a vertex for each object to be updated, and an edge connecting two objects whenever one of them needs to be updated earlier than the other. A cycle in this graph is called a <b>circular</b> <b>dependency,</b> and is generally not allowed, because {{there would be no}} way to consistently schedule the tasks involved in the cycle.|$|E
25|$|Name servers in {{delegations}} {{are identified}} by name, {{rather than by}} IP address. This means that a resolving name server must issue another DNS request {{to find out the}} IP address of the server to which it has been referred. If the name given in the delegation is a subdomain of the domain for which the delegation is being provided, there is a <b>circular</b> <b>dependency.</b>|$|E
500|$|This {{declares}} {{the class}} member method where the program begins execution. The [...]NET runtime calls the [...] method. (Note: [...] {{may also be}} called from elsewhere, like any other method, e.g. from another method of [...]) The [...] keyword makes the method accessible without an instance of [...] Each console application's [...] entry point must be declared [...] Otherwise, the program would require an instance, but any instance would require a program. To avoid that irresolvable <b>circular</b> <b>dependency,</b> C# compilers processing console applications (like that above) report an error, {{if there is no}} [...] method. The [...] keyword declares that [...] has no return value.|$|E
50|$|In {{very large}} {{software}} designs, software engineers may lose the context and inadvertently introduce <b>circular</b> <b>dependencies.</b> There are tools to analyze software and find unwanted <b>circular</b> <b>dependencies.</b>|$|R
50|$|<b>Circular</b> <b>dependencies</b> {{are often}} {{introduced}} by inexperienced programmers {{who need to}} implement some kind of callback functionality. Experienced programmers avoid such unnecessary <b>circular</b> <b>dependencies</b> by applying design patterns like the observer pattern.|$|R
50|$|<b>Circular</b> <b>dependencies</b> {{can cause}} a domino effect when a small local change in one module spreads into other modules and has {{unwanted}} global effects (program errors, compile errors). <b>Circular</b> <b>dependencies</b> can also result in infinite recursions or other unexpected failures.|$|R
2500|$|For example, if the {{authoritative}} name server for example.org is ns1.example.org, a computer {{trying to resolve}} www.example.org first resolves ns1.example.org. Since ns1 is contained in example.org, this requires resolving example.org first, which presents a <b>circular</b> <b>dependency.</b> To break the dependency, the name server for the top level domain org includes glue along with the delegation for example.org. [...] The glue records are address records that provide IP addresses for ns1.example.org. The resolver uses {{one or more of}} these IP addresses to query one of the domain's authoritative servers, which allows it to complete the DNS query.|$|E
5000|$|In case of <b>circular</b> <b>dependency,</b> this {{back-pressure}} {{can lead}} to deadlock.|$|E
5000|$|PARSEC {{was created}} to break this <b>circular</b> <b>dependency.</b> It was {{designed}} to fulfill the following five objectives: ...|$|E
5|$|<b>Dependency</b> graphs without <b>circular</b> <b>dependencies</b> form DAGs.|$|R
50|$|<b>Circular</b> <b>dependencies</b> {{are natural}} in many domain models where certain objects {{of the same}} domain depend on each other. However, in {{software}} design <b>circular</b> <b>dependencies</b> between larger software modules are considered an anti-pattern because of their negative effects. Mutually recursive modules are, however, somewhat common in functional programming, where inductive and recursive definitions are often encouraged.|$|R
5000|$|Note {{that there}} are <b>circular</b> <b>dependencies</b> among the {{formulas}} for , [...] and [...] This naturally suggests an EM-like algorithm: ...|$|R
50|$|In {{software}} engineering, a <b>circular</b> <b>dependency</b> is {{a relation}} between {{two or more}} modules which {{either directly or indirectly}} depend on each other to function properly. Such modules are also known as mutually recursive.|$|E
50|$|The sbt project uses sbt {{to build}} itself, and {{considers}} that dogfooding {{is a positive}} feature. To the Debian project, however, that is considered a <b>circular</b> <b>dependency,</b> that they try to minimize. As a result, sbt is not yet in Debian.|$|E
5000|$|Assume {{the simple}} {{calculator}} from before. The equation system [...] "A=B; B=D+C; C=D+A; D=12;" [...] contains a <b>circular</b> <b>dependency</b> formed by A, B and C, as B must be evaluated before A, C must be evaluated before B and A must be evaluated before C.|$|E
50|$|Recalculation {{generally}} {{requires that}} there are no <b>circular</b> <b>dependencies</b> in a spreadsheet. A dependency graph is a graph that has a vertex for each object to be updated, and an edge connecting two objects whenever one of them needs to be updated earlier than the other. <b>Dependency</b> graphs without <b>circular</b> <b>dependencies</b> form directed acyclic graphs, representations of partial orderings (in this case, across a spreadsheet) that can be relied upon to give a definite result.|$|R
50|$|<b>Circular</b> <b>dependencies</b> {{may also}} cause memory leaks by {{preventing}} certain very primitive automatic garbage collectors (those that use reference counting) from deallocating unused objects.|$|R
50|$|In a {{dependency}} graph, {{the cycles}} of <b>dependencies</b> (also called <b>circular</b> <b>dependencies)</b> lead to {{a situation in which}} no valid evaluation order exists, because none of the objects in the cycle may be evaluated first. If a dependency graph does not have any <b>circular</b> <b>dependencies,</b> it forms a directed acyclic graph, and an evaluation order may be found by topological sorting. Most topological sorting algorithms are also capable of detecting cycles in their inputs, however, it may be desirable to perform cycle detection separately from topological sorting in order to provide appropriate handling for the detected cycles.|$|R
50|$|Name servers in {{delegations}} {{are identified}} by name, {{rather than by}} IP address. This means that a resolving name server must issue another DNS request {{to find out the}} IP address of the server to which it has been referred. If the name given in the delegation is a subdomain of the domain for which the delegation is being provided, there is a <b>circular</b> <b>dependency.</b>|$|E
5000|$|Next, {{it calls}} the [...] {{function}} which loops {{through all the}} services marked as auto-start, {{paying attention to the}} calculated load-order dependencies. In case of a <b>circular</b> <b>dependency</b> an error is noted and the service depending on a service that belongs to a group coming later in the load order is skipped. For delayed auto-start services, grouping has no effect, and those are loaded at a later stage of system startup.|$|E
50|$|Implementation of {{circular}} dependencies in C/C++ {{can be a}} bit tricky, {{because any}} class or structure definition must be placed above its usage in the same file. A <b>circular</b> <b>dependency</b> between classes A and B will thus both require the definition of A to be placed above B, and the definition of B to be placed above A, which of course is impossible. A forward declaration is therefore needed to accomplish this.|$|E
40|$|The use of {{components}} to construct simulation models has many advantages and {{the technique is}} being used by many authors. However, in agro-ecological simulation there are some practical problems relating to the occurrence of <b>circular</b> <b>dependencies</b> between components and to tightly linked components. The objective {{of this paper is}} to present practical solutions to these problems. <b>Circular</b> <b>dependencies</b> are addressed by the introduction of a specialized component. Likewise, the degree of linking between component models can in some cases be reduced by introducing a specialized component. The practical problems that have cropped up in our work were successfully addressed and re-use of our component models has become more intuitive...|$|R
50|$|<b>Circular</b> <b>dependencies</b> {{can cause}} many {{unwanted}} effects in software programs. Most problematic from a software design {{point of view}} is the tight coupling of the mutually dependent modules which reduces or makes impossible the separate re-use of a single module.|$|R
50|$|A useful {{property}} of self-stabilizing algorithms {{is that they}} can be composed of layers if the layers do not exhibit any <b>circular</b> <b>dependencies.</b> The stabilization time of the composition is then bounded by the sum of the individual stabilization times of each layer.|$|R
50|$|For example, if the {{authoritative}} name server for example.org is ns1.example.org, a computer {{trying to resolve}} www.example.org first resolves ns1.example.org. Since ns1 is contained in example.org, this requires resolving example.org first, which presents a <b>circular</b> <b>dependency.</b> To break the dependency, the name server for the top level domain org includes glue along with the delegation for example.org. The glue records are address records that provide IP addresses for ns1.example.org. The resolver uses {{one or more of}} these IP addresses to query one of the domain's authoritative servers, which allows it to complete the DNS query.|$|E
5000|$|This {{declares}} {{the class}} member method where the program begins execution. The [...]NET runtime calls the [...] method. (Note: [...] {{may also be}} called from elsewhere, like any other method, e.g. from another method of [...]) The [...] keyword makes the method accessible without an instance of [...] Each console application's [...] entry point must be declared [...] Otherwise, the program would require an instance, but any instance would require a program. To avoid that irresolvable <b>circular</b> <b>dependency,</b> C# compilers processing console applications (like that above) report an error, {{if there is no}} [...] method. The [...] keyword declares that [...] has no return value.|$|E
50|$|The root servers {{have the}} {{official}} names a.root-servers.net to m.root-servers.net. To resolve these names into addresses, a DNS resolver must first find an authoritative server for the net zone. To avoid this <b>circular</b> <b>dependency,</b> {{the address of}} at least one root server must be known for bootstrapping access to the DNS. For this purpose operating systems or DNS server or resolver software packages typically include a file with all addresses of the DNS root servers. Even if the IP addresses of some root servers change over the years, at least one is needed to retrieve the current list of all name servers. This address file is called named.cache in the BIND name server reference implementation. The current official version is distributed by ICANN's InterNIC.|$|E
40|$|This thesis {{presents}} a concept for controlling {{the exchange of}} data in computational networks forming integrated design models. Its primary focus is on managing <b>circular</b> <b>dependencies</b> which may lead to an infinite propagation of changes of design parameter values through the system without converging to a final solution. The proposed technique applies graph algorithms to analyze the topology of the network and to locate its components with <b>circular</b> <b>dependencies.</b> These parts are encapsulated and solved separately. It is shown that by determining their feedback vertex sets their solving can be formulated as root finding problems of systems of equations of minimal dimensionality. The implementation of this concept, a software program that provides a collection of numerical search methods for solving systems of equations, is described. This collection includes algorithms specialized on root finding and techniques for local and global optimization...|$|R
5000|$|Packages {{may come}} from within a {{particular}} distribution (for example Red Hat Enterprise Linux) or be built for it by other parties (for example RPM Fusion for Fedora). <b>Circular</b> <b>dependencies</b> among mutually dependent RPMs (so-called [...] "dependency hell") can be problematic; in such cases a single installation command needs to specify all the relevant packages.|$|R
40|$|The Composite {{design pattern}} is a {{well-known}} implementation of whole-part relationships with trees of Composite objects. This paper presents a permission-based specification of the Composite pattern that allows nodes in an object hierarchy to depend on invariants over their children while permitting clients to add new children to any node in the hierarchy at any time. Permissions can capture the <b>circular</b> <b>dependencies</b> between nodes and their children that arise in this context. The paper also discusses verifying a Composite implementation and known limitations of the presented specification...|$|R
50|$|Directed acyclic graphs {{representations}} of partial orderings have many applications in scheduling for systems of tasks with ordering constraints.An important class of problems {{of this type}} concern collections of objects {{that need to be}} updated, such as the cells of a spreadsheet after one of the cells has been changed, or the object files of a piece of computer software after its source code has been changed.In this context, a dependency graph is a graph that has a vertex for each object to be updated, and an edge connecting two objects whenever one of them needs to be updated earlier than the other. A cycle in this graph is called a <b>circular</b> <b>dependency,</b> and is generally not allowed, because there would be no way to consistently schedule the tasks involved in the cycle.Dependency graphs without circular dependencies form DAGs.|$|E
40|$|Recent {{research}} has shown that MT-based sentence alignment is a robust approach for noisy parallel texts. However, using Machine Translation for sentence alignment causes a chicken-and-egg problem: to train a corpus-based MT system, we need sentence-aligned data, and MT-based sentence alignment depends on an MT system. We describe a bootstrapping approach to sentence alignment that resolves this <b>circular</b> <b>dependency</b> by computing an initial alignment with length-based methods. Our evaluation shows that iterative MT-based sentence alignment significantly outperforms widespread alignment approaches on our evaluation set, without requiring any linguistic resources other than the to-be-aligned bitext...|$|E
40|$|We study FJf, a {{concurrent}} object calculus {{with future}} types and operations {{for getting the}} values and releasing the control. Programs in FJf may manifest locks (deadlocks or livelocks) due to badly programmed release points. In order to statically detect possible misbehaviours, we develop a technique for the lock analysis based on contracts, which are abstract descriptions of method’s behaviours. Contracts are derived by a type inference algorithm and are modeled by finite state automata whose states retain information on caller-callee dependencies. A potential lock is detected when a <b>circular</b> <b>dependency</b> is found in some state of the automata...|$|E
40|$|Abstract—We generalize {{the theory}} of {{permutations}} of names to so-called mutations that transform tuples by introducing duplicates and fresh names. The theory of mutations underpins an algorithm for detecting deadlocks (i. e. <b>circular</b> <b>dependencies</b> between resources) in a model defining dependencies – the language for lams. We demonstrate that our algorithm is a decision procedure for so-called linear lams while it is imprecise but sound in the general case. As a consequence of our results, deadlock analyzers for programming languages may be specified by defining an association programs/lams. I...|$|R
2500|$|Since October 2005, {{only the}} stage3 {{installations}} have been officially supported, {{due to the}} inherent complexities of bootstrapping from earlier stages (which requires resolving and then breaking numerous <b>circular</b> <b>dependencies).</b> Tarballs for stage1 and stage2 were distributed for some time after this, although the instructions for installing from these stages {{had been removed from}} the handbook and moved into the Gentoo FAQ. , only the supported stage3 tarballs are publicly available; stage1 and stage2 tarballs are only [...] "officially" [...] generated and used internally by Gentoo development teams. However, if so desired, a user may still rebuild the toolchain or reinstall the base system software during or after a normal stage3 installation, effectively simulating the old bootstrap process.|$|R
40|$|We {{introduce}} a basic model for contracts. Our model extends event structures {{with a new}} relation, which faithfully captures the <b>circular</b> <b>dependencies</b> among contract clauses. We establish whether an agreement exists which respects all the contracts at hand (i. e. all the dependencies can be resolved), and we detect the obligations of each participant. The main technical contribution is a correspondence between our model and a fragment of the contract logic PCL [6]. More precisely, we show that the reachable events are exactly those which correspond to provable atoms in the logic. Despite of this strong correspondence, our model improves [6] by exhibiting a finer-grained notion of culpability, which {{takes into account the}} legitimate orderings of events. ...|$|R
