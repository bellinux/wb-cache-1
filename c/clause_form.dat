64|303|Public
5000|$|... the {{attestation}} proper, {{either in}} <b>clause</b> <b>form</b> or broken out into averments; ...|$|E
5000|$|As an example, {{the formula}} saying [...] "Anyone who loves all animals, is in turn loved by someone" [...] is {{converted}} into CNF (and subsequently into <b>clause</b> <b>form</b> {{in the last}} line) as follows (highlighting replacement rule redices in [...] ): ...|$|E
5000|$|The Establishment Clause {{together}} with the Free Exercise <b>Clause</b> <b>form</b> the constitutional right of freedom of religion that is protected by the First Amendment to the United States Constitution. The relevant constitutional text is: [...] "Congress shall make no law respecting an establishment of religion, or prohibiting the free exercise thereof..." ...|$|E
5000|$|Past participles, or participial phrases (<b>clauses)</b> <b>formed</b> from them, {{are used}} as follows: ...|$|R
5000|$|The present participle, or participial phrases (<b>clauses)</b> <b>formed</b> from it, {{are used}} as follows: ...|$|R
5000|$|The interrogatives tend to {{have two}} forms, {{in the case of}} three a reduced <b>clause</b> initial <b>form</b> and a fuller <b>clause</b> final <b>form,</b> as in the {{following}} example: ...|$|R
50|$|Plaisted's {{research}} interests include term rewriting systems, automated theorem proving, logic programming, and algorithms. His research accomplishments in theorem proving include work on the recursive path ordering, the associative path ordering, abstraction, the simplified and modified problem reduction formats, ground reducibility,nonstandard <b>clause</b> <b>form</b> translations, rigid E-unification, Knuth-Bendix completion, replacement rules in theorem proving, instance-based theorem proving strategies, and semantics in theorem proving.|$|E
40|$|Most {{resolution}} theorem provers {{convert a}} theorem into <b>clause</b> <b>form</b> before attempting {{to find a}} proof. The conventional translation of a first-order formula into <b>clause</b> <b>form</b> often obscures {{the structure of the}} formula, and may increase the length of the formula by an exponential amount in the worst case. We present a non-standard <b>clause</b> <b>form</b> translation that preserves more {{of the structure of the}} formula than the conventional translation. This new translation also avoids the exponential increase in size which may occur with the standard translation. We show how this idea may be combined with the idea of replacing predicates by their definitions before converting to <b>clause</b> <b>form.</b> We give a method of lock resolution which is appropriate for the non-standard <b>clause</b> <b>form</b> translation, and which has yielded a spectacular reduction in search space and time for one example. These techniques should increase the attractiveness of resolution theorem provers for program verification applications, since the theorems that arise in program verification are often simple but tedious for humans to prove...|$|E
40|$|A new {{technique}} is presented for computing minimal diagnoses of a system, based on Reiter's theory of diagnosis from first principles. Modifications to the technique are introduced that restrict the diagnoses generated to those representing single faults. This approach does {{not rely on}} a <b>clause</b> <b>form</b> representation (although it is applicable to systems represented in <b>clause</b> <b>form),</b> nor does it require generating the set of minimal conflicts. Experimental results are presented in which the performance of an implementation of these techniques on commonly used benchmark problems is measured...|$|E
5000|$|In {{the third}} {{conditional}} (where the condition clause expresses a counterfactual past condition; this may also {{occur in the}} mixed conditional), the condition <b>clause</b> <b>formed</b> with the auxiliary had can be inverted: ...|$|R
40|$|Theorem prover for first-order logic usually {{operate on}} a set of clauses. Since it is more natural and {{adequate}} to code problems in full first-order logic, the problem of translating a formula into <b>clause</b> normal <b>form</b> is an important one in this field. From experience we know that a theorem prover can find a proof more easily with a compact <b>clause</b> normal <b>form</b> than with a huge set of clauses. In this thesis we present powerful methods to obtain compact <b>clause</b> normal <b>forms...</b>|$|R
50|$|Scrutton LJ {{found the}} {{exclusion}} <b>clause</b> <b>formed</b> {{part of the}} contract. It was immaterial that L'Estrange had not read the clause. The fact that she signed it meant that she was bound by it. She is deemed to have read and agreed {{to the terms of}} the contract.|$|R
40|$|In {{this paper}} we {{illustrate}} {{by means of}} an example, namely SHn-logics, a method for translation to <b>clause</b> <b>form</b> and automated theorem proving for first-order manyvalued logics based on distributive lattices with operators. 1 Introduction The main goal {{of this paper is to}} present a method for translation to <b>clause</b> <b>form</b> and automated theorem proving in finitely-valued logics having as algebras of truth values distributive lattices with certain types of operators. Many non-classical logics that occur in practical applications fall in this class. One of the advantages of distributive lattices (with well-behaved operators) is the existence, in such cases, of good representation theorems, such as the Priestley representation theorem. The method for translation to <b>clause</b> <b>form</b> we present uses the Priestley dual of the algebra of truth values. The ideas behind this method are very natural, even if the algebraic notions used may at first sight seem involved. This is why in this paper we illustra [...] ...|$|E
40|$|Despite the {{widespread}} use and study of Boolean satisfiability for a diverse range of problem domains, encoding of problems is usually given to general propositional logic {{with little or no}} discussion of the conversion to <b>clause</b> <b>form</b> that will be necessary. In this paper we present a fast and easy to implement conversion to equisatisfiable <b>clause</b> <b>form</b> for Boolean circuits, a popular representation of propositional logic formulae. We show that the conversion is equivalent to that of Boy de la Tour and is hence optimal in the number of clauses produced for linear input formulae (formul excluding #), and we discuss the optimality for other input formulae...|$|E
40|$|In formalizing knowlege {{for common}} sense reasoning, one often needs to {{partition}} some domain. An instance of {{this from the}} block's world is the statement " All blocks are one of held, on the table, or on another block. " Although we can write such an axiom in predicate calculus using the standard logical connectives, or in <b>clause</b> <b>form</b> as input to a resolution theorem prover, such representations are highly space inefficient. A generalized <b>clause</b> <b>form</b> is presented that allows for the compact representation of arbitrary partitions, along {{with a set of}} corresponding inference rules whose soundness and refutation completeness are proven, Additionally, an implementation of a subset of these rules is described that demonstrates their utility with certain kinds of common sense rule bases. ...|$|E
5000|$|This clause is {{understood}} to grant Congress the power to enact copyright laws. The Copyright <b>Clause</b> <b>forms</b> the basis for both U.S. copyright law ("Science", [...] "Authors", [...] "Writings") and patent law ("useful Arts", [...] "Inventors", [...] "Discoveries"), and requires that these exclusive rights expire ("for limited Times").|$|R
25|$|It {{applies to}} {{underlying}} transitive <b>clauses</b> and <b>forms</b> a derived intransitive.|$|R
5000|$|It {{applies to}} {{underlying}} transitive <b>clauses</b> and <b>form</b> a derived intransitive.|$|R
40|$|Abstract. The Boolean {{circuits}} is {{well established}} as a data structure for building propositional encodings of problems in preparation for satisfiability solving. The standard method for converting Boolean circuits to <b>clause</b> <b>form</b> (naming every vertex) {{has a number of}} shortcomings. In this paper we give a projection of several well-known <b>clause</b> <b>form</b> conversions to a simplified form of Boolean circuit. We introduce a new conversion which we show is equivalent to that of Boy de la Tour in certain circumstances and is hence optimal in the number of clauses that it produces. We extend the algorithm to cover reduced Boolean circuits, a data structure used by the model checker NuSMV. We present experimental results for this and other conversion procedures on BMC problems demonstrating its superiority, and conclude that the CNF conversion has a significant role in reducing the overall solving time. ...|$|E
40|$|Abstract. Despite the {{widespread}} use and study of Boolean satisfiability for a diverse range of problem domains, encoding of problems is usually given to general propositional logic {{with little or no}} discussion of the conversion to <b>clause</b> <b>form</b> that will be necessary. In this paper we present a fast and easy to implement conversion to equisatisfiable <b>clause</b> <b>form</b> for Boolean circuits, a popular representation of propositional logic formulae. We show that the conversion is equivalent to that of Boy de la Tour and is hence optimal in the number of clauses produced for linear input formulae (formulæ excluding ↔), and we discuss the optimality for other input formulae. We present experimental results for this and other conversion procedures on BMC problems demonstrating its superiority, and conclude that the CNF conversion plays a large part in reducing the overall solving time. ...|$|E
40|$|Prolog is a logic {{programming}} language accepting {{a more general}} <b>clause</b> <b>form</b> than standard Prolog (hereditary Harrop formulas instead of Horn formulas) and using simply typed -terms as a term domain instead of first order terms. Despite these extensions, it is still amenable to goal-directed proofs and can still be given procedural semantics. However, the execution of Prolog programs requires several departures from the standard resolution scheme. First, the augmented <b>clause</b> <b>form</b> causes the program (a set of clauses) and the signature (a set of constants) to be changeable, but in a very disciplined way. Second, the new term domain introduces {{the need for a}} fi-reduction operation at run-time, and has a semi-decidable and infinitary unification theory. MALI is an abstract memory designed for storing the search-state of depth-first search processes. Its main feature is its efficient memory management. We have used an original Prolog-to-(C+MALI) translation: predicates are transformed into [...] ...|$|E
5000|$|They {{apply to}} {{underlying}} transitive <b>clauses</b> and <b>form</b> a derived intransitive.|$|R
40|$|In <b>clause</b> <b>forms</b> {{of a state}} {{ownership}} in the industry as object of management are considered. The general approaches to a choice of optimum necessary degree of influence of the state on groups of the concrete enterprises are formulated. Recommendations on organizational-legal perfection of a complex of the enterprises with the state participation are offered...|$|R
40|$|In <b>clause</b> <b>forms</b> of state-private {{partnership}} on {{attraction of}} investments into sphere of a railway transportation, including {{with use of}} means of Investment fund of the Russian Federation are considered. The special attention is given to directions of privatization and capitalization of Open Society "Russian railways", stimulation of en-terprise activity of private transport agencies...|$|R
40|$|We {{present a}} {{compiled}} implementation of λProlog {{that uses the}} abstract memory MALI for representing the execution state. λProlog is a logic programming language allowing a more general <b>clause</b> <b>form</b> than Standard Prolog's (namely hereditary Harrop formulas instead of Horn formulas) and using simply typed λ-terms as a term domain instead of first order terms. The augmented <b>clause</b> <b>form</b> causes the program (a set of clauses) and the signature (a set of constants) to be changeable in a very disciplined way. The new term domain has a semi-decidable and infinitary unification theory, and it introduces {{the need for a}} fi-reduction operation at run-time. MALI is an abstract memory that is suitable for storing the search-state of depth-first search processes. Its main feature is its efficient memory management. We have used an original λProlog-to-C translation along which predicates are transformed into functions operating on continuations for handling failure and success in unifications, and change [...] ...|$|E
40|$|Abstract. In {{this paper}} we {{establish}} {{a link between}} satisfiability of universal sentences with respect to varieties of distributive lattices with operators and satisfiability with respect to certain classes of relational structures. We use these results for giving a method for translation to <b>clause</b> <b>form</b> of universal sentences in such varieties, and then use results from automated theorem proving to obtain decidability and complexity results for the universal theory of some such varieties. ...|$|E
40|$|We {{show how}} {{a wide variety}} of role-based access control {{policies}} may be formally specified in the stratified subset of <b>clause</b> <b>form</b> logic. We then show how these formal specifications may be automatically translated into a small subset of SQL to be used to seamlessly protect a relational database from unauthorized read and update requests made by authenticated users. We demonstrate the power of our approach by showing how a variety of access control policies can be represented...|$|E
5000|$|A {{progressive}} aspect can {{be formed}} by connecting the verbal noun to the existential verb with the progressive particle [...] The object of a verbal noun {{is in the}} genitive, if it is definite. If a nonfinite <b>clause</b> <b>forms</b> the complement of the verb, the verbal noun stands alone (without a preposition) in the clause.|$|R
5000|$|... this, these: full form dhiswan, colloquial <b>form</b> dhisan, reduced, <b>clause</b> initial <b>form</b> san, sa ...|$|R
5000|$|Relative <b>clauses</b> are <b>formed</b> {{by adding}} a relativizing ('REL' below) suffix to the verb: ...|$|R
40|$|Abstract. We give a resolution-based {{procedure}} for deciding unifiability in {{the variety of}} bounded distributive lattices. The main idea {{is to use a}} structure-preserving translation to <b>clause</b> <b>form</b> to reduce the problem of testing the satisfiability of a unification problem S to the problem of checking the satisfiability of a set Φ S of (constrained) clauses. These ideas can be used for unification with free constants and for unification with linear constant restrictions. Complexity issues are also addressed...|$|E
40|$|In {{this paper}} we {{describe}} a project (IMPRESS) which utilised a Machine Learning Tool for the Valida-tion of an Air l+afic Control Domain Theory. During the project, novel ‘techniques were devised for the au-tomated revision of general <b>clause</b> <b>form</b> theories using training examples. This technique involves focusing {{in on the}} parts of a theory which involve ordinal sorts, and applying geometrical revision operators to repair faulty component parts. The method is illustrated with experimental results obtained during the project. 1...|$|E
40|$|This paper studies Petri net {{models for}} the Horn <b>clause</b> <b>form</b> of propositional logic and of first order {{predicate}} logic. A net model for logical inconsistency check is pro-posed. Algorithms for computing T·invariants of Petri net models of logical inference systems are investigated. The algorithms are ba 8 ed {{on the idea of}} resolution and exploit the presence of one-literal, pure-literal and splitting clauses to lead to faster computation. Algorithms for computing T-invariants of High Level Petri net models of predicate logic are presented...|$|E
5000|$|... that, those: full form dhaswan, colloquial <b>form</b> dhasan, reduced, <b>clause</b> initial <b>form</b> san, sa ...|$|R
40|$|The Satisfiability problem (SAT) is {{a famous}} NP-Complete problem, which {{consists}} of an assignment of Boolean variables (true or false) and some <b>clauses</b> <b>formed</b> of these variables. A clause is a disjunction of some Boolean literals and can be true {{if and only if}} any of them is true. A SAT instance is satisfied if and only if all the clauses are simultaneously true. As...|$|R
50|$|The syntax of a {{dependent}} clause is generally {{the same as}} that of an independent clause, except that the dependent clause usually begins with a subordinating conjunction or relative pronoun (or phrase containing such). In some situations (as already described) the conjunction or relative pronoun that can be omitted. Another type of dependent clause with no subordinating conjunction is the conditional <b>clause</b> <b>formed</b> by inversion (see below).|$|R
