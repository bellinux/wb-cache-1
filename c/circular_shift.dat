94|107|Public
25|$|The fast folding {{algorithm}} {{is analogous to}} the FFT, except that it operates on a series of binned waveforms rather than a series of real or complex scalar values. Rotation (which in the FFT is multiplication by a complex phasor) is a <b>circular</b> <b>shift</b> of the component waveform.|$|E
2500|$|Multiplying [...] by {{a linear}} phase [...] for some integer m {{corresponds}} to a <b>circular</b> <b>shift</b> of the output : [...] is replaced by , where the subscript is interpreted modulo N (i.e., periodically). [...] Similarly, a <b>circular</b> <b>shift</b> of the input [...] corresponds to multiplying the output [...] by a linear phase. Mathematically, if [...] represents the vector x then ...|$|E
5000|$|In {{combinatorial}} mathematics, a <b>circular</b> <b>shift</b> is {{the operation}} of rearranging the entries in a tuple, either by moving the final entry to the first position, while shifting all other entries to the next position, or by performing the inverse operation. A <b>circular</b> <b>shift</b> is {{a special kind of}} cyclic permutation, which in turn is a special kind of permutation. Formally, a <b>circular</b> <b>shift</b> is a permutation σ of the n entries in the tuple such that either ...|$|E
5000|$|... {{and then}} the {{sequence}} repeats; this four-tuple therefore has four distinct <b>circular</b> <b>shifts.</b> However, not all n-tuples have n distinct <b>circular</b> <b>shifts.</b> For instance, the 4-tuple (a, b, a, b) only has 2 distinct <b>circular</b> <b>shifts.</b> In general the number of <b>circular</b> <b>shifts</b> of an n-tuple could be any divisor of n, depending on the entries of the tuple.|$|R
50|$|The {{result of}} {{repeatedly}} applying <b>circular</b> <b>shifts</b> {{to a given}} tuple are also called the <b>circular</b> <b>shifts</b> of the tuple.|$|R
5000|$|The only {{operations}} {{used are}} XOR, <b>circular</b> <b>shifts</b> and S-Box applications ...|$|R
5000|$|... where [...] {{represents}} the complex conjugate and [...] represents a <b>circular</b> <b>shift.</b>|$|E
5000|$|Multiplying [...] by {{a linear}} phase [...] for some integer m {{corresponds}} to a <b>circular</b> <b>shift</b> of the output : [...] is replaced by , where the subscript is interpreted modulo N (i.e., periodically). Similarly, a <b>circular</b> <b>shift</b> of the input [...] corresponds to multiplying the output [...] by a linear phase. Mathematically, if [...] represents the vector x then ...|$|E
5000|$|CSHIFT <b>Circular</b> <b>shift</b> EOSHIFT End-off shift TRANSPOSE Transpose of {{an array}} of rank two ...|$|E
5000|$|For example, {{repeatedly}} applying <b>circular</b> <b>shifts</b> to the four-tuple (a, b, c, d) successively gives ...|$|R
30|$|Note that to work properly, the <b>circular</b> <b>shifting</b> network must support {{concurrent}} subrotations {{as described}} in [24].|$|R
50|$|Each {{of these}} five points has eight {{possible}} sign patterns and three possible <b>circular</b> <b>shifts,</b> giving a total of 120 different points.|$|R
5000|$|... #Caption: If 00010111 {{is a valid}} codeword, {{applying}} a right <b>circular</b> <b>shift</b> gives the string 10001011. If the code is cyclic, then 10001011 is again a valid codeword. In general, {{applying a}} right <b>circular</b> <b>shift</b> moves the least significant bit (LSB) to the leftmost position, so that it becomes the most significant bit (MSB); the other positions are shifted by 1 to the right.|$|E
5000|$|The scalar triple {{product is}} {{invariant}} under a <b>circular</b> <b>shift</b> of its three operands (a, b, c): ...|$|E
5000|$|Input: 101110001110 -> three segments: 1011, 1000, 1110.Iteration 1: segment: 1011 {{checksum}}: 0000 bitmask: 1111a) Apply <b>circular</b> <b>shift</b> to the checksum: 0000 -> 0000b) Add checksum and segment together, apply bitmask {{onto the}} obtained result: 0000 + 1011 = 1011 -> 1011 & 1111 = 1011Iteration 2: [...] segment: 1000 checksum: 1011 bitmask: 1111a) Apply <b>circular</b> <b>shift</b> to the checksum: 1011 -> 1101b) Add checksum and segment together, apply bitmask onto the obtained result: 1101 + 1000 = 10101 -> 10101 & 1111 = 0101Iteration 3: segment: 1110 checksum: 0101 bitmask: 1111a) Apply <b>circular</b> <b>shift</b> to the checksum: 0101 -> 1010b) Add checksum and segment together, apply bitmask onto the obtained result: 1010 + 1110 = 11000 -> 11000 & 1111 = 1000Final checksum: 1000 ...|$|E
3000|$|... is {{dependent}} on a preset gain threshold [7]. Inverse Fast Fourier transforms (FFT) along with <b>circular</b> <b>shifts</b> (hence the modeling delay) are needed to obtain causal FIR filters.|$|R
5000|$|Cartesian {{coordinates}} for the vertices of a truncated dodecadodecahedron {{are all the}} triples {{of numbers}} obtained by <b>circular</b> <b>shifts</b> and sign changes from the following points (where [...] is the golden ratio): ...|$|R
5000|$|<b>Circular</b> <b>shifts</b> {{are used}} often in {{cryptography}} {{in order to}} permute bit sequences. Unfortunately, many programming languages, including C, do not have operators or standard functions for <b>circular</b> <b>shifting,</b> even though virtually all processors have bitwise operation instructions for it (e.g. Intel x86 has ROL and ROR).However, some compilers may provide access to the processor instructions by means of intrinsic functions. In addition, {{it is possible to}} write standard ANSI C code that compiles down to the [...] "rotate" [...] assembly language instruction (on CPUs that have such an instruction). Most C compilers recognize the following idiom, and compile it to a single 32-bit rotate instruction.|$|R
50|$|In {{computer}} programming, a <b>circular</b> <b>shift</b> (or bitwise rotation) is a shift operator that shifts all bits of its operand. Unlike an arithmetic shift, a <b>circular</b> <b>shift</b> {{does not}} preserve a number's sign bit or distinguish a number's exponent from its significand (sometimes {{referred to as}} the mantissa). Unlike a logical shift, the vacant bit positions are not filled in with zeros but are filled in with the bits that are shifted out of the sequence.|$|E
5000|$|When {{multiplying}} two N×N matrices A and B, we need N×N processing nodes P {{arranged in}} a 2d grid. Initially pi,j is responsible for ai,j and bi,j. row i of matrix a is circularly shifted by i elements to the left. col j of matrix b is circularly shifted by j elements up. Repeat n times: pij multiplies its two entries and adds to running total. <b>circular</b> <b>shift</b> each row of a 1 element left <b>circular</b> <b>shift</b> each col of b 1 element up ...|$|E
5000|$|A sorted {{sequence}} is a monotonically non-decreasing (or non-increasing) sequence. A bitonic {{sequence is}} a sequence with [...] for some , or a <b>circular</b> <b>shift</b> {{of such a}} sequence.|$|E
3000|$|... is <b>circular</b> <b>shifted</b> to {{synchronize}} {{with the left}} signal. Then, both signals are synthesized by applying a partial weighting kernel. Each signal is multiplied with another signal which convoluted with partial weighting kernel with size l [...]...|$|R
3000|$|... is circularly {{shifted and}} made ready for its next use, by {{applying}} compound or incremental rotations [12]; this operation {{is carried out}} by the <b>circular</b> <b>shifting</b> network of Figure 7, and more details about its architecture are available in [24].|$|R
3000|$|..., {{which are}} the {{estimates}} of the sharing parameters β,γ,B and the original signal θ 1. The operators Left(A 1,l) and Right(A 1,l) denote <b>circular</b> <b>shifting</b> the columns of A 1 {{to the left and}} to the right by l columns.|$|R
50|$|A {{ring counter}} is a <b>circular</b> <b>shift</b> {{register}} which is initiated such {{that only one}} of its flip-flops is the state one while others are in their zero states.|$|E
5000|$|If the bit {{sequence}} 0001 0111 {{were subjected}} to a <b>circular</b> <b>shift</b> of one bit position... (see images below)If the bit sequence 1001 0110 {{were subjected to}} the following operations: ...|$|E
5000|$|Bit inquiry BIT_SIZE Number of bits in {{the model}} Bit {{manipulation}} BTEST Bit testing IAND Logical AND IBCLR Clear bit IBITS Bit extraction IBSET Set bit IEOR Exclusive OR IOR Inclusive OR ISHFT Logical shift ISHFTC <b>Circular</b> <b>shift</b> NOT Logical complement Transfer function, as in ...|$|E
50|$|There {{are also}} compiler-specific intrinsics {{implementing}} <b>circular</b> <b>shifts,</b> like _rotl8, _rotl16, _rotr8, _rotr16 in Microsoft Visual C++. Clang provides some rotate intrinsics for Microsoft compatibility that suffers the problems above. GCC {{does not offer}} rotate intrinsics. Intel also provides x86 Intrinsics.|$|R
30|$|Specifically, in the EDA-based {{algorithm}} {{which is}} represented in [18], after <b>circular</b> <b>shifting</b> J best sequences, the PDF of the current stage is calculated by {{counting the number of}} used subcarriers in J selected placements. Obviously, the counting process is independent of the <b>circular</b> <b>shifting.</b> Another drawback of the algorithm can be considered as trapping in the local minima, since the current PDF is considered without taking into account previous ones. Apparently, the PDF is stuck in local minima more rapidly, and thus, the algorithm would be terminated. Although the speed of convergence is more than SCE algorithm, the accuracy is less since local minima trapping has occurred more rapidly. This algorithm is considered in Algorithm 3.|$|R
50|$|In coding theory, a {{cyclic code}} is a block code, where the <b>circular</b> <b>shifts</b> of each {{codeword}} gives another word {{that belongs to}} the code. They are error-correcting codes that have algebraic properties that are convenient for efficient error detection and correction.|$|R
50|$|The fast folding {{algorithm}} {{is analogous to}} the FFT, except that it operates on a series of binned waveforms rather than a series of real or complex scalar values. Rotation (which in the FFT is multiplication by a complex phasor) is a <b>circular</b> <b>shift</b> of the component waveform.|$|E
5000|$|In practice, it is {{more likely}} that [...] will be a simple linear shift of , rather than a <b>circular</b> <b>shift</b> as {{required}} by the explanation above. In such cases, [...] will not be a simple delta function, which will reduce the performance of the method. In such cases, a window function (such as a Gaussian or Tukey window) should be employed during the Fourier transform to reduce edge effects, or the images should be zero padded so that the edge effects can be ignored. If the images consist of a flat background, with all detail situated away from the edges, then a linear shift will be equivalent to a <b>circular</b> <b>shift,</b> and the above derivation will hold exactly. The peak can be sharpened by using edge or vector correlation.|$|E
5000|$|A {{ring counter}} {{is a type}} of counter {{composed}} of a type of <b>circular</b> <b>shift</b> register. The output of the last shift register is fed to the input of the first register. The Hamming distance of an Overbeck counter is 2, the Hamming distance of a Johnson counter is 1 ...|$|E
5000|$|We {{define a}} pair of words in A&lowast; of the form uv and vu as {{conjugate}}: the conjugates of a word are thus its <b>circular</b> <b>shifts.</b> [...] Two words are conjugate in this sense if they are conjugate {{in the sense of}} group theory as elements of the free group generated by A.|$|R
40|$|The longest common {{subsequence}} (LCS) {{problem is}} a classic and well-studied problem in computer science. LCS is a central problem in stringology and finds broad applications in text compression, error-detecting codes and biological sequence comparison. However, in numerous contexts, words represent cyclic sequences of symbols and LCS must be generalized to consider all <b>circular</b> <b>shifts</b> of the strings. This occurs especially in computational biology when genetic material is sequenced form circular DNA or RNA molecules. This initiates the problem of longest common cyclic subsequence (LCCS) which finds the longest subsequence between all <b>circular</b> <b>shifts</b> of two strings. In this paper, we give an O(n^ 2) algorithm for solving LCCS problem where n {{is the number of}} symbols in the strings. Comment: This paper has been withdrawn by the author due to a crucial error in the proof...|$|R
3000|$|..., and {{normalized}} {{subcarrier spacing}} Q) just by using simple {{digital signal processing}} blocks such as up/down-sampling converters, filters, and sample delays. As already mentioned, no complicated <b>circular</b> <b>shifts,</b> temporary buffers, or memory swapping operations are required, which means a considerable simplification of those FBMC implementations where Q is rational, which have been commonly ignored by the research community.|$|R
