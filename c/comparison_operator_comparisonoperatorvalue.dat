0|230|Public
5000|$|Therein, [...] is <b>comparison</b> <b>operator</b> and [...] is a {{probability}} threshold.|$|R
5000|$|Prevent {{mistakes}} {{arising from}} using the wrong <b>comparison</b> <b>operator</b> (e.g. coding “<”, when “<=” was intended).|$|R
25|$|Whether or {{not they}} are a {{comparison}} sort. A comparison sort examines the data only by comparing two elements with a <b>comparison</b> <b>operator.</b>|$|R
5000|$|JavaScript {{provides}} a Boolean data type with [...] and [...] literals. The typeof operator returns the string [...] for these primitive types. When {{used in a}} logical context, , , , , , and the empty string (...) evaluate as [...] due to automatic type coercion. All other values (the complement of the previous list) evaluate as , including the strings , [...] and any object. Automatic type coercion by the equality <b>comparison</b> <b>operators</b> ( [...] and [...] ) can be avoided by using the type checked <b>comparison</b> <b>operators,</b> ( [...] and [...] ).|$|R
40|$|This paper proposes an {{improvement}} of an efficient multiobjective optimization algorithm, Non-dominated Sorting Genetic Algorithm II, NSGA-II, {{that has been}} here applied {{to solve the problem}} of optimal capacitors placement in distribution systems. The studied improvement involves the Crowded <b>Comparison</b> <b>Operator</b> and modifies it in order to handle several constraints. The problem of optimal location and sizing of capacitor banks for losses reduction and voltage profile flattening in medium voltage (MV) automated distribution systems is a difficult combinatorial constrained optimization problem which is deeply studied in literature. In this paper, the efficiency of the proposed Crowded <b>Comparison</b> <b>Operator,</b> CCO 1, is compared to the efficiency of another Crowded <b>Comparison</b> <b>Operator,</b> CCO 2, whose definition derives from the constraint-domination principle proposed by Deb et al. The two operators are tested on difficult test problems as well as on the optimal capacitors placement problem...|$|R
50|$|CDMI {{specifies}} {{a way for}} {{systems to}} support arbitrary queries against CDMI containers, with a rich set of <b>comparison</b> <b>operators,</b> including support for regular expressions.|$|R
3000|$|Definition 18 [5]Let (E, ≤) be a vector lattice and K be its {{positive}} cone. A monotone increasing mapping φ : K → K {{is called}} <b>comparison</b> <b>operator</b> if [...]...|$|R
50|$|Other {{operators}} {{have been}} introduced or proposed since Codd's introduction of the original eight including relational <b>comparison</b> <b>operators</b> and extensions that offer support for nesting and hierarchical data, among others.|$|R
5000|$|However, some {{programming}} languages {{may provide}} alternative <b>comparison</b> <b>operators</b> that do distinguish the two zeros. This is the case, for example, of the equals method in Java's [...] wrapper class.|$|R
5000|$|... class Student include Comparable # The class Student {{inherits}} Comparable module using include keyword attr_accessor :name, :score def initialize(name, score) @name = name @score = score end # Including the Comparison module, {{requires the}} implementing class {{to define the}} <=> <b>comparison</b> <b>operator</b> # Here's the <b>comparison</b> <b>operator.</b> We compare 2 student instances based on their scores. def <=>(other) @score <=> other.score end # Here's the good bit - I get access to <, <=, >,>= and other methods of the Comparable Interface for free.ends1 = Student.new("Peter", 100)s2 = Student.new("Jason", 90)s1 > s2 #trues1 <= s2 #false ...|$|R
5000|$|Resulting SQL:SELECT * FROM Contacts WHERE City='Sampleton' AND Zipcode='12345'More {{advanced}} {{versions of}} QBE have other <b>comparison</b> <b>operator</b> options, often via a pull-down menu, such as [...] "Contains", [...] "Not Contains", [...] "Starts With", [...] "Greater-Than", and so forth.|$|R
50|$|Single {{and double}} pairs of <b>comparison</b> <b>operators</b> (<<, >>) (meaning {{much smaller than}} and much greater than) are {{sometimes}} used instead of guillemets («, ») (used as quotation marks in many languages) when the proper characters are not available.|$|R
3000|$|... {{provided}} x - y ∈ K and φ : K → K is (c) - <b>comparison</b> <b>operator.</b> Then, {{the common}} fixed point problem CFP(f, g, E) has a solution provided that f is order continuous and g is a dominated map.|$|R
5000|$|Basic SQL <b>comparison</b> <b>operators</b> always return Unknown when {{comparing}} anything with Null, so the SQL standard provides for two special Null-specific comparison predicates. The [...] and [...] predicates (which use a postfix syntax) test whether data is, or is not, Null.|$|R
5000|$|In {{programming}} languages with {{a built-in}} Boolean data type, such as Pascal and Java, the <b>comparison</b> <b>operators</b> such as [...] and [...] are usually defined to return a Boolean value. Conditional and iterative commands may be defined to test Boolean-valued expressions.|$|R
5000|$|... class Person attr_reader :name, :age def initialize(name, age) @name, @age = name, age end def <=>(person) # the <b>comparison</b> <b>operator</b> for sorting @age <=> person.age end def to_s [...] "#{@name} (#{@age})" [...] endendgroup = Person.new("Bob", 33), Person.new("Chris", 16), Person.new("Ash", 23)puts group.sort.reverse ...|$|R
5000|$|A {{large number}} of {{algorithms}} to perform activities such as searching and sorting are provided in the STL, each implemented to require {{a certain level of}} iterator (and therefore will work on any container that provides an interface by iterators). Searching algorithms like [...] and [...] use binary search and like sorting algorithms require that the type of data must implement <b>comparison</b> <b>operator</b> [...] or custom comparator function must be specified; such <b>comparison</b> <b>operator</b> or comparator function must guarantee strict weak ordering. Apart from these, algorithms are provided for making heap from a range of elements, generating lexicographically ordered permutations of a range of elements, merge sorted ranges and perform union, intersection, difference of sorted ranges.|$|R
5000|$|According to the IEEE 754 standard, {{negative}} {{zero and}} positive zero should compare as equal {{with the usual}} (numerical) <b>comparison</b> <b>operators,</b> like the [...] operators of C and Java. In those languages, special programming tricks {{may be needed to}} distinguish the two values: ...|$|R
5|$|Basic SQL <b>comparison</b> <b>operators</b> always return Unknown when {{comparing}} anything with Null, so the SQL standard provides for two special Null-specific comparison predicates. The IS NULL and IS NOT NULL predicates (which use a postfix syntax) test whether data is, or is not, Null.|$|R
40|$|This {{document}} {{describes a}} parallel genomic sequence <b>comparison</b> <b>operator</b> for reconfigurable platforms. It has been implemented for {{speeding up the}} time consuming parts of the IRISA-TBLASTN program designed for comparing full genomes with large protein banks. Speed-up ranging from 25 to 200 has been measured on real genomic data...|$|R
50|$|TCC does {{perform a}} few optimizations, such as {{constant}} propagation for all operations, multiplications and divisions are optimized to shifts when appropriate, and <b>comparison</b> <b>operators</b> are specially optimized (by maintaining a special cache for the processor flags). It also does some simple register allocation, which prevents many extraneous save/load pairs inside a single statement.|$|R
50|$|Farooqui left UBL to help {{a leading}} {{international}} personal finance <b>comparison</b> <b>operator</b> from Asia set up their business for the Pakistani market; the international operator chose not to pursue the market opportunity at last moment due to a shift in overall strategy. Upon the international comparison platform exiting Pakistan, Farooqui chose to continue the opportunity on his own.|$|R
5000|$|Additionally, {{the use of}} the [...] "less than" [...] and [...] "greater than" [...] signs as delimiters is {{problematic}} for tools (such as text editors) which analyze source code syntactically. It is difficult for such tools to determine whether a use of these tokens is as <b>comparison</b> <b>operators</b> or template delimiters. For example, this line of code: ...|$|R
50|$|The {{constant}} {{is written}} {{to the left of}} the <b>comparison</b> <b>operator,</b> and the variable whose value is being checked against the constant is {{written to the}} right. This order is comparable to the non-standard speaking style of Yoda, which is roughly object-subject-verb (e.g., “When nine hundred years old you reach, look as good you will not.").|$|R
5000|$|References to data {{constructs}} {{and procedures}} {{may be made}} using the ref keyword. These can be dereferenced using the val keyword. When using reference variables, <b>comparison</b> <b>operators</b> are available to check whether two reference variables refer to the same item of data ( [...] :=: [...] ) or whether the data they point to is the same ( [...] = [...] ).|$|R
25|$|The {{essential}} {{difference between}} atoms and lists was that atoms were immutable and unique. Two atoms {{that appeared in}} different places in source code but were written {{in exactly the same}} way represented the same object, whereas each list was a separate object that could be altered independently of other lists and could be distinguished from other lists by <b>comparison</b> <b>operators.</b>|$|R
5000|$|The {{three-way}} <b>comparison</b> <b>operator</b> for {{numbers is}} spelled [...] in Perl, Ruby, Groovy, PHP and Ceylon, and {{is called the}} spaceship operator because it reminded Randal L. Schwartz of the spaceship in an HP BASIC Star Trek game. Another coder has suggested {{that it was so}} named because it looked similar to Darth Vader's TIE fighter in the Star Wars saga.|$|R
40|$|We {{introduce}} a new method of obtaining guaranteed enclosures of the eigenvalues {{of a variety of}} self-adjoint differential and difference operators with discrete spectrum. The method is based upon subdividing the region into a number of simpler regions for which eigenvalue enclosures are already available. AMS Subject Classification: 34 L 15, 35 P 15, 49 R 05, 49 R 10, 65 L 15, 65 L 60, 65 L 70, 65 N 25. Keywords: spectrum, eigenvalues, spectral enclosures, interval arithmetic, Rayleigh-Ritz, Temple-Lehmann. 1 Introduction A rigorous method of obtaining enclosures of the eigenvalues of self-adjoint operators has recently been described by Goerisch and Plum [4, 7, 8, 9]. It depends upon having a soluble <b>comparison</b> <b>operator,</b> from which a controlled homotopy is carried out. In this paper we {{introduce a}} new method which has the advantage of not requiring such a <b>comparison</b> <b>operator,</b> and apply it to a variety of examples. In Sections 2 to 5 we consider Sturm-Liouville operators in some detail. Sections 6 an [...] ...|$|R
5000|$|Comparison of programmer-defined {{data types}} (data types {{for which the}} {{programming}} language has no in-built understanding) may {{be carried out by}} custom-written or library functions (such as [...] mentioned above), or, in some languages, by overloading a <b>comparison</b> <b>operator</b> - that is, assigning a programmer-defined meaning that depends on the data types being compared. Another alternative is using some convention such as memberwise comparison.|$|R
5000|$|Initial {{implementations}} of {{the language}} C (1972) provided no Boolean type, {{and to this day}} Boolean values are commonly represented by integers (s) in C programs. The <b>comparison</b> <b>operators</b> ( [...] , , etc.) are defined to return a signed integer (...) result, either 0 (for false) or 1 (for true). Logical operators ( [...] , , , etc.) and condition-testing statements ( [...] , [...] ) assume that zero is false and all other values are true.|$|R
40|$|International audienceNew {{applications}} {{that are being}} required to employ Database Management Systems (DBMSs), such as storing and retrieving complex data (images, sound, temporal series, genetic data, etc.) and analytical data processing (data mining, social networks analysis, etc.), increasingly impose {{the need for new}} ways of expressing predicates. Among the new most studied predicates are the similarity-based ones, where the two commonest are the similarity range and the k-nearest neighbor predicates. The k-nearest neighbor predicate is surely the most interesting for several applications, including Content-Based Image Retrieval (CBIR) and Data Mining (DM) tasks, yet it is also the most expensive to be evaluated. A strong motivation to include operators to execute the k-nearest neighbor predicate inside a DBMS is to employ the powerful resource of query rewriting following algebraic properties to optimize query execution. Unfortunately, too few properties of the k-nearest neighbor operator have been identified so far that allow query rewriting rules leading to effectively more efficient query execution. In fact, a k-nearest neighbor operator does not even commute with either other k-nearest neighbor operator or any other attribute <b>comparison</b> <b>operators</b> (similarity range or any other of the traditional attribute <b>comparison</b> <b>operator).</b> In this paper, we investigate a new class of properties for the k-nearest neighbor operator based not on expression equivalence, but on result set inclusion. We develop a complete set of properties based on set inclusion, which can be successfully employed to rewrite query expressions involving k-nearest neighbor operators combined to any of the traditional attribute <b>comparison</b> <b>operators</b> or to other k-nearest neighbor and similarity range operators. We also give examples of how applying those properties to rewrite queries improve retrieval efficiency...|$|R
40|$|All <b>comparison</b> <b>operators</b> {>, ≥, <, ≤, =} are exact. In {{order to}} {{determine}} the sign of a real number x the data type first computes a rational number q such that |x| ≤ q implies x = 0 and then computes an approximation of x of sufficient precision to decide the sign of x. The user may assist the data type by providing a separation bound q.|$|R
40|$|PPSN 2016 : 14 th International Conference on Parallel Problem Solving from Nature, 17 - 21 September 2016, Edinburgh, ScotlandThis is {{the author}} {{accepted}} manuscript. The final version is available from Springer Verlag via the DOI in this record. The use of hyper-heuristics is increasing in the multi-objective optimisation domain, and the next logical advance in such methods is to use them in the solution of many-objective problems. Such problems comprise four or more objectives and are known to present a significant challenge to standard dominance-based evolutionary algorithms. We in- corporate three <b>comparison</b> <b>operators</b> as alternatives to dominance and investigate their potential to optimise many-objective problems with a hyper-heuristic from the literature. We discover that the best results are obtained using either the favour relation or hypervolume, but conclude that changing the <b>comparison</b> <b>operator</b> alone will not allow for the generation of estimated Pareto fronts that are both close to and fully cover the true Pareto front. This work was funded under EPSRC grant EP/K 000519 / 1...|$|R
30|$|Crowded {{comparison}} operator: The crowded <b>comparison</b> <b>operator</b> {{guides the}} selection process at the various stages of the algorithm towards a good spread of the solutions in the optimum fronts. This operator is applied between two solutions with differing non-domination ranks; it prefers the solution with better rank. Otherwise, if both solutions {{belong to the same}} front then we prefer the solution which is located in a lesser crowded region (Deb 2002; Deb et al. 2002).|$|R
40|$|We {{study the}} Schr 7 ̆fodinger {{operator}} (x) in) with a interaction supported by an in nite non-planar surface which is smooth, admits a global normal parameterization, and is asymptotically planar in a suitable sense. We show {{that for a}} large enough > 0 this operator has a non-empty discrete spectrum and derive an asymptotic expansion of the eigenvalues {{in terms of a}} " <b>comparison</b> <b>operator</b> determined by the geometry of the surface. ...|$|R
5000|$|Python 2.2 {{and earlier}} {{does not have}} an {{explicit}} boolean type. In all versions of Python, boolean operators treat zero values or empty values such as , , , , , and [...] as false, while in general treating non-empty, non-zero values as true. In Python 2.2.1 the boolean constants [...] and [...] were added to the language (subclassed from 1 and 0). The binary <b>comparison</b> <b>operators</b> such as [...] and [...] return either [...] or [...]|$|R
