197|18|Public
50|$|Mariano Ceccato, Andrea Capiluppi, Paolo Falcarin, Cornelia Boldyreff, A Large Study on the Effect of <b>Code</b> <b>Obfuscation</b> on the Quality of Java Code, Journal of Empirical Software Engineering, (under review).|$|E
5000|$|Dotfuscator is a {{tool that}} hinders reverse {{engineering}} and tampering for [...]NET, Xamarin and Universal Windows Platform applications. It implements a combination of <b>code</b> <b>obfuscation,</b> optimization, shrinking, and hardening technologies.|$|E
50|$|Software is {{also said}} to be {{tamper-resistant}} when it contains measures to make reverse engineering harder, or to prevent a user from modifying it against the manufacturer's wishes (removing a restriction on {{how it can be}} used, for example). One commonly used method is <b>code</b> <b>obfuscation.</b>|$|E
40|$|Shape-memory alloys are metal {{pieces that}} "remember" their {{original}} cold-forged shapes {{and return to}} the pre-deformed shape after heating. In this work we construct a software analogous of shape-memory alloys: programs whose <b>code</b> resists <b>obfuscation.</b> We show how to pour arbitrary functions into protective envelops that allow recovering the functions' exact initial <b>code</b> after <b>obfuscation.</b> We explicit the theoretical foundations of our method and provide a concrete implementation in Scheme...|$|R
40|$|Abstract. <b>Code</b> <b>obfuscations</b> are semantics-preserving <b>code</b> transformations used {{to protect}} a program from reverse engineering. There is {{generally}} no expectation of complete, long-term, protection. Rather, there is a trade-off between the protection afforded by an obfuscation (i. e. the amount of resources an adversary has to expend to overcome the layer of confusion added by the transformation) and the resulting performance overhead. In this paper we examine the problems that arise when constructing an Obfuscation Executive. This is the main loop in charge of a) selecting {{the part of the}} application to be obfuscated next, b) choosing the best transformation to apply to this part, c) evaluating how much confusion and overhead has been added to the application, and d) deciding when the obfuscation process should terminate. ...|$|R
40|$|Malware {{detection}} is {{a crucial}} aspect of software security. Current malware detectors work by checking for “signatures, ” which attempt to capture (syntactic) characteristics of the machine-level byte sequence of the malware. This reliance on a syntactic approach makes such detectors vulnerable to <b>code</b> <b>obfuscations,</b> increasingly used by malware writers, that alter syntactic properties of the malware byte sequence without significantly affecting their execution behavior. This paper takes {{the position that the}} key to malware identification lies in their semantics. It proposes a semantics-based framework for reasoning about malware detectors and proving properties such as soundness and completeness of such detectors. Our approach uses a trace semantics to characterize the behaviors of malware as well as the program being checked for infection, and uses abstract interpretation to “hide ” irrelevant aspects of these behaviors. As a concrete application of our approach, we show that the semantics-aware malware detector proposed by Christodorescu et al. is complete with respect to a number of common obfuscations used by malware writers. 1...|$|R
50|$|StarForce MMOG is a {{professional}} solution for MMO game developers providing MMO game protection against various threats (cheats and bots). Included tools help to secure game servers against unauthorized game launches, enable game <b>code</b> <b>obfuscation</b> and offer protection against cracking and modification, {{as well as providing}} game traffic security.|$|E
5000|$|There {{are several}} {{advantages}} of automated <b>code</b> <b>obfuscation</b> {{that have made}} it popular and widely useful across many platforms. On some platforms (such as Java., Android, and [...]NET) a free tool called decompiler can easily reverse-engineer source code from an executable or library. A main advantage of automated <b>code</b> <b>obfuscation</b> is that it helps protect the trade secrets (intellectual property) contained within software by making reverse-engineering a program difficult and economically unfeasible. Other advantages might include helping to protect licensing mechanisms and unauthorized access, and shrinking {{the size of the}} executable. Note that not always one can have tamper resistant hardware to conceal secrets in code and secret data, hence one will employ obfuscation to make reversing the code and finding the secret hard. In these scenarios the end user gets a version of the software, and this same user is the adversary. The attack was therefore called `MATE: Man-at-the-End' attack, based on the traditional cryptographic attack known as MITM: Man-in-the-middle attack.|$|E
50|$|For {{proprietary}} software, {{the provisions}} of the various copyright laws, trade secrecy and patents are used to keep the source code closed. Additionally, many pieces of retail software come with an end-user license agreement (EULA) which typically prohibits decompilation, reverse engineering, analysis, modification, or circumventing of copy protection. Types of source code protection beyond traditional compilation to object code include code encryption, <b>code</b> <b>obfuscation</b> or code morphing.|$|E
40|$|Context: Obfuscation is {{a common}} {{technique}} used to protect software against mali- cious reverse engineering. Obfuscators manipulate the source code {{to make it harder}} to analyze and more difficult to understand for the attacker. Although different ob- fuscation algorithms and implementations are available, they have never been directly compared in a large scale study. Aim: This paper aims at evaluating and quantifying the effect of several different obfuscation implementations (both open source and commercial), to help developers and project manager to decide which one could be adopted. Method: In this study we applied 44 obfuscations to 18 subject applications covering a total of 4 millions lines of code. The effectiveness of these source <b>code</b> <b>obfuscations</b> has been measured using 10 code metrics, considering modularity, size and complexity of code. Results: Results show that some of the considered obfuscations are effective in mak- ing code metrics change substantially from original to obfuscated code, although this change (called potency of the obfuscation) is different on different metrics. In the pa- per we recommend which obfuscations to select, given the security requirements of the software to be protected...|$|R
40|$|Mobile code is {{computer}} code that roams and executes remotely {{on a computer}} network. While it has advantages such as autonomous computing, mobile code {{is very hard to}} protect against malicious host attacks. In this paper, a multi-layer protection framework of mobile <b>code,</b> including complete <b>obfuscation,</b> encrypted execution and code watermarking, is presented. With security strengthened, mobile code is ready for large-scale deployment on open distributed computer networks...|$|R
40|$|International audienceVaucanson is an {{open source}} C++ {{platform}} dedicated to the computation with finite weighted automata. It is generic: it allows to write algorithms that apply on a wide set of mathematical objects. Initiated ten years ago, several shortcomings were discovered along the years, especially problems related to <b>code</b> complexity and <b>obfuscation</b> as well as performance issues. This paper presents the concepts underlying 2, a complete rewrite of the platform that addresses these issues...|$|R
50|$|WireLurker {{monitors}} any iOS device connected via USB with {{an infected}} macOS computer and installs downloaded third-party applications or automatically generated malicious applications onto the device. WireLurker can infect a device {{regardless of whether}} it is jailbroken or not. WireLurker is a complex form of malware that utilizes techniques such as file hiding, <b>code</b> <b>obfuscation</b> and encryption. WireLurker is capable of stealing a variety of information from the mobile devices it infects and regularly requests updates from the attackers command and control server.|$|E
50|$|While {{obfuscation}} {{can make}} reading, writing and reverse-engineering a program difficult and time-consuming, {{it will not}} necessarily make it impossible. Some anti-virus software, such as AVG, will also alert their users when they land on a site with code that is manually obfuscated, {{as one of the}} purposes of obfuscation can be to hide malicious code. However, some developers may employ <b>code</b> <b>obfuscation</b> for the purpose of reducing file size or increasing security. The average user may not expect their antivirus software to provide alerts about an otherwise harmless piece of code, especially from trusted corporations, so such a feature may actually serve as a deterrent.|$|E
50|$|The {{most common}} {{software}} crack is the modification of an application's binary to cause or prevent a specific key branch in the program's execution. This {{is accomplished by}} reverse engineering the compiled program code using a debugger such as SoftICE, x64dbg, OllyDbg, GDB, or MacsBug until the software cracker reaches the subroutine that contains the primary method of protecting the software (or by disassembling an executable file with a program such as IDA). The binary is then modified using the debugger or a hex editor or monitor {{in a manner that}} replaces a prior branching opcode with its complement or a NOP opcode so the key branch will either always execute a specific subroutine or skip over it. Almost all common software cracks are a variation of this type. Proprietary software developers are constantly developing techniques such as <b>code</b> <b>obfuscation,</b> encryption, and self-modifying code to make this modification increasingly difficult. Even with these measures being taken, developers struggle to combat software cracking. This is because it is very common for a professional to publicly release a simple cracked EXE or Retrium Installer for public download, eliminating the need for inexperienced users to crack the software themselves.|$|E
40|$|Automatic malware {{analysis}} {{is an essential}} part of today's computer security practices. Nearly one million malware samples were delivered to the analysts on a daily basis on year 2014 alone while the number of samples submitted for analysis increases almost exponentially each year. Given the size of the threat we are facing today and the amount of malicious codes emerging every day, the ability to automatically analyze unknown and unwanted software is critically important more than ever. On the other hand, malware writers adapt their malicious codes to new security measurements to protect them from being exposed and detected. This is usually achieved by employing obfuscation techniques that complicate the reverse engineering and analysis of the code by adding lots of unnecessary and irrelevant computations. Most of the malicious samples found in the wild are obfuscated and equipped with complicated anti-analysis defenses intended to hide the malicious intent of the malware by defeating the analysis and/or increasing the analysis time. Deobfuscation (reversing the obfuscation) requires automatic techniques to extract the original logic embedded in the obfuscated code for further analysis. Presumably the deobfuscated code requires less analysis time and is easier to analyze compared to the obfuscated one. Previous approaches in this regard target specific types of obfuscations by making strong assumptions about the underlying protection scheme leaving opportunities for the adversaries to attack. This work addresses this limitation by proposing new program analysis techniques that are effective against <b>code</b> <b>obfuscations</b> while being generic by minimizing the assumptions about the underlying code. We found that standard program analysis techniques, including well-known data and control flow analyses and/or symbolic execution, suffer from imprecision due to the obfuscation and show how to mitigate this loss of precision. Using more precise program analysis techniques, we propose a deobfuscation technique that is successful in reversing the complex obfuscation techniques such as virtualization-obfuscation and/or Return-Oriented Programming (ROP) ...|$|R
40|$|Abstract — As various {{computers}} are connected {{into a world}} wide network, software protections becomes a more and more important issue for software users and developers. There are some technical measures for software protections, such as hardwarebased protections and software-based techniques, etc. Software obfuscation {{is one of these}} measures. It protects software from unauthorized modification by making software more obscure so that it is hard for the potential attacker to understand the obfuscated software. Chow et al. use residue number technique to software obfuscation by encoding variables in the original program to hide the true meaning of these variables [1]. There is some discussion about the division of residue numbers in [1], but, in order to lay a sound ground for this technique, we proposed homomorphic functions in [2] to deal with division by several constants in residue numbers. Data structures are important components of programme and they are key clues for people to understand codes. Obfuscating data structures of programme will make it very hard for an enemy to attack them. In this paper, we apply homomorphic functions to obfuscating the data structures of software. Index Terms — software <b>obfuscation,</b> residue number <b>coding,</b> homomorphic <b>obfuscation.</b> I...|$|R
40|$|Computer and {{communication}} industries develop {{so rapidly that}} the demand for software becomes larger and larger {{and the demand for}} software protections, such as copyright and anti-tampering defense, are more and more important to software users and developers. There are some technical measures for software protections, such as hardware-based protections, network filters, cryptosystems, etc. Software obfuscation is one of these measures. It protects software from unauthorized modification by making software more obscure so that it is hard for the potential attacker to understand the obfuscated software. In software obfuscation, we can obfuscate the control flow and the data flow of the software. In this paper, we explore an obfuscation based on residue number coding, which is a method widely used in hardware design, high precision integer arithmetic, and cryptography [1]. Recently, it has used as an obfuscation that encoded variables in the original program to hide the true meaning of these variables [2]. There is some discussion about the division of residue numbers in [2], but the technique proposed there is incorrect. In this paper, we establish a provable residue number encoding for software obfuscation, especially a provable algorithm for division by several constants in residue numbers. KEY WORDS software <b>obfuscation,</b> residue number <b>coding,</b> homomorphic <b>obfuscation.</b> ...|$|R
40|$|Abstract. In {{this paper}} we {{introduce}} a semantic-based approach for <b>code</b> <b>obfuscation.</b> The aim of <b>code</b> <b>obfuscation</b> {{is to prevent}} malicious users to disclose properties of the original source program. This goal can be precisely modeled by abstract interpretation, where the hiding of properties corresponds to abstract the semantics. We derive a general theory based on abstract interpretation, where the potency of <b>code</b> <b>obfuscation</b> can be measured by comparing hidden properties in the lattice of abstract interpretations. Semantic-based <b>code</b> <b>obfuscation</b> is applied to show that well known program transformation methods, such as constant propagation, {{can be seen as}} <b>code</b> <b>obfuscation...</b>|$|E
40|$|In {{this thesis}} we {{establish}} a quantitative framework {{to measure and}} study the security of <b>code</b> <b>obfuscation,</b> an effective software protection method that defends software against malicious reverse engineering. Despite the recent positive result by Garg et al. [GGH+ 13] that shows the possibility of obfuscating using indistinguishability obfuscation definition, <b>code</b> <b>obfuscation</b> has two major challenges: firstly, the lack of theoretical foundation {{that is necessary to}} define and reason about <b>code</b> <b>obfuscation</b> security; secondly, it is an open problem whether there exists security metrics that measure and certify the current state-of-the-art of <b>code</b> <b>obfuscation</b> techniques. To address these challenges, we followed a research methodology that consists of the following main routes: a formal approach to build a theory that captures, defines and measures the security of <b>code</b> <b>obfuscation,</b> and an experimental approach that provides empirical evidence about the soundness and validity of the proposed theory and metrics. To this end, we propose Algorithmic Information Theory, known as Kolmogorov complexity, as a theoretical and practical model to define, study, and measure the security of <b>code</b> <b>obfuscation.</b> We introduce the notion of unintelligibility, an intuitive way to define <b>code</b> <b>obfuscation,</b> and argue that it is not sufficient to capture the security of <b>code</b> <b>obfuscation.</b> We then present a more powerful security definition that is based on the algorithmic mutual information, and show that is able to effectively capture <b>code</b> <b>obfuscation</b> security. We apply our proposed definition to prove the possibility of obtaining security in <b>code</b> <b>obfuscation</b> under reasonable assumptions. We model adversaries with deobfuscation capabilities that explicitly realise the required properties for a successful deobfuscation attack. We build a quantitative model that comprises a set of security metrics, which are derived from our proposed theory and based on lossless compression, aiming to measure the quality of <b>code</b> <b>obfuscation</b> security. We propose normalised information distance NID as a metric to measure <b>code</b> <b>obfuscation</b> resilience, and establish the relation between our security definition and the normalised information distance. We show that if the security conditions for code obfuscations are satisfied (the extreme case) then the NID tends to be close to one, which is the maximum value that can be achieved. Finally, we provide an experimental evaluation to provide empirical validation for the proposed metrics. Our results show that the proposed measures are positively correlated with the degree of obfuscation resilience to an attacker using decompilers, i. e. the percentage of the clear code that was not recovered by an attacker, which indicates a positive relationship with the obfuscation resilience factor. Open Acces...|$|E
40|$|Aspect-oriented <b>code</b> <b>obfuscation,</b> Proceedings of the 2009 International Conference on Software Technology and Engineering Chennai, India pp. 252 - 257. This paper {{reports on}} an {{exploratory}} study investigating {{the feasibility of}} using aspect-oriented constructs to instrument objects {{for the purposes of}} <b>code</b> <b>obfuscation.</b> With Java programs it is difficult to protect the intellectual property rights and secret information in untrusted environments. Consequently the utilization of software obfuscation techniques has become relevant. It has been found that Aspect-Oriented programming might be abused to overcome advanced <b>code</b> <b>obfuscation</b> used in Java Bytecode. In this paper possible intervention strategy to prevent these types of attacks using aspect-oriented programming language such as AspectJ is presented...|$|E
40|$|Abstract—Malicious {{software}} {{are usually}} obfuscated to avoid detection and resist analysis. When new malware is encountered, such obfuscations {{have to be}} penetrated or removed (“deobfus-cated”) {{in order to understand}} the internal logic of the code and devise countermeasures. This paper discusses a generic approach for deobfuscation of obfuscated executable code. Our approach does not make any assumptions about the nature of the obfuscations used, but instead uses semantics-preserving program transformations to simplify away <b>obfuscation</b> <b>code.</b> We have applied a prototype implementation of our ideas to a variety of different kinds of obfuscation, including emulation-based obfuscation, emulation-based <b>obfuscation</b> with runtime <b>code</b> unpacking, and return-oriented programming. Our experimental results are encouraging and suggest that this approach can be effective in extracting the internal logic from code obfuscated using a variety of obfuscation techniques, including tools such as Themida that previous approaches could not handle...|$|R
40|$|Android malware {{are often}} created by injecting {{malicious}} payloads into benign applications. They employ <b>code</b> and string <b>obfuscation</b> techniques {{to hide their}} presence from antivirus scanners. Recent {{studies have shown that}} common antivirus software and static analysis tools are not resilient to such obfuscation techniques. To address this problem, we develop a robust fingerprinting approach that can deal with complex obfuscation {{with a high degree of}} accuracy. Our approach, called OpSeq, scores similarity as a func-tion of normalized opcode sequences found in sensitive func-tional modules as well as app permission requests. This com-bination of structural and behavioral features results in a distinctive fingerprint for a malware sample, thereby improv-ing our model’s overall recall rate. We tested our prototype on 1, 192 known malware samples belonging to 25 different families, 359 benign apps, and 207 new obfuscated malware variants. The empirical results show that OpSeq can cor-rectly detect known malware with an F-Score of 98 %. CCS Concepts •Security and privacy→Malware and its mitigation; •Software and its engineering → Automated static anal-ysis; •Information systems → Similarity measures...|$|R
40|$|Security and {{performance}} are most essential and prime challenges for networking phenomenon. Computation {{on the remote}} host is generally done through links. Thus security is needed when the code {{is on the way}} to the destination host. A program travelling over the link is extremely venerable to be forged for malfunctioning. On the other hand Software’s are commonly distributed with all information in the code itself, for example java byte codes. Byte codes are easy to reverse engineer. Any rival company may get the algorithms and techniques used in the product. Therefore a protection is needed to keep information secret. In both the cases obfuscation seem to be promising solution to the problem. <b>Obfuscation</b> makes <b>code</b> less understandable without changing its functionality. In this paper we have proposed an obfuscator that converts source code of a mobile agent into unintelligible code. Whole paper mainly focuses on obfuscating mobile agents whereas the technique can be used for any software obfuscation. Keywords Mobile agents, network management, network security, <b>obfuscation,</b> <b>code</b> confidentiality. 1...|$|R
40|$|Mobile {{devices have}} become {{ubiquitous}} due to centralization of private user information, contacts, messages and multiple sensors. Google Android, an open-source mobile Operating System (OS), {{is currently the}} market leader. Android popularity has motivated the malware authors to employ set of cyber attacks leveraging <b>code</b> <b>obfuscation</b> techniques. Obfuscation is an action that modifies an application (app) code, preserving the original semantics and functionality to evade anti-malware. <b>Code</b> <b>obfuscation</b> is a contentious issue. Theoretical code analysis techniques indicate that, attaining a verifiable and secure obfuscation is impossible. However, obfuscation tools and techniques are popular both among malware developers (to evade anti-malware) and commercial software developers (protect intellectual rights). We conducted a survey to uncover answers to concrete and relevant questions concerning Android <b>code</b> <b>obfuscation</b> and protection techniques. The {{purpose of this paper}} is to review <b>code</b> <b>obfuscation</b> and code protection practices, and evaluate efficacy of existing code de-obfuscation tools. In particular, we discuss Android <b>code</b> <b>obfuscation</b> methods, custom app protection techniques, and various de-obfuscation methods. Furthermore, we review and analyse the obfuscation techniques used by malware authors to evade analysis efforts. We believe that, there is a need to investigate efficiency of the defense techniques used for code protection. This survey would be beneficial to the researchers and practitioners, to understand obfuscation and de-obfuscation techniques to propose novel solutions on Android...|$|E
40|$|In {{recent years}} <b>code</b> <b>obfuscation</b> has {{attracted}} research interest as a promising technique for protecting secret properties of programs. The basic idea of <b>code</b> <b>obfuscation</b> is to transform programs {{in order to}} hide their sensitive information while preserving their functionality. One of the major drawbacks of <b>code</b> <b>obfuscation</b> {{is the lack of}} a rigorous theoretical framework that makes it difficult to formally analyze and certify the effectiveness of obfuscating techniques. We face this problem by providing a formal framework for <b>code</b> <b>obfuscation</b> based on abstract interpretation and program semantics. In particular, we show that what is hidden and interpretations of program semantics. Being able to specify what is masked and what is preserved by an obfuscation allows us to understand its potency, namely the amount of obscurity that the transformation adds to programs. In the proposed framework, obfuscation and attackers are modeled as approximations of program semantics and the lattice of abstract interpretations provides a formal tool for comparing obfuscations with respect to their potency. In particular, we prove that our framework provides an adequate setting to measure not only the potency of an obfuscation but also its resilience, i. e., the difficulty of undoing the obfuscation. We consider <b>code</b> <b>obfuscation</b> by opaque predicate insertion and we show how the degree of abstraction needed to disclose different opaque predicates allows us to compare their potency and resilience...|$|E
40|$|<b>Code</b> <b>obfuscation</b> {{is one of}} {{the most}} {{powerful}} concepts in cryptography. It could yield functional encryption, digital rights management, and maybe even secure cloud computing. However, general <b>code</b> <b>obfuscation</b> has been proven impossible and the research then focused on obfuscating very specific functions, studying weaker security definitions for obfuscation, and using tamper-proof hardware tokens to achieve general <b>code</b> <b>obfuscation.</b> Following this last line this work presents the first scheme which bases general <b>code</b> <b>obfuscation</b> of multiple programs on one single stateless hardware token. Our construction is proven secure in the UC-framework and proceeds in three steps: 1. We construct an obfuscation scheme based on fully homomorphic encryption (FHE) and a hybrid functionality conditional decrypt, which decrypts the result of a homomorphic computation given a proof that the computation was performed as intended. One difficulty of the first step are possible decryptions errors in the FHE. These decryption errors can occur whenever the randomness for the encryption is chosen maliciously by the receiver of the obfuscated code. Such decryption errors then could make a real obfuscated computation distinguishable from...|$|E
40|$|Metamorphism is a {{technique}} that mutates the binary <b>code</b> using different <b>obfuscations</b> and never keeps the same sequence of opcodes in the memory. This stealth technique provides the capability to a malware for evading detection by simple signature-based (such as instruction sequences, byte sequences and string signatures) anti-malware programs. In this paper, we present a new scheme named Annotated Control Flow Graph (ACFG) to efficiently detect such kinds of malware. ACFG is built by annotating CFG of a binary program and is used for graph and pattern matching to analyse and detect metamorphic malware. We also optimize the runtime of malware detection through parallelization and ACFG reduction, maintaining the same accuracy (without ACFG reduction) for malware detection. ACFG proposed in this paper: (i) captures the control flow semantics of a program; (ii) provides a faster matching of ACFGs and can handle malware with smaller CFGs, compared with other such techniques, without compromising the accuracy; (iii) contains more information and hence provides more accuracy than a CFG. Experimental evaluation of the proposed scheme using an existing dataset yields malware detection rate of 98. 9 % and false positive rate of 4. 5 %...|$|R
40|$|International audienceAn {{important}} part of malware analysis is dynamic analysis. Dynamic analysis try to defeat the techniques used by malware developers that hide their malicious <b>code</b> using <b>obfuscation,</b> ciphering, stealth techniques, etc. For example, a malicious developer can simply delay the execution of his malicious code for {{a certain period of}} time. His goal is {{to be sure that the}} malware runs on a device of a real user and not on an analysis platform. Thus, the major constraint with dynamic approaches is that their efficiency relies on the effective observation of the malicious behavior. For automating application executions, a first framework [1] proposes to stress applications by sending pseudo-random streams of user events such as clicks, touches, or gestures, and system-level events. Better than a monkey, Dynodroid [2] generates more relevant UI and system inputs. Nevertheless, for a lot of malware we are far from triggering their behavior. Android malware are regularly a repackaged version of regular applications: the malicious code is dissimulated inside the initial code. From a quantitative point of view, an android application is a collection of bytecode instructions that can represent a lot of possible execution paths. The previous cited approaches mainly focus on the test of the application and cannot cover all possible execution paths: using these techniques will certainly not reveal interesting observations for the malicious behavior. We are currently working on a solution to automatically identify suspicious parts of the code and then to trigger its execution. Our approach is divided into three steps. The first step resorts to static analysis: we define a scoring function that computes an indicator of risk for each method in the bytecode. The second step consists in computing an execution path that leads to the code identified as the most dangerous. The third step enables to modify the bytecode in order to force this particular execution path. This last step is the most tricky: it requires to change the control flow and to generate the right UI events in order to succeed in executing the suspicious code...|$|R
40|$|Malware {{programs}} (e. g., viruses, worms, Trojans, etc.) are {{a worldwide}} epidemic. Studies and {{statistics show that}} the impact of malware is getting worse. Malware detectors are the primary tools in the defence against malware. Most commercial anti-malware scanners maintain a database of malware patterns and heuristic signatures for detecting malicious programs within a computer system. Malware writers use semantic-preserving <b>code</b> transformation (<b>obfuscation)</b> techniques to produce new stealth variants of their malware programs. Malware variants are hard to detect with today's detection technologies as these tools rely mostly on syntactic properties and ignore the semantics of malicious executable programs. A robust malware detection technique is required to handle this emerging security threat. In this thesis, we propose a new methodology that overcomes the drawback of existing malware detection methods by analysing the semantics of known malicious code. The methodology consists of three major analysis techniques: the development of a semantic signature, slicing analysis and test data generation analysis. The core element in this approach is to specify an approximation for malware code semantics and to produce signatures for identifying, possibly obfuscated but semantically equivalent, variants of a sample of malware. A semantic signature consists of a program test input and semantic traces of a known malware code. The key challenge in developing our semantics-based approach to malware variant detection is to achieve a balance between improving the detection rate (i. e. matching semantic traces) and performance, with or without the e ects of obfuscation on malware variants. We develop slicing analysis to improve the construction of semantic signatures. We back our trace-slicing method with a theoretical result that shows the notion of correctness of the slicer. A proof-of-concept implementation of our malware detector demonstrates that the semantics-based analysis approach could improve current detection tools and make the task more di cult for malware authors. Another important part of this thesis is exploring program semantics for the selection of a suitable part of the semantic signature, for which we provide two new theoretical results. In particular, this dissertation includes a test data generation method that works for binary executables and the notion of correctness of the method...|$|R
40|$|Abstract: The {{main problem}} in {{designing}} effective <b>code</b> <b>obfuscation</b> is to guarantee security. State {{of the art}} obfuscation techniques rely on an unproven concept of security, and therefore are not regarded as provably secure. In this paper, we undertake a theoretical investigation of <b>code</b> <b>obfuscation</b> security based on Kolmogorov complexity and algorithmic mutual information. We introduce a new definition of <b>code</b> <b>obfuscation</b> that requires the algorithmic mutual information between a code and its obfuscated version to be minimal, allowing for controlled amount of information to be leaked to an adversary. We argue that our definition avoids the impossibility results of Barak et al. and is more advantageous then obfuscation indistinguishability definition in the sense it is more intuitive, and is algorithmic rather than probabilistic. ...|$|E
40|$|Abstract. <b>Code</b> <b>obfuscation</b> and {{software}} watermarking {{are well known}} techniques designed to prevent the illegal reuse of software. <b>Code</b> <b>obfuscation</b> prevents malicious reverse engineering, while software watermarking protects code from piracy. An interesting class of algorithms for <b>code</b> <b>obfuscation</b> {{and software}} watermarking relies on the insertion of opaque predicates. It turns out that attackers based on a dynamic or an hybrid static-dynamic approach are either not precise or time consuming in eliminating opaque predicates. We present an abstract interpretation-based methodology for removing opaque predicates from programs. Abstract interpretation provides the right framework for proving the correctness of our approach, together with a general methodology for designing efficient attackers for a relevant class of opaque predicates. Experimental evaluations show that abstract interpretation based attacks significantly reduce {{the time needed to}} eliminate opaque predicates. ...|$|E
40|$|Abstract- Over the years, several {{software}} protection techniques {{have been developed}} to avoid global software piracy, which has increased over 40 % and has caused $ 11 billion loss. <b>Code</b> <b>Obfuscation</b> is one of these techniques and it is very promising one. <b>Code</b> <b>obfuscation</b> is a form of {{software protection}} against unauthorized reverse-engineering. In this paper, we give information about available software obfuscation tool kits in the market, along with JHide and their comparison. We propose three new obfuscation techniques, based on composite functions, which ar...|$|E
40|$|Self-modifying code (SMC), in this paper, broadly {{refers to}} any program that loads, generates, or mutates code at runtime. It {{is widely used}} {{in many of the}} world’s {{critical}} software systems to support runtime code generation and optimization, dynamic loading and linking, OS boot loader, just-in-time compilation, binary translation, or dynamic <b>code</b> encryption and <b>obfuscation.</b> Unfortunately, SMC is also extremely di   cult to reason about: existing formal verification techniques—including Hoare logic and type system— consistently assume that program code stored in memory is fixed and immutable; this severely limits their applicability and power. This paper presents a simple but novel Hoare-logic-like framework that supports modular verification of general von-Neumann machine code with runtime code manipulation. By dropping the assumption that code memory is fixed and immutable, we are forced to apply local reasoning and separation logic at the very beginning, and treat program code uniformly as regular data structure. We address the interaction between separation and code memory and show how to establish the frame rules for local reasoning even in the presence of SMC. Our framework is realistic, but designed to be highly generic, so that it can support assembly code under all modern CPUs (including both x 86 and MIPS). Our system is expressive and fully mechanized. We prove its soundness in the Coq proof assistant and demonstrate its power by certifying a series of realistic examples and applications—all of which can directly run on the SPIM simulator or any stock x 86 hardware...|$|R
40|$|Abstract—Illegal code reuse {{has become}} {{a serious threat to}} the {{software}} community. Identifying similar or identical code fragments becomes much more challenging in code theft cases where plagiarizers can use various automated <b>code</b> transformation or <b>obfuscation</b> techniques to hide stolen code from being detected. Previous works in this field are largely limited in that (i) most of them cannot handle advanced obfuscation techniques, and (ii) the methods based on source code analysis are not practical since the source code of suspicious programs typically cannot be obtained until strong evidences have been collected. Based on the observation that some critical runtime values of a program are hard to be replaced or eliminated by semantics-preserving transformation techniques, we introduce a novel approach to dynamic characterization of executable programs. Leveraging such invariant values, our technique is resilient to various control and data obfuscation techniques. We show how the values can be extracted and refined to expose the critical values and how we can apply this runtime property to help solve problems in software plagiarism detection. We have implemented a prototype with a dynamic taint analyzer atop a generic processor emulator. Our value-based plagiarism detection method (VaPD) uses the longest common subsequence based similarity measuring algorithms to check whether two code fragments belong to the same lineage. We evaluate our proposed method through a set of real-world automated obfuscators. Our experimental results show that the value-based method successfully discriminates 34 plagiarisms obfuscated by SandMark, plagiarisms heavily obfuscated by KlassMaster, programs obfuscated by Thicket, and executables obfuscated by Loco/Diablo. Keywords—Software plagiarism detection, dynamic code identification. F...|$|R
40|$|Source <b>code</b> <b>obfuscation</b> is a {{protection}} mechanism widely used {{to limit the}} possibility of malicious reverse engineering or attack activities on a software system. Although several <b>code</b> <b>obfuscation</b> techniques and tools are available, little knowledge is available about the capability of obfuscation to reduce attackers ’ efficiency, and the contexts in which such an efficiency may vary. This paper reports the outcome of two controlled experiments meant to measure the ability of subjects to understand and modify decompiled, obfuscated Java code, compared to decompiled, clear code. Results quantify to what extent <b>code</b> <b>obfuscation</b> is able to make attacks more difficult to be performed, and reveal that obfuscation can mitigate the effect of factors that can alter {{the likelihood of a}} successful attack, such as the attackers’ skill and experience, or the intrinsic characteristics of the system under attack. Keywords: Empirical studies, Software Obfuscation, Program comprehensio...|$|E
