2|69|Public
40|$|We {{construct}} a locally compact Hausdorff topology {{on the path}} space of a finitely aligned k-graph Λ. We identify the boundary-path space ∂Λ as the spectrum of a commutative C^*-subalgebra D_Λ of C^*(Λ). Then, using a construction {{similar to that of}} Farthing, we {{construct a}} finitely aligned k-graph Λ with no sources in which Λ is embedded, and show that ∂Λ is homeomorphic to a subset of ∂Λ. We show that when Λ is row-finite, we can identify C^*(Λ) with a full corner of C^*(Λ), and deduce that D_Λ is isomorphic to a corner of D_Λ. Lastly, we show that this isomorphism implements the homeomorphism between the boundary-path spaces. Comment: 30 pages, all figures drawn with TikZ/PGF. Updated numbering and minor corrections to coincide with published version. Updated 29 -Feb- 2012 to fix a <b>compiling</b> <b>error</b> which resulted in the arXiv PDF output containing two copies of the articl...|$|E
40|$|Abstract. In {{this paper}} we present the type system of Java version 1. 5 and a type {{inference}} algorithm for untyped Java programs. By a small example {{we show that}} the code is more reusable if a type inference algorithm is used. 1 Generic types in Java In version 1. 5 of sun’s java (G–JAVA), generic types are implemented [1]. Generic types are parameterized types. The parameters can be instantiated by other types. For example the type of the vectors has a parameter Vector. Then a declaration “Vector var; ” means that the vector var contains only Integers. The main advantage is, that in each other method, which needs {{an element of the}} vector, the type of the element is Integer, definitely. This means that on the one hand many type casts are no longer needed. For example “var. get(5). intValue() ”without type cast is correct. On the other hand some run time errors become compiling errors. For example: ((String) var. get(5)) ++ “hallo ” causes already a <b>compiling</b> <b>error...</b>|$|E
5000|$|... v-- {{we have a}} 'Printer' here, not a 'CoutPrinter'CoutPrinter (...) [...]print("Hello [...] ").SetConsoleColor(Color.red).println("Printer!"); // <b>compile</b> <b>error</b> ...|$|R
5000|$|Though Java and C# {{have the}} same {{operators}} as C, this mistake usually causes a <b>compile</b> <b>error</b> in these languages instead, because the if-condition must be of type , {{and there is no}} implicit way to convert from other types (e.g., numbers) into s. So unless the variable that is assigned to has type [...] (or wrapper type [...] ), there will be a <b>compile</b> <b>error.</b>|$|R
5000|$|... @Override - Checks {{that the}} method is an override. Causes a <b>compile</b> <b>error</b> if {{the method is}} not found {{in one of the}} parent classes or {{implemented}} interfaces.|$|R
5000|$|This {{enumeration}} is type-safe. Enum class {{values are}} not implicitly converted to integers. Thus, they cannot {{be compared to}} integers either (the expression [...] gives a <b>compile</b> <b>error).</b>|$|R
5000|$|This {{should return}} {{the size of}} [...] C++03 disallows this, {{so it is a}} <b>compile</b> <b>error.</b> C++11 allows it. It is also allowed for the [...] {{operator}} introduced in C++11.|$|R
50|$|Also, __gc classes cannot {{inherit from}} more than one class, as such__gc class a {};__gc class b {};__gc class c: public a, public b {}; //will produce an errorthe {{preceding}} will produce a <b>compile</b> <b>error.</b>|$|R
5000|$|Any {{attempt to}} {{reassign}} , , , or [...] {{will result in}} a <b>compile</b> <b>error.</b> In fact, even if the constructor doesn't set a final variable, attempting to set it outside the constructor {{will result in a}} compilation error.|$|R
50|$|Circular {{dependencies}} {{can cause}} a domino effect when a small local change in one module spreads into other modules and has unwanted global effects (program <b>errors,</b> <b>compile</b> <b>errors).</b> Circular dependencies can also result in infinite recursions or other unexpected failures.|$|R
5000|$|Pike {{requires}} explicit type definitions for all variables. It {{uses this}} information to report type <b>errors</b> at <b>compile</b> time. The following code will cause a <b>compile</b> <b>error</b> because {{the value of the}} variable [...] "number" [...] must be an integer but the code is attempting to assign floating point and string values to it.|$|R
50|$|Several {{operating}} system distributions are geared towards penetration testing. Such distributions typically contain a pre-packaged and pre-configured set of tools. The penetration tester {{does not have}} to hunt down each individual tool, which might increase the risk complications—such as <b>compile</b> <b>errors,</b> dependencies issues, configuration errors. Also, acquiring additional tools may not be practical in the tester's context.|$|R
50|$|Information {{found in}} {{historical}} or genealogical sources can be unreliable {{and it is}} good practice to evaluate all sources with a critical eye. Factors influencing the reliability of genealogical information include: {{the knowledge of the}} informant (or writer); the bias and mental state of the informant (or writer); the passage of time and the potential for copying and <b>compiling</b> <b>errors.</b>|$|R
5000|$|Earlier {{versions}} of WPP caused <b>compiling</b> <b>errors</b> {{when more than}} one trace macro header was included into a source file (for example, if a source file with tracing included a header that had tracing in inline functions). This is fixed {{in the most recent}} version. Note that this is also a limitation of the template file, not the WPP tool itself.|$|R
40|$|Release_ 2015. 09. 2 (Changes {{relative}} to Release_ 2015. 09. 1) Acknowledgements: Brian Kelley, Paolo Tosco, Riccardo Vianello Bug Fixes: Fixed a post-decrement which causes a crash when compiling under Windows with MSVC 9 (from ptosco) Fixes a memory leak in fragmentMol (github # 669 from bp-kelley) MMPA <b>compile</b> <b>error</b> with Microsoft Visual C++ Compiler for Python 2. 7 (github # 655 from rvianello...|$|R
5000|$|Java {{does not}} have uninitialized variables. Fields of classes and objects {{that do not have}} an {{explicit}} initializer and elements of arrays are automatically initialized with the default value for their type (false for boolean, 0 for all numerical types, null for all reference types). Local variables in Java must be definitely assigned to before they are accessed, or it is a <b>compile</b> <b>error.</b>|$|R
40|$|Part 1 : Computer Studies - Developing Practices and Involving StakeholdersInternational audienceThe use of block-based visual {{language}} in introductory programming {{is a popular}} method in education. However, there is little research which provides evidence showing advantages of block-based language. This paper {{presents the results of}} learning data analysis with fine grain logs recorded by students’ development environment where the students can select their language in block-based or Java. A total of 400 + students’ logs collected each of four years were analyzed. The results show that migration from Block to Java can be consistently seen each year, although the whole block-editing rate was influenced by the method of the instructor’s introduction. Though block-editing did not affect working time and Lines of Code (LOC), it could reduce the <b>compile</b> <b>error</b> correction time, whereas using Java requires approximately 20 % of <b>compile</b> <b>error</b> correction time for students. We concluded that block-based language worked to encourage students to focus high-level algorithm creation, as well as it provides an advantage to understanding text-based language...|$|R
5000|$|Java 8 {{introduces}} default methods on interfaces. If [...] are interfaces, [...] can each {{provide a}} different implementation to an abstract method of , causing the diamond problem. Either class [...] must reimplement the method (the body {{of which can}} simply forward the call {{to one of the}} super implementations), or the ambiguity will be rejected as a <b>compile</b> <b>error.</b> Prior to Java 8, Java was not subject to the Diamond problem risk, as Java does not support multiple inheritance.|$|R
40|$|We {{review the}} {{symmetry}} {{energy in the}} context of AdS/CFT correspondence. After constructing $D$ brane configurations corresponding to dense system in boundary theory, we calculate the symmetry energy by solving DBI action of $D$ branes in confining and deconfining phase. We conclude the density dependence of the symmetry energy has scaling law whose power depends only on dimensionality of the branes and space-time. Comment: 9 pages, 5 figures. Some <b>compile</b> <b>errors</b> are corrected. arXiv admin note: substantial text overlap with arXiv: 1201. 045...|$|R
50|$|Without an {{explicit}} cast, arrays can't and won't {{be converted to}} pointers {{and it is a}} <b>compile</b> time <b>error.</b> This is a property of type-safe programming.|$|R
5000|$|Scala {{require a}} {{subclass}} to use keyword [...] "override" [...] explicitly {{in order to}} override a parent class method. In the book [...] "Programming in Scala, 2nd Edition", the author writes that (with modifications here) If there was no method f (...) , the client’s original implementation of method f (...) could not have had an override modifier. Once you add the f (...) method to the second version of your library class, a recompile of the client code would give an <b>compile</b> <b>error</b> instead of wrong behavior.|$|R
500|$|C# has {{the ability}} to utilize LINQ through the Microsoft.NET Framework with the IEnumerable Interface a {{developer}} can query any [...]NET collection class, XML documents, ADO.NET datasets, and SQL databases. [...] There are some advantages to using LINQ in C# and they are as follows: [...] intellisense support, strong filtering capabilities, type safety with <b>compile</b> <b>error</b> checking ability, and brings consistency for querying data over a variety of sources. [...] There are several different language structures that can be utilized with C# with LINQ and they are query expressions, lambda expressions, anonymous types, implicitly typed variables, extension methods, and object initializers.|$|R
40|$|Abstract. This paper {{presents}} {{the design and}} development of a system for the detection and correction of syntactic errors in free texts. The system is composed of three main modules: a) a robust syntactic analyser, b) a compiler that will translate error processing rules, and c) a module that coordinates {{the results of the}} analyser, applying different combinations of the already <b>compiled</b> <b>error</b> rules. The use of the syntactic analyser (a) and the rule processor (b) is independent and not necessarily sequential. The specification language used for the description of the error detection/correction rules is abstract, general, declarative, and based on linguistic information. ...|$|R
5000|$|Although {{the code}} is <b>compiled</b> without <b>error,</b> it throws a runtime {{exception}} (...) when executing the third line of code. This type of {{problem can be}} avoided by using generics and is the primary motivation for using generics.|$|R
50|$|Genealogists must {{consider}} the effects that copying and <b>compiling</b> <b>errors</b> may have had on the information in a source. For this reason, sources are generally categorized in two categories: original and derivative. An original source {{is one that is}} not based on another source. A derivative source is information taken from another source. This distinction is important because each time a source is copied, information about the record may be lost and errors may result from the copyist misreading, mistyping, or miswriting the information. Genealogists should consider the number of times information has been copied and the types of derivation a piece of information has undergone. The types of derivatives include: photocopies, transcriptions, abstracts, translations, extractions, and compilations.|$|R
50|$|More specifically, {{covariant}} (wide to narrower) or contravariant (narrow to wider) {{return type}} {{refers to a}} situation where the return type of the overriding method is changed to a type related to (but different from) the return type of the original overridden method. The relationship between the two covariant return types is usually one which allows substitution of the one type with the other, following the Liskov substitution principle. This usually implies that the return types of the overriding methods will be subtypes of the return type of the overridden method. The above example specifically illustrates such a case. If substitution is not allowed, the return type is invariant and causes a <b>compile</b> <b>error.</b>|$|R
50|$|The {{function}} myfunction expects {{an integer}} argument {{to be on}} the stack or in a register when it is called. If the prototype is omitted, the compiler will have no way of enforcing this and myfunction will end up operating on some other datum on the stack (possibly a return address or the value of a variable that is currently not in scope). By including the function prototype, you inform the compiler that the function myfunction takes one integer argument and you enable the compiler to catch these kinds of errors and make the compilation process run smoothly. This feature was removed from the C99 standard, thus omission of a function prototype will result in a <b>compile</b> <b>error.</b>|$|R
40|$|We {{determine}} {{the density of}} monic integer polynomials of given degree n> 1 that have squarefree discriminant; in particular, we prove {{for the first time}} that the lower density of such polynomials is positive. Similarly, we prove that the density of monic integer polynomials f(x), such that f(x) is irreducible and Z[x]/(f(x)) is the ring of integers in its fraction field, is positive, and is in fact given by ζ(2) ^- 1. It also follows from our methods that there are ≫ X^ 1 / 2 + 1 /n monogenic number fields of degree n having associated Galois group S_n and absolute discriminant less than X, and we conjecture that the exponent in this lower bound is optimal. Comment: 27 pages; some amusing <b>compiling</b> <b>errors</b> fixe...|$|R
40|$|In {{this report}} we {{introduce}} the compile time constraint library of the pe physics engine. These compile time constraints are {{a valuable tool}} to detect <b>compile</b> time <b>errors</b> and {{in case of an}} error to abort the compilation process and report the error by emitting a comprehensible error message. Additionally, they offer the option to enforce certain design decisions. ...|$|R
5000|$|Rust {{features}} type inference, {{for variables}} declared with the [...] keyword. Such variables {{do not require}} a value to be initially assigned to determine their type. A <b>compile</b> time <b>error</b> results if any branch of code fails to assign a value to the variable. Variables which will be assigned multiple times must be marked with the [...] keyword.|$|R
40|$|Anti-patterns and code-smells {{are signs}} in the source code which are not defects (does not prevent the program from {{functioning}} and does not cause <b>compile</b> <b>errors)</b> and are rather indicators of deeper and bigger problems. Exception handling is a programming construct de- signed to handle the occurrence of anomalous or exceptional conditions (that changes the normal flow of program execution). In this paper, we present an Eclipse plug-in (called as Parichayana) for detecting exception handling anti-patterns and code smells in Java programs. Parichayana is capable of automatically detecting several commonly occurring excep- tion handling programming mistakes. We extend the Eclipse IDE and create new menu entries and associated action via the Parichayana plug- in (free and open-source hosted on GitHub). We compare and contrast Parichayana with several code smell detection tools and demonstrate that our tool provides unique capabilities in context to existing tools. We have created an update site and developers can use the Eclipse up- date manager to install Parichayana from our site. We used Parichyana on several large open-source Java based projects and detected presence of exception handling anti-patternsComment: Tools Demo Paper (paper provides links to the video demo and source code...|$|R
50|$|Control Data Corporation {{computers}} {{had another}} version of FORTRAN 77, called Minnesota FORTRAN (MNF), designed especially for student use, with variations in output constructs, special uses of COMMONs and DATA statements, optimizations code levels for <b>compiling,</b> and detailed <b>error</b> listings, extensive warning messages, and debugs.|$|R
5000|$|Compiler: Performs {{compilation}} of the HiveQL query, which converts the query to an execution plan. This plan contains the tasks and steps {{needed to be}} performed by the Hadoop MapReduce to get the output as translated by the query. The compiler converts the query to an abstract syntax tree (AST). After checking for compatibility and <b>compile</b> time <b>errors,</b> it converts the AST to a directed acyclic graph (DAG). The DAG divides operators to MapReduce stages and tasks based on the input query and data.|$|R
50|$|For <b>compiled</b> languages, syntax <b>errors</b> are {{detected}} at compile-time. A {{program will}} not compile until all syntax errors are corrected. For interpreted languages, however, a syntax error may be detected during program execution, and an interpreter's error messages might not differentiate syntax errors from errors of other kinds.|$|R
50|$|No {{standard}} for pseudocode syntax exists, {{as a program}} in pseudocode is not an executable program. Pseudocode resembles, but {{should not be confused}} with skeleton programs which can be <b>compiled</b> without <b>errors.</b> Flowcharts, drakon-charts and Unified Modeling Language (UML) charts can be thought of as a graphical alternative to pseudocode, but are more spacious on paper. Languages such as HAGGIS bridge the gap between pseudocode and code written on programming languages. Its main use is to introduce students to high level languages through use of this hybrid language.|$|R
5000|$|In a pre-release {{version of}} the {{original}} MAD, as a reference to MAD's namesake, MAD magazine, when a program contained too many <b>compile</b> time <b>errors</b> the compiler would print a full-page picture of Alfred E. Neuman using ASCII art. The caption read, [...] "See this man about your program--He might want to publish it. He never worries--but {{from the looks of}} your program, you should." [...] This feature {{was not included in the}} final official version. However, it was included in the production version for the IBM 7040.|$|R
