70|1313|Public
2500|$|Four {{levels of}} {{variable}} scope (global, <b>class,</b> <b>instance,</b> and local) denoted by sigils {{or the lack}} thereof ...|$|E
2500|$|C++ {{templates}} enable generic programming. C++ supports function, class, alias {{and variable}} templates. Templates may be parameterized by types, compile-time constants, and other templates. Templates are implemented by instantiation at compile-time. To instantiate a template, compilers substitute specific arguments for a template's parameters {{to generate a}} concrete function or <b>class</b> <b>instance.</b> Some substitutions are not possible; these are eliminated by an overload resolution policy described by the phrase [...] "Substitution failure is not an error" [...] (SFINAE). Templates are a powerful tool {{that can be used}} for generic programming, template metaprogramming, and code optimization, but this power implies a cost. Template use may increase code size, because each template instantiation produces a copy of the template code: one for each set of template arguments, however, this is the same or smaller amount of code that would be generated if the code was written by hand. This is in contrast to run-time generics seen in other languages (e.g., Java) where at compile-time the type is erased and a single template body is preserved.|$|E
5000|$|The statechart diagram {{defines the}} states, events, and state {{transitions}} {{for a class}} or <b>class</b> <b>instance.</b>|$|E
40|$|In {{this paper}} a method is {{proposed}} to compute typical objects for the {{classes in the}} scheme of a fuzzy object oriented database. Typical objects are considered as "representatives " of a fuzzy majority of the <b>class</b> <b>instances.</b> The <b>instances</b> of a <b>class</b> are represented in a topological space and the typical object is derived as "closest " to the fuzzy majority of the <b>class</b> <b>instances.</b> 1...|$|R
40|$|In {{view of the}} SVM {{classification}} for the imbalanced sand-dust storm data sets, {{this paper}} proposes a hybrid self-adaptive sampling method named SRU-AIBSMOTE algorithm. This method can adaptively adjust neighboring selection strategy based on the internal distribution of sample sets. It produces virtual minority <b>class</b> <b>instances</b> through randomized interpolation in the spherical space which consists of minority <b>class</b> <b>instances</b> and their neighbors. The random undersampling is also applied to undersample the majority <b>class</b> <b>instances</b> for removal of redundant data in the sample sets. The comparative experimental results on the real data sets from Yanchi and Tongxin districts in Ningxia of China show that the SRU-AIBSMOTE method can obtain better classification performance than some traditional classification methods...|$|R
5000|$|... alink - {{library for}} modules (.so) dynamic loading. Allows to invoke {{functions}} and get <b>class</b> <b>instances</b> from modules.|$|R
5000|$|Four {{levels of}} {{variable}} scope (global, <b>class,</b> <b>instance,</b> and local) denoted by sigils {{or the lack}} thereof ...|$|E
5000|$|... '''''' - Makes {{the method}} static and {{accessible}} without {{creation of a}} <b>class</b> <b>instance.</b> However static methods cannot access non-static members in the same class.|$|E
5000|$|... '''''' - Declares that {{a thread}} {{executing}} this method must acquire monitor. For [...] methods the monitor is the <b>class</b> <b>instance</b> or java.lang.Class if {{the method is}} static.|$|E
50|$|Arrays in Java {{are created}} at runtime, just like <b>class</b> <b>instances.</b> Array length is defined at {{creation}} and cannot be changed.|$|R
5000|$|... ===Static member {{variables}}=== In C++, member variables declared as [...] inside class definitions are {{class variables}} (shared between all <b>class</b> <b>instances,</b> {{as opposed to}} instance variables).|$|R
5000|$|When a {{class is}} defined as a domain class, that is, one managed by GORM, methods are {{dynamically}} added to aid in persisting the <b>class's</b> <b>instances.</b> http://grails.org/DomainClass+Dynamic+Methods ...|$|R
5000|$|Designates {{the type}} of the first {{parameter}} (namely the <b>class</b> <b>instance)</b> as {{the first in the}} type stack (here [...] is not nested and thus has index 0).|$|E
50|$|In D, {{closures}} {{are implemented}} by delegates, a function pointer {{paired with a}} context pointer (e.g. a <b>class</b> <b>instance,</b> or a stack frame on the heap {{in the case of}} closures).|$|E
50|$|The private class data {{design pattern}} solves the {{problems}} above by extracting a data class for the target class {{and giving the}} target <b>class</b> <b>instance</b> an instance of the extracted data class.|$|E
5000|$|Significantly relaxed rules {{regarding}} the allowable shape of type <b>class</b> <b>instances.</b> When these are enabled in full, the type class system becomes a Turing-complete language for logic programming at compile time.|$|R
5000|$|... has {{the method}} , {{which is used}} to {{describe}} two objects as equal, or to indicate one is greater than the other. Generics allow implementing classes to specify which <b>class</b> <b>instances</b> can be compared to them.|$|R
5000|$|<b>Class</b> <b>instances</b> are {{dynamically}} {{created with}} the [...] keyword. A constructor denoted by [...] can be defined. Garbage collection is automatic, {{so there is}} no language facility to explicitly destroy instances created by the new operator.|$|R
5000|$|PHP 5.3 added a {{new class}} called [...] and magic method [...] that makes a <b>class</b> <b>instance</b> invocable.$x = 3;$func = function($z) { return $z *= 2; };echo $func($x); // prints 6 ...|$|E
5000|$|Scala allows mixing in a trait (creating an {{anonymous}} type) when {{creating a new}} instance of a class. In {{the case of a}} Person <b>class</b> <b>instance,</b> not all instances can sing. This feature comes use then: ...|$|E
5000|$|Accessing {{a static}} class memberStatic members are {{accessed}} {{by using the}} name of the class or any other type. This does not require the creation of a <b>class</b> <b>instance.</b> Static members are declared using the [...] modifier.|$|E
50|$|<b>Class</b> <b>instances</b> can {{be created}} through {{functional}} sequences, as <b>instancing</b> a <b>class</b> is morphologically equivalent to calling its symbol, and so, evaluating a functional sequence whose first element is a class {{has the effect of}} creating an instance.|$|R
40|$|Traditional {{classification}} algorithms, in many times, perform {{poorly on}} imbalanced data sets {{in which some}} classes are heavily outnumbered by the remaining classes. For this kind of data, minority <b>class</b> <b>instances,</b> which are usually much more of interest, are often misclassified. The paper proposes a method {{to deal with them}} by changing class distribution through over-sampling at the borderline between the minority class and the majority class of the data set. A Support Vector Machines (SVMs) classifier then is trained to predict new unknown instances. Compared to other over-sampling methods, the proposed method focuses only on the minority <b>class</b> <b>instances</b> lying around the borderline {{due to the fact that}} this area is most crucial for establishing the decision boundary. Furthermore, new instances will be generated in such a manner that minority class area will be expanded further toward the side of the majority class at the places where there appear few majority <b>class</b> <b>instances.</b> Experimental results show that the proposed method can achieve better performance than some other over-sampling methods, especially with data sets having low degree of overlap due to its ability of expanding minority class area in such cases...|$|R
50|$|At runtime the <b>class</b> <b>instances</b> that {{implement}} {{these three}} roles must provide the services {{specified by the}} IVar interface through their var ports. One such class is Variable, shown on the diagram with a port named var of type Var that realizes the IVar interface.|$|R
5000|$|For example, a {{base class}} [...] {{could have a}} virtual {{function}} [...] Subclass [...] would implement [...] differently than subclass , but one can invoke [...] on any <b>class</b> <b>instance</b> referred to as Animal, and get the [...] behaviour of the specific subclass.|$|E
5000|$|The {{following}} [...] "monad-logger" [...] {{calls are}} also available from [...] "yesod-core":$(logDebug) [...] "This is a debug log message"$(logInfo), $(logWarn), $(logError) and $(logOther) {{are also available}}You can set per case log default by overriding the shouldLog method of the Yesod <b>class</b> <b>instance</b> for the site.|$|E
50|$|After {{the request}} has been processed, the {{instance}} of the page class is discarded {{and with it the}} entire control tree. This is a source of confusion among novice ASP.NET programmers who rely on the <b>class</b> <b>instance</b> members that are lost with every page request/response cycle.|$|E
40|$|Functional {{dependencies}} {{provide for}} a relational specification of user-programmable type improvement connected to type <b>class</b> <b>instances.</b> On the other hand, the more recent type families (also known as type functions) equip the programmer with a functional specification for user-programmable type improvement decoupled from type <b>class</b> <b>instances.</b> Functional dependencies are supported by both GHC and Hugs, while the most recent version of GHC also supports type functions. There is an enthusiastic and lively debate which feature shall {{make it into the}} next Haskell standard, Haskell-Prime. Currently, further progress in the standardization appears to be stalled on this issue. In this paper, we attempt to rekindle the debate with new insights in type inference issues behind functional dependencies (FDs) and type functions (TFs), without taking sides. status: publishe...|$|R
40|$|Haskell 2010 lacks {{flexibility}} {{for creating}} <b>instances</b> of type <b>classes</b> for type constructors with multiple type arguments. We {{would like to}} make the order of type arguments to a type constructor irrelevant to how type <b>class</b> <b>instances</b> can be specified. None of the currently available techniques in Haskell allow this satisfactorily. To solve this, we have added the concept of type-level lambdas as anonymous type synonyms to Haskell. As higher-order unification of lambda terms in general is undecidable, we take a conservative approach to equality between type-level lambdas. We propose a number of small changes to the constraint solver that will allow type-level lambdas to be used in type <b>class</b> <b>instances.</b> We show that this satisfies our goal, while having only minor impact on existing Haskell code...|$|R
50|$|Interface-based {{programming}} {{defines the}} application {{as a collection}} of components, in which Application Programming Interface (API) calls between components may only be made through abstract interfaces, not concrete <b>classes.</b> <b>Instances</b> of <b>classes</b> will generally be obtained through other interfaces using techniques such as the Factory pattern.|$|R
50|$|Classes and {{monitors}} are similar: both package private variables and procedures with public procedures (called procedure entries). A <b>class</b> <b>instance</b> {{can be used}} by only one process, whereas a monitor instance may be shared by processes. Monitors provide the only mechanism for interprocess communication in a Concurrent Pascal program.|$|E
50|$|The next goal is {{to provide}} solid support for dynamic {{programming}} such as that found in languages like Borland's Object Pascal, Java, or Objective-C. This included RTTI or reflection like classes that allow the developer to query all sorts of information about a given <b>class</b> <b>instance</b> at runtime.|$|E
50|$|The proof {{assistant}} Coq {{has also}} supported type classes in recent versions. Unlike in ordinary programming languages, in Coq, any laws {{of a type}} class (such as the monad laws) that are stated within the type class definition, must be mathematically proved of each type <b>class</b> <b>instance</b> before using them.|$|E
5000|$|Metaclass - {{initializing}} <b>class</b> variables, <b>instance</b> creation messages ...|$|R
40|$|We {{present a}} system that {{constructs}} “implicit shape models” for classes of rigid 3 D objects and utilizes these models to estimating the pose of <b>class</b> <b>instances</b> in single 2 D images. We use the framework of implicit shape models to construct a voting procedure that allows for 3 D transformations and projection and accounts for self occlusion. The model is comprised {{of a collection of}} learned features, their 3 D locations, their appearances in different views, and the set of views in which they are visible. We further learn the parameters of a model from training images by applying a method that relies on factorization. We demonstrate the utility of the constructed models by applying them in pose estimation experiments to recover the viewpoint of <b>class</b> <b>instances.</b> 1...|$|R
30|$|These {{datasets}} {{are organized}} in a conceptual schema as Fig.  2 illustrates. Thus, the classes of the schema are: (i) Articles {{that correspond to}} the Wikipedia articles organized as <b>class</b> <b>instances,</b> (ii) Categories that correspond to the appropriate categories of the Wikipedia articles, (iii) WordNet that stores the type of every Wikipedia article.|$|R
