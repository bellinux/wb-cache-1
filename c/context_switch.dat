380|1041|Public
25|$|An {{operating}} system kernel contains a scheduling program which determines {{how much time}} each process spends executing, and in which order execution control should be passed to programs. Control is passed to a process by the kernel, which allows the program access to the CPU and memory. Later, control is returned to the kernel through some mechanism, so that another program may be allowed to use the CPU. This so-called passing of control between the kernel and applications is called a <b>context</b> <b>switch.</b>|$|E
25|$|The {{main feature}} change was support for Microsoft's 64-bit {{operating}} system, however support for Banyan VINES was also dropped from {{this version of}} MDAC. There were several known issues: MDAC 2.7 continued causing connectivity problems on clustered servers running Microsoft SQL Server 6.5 or SQL Server 7.0, with no workaround provided by Microsoft. When creating or configuring ODBC data source names (DSNs) using the Microsoft SQL Server ODBC driver the network library protocol might unexpectedly switch to TCP/IP, even if the DSN was configured to use named pipes. This issue was found by InfoWorld reporter Randall C. Kennedy, who identified that the change was actually made in MDAC 2.6 but was never documented. It was discovered when testing client/server database workloads on a Windows XP computer; InfoWorld claims that although overall server CPU utilization rose by only 8 percent using TCP/IP, context switches per second dropped by more than 150 percent (which is of course impossible because you would then have a negative <b>context</b> <b>switch</b> rate - the drop is either 33% or 60% depending on which planet the author was on {{at the time of}} writing) for a 10-user workload. They were unimpressed that a fundamental functional change to the default behaviour of Net-Lib occurred without more than a passing mention in an unrelated document. Windows XP users also sometimes experienced problems connecting to SQL Server because SQL Server attempts to use certificates it finds on the local computer, however if {{there is more than one}} certificate available it did not know which one to use. When attempting to use Microsoft Analysis Services 2000 RTM, an error would sometimes appear when trying to browse cubes. Microsoft also discovered a problem in Windows 95, Windows 98, and Windows Me's setup program which prevented the MDAC installation program from rolling back when it encountered an installation error.|$|E
50|$|When a {{transition}} between user mode and kernel mode {{is required in}} an operating system, a <b>context</b> <b>switch</b> is not necessary; a mode transition is not by itself a <b>context</b> <b>switch.</b> However, depending on the operating system, a <b>context</b> <b>switch</b> may also take place at this time.|$|E
5000|$|... <b>context</b> <b>switching</b> between threads in {{the same}} process is {{typically}} faster than <b>context</b> <b>switching</b> between processes.|$|R
40|$|Abstract. In {{systems with}} power constraints, <b>context</b> <b>switches</b> in a task {{schedule}} result in wasted power consumption. We present variants of priority scheduling algorithms – Rate Monotonic and Earliest Deadline First- that {{reduce the number}} of <b>context</b> <b>switches</b> in a schedule. We prove that our variants output feasible schedules whenever the original algorithms do. We present experimental results to show that our variants significantly {{reduce the number of}} <b>context</b> <b>switches.</b> Our results also show that the number of <b>context</b> <b>switches</b> in the schedules output by these algorithms is close to the minimum possible number...|$|R
5000|$|Associated {{performance}} issues, e.g., software <b>context</b> <b>switching</b> can be selective {{and store}} only those registers that need storing, whereas hardware <b>context</b> <b>switching</b> stores nearly all registers {{whether they are}} required or not.|$|R
50|$|Coarse-grained: The main {{processor}} pipeline contains only one thread at a time. The processor must effectively perform a rapid <b>context</b> <b>switch</b> before executing a different thread. This fast <b>context</b> <b>switch</b> is {{sometimes referred to}} as a thread switch. There {{may or may not be}} additional penalty cycles when switching.|$|E
50|$|System {{calls in}} most Unix-like systems are {{processed}} in kernel mode, which {{is accomplished by}} changing the processor execution mode to a more privileged one, but no process <b>context</b> <b>switch</b> is necessary although a privilege <b>context</b> <b>switch</b> does occur. The hardware sees {{the world in terms}} of the execution mode according to the processor status register, and processes are an abstraction provided by the operating system. A system call does not generally require a <b>context</b> <b>switch</b> to another process; instead, it is processed in the context of whichever process invoked it.|$|E
5000|$|The {{implementation}} of [...] moves the caller of synchronize_cpu to each CPU, thus blocking until all CPUs {{have been able}} to perform the <b>context</b> <b>switch.</b> Recall that this is a non-preemptive environment and that blocking within an RCU read-side critical section is illegal, which imply {{that there can be no}} preemption points within an RCU read-side critical section. Therefore, if a given CPU executes a <b>context</b> <b>switch</b> (to schedule another process), we know that this CPU must have completed all preceding RCU read-side critical sections. Once all CPUs have executed a <b>context</b> <b>switch,</b> then all preceding RCU read-side critical sections will have completed.|$|E
40|$|<b>Context</b> <b>switching</b> {{times are}} {{a major source of}} {{overhead}} in medium to fine grain process scheduling. We compared three different <b>context</b> <b>switching</b> techniques for non-preemptive scheduling in context of hardware/software codesign, and found major differences in performance and code size efficiency. 1 Introduction The impact of <b>context</b> <b>switching</b> on the overall execution time of a real [...] time system depends on the hardware platform and on the type of constraints. While in the design of larger real-time systems, <b>context</b> <b>switching</b> time is often neglected or roughly estimated or bounded [2, 10], this is less useful in hardware/software system design with many different communication mechanisms and tasks which can have widely varying time constraints. Typical real-time operating systems show <b>context</b> <b>switching</b> times of several to tens of microseconds [2] which is large compared to hardware/software communication or hardware execution times. So, in trading off hardware and software solutions, a c [...] ...|$|R
40|$|Abstract. Scheduling {{algorithms}} {{significantly affect}} {{the performance of}} a real-time system. In systems with power constraints, <b>context</b> <b>switches</b> in a schedule result in wasted power consumption. We present a scheduling algorithm and a heuristic for reducing the number of <b>context</b> <b>switches.</b> The algorithm executes in near linear time {{in terms of the number}} of jobs, finds a feasible schedule in most cases if it exists, and reasonably reduces the number of <b>context</b> <b>switches.</b> Thus it is a power-aware scheduling algorithm. ...|$|R
3000|$|<b>Context</b> <b>switching</b> Context-switching {{frameworks}} dynamically select classifiers and/or distance metrics {{based on}} the quality of the sample. A serial framework for quality-based <b>context</b> <b>switching</b> is illustrated in Figure 4 b. Recent literature[23 – 27] demonstrates the advantages of <b>context</b> <b>switching</b> of a biometric recognition pipeline {{based on the}} feedback from quality assessment algorithms. Vatsa et al.[23] propose a parallel <b>context</b> <b>switching</b> framework that uses energy in sub-bands, activity level, and pose angle for selecting the appropriate uni-modal classifier or fusion algorithm. Sellahewa and Jassim[25] present a simple thresholding-based adaptive fusion approach on illumination estimation from first-order statistics. Bhatt et al.[26] propose a serial framework of quality-based classifier selection using both image quality and biometric-specific quality metrics. Alonso-Fernandez et al.[28] present a quality-based <b>context</b> <b>switching</b> framework to improve sensor inter-operability in fingerprint biometric. Poh and Kittler[10] propose a unified framework for fusion of biometric classifiers at match score level by incorporating quality measures. This framework is based on a Bayesian perspective and can be used both as a generative and discriminative classifier.|$|R
50|$|The <b>context</b> <b>switch</b> is {{critical}} {{operation in the}} system and the time of its execution determines if how effective the system is. Because of that the <b>context</b> <b>switch</b> in the DioneOS system was optimized for short time. The most important parts were written in assembler, so the switch can be done in 12-17 μs (for fosc=25 MHz).|$|E
5000|$|Cache is {{physically}} addressed, solving many cache aliasing problems and reducing <b>context</b> <b>switch</b> overhead.|$|E
50|$|Conceptually, {{multithreading}} {{is equivalent}} to a <b>context</b> <b>switch</b> at the operating system level. The difference is that a multithreaded CPU can do a thread switch in one CPU cycle instead of the {{hundreds or thousands of}} CPU cycles a <b>context</b> <b>switch</b> normally requires. This is achieved by replicating the state hardware (such as the register file and program counter) for each active thread.|$|E
40|$|We {{propose a}} new language-neutral {{primitive}} for the LLVM compiler, which provides efficient <b>context</b> <b>switching</b> and message passing between lightweight threads of control. The primitive, called SWAPSTACK, {{can be used}} by any language implementation based on LLVM to build higher-level language structures such as continuations, co-routines, and lightweight threads. As part of adding the primitives to LLVM, we have also added compiler support for passing parameters across <b>context</b> <b>switches.</b> Our modified LLVM compiler produces highly efficient code through a combination of exposing the <b>context</b> <b>switching</b> code to existing compiler optimizations, and adding novel compiler optimizations to further reduce the cost of <b>context</b> <b>switches.</b> To demonstrate the generality and efficiency of our primitives, we add one-shot continuations to C++, and provide a simple fiber library that allows millions of fibers to run on multiple cores, with a work-stealing scheduler and fast inter-fiber sychronization. We argue that compiler-supported lightweight <b>context</b> <b>switching</b> can be significantly faster than using a library to <b>switch</b> between <b>contexts,</b> and provide experimental evidence to support the position...|$|R
40|$|Introduction To {{address the}} {{increasing}} demand for customized and application-specific processing on network routers, "active networks" have been proposed [1]. Active network routers are capable of processing code, which is either carried {{as part of the}} datagram's payload or referenced by a specific value in the datagram. Execution Environments (EEs) provide the context in which active processing is performed. Process and thread scheduling for Execution Environments differs from regular timeslice scheduling as implemented by modern general-purpose operating systems. Active packets can contain individual code, which leads to <b>context</b> <b>switches</b> (additional to the <b>context</b> <b>switches</b> caused by scheduling) when packets with different code are processed in EEs. Contrary to general-purpose OSs, where this happens only when new applications are launched, these additional <b>context</b> <b>switches</b> can occur frequently when many packets contain individual code. <b>Context</b> <b>switching</b> times of several thousand...|$|R
40|$|Nowadays {{more and}} more {{embedded}} real-time applications use multithreading. The benefits of multithreading include better throughput, improved responsiveness, and ease of development. However, these benefits come with costs and pitfalls which are unacceptable for a typical hard real-time system. These costs are mainly caused by scheduling and <b>context</b> <b>switching</b> between threads. While different scheduling algorithms {{have been developed to}} improve the overall system performance, <b>context</b> <b>switching</b> still consumes lot of processor resources and presents a major overhead, especially for hard real-time applications. In this paper, we propose a new approach to improve the overall performance of embedded systems that use multithreading by moving the <b>context</b> <b>switching</b> component of the Real-Time Operating System (RTOS) to the processor hardware itself. This technique leads to savings of processor clock cycles used by <b>context</b> <b>switching,</b> which is a very important resource for a hard real-time embedded systems...|$|R
5000|$|<b>Context</b> <b>switch</b> {{times and}} other thread {{operations}} {{are free and}} have {{no impact on the}} model ...|$|E
50|$|Bellmac 32 {{hardware}} {{was able}} to store all instructions, data and register contents associated with a process during a <b>context</b> <b>switch.</b>|$|E
50|$|The <b>context</b> <b>switch</b> {{measured}} from signaling point in ISR to other thread recovery takes 10us (for fosc=25 MHz) in the DioneOS system.|$|E
50|$|As an example, {{reading a}} file and then sending {{it over a}} network the {{traditional}} way requires two data copies and two <b>context</b> <b>switches</b> per read/write cycle. One of those data copies use the CPU. Sending the same file via zero copy reduces the <b>context</b> <b>switches</b> to two and eliminates all CPU data copies.|$|R
50|$|The {{dispatcher}} {{should be}} as fast as possible, since it is invoked during every process <b>switch.</b> During the <b>context</b> <b>switches,</b> the processor is virtually idle {{for a fraction of}} time, thus unnecessary <b>context</b> <b>switches</b> should be avoided. The time it takes for the dispatcher to stop one process and start another is known as the dispatch latency.|$|R
5000|$|ICPP {{leads to}} fewer <b>context</b> <b>switches</b> as {{blocking}} is prior to first execution ...|$|R
5000|$|... (N * K / P)*{(N + P)!} Where [...] N = {{number of}} threads K = {{potential}} <b>context</b> <b>switch</b> points P = budget of pre-emptive context switches ...|$|E
50|$|When a <b>context</b> <b>switch</b> occurs, {{the cache}} state is {{modified}} {{and some of}} its blocks are replaced. The misses on access to these blocks are called replaced misses.|$|E
50|$|MAJC {{attempted}} {{to address this}} problem through the ability to execute code from other threads if the current thread stalled on memory. Switching threads is normally a very expensive process known as a <b>context</b> <b>switch,</b> and on a normal processor the switch would overwhelm any savings and generally slow the machine down. On MAJC, the system could hold the state for up to four threads in memory at the same time, reducing the <b>context</b> <b>switch</b> to a few instructions in length. This feature has since appeared on other processors; Intel refers to it as HyperThreading.|$|E
5000|$|Linux native threads have {{slightly}} better performance on I/O and <b>context</b> <b>switching</b> operations.|$|R
40|$|One {{property}} that distinguishes reconfigurable computing from rapid prototyping {{is the ability}} to configure the computational fabric on-line while an application is running. Conventional reconfigurable computing platforms utilize commodity FPGAs, which typically have relatively long configuration times. Shrinking the configuration time down to the nanosecond region opens possibilities for rapid <b>context</b> <b>switching</b> and virtualizing the computational resources. An experimental <b>context</b> <b>switching</b> FPGA, called the CSRC, has been created by BAE Systems, and gives researchers the opportunity to explore context-switching applications. This paper presents results obtained from constructing both control-driven and data-driven <b>context</b> <b>switching</b> applications on the CSRC device, along with unique properties of the run-time and compile-time environment...|$|R
50|$|ARM {{processors}} use ARM register {{banks for}} fast interrupt request. x86 processors use <b>context</b> <b>switching</b> and fast interrupt for switching between instruction, decoder, GPRs and register files, {{if there is}} more than one, before the instruction is issued, but this is only existing on processors that support superscalar. However, <b>context</b> <b>switching</b> is a totally different mechanism to ARM's register bank within the registers.|$|R
5000|$|In the DioneOS {{system the}} <b>context</b> <b>switch</b> can be {{initiated}} from interrupt service routine. This property {{is useful for}} moving an event handling to the thread and commonly implemented in two-layer architecture: ...|$|E
50|$|Most commonly, within some {{scheduling}} scheme, one process must be switched {{out of the}} CPU so another {{process can}} run.This <b>context</b> <b>switch</b> can be triggered by the process making itself unrunnable, such as by waiting for an I/O or synchronization operation to complete. On a pre-emptive multitasking system, the scheduler may also switch out processes which are still runnable. To prevent other processes from being starved of CPU time, preemptive schedulers often configure a timer interrupt to fire when a process exceeds its time slice. This interrupt ensures that the scheduler will gain control to perform a <b>context</b> <b>switch.</b>|$|E
50|$|To do this, such CPUs {{include several}} sets of registers. When a <b>context</b> <b>switch</b> occurs, the {{contents}} of the working registers are simply copied into one of a set of registers for this purpose.|$|E
5000|$|The use of queue can degrade {{performance}} of ABQL if a thread in the queue gets <b>context</b> <b>switched</b> out then it won't {{be able to}} acquire the lock despite the lock being available.This will also stall the future threads in the queue until the thread that was <b>context</b> <b>switched</b> out or experience an interrupt successfully acquires and releases the lock.|$|R
50|$|Furthermore, cache misses due to <b>context</b> <b>switching</b> may {{be placed}} into two {{categories}} described below.|$|R
2500|$|Flush Control – {{applications}} {{can control}} flushing of pending commands before <b>context</b> <b>switching</b> – enabling high-performance multithreaded applications; ...|$|R
