66|10000|Public
2500|$|Most {{programming}} languages (including Lisp, ML and imperative languages like C and Java) {{are described}} as [...] "strict", meaning that functions applied to non-normalising arguments are non-normalising. This is done essentially using applicative order, <b>call</b> <b>by</b> <b>value</b> reduction (see below), but usually called [...] "eager evaluation".|$|E
50|$|Every {{data object}} in S-algol {{must be given}} a value when it is declared. This {{corresponds}} to <b>call</b> <b>by</b> <b>value</b> parameter passing and removes {{the possibility of using}} an uninitialised value. In fact <b>call</b> <b>by</b> <b>value</b> is the only parameter passing method in S-algol. Reference and result parameters are rejected, which is consistent with the S-algol ban on passing l-values. Structures and vectors are passed as pointers to the objects, but this is still <b>call</b> <b>by</b> <b>value</b> as the behavior {{is the same as the}} value used on the right side of assignments.|$|E
50|$|<b>Call</b> <b>by</b> <b>value</b> is not {{a single}} {{evaluation}} strategy, but rather the family of evaluation strategies in which a function's argument is evaluated before being passed to the function. While many programming languages (such as Common Lisp, Eiffel and Java) that use <b>call</b> <b>by</b> <b>value</b> evaluate function arguments left-to-right, some evaluate functions and their arguments right-to-left, and others (such as Scheme, OCaml and C) leave the order unspecified.|$|E
5000|$|Wirth has {{reportedly}} told the joke that, because Europeans pronounce his name properly, while Americans pronounce it as [...] "nickel's worth", he is <b>called</b> <b>by</b> name in Europe and <b>called</b> <b>by</b> <b>value</b> in America.|$|R
40|$|AbstractCall <b>by</b> <b>value</b> and <b>call</b> <b>by</b> name {{have some}} {{subtleties}} {{when used in}} a nondeterministic programming language. A common formalism is used to establish the denotational semantics of recursive programs <b>called</b> <b>by</b> name and <b>called</b> <b>by</b> <b>value.</b> Ashcroft and Hennessy introduced the idea of differentiating between selecting arguments from a set of arguments {{at the point of}} invocation and selecting arguments during the run of the procedure. This distinction is shown to be independent of the evaluation according to value or name, giving rise to four possible parameter passing methods, all of which have a suitable least fixed point semantics...|$|R
40|$|A fixed-point {{characterization}} of the inside-out (IO) and outside-in (OI) context-free tree languages is given. This characterization is used to obtain a theory of nondeterministic systems of context-free equations with parameters. Several “Mezei-and-Wright-like” results are obtained which relate the context-free tree languages to recognizable tree languages and to nondeterministic recursive program(scheme) s (<b>called</b> <b>by</b> <b>value</b> and <b>called</b> <b>by</b> name). Closure properties of the context-free tree languages are discussed. Hierarchies of higher level equational subsets of an algebra are considered...|$|R
5000|$|Block structure, with {{underlying}} semantics (including recursion), à la Algol 60. Arguments {{are passed}} using call by reference, using dummy variables for values where needed (<b>call</b> <b>by</b> <b>value).</b>|$|E
50|$|<b>Call</b> <b>by</b> <b>value</b> (also {{referred}} to as pass by value) {{is the most common}} evaluation strategy, used in languages as different as C and Scheme. In <b>call</b> <b>by</b> <b>value,</b> the argument expression is evaluated, and the resulting value is bound to the corresponding variable in the function (frequently by copying the value into a new memory region). If the function or procedure is able to assign values to its parameters, only its local copy is assigned—that is, anything passed into a function call is unchanged in the caller's scope when the function returns.|$|E
50|$|The exact {{mechanism}} for assigning arguments to parameters, called argument passing, {{depends upon the}} evaluation strategy used for that parameter (typically <b>call</b> <b>by</b> <b>value),</b> which may be specified using keywords.|$|E
5000|$|... {{provides}} named parameter inheritance in nested routine <b>calls,</b> <b>by</b> reference or <b>value.</b>|$|R
5000|$|Since {{the limited}} {{size of the}} LGP-30 precluded a full {{implementation}} of ALGOL 60, certain of its features (arrays <b>called</b> <b>by</b> <b>value,</b> own arrays, strings, variable array bounds, and recursion) were omitted; but the implementers did include parameters <b>called</b> <b>by</b> name, using [...] "thunks", and integer labels. They dubbed their work ALGOL 30, since {{it was for the}} LGP-30. From this project emerged a small group of undergraduate students who were well equipped to perform further work in the development of computer languages. For instance, one student (Stephen J. Garland) discovered that compound statements and blocks could be included in the Samelson and Bauer scanning algorithm. This simple fact was not published until some years later.|$|R
50|$|In C/C++, it is {{possible}} to declare the parameter of a function or method as constant. This is a guarantee that this parameter cannot be modified after the first assignment (inadvertently). If the parameter is a pre-defined (built-in) type, it is <b>called</b> <b>by</b> <b>value</b> and cannot be modified. If it is a user-defined type, the variable is the pointer address, which cannot be modified either. However, the content of the object can be modified without limits. Declaring parameters as constants may be a way to signalise that this value should not be changed, but the programmer must keep in mind that checks about modification of an object cannot be done by the compiler.|$|R
5000|$|In {{the most}} common case, <b>call</b> <b>by</b> <b>value,</b> a {{parameter}} acts within the subroutine as a variable initialized {{to the value of}} the argument (a local (isolated) copy of the argument if the argument is a variable), but in other cases, e.g. call by reference, the argument supplied by the caller can be affected by actions within the called subroutine (as discussed in evaluation strategy). In <b>call</b> <b>by</b> <b>value,</b> one can thus think of arguments as values (properly, think of the value of arguments as the [...] "arguments" [...] themselves), but in general arguments are not simply values.|$|E
5000|$|Call by copy-restore (also {{referred}} to as copy-in copy-out, <b>call</b> <b>by</b> <b>value</b> result or <b>call</b> <b>by</b> <b>value</b> return—as termed in the Fortran community) is a special case of call by reference where the provided reference is unique to the caller. This variant has gained attention in multiprocessing contexts and Remote procedure call : if a parameter to a function call is a reference that might be accessible by another thread of execution, its contents may be copied to a new reference that is not; when the function call returns, the updated contents of this new reference are copied {{back to the original}} reference ("restored").|$|E
50|$|Although {{this term}} has {{widespread}} usage in the Python community, identical semantics in other languages such as Java and Visual Basic are {{often described as}} <b>call</b> <b>by</b> <b>value,</b> where the value is implied to be {{a reference to the}} object.|$|E
40|$|Abstract. Function <b>call</b> {{and passing}} <b>by</b> <b>value</b> {{is a very}} {{important}} content in C++ tutorials. It is difficult to understand or grasp too. This article introduced the features of C++’s function and passing <b>by</b> <b>value</b> briefly <b>by</b> analyzing data’s storage in memory and the conception of runtime stack. It also discussed how to improve teaching’s quality on such courses by means of these deep analyses...|$|R
40|$|AbstractFunctors {{which are}} determined, up to natural isomorphism, <b>by</b> their <b>values</b> on objects, are <b>called</b> DVO (Defined <b>by</b> <b>Values</b> on Objects). We {{focus on the}} {{collection}} of polynomial functors on a category of sets (classes), and we give a characterization theorem of the DVO functors over such collection of functors. Moreover, we show that the (κ-bounded) powerset functor is not DVO...|$|R
40|$|Within the {{framework}} of (first [...] order) recursive applicative program schemes we prove the parameter [...] passing mechanisms <b>call</b> [...] <b>by</b> [...] name and <b>call</b> [...] <b>by</b> [...] <b>value</b> {{to be of the}} same computational power, thus solving an open problem in the theory of functional programming. The equivalence proof is given constructively by a detour through flowchart program schemes which operate on pushdown stores. This result is in contrast to the non [...] deterministic (i. e., language [...] theoretic) case where the outermost (OI) and the innermost (IO) expansion strategy of macro grammars lead to incomparable classes of string languages...|$|R
5000|$|The {{description}} [...] "call by value {{where the}} value is a reference" [...] is common (but {{should not be}} understood as being call by reference); another term is call by sharing. Thus the behaviour of <b>call</b> <b>by</b> <b>value</b> Java or Visual Basic and <b>call</b> <b>by</b> <b>value</b> C or Pascal are significantly different: in C or Pascal, calling a function with a large structure as an argument will cause the entire structure to be copied (except if it's actually {{a reference to a}} structure), potentially causing serious performance degradation, and mutations to the structure are invisible to the caller. However, in Java or Visual Basic only the reference to the structure is copied, which is fast, and mutations to the structure are visible to the caller.|$|E
5000|$|Most {{programming}} languages (including Lisp, ML and imperative languages like C and Java) {{are described}} as [...] "strict", meaning that functions applied to non-normalising arguments are non-normalising. This is done essentially using applicative order, <b>call</b> <b>by</b> <b>value</b> reduction (see below), but usually called [...] "eager evaluation".|$|E
50|$|In a non-strict {{functional}} programming language, strictness analysis refers to any algorithm used {{to prove the}} strictness of a function with respect {{to one or more}} of its arguments. Such functions can be compiled to a more efficient calling convention, such as <b>call</b> <b>by</b> <b>value,</b> without changing the meaning of the enclosing program.|$|E
40|$|This paper {{outlines}} {{the structure of}} a standard auto lease contract, and identifies the call option within the lease contract. I then explore a method which allows for the exercise of the option. To value the option sold in an auto lease I bound the option price below <b>by</b> <b>valuing</b> the option as a European <b>call,</b> and above <b>by</b> <b>valuing</b> the option as an American call. I note why the true value of the option should be between the European and American call values. Finding the option value assists in the lease or buy decision. The lessee should lease if the lease option value is greater than the rent charge. In the case of the lessor, I show how to find the threshold rent factor. This rent factor is invaluable for risk management in auto finance companies...|$|R
40|$|The {{asset value}} of {{generation}} investment was studied. The generation investment evaluation model was built, and a stochastic differential electricity price model was also proposed in this work. Some characteristics, {{such as the}} multi-periodic and volatility of price, force outage and life time of generator were considered in the model. Based on the theory of stochastic differential equation, the physical property of price model was proved. The analytic solution of the presented model was deduced according to the method <b>called</b> <b>valuing</b> <b>by</b> expected utility, and the sensitivities of parameters were also analyzed. Numerical simulation results validate the proposed model and analytic solution. link_to_subscribed_fulltex...|$|R
40|$|Definition. A set functor F is <b>called</b> DVO (determined <b>by</b> <b>values</b> on objects), {{if every}} set functor G, such that |FX | = |GX | for all sets X, is {{isomorphic}} (i. e. naturally equivalent) to F. (By |Y | we mean the cardinality of Y.) We aim {{to solve the}} following: Open problem. Find all DVO functors! One of the aims of this talk {{is to make it}} clear that this problem is algebraic rather than categorial. It is related to (and seems to be easier than) Open problem. Find all varieties which are uniquely determined by their free spectra. (In other words, find all varieties which are uniquely determined <b>by</b> <b>values</b> of their free functors on objects.) First recall the relevant known results. • Every DVO set functor is finitary, i. e. preserves directed colimits. This fact was first proved in [2], using a specific set-theoretical assumption. The absolute (and more involved) proof was given in [3]. • DVO set functors containing a copy of a constant functor were character...|$|R
50|$|Simula {{supports}} {{call by name}} so the Jensen's Device {{can easily}} be implemented.However, the default transmission mode for simple parameter is <b>call</b> <b>by</b> <b>value,</b> contrary to ALGOL which used call by name.The source code for the Jensen's Device must therefore specify call by name for the parameters when compiled by a Simula compiler.|$|E
50|$|In purely {{functional}} languages {{there is}} typically no semantic {{difference between the}} two strategies (since their data structures are immutable, so there is no possibility for a function to modify any of its arguments), so they are typically described as <b>call</b> <b>by</b> <b>value</b> even though implementations frequently use call by reference internally for the efficiency benefits.|$|E
50|$|For {{immutable}} objects, {{there is}} no real difference between call by sharing and <b>call</b> <b>by</b> <b>value,</b> except if object identity is visible in the language. The use of call by sharing with mutable objects is an alternative to input/output parameters: the parameter is not assigned to (the argument is not overwritten and object identity is not changed), but the object (argument) is mutated.|$|E
40|$|MOTIVATION: Sufficiently powered case-control {{studies with}} {{next-generation}} sequence (NGS) data remain prohibitively expensive for many investigators. If feasible, {{a more efficient}} strategy would be to include publicly available sequenced controls. However, these studies can be confounded by differences in sequencing platform; alignment, single nucleotide polymorphism and variant calling algorithms; read depth; and selection thresholds. Assuming one can match cases and controls {{on the basis of}} ethnicity and other potential confounding factors, and one has access to the aligned reads in both groups, we investigate the effect of systematic differences in read depth and selection threshold when comparing allele frequencies between cases and controls. We propose a novel likelihood-based method, the robust variance score (RVS), that substitutes genotype <b>calls</b> <b>by</b> their expected <b>values</b> given observed sequence data. RESULTS: We show theoretically that the RVS eliminates read depth bias in the estimation of minor allele frequency. We also demonstrate that, using simulated and real NGS data, the RVS method controls Type I error and has comparable power to the 'gold standard' analysis with the true underlying genotypes for both common and rare variants. AVAILABILITY AND IMPLEMENTATION: An RVS R script and instructions can be found at strug. research. sickkids. ca, and at [URL] CONTACT: lisa. strug@utoronto. ca SUPPLEMENTARY INFORMATION: Supplementary data are available at Bioinformatics online...|$|R
5000|$|Dynamic method <b>calls</b> are {{triggered}} <b>by</b> a <b>value</b> of type [...] as any implicit or explicit parameter (and {{not just}} a receiver). For example: ...|$|R
5000|$|It {{eliminates}} {{having to}} pass references and then dereference them, when using <b>call</b> <b>by</b> reference (or <b>call</b> <b>by</b> address, or <b>call</b> <b>by</b> sharing).|$|R
50|$|ECL was an {{interactive}} system where programs were represented within the system; {{there was a}} compatible compiler and interpreter. It had an ALGOL-like syntax and an extensible data type system, with data types as first-class citizens. Data objects were values, not references, and the calling conventions gave a choice between <b>call</b> <b>by</b> <b>value</b> and call by reference for each argument.|$|E
5000|$|Many {{languages}} support call {{by reference}} {{in some form or}} another, but comparatively few use it as a default. FORTRAN II is an early example of a call-by-reference language. A few languages, such as C++, PHP, Visual Basic [...]NET, C# and REALbasic, default to <b>call</b> <b>by</b> <b>value,</b> but offer special syntax for call-by-reference parameters. C++ additionally offers {{call by reference}} to const.|$|E
50|$|Likewise, the {{operational}} semantics of simply typed lambda calculus {{can be fixed}} as for the untyped lambda calculus, using call by name, <b>call</b> <b>by</b> <b>value,</b> or other evaluation strategies. As for any typed language, type safety is a fundamental property {{of all of these}} evaluation strategies. Additionally, the strong normalization property described below implies that any evaluation strategy will terminate on all simply typed terms.|$|E
40|$|It {{is argued}} that the {{so-called}} fitting attitude- or buck-passing pattern of analysis may be applied to personal values too (and not only to impersonal values, which is the standard analysandum) if the analysans is fine-tuned in the following way: An object has personal value for a person a, {{if and only if}} there is reason to favour it for a’s sake (where “favor” is a place-holder for different pro-responses that are <b>called</b> for <b>by</b> the <b>value</b> bearer). One benefit with it is its wide range: different kinds of <b>values</b> are analysable <b>by</b> the same general formula. Moreover, by situating the distinguishing quality in the attitude rather than the reason part, the analysis admits that personal value is recognizable as a <b>value</b> not only <b>by</b> the person for whom it has personal value, but for everyone else too. We thereby avoid facing two completely dif-ferent notions of value, viz., one pertaining to impersonal value, and another to personal value. The analysis also elucidates why we are (at least pro tanto) justified in our concern for objects that are valuable for us; if value just is, as it is suggested, the existence of reasons for such a concern, the justification is immediately forthcoming...|$|R
5000|$|Urvashi as Ammu (as <b>called</b> <b>by</b> Nandakumar, her husband) / Thulasi (as <b>called</b> <b>by</b> Shakthi, her ex-lover) / Chakki (as <b>called</b> <b>by</b> her parents) ...|$|R
5000|$|Example the <b>call</b> <b>by</b> {{address that}} simulates <b>call</b> <b>by</b> {{reference}} in C: ...|$|R
