64|77|Public
25|$|A client {{that does}} key pinning adds an extra step beyond the normal X.509 {{certificate}} validation: After obtaining the server's certificate {{in the standard}} way, the client checks the public key(s) in the server's <b>certificate</b> <b>chain</b> against a set of (hashes of) public keys for the server name. Typically the public key hashes are bundled with the application. For example, Google Chrome includes public key hashes for the *.google.com certificate that detected fraudulent certificates in 2011. (Chromium does not enforce the hardcoded key pins.) Since then, Mozilla has introduced public key pinning to its Firefox browser.|$|E
50|$|For faster cache validation, {{the time}} for how long the user session key and <b>certificate</b> <b>chain</b> are cached can be adjusted.|$|E
50|$|The full PKCS #12 {{standard}} is very complex. It enables buckets of complex {{objects such as}} PKCS #8 structures, nested deeply. But in practice it is normally used to store just one private key and its associated <b>certificate</b> <b>chain.</b>|$|E
5000|$|... #Subtitle level 2: <b>Certificate</b> <b>chains</b> and {{cross-certification}} ...|$|R
50|$|Examining how <b>certificate</b> <b>chains</b> {{are built}} and validated, it is {{important}} to note that a concrete certificate can be part of very different <b>certificate</b> <b>chains</b> (all of them valid). This is because several CA certificates can be generated for the same subject and public key signing them with different private keys (from different CAs or different private keys from the same CA). So, although a single X.509 certificate can have only one issuer and one CA signature, it can be validly linked to more than one certificate building completely different <b>certificate</b> <b>chains.</b> This is crucial for cross-certification between PKIs and other applications.|$|R
50|$|Most browsers disable pinning for <b>certificate</b> <b>chains</b> {{with private}} root {{certificates}} to enable various corporate content inspection scanners and web debugging tools (such as mitmproxy or Fiddler).|$|R
50|$|Path {{validation}} {{is necessary}} for a relying party to make an informed trust decision when presented with any certificate that is not already explicitly trusted. For example, in a hierarchical PKI, a <b>certificate</b> <b>chain</b> starting with a web server certificate {{might lead to a}} small CA, then to an intermediate CA, then to a large CA whose trust anchor is present in the relying party's web browser. In a bridged PKI, a <b>certificate</b> <b>chain</b> starting with a user at Company A might lead to Company A's CA certificate, then to a bridge CA, then to company B's CA certificate, then to company B's trust anchor, which a relying party at company B could trust.|$|E
5000|$|The HPKP policy {{specifies}} hashes of {{the subject}} public key info {{of one of the}} certificates in the website's authentic X.509 public key <b>certificate</b> <b>chain</b> (and at least one backup key) in [...] directives, and a period of time during which the user agent shall enforce public key pinning in [...] directive, optional [...] directive to include all subdomains (of the domain that sent the header) in pinning policy and optional [...] directive with URL where to send pinning violation reports. At least one of the public keys of the certificates in the <b>certificate</b> <b>chain</b> needs to match a pinned public key in order for the chain to be considered valid by the user agent.|$|E
50|$|At {{least one}} backup key must be pinned, {{in case the}} current pinned key needs to be replaced. The HPKP is not valid without this backup key (a backup key {{is defined as a}} public key not present in the current <b>certificate</b> <b>chain).</b>|$|E
3000|$|... {{subgraph}} {{is generated}} by applying first the reverse process and then adding in-going arcs. The <b>certificate</b> <b>chains</b> required in the authentication are built by using the arcs [...]...|$|R
40|$|A Certification Authority (CA) {{can be used}} {{to certify}} keys and build a public-key {{infrastructure}} (PKI) when all users trust the same CA. A decentralized PKI trades off absolute assurance on keys for independence from central control and improved scalability and robustness. The PGP ``web of trust'' model has been suggested as a decentralized certification system, and has been used with great success for secure email. Although the PGP web of trust model allows anyone to issue certificates which {{can be used to}} form <b>certificate</b> <b>chains,</b> the discovery and construction of <b>certificate</b> <b>chains</b> relies on centralized keyservers to store certificates and respond to queries. In this paper, we design and implement KeyChains, a peer-to-peer system which incorporates a novel lookup mechanism specifically tailored to the task of generating and retrieving <b>certificate</b> <b>chains</b> in completely unstructured networks. By layering our system on top of the web of trust model, we thus obtain the first PKI which is truly decentralized in all respects. Our analysis and simulations show that the resulting system is both efficient and secure...|$|R
50|$|<b>Certificate</b> <b>chains</b> {{are used}} in order to check that the public key (PK) {{contained}} in a target certificate (the first <b>certificate</b> in the <b>chain)</b> and other data contained in it effectively belongs to its subject. In order to ascertain this, the signature on the target certificate is verified by using the PK contained in the following certificate, whose signature is verified using the next certificate, and so on until the last <b>certificate</b> in the <b>chain</b> is reached. As the last certificate is a trust anchor, successfully reaching it will prove that the target certificate can be trusted.|$|R
5000|$|A <b>certificate</b> <b>chain</b> (see the {{equivalent}} concept of [...] "certification path" [...] defined by RFC 5280) {{is a list}} of certificates (usually starting with an end-entity certificate) followed by one or more CA certificates (usually the last one being a self-signed certificate), with the following properties: ...|$|E
50|$|There are {{at least}} two reasons why a self-signed {{certificate}} based PKI may have decreased overall risk. The first, also shared with private PKI systems, it that they avoid the problems of trusting third parties that may improperly sign certificates. Self-signed certificate transactions usually present a far smaller attack surface, by eliminating both the complex <b>certificate</b> <b>chain</b> validation, and CA revocation checks like CRL and OCSP.|$|E
50|$|The {{chain of}} trust of a <b>certificate</b> <b>chain</b> is an ordered list of certificates, {{containing}} an end-user subscriber certificate and intermediate certificates (that represents the intermediate CA), {{that enables the}} receiver to verify that the sender and all intermediates certificates are trustworthy. This process is best described in the page Intermediate certificate authority. See also X.509 certificate chains for a description of these concepts in a widely used standard for digital certificates.|$|E
50|$|The Resource Public Key Infrastructure (RPKI) is {{designed}} to authenticate route origins via cryptographic <b>certificate</b> <b>chains</b> demonstrating address block range ownership, but is not widely deployed yet. Once deployed, IP hijacking through errant issues at the origin (via both accident or intent) should be detectable and filterable.|$|R
50|$|OCSP {{stapling}} {{is designed}} {{to reduce the cost}} of an OCSP validation---both for the client and the OCSP responder---especially for large sites serving many simultaneous users. However, OCSP stapling supports only one OCSP response at a time, which is insufficient for <b>certificate</b> <b>chains</b> with intermediate CA certs.|$|R
30|$|There is a {{characteristic}} in the designed algorithm that is {{shared with the}} proposal described at [22]. It is possible to adapt the number of <b>certificate</b> <b>chains</b> to be built {{as well as their}} length depending on the characteristics of the MANET where the proposal must be implemented.|$|R
50|$|If {{the user}} agent {{performs}} pin validation and fails {{to find a}} valid SPKI fingerprint in the served <b>certificate</b> <b>chain,</b> it will POST a JSON formatted violation report to the host specified in the report-uri directive containing details of the violation. The user agent cannot send HPKP violation reports to the same domain, as the report was triggered because the connection failed, so hosts must use an alternative domain or use a reporting service.|$|E
50|$|For example, attackers might {{compromise}} {{a certificate}} authority, and then mis-issue certificates for a web origin. To combat this risk, the HTTPS web server serves {{a list of}} “pinned” public key hashes valid for a given time; on subsequent connections, during that validity time, clients expect the server to use {{one or more of}} those public keys in its <b>certificate</b> <b>chain.</b> If it does not, an error message is shown, which cannot be (easily) bypassed by the user.|$|E
50|$|The Signature RTD 2.0 {{supports}} two certificate formats. One being X.509 certificate {{format and}} the other the Machine to Machine (M2M) Certificate format. The M2M Certificate format is a subset of X.509 designed for limited memory typically found on NFC tags. The author's certificate can optionally be replaced with a URI reference to that certificate or <b>Certificate</b> <b>Chain</b> so that messages can be cryptographically verified. The URI certificate reference designed to save memory for NFC tags.|$|E
50|$|Federation problem: <b>Certificate</b> <b>chains</b> {{that are}} the result of {{subordinate}} CAs, bridge CAs, and cross-signing make validation complex and expensive in terms of processing time. Path validation semantics may be ambiguous. The hierarchy with a third-party trusted party is the only model. This is inconvenient when a bilateral trust relationship is already in place.|$|R
40|$|Effective storing, {{retrieval}} {{and interpretation}} of <b>certificate</b> <b>chains</b> is a difficult problem. The original X. 500 and X. 509 proposals, with their rigid global naming scheme and complex access protocols {{have proved to be}} less than optimal, leading to various short-cuts. For example, the de facto X. 509 retrieval protocol appears to be TCP/IP based LDAP instead of the original OSI based Directory Access Protocol, DAP. In this paper we present a completely new architecture for administration, storing and retrieval of digital certificates. Instead of X. 509 certificates we base our architecture on SPKI, a more flexible certificate format proposed by the IETF. The new architecture allows complex <b>certificate</b> <b>chains</b> to be effectively and easily administered, using the Internet Domain Name Service, or DNS, as the certificate storage, replication and retrieval mechanism. The interpretation of the certificates is based on our Internet Security Policy Daemon architecture. 1 Introduction A digital [...] ...|$|R
40|$|Abstract. The {{authorization}} {{problem is}} to decide whether, according to a security policy, some principal should be allowed access to a resource. In the trust-management system SPKI/SDSI, the security policy is given {{by a set of}} certificates, and proofs of authorization take the form of <b>certificate</b> <b>chains.</b> The certificate-chain-discovery {{problem is to}} discover a proof of authorization for a given request. Although certificate-chain-discovery algorithms for SPKI/SDSI have been investigated by several researchers, previous work did not address how to perform certificatechain discovery in distributed environments. We address the certificate-chain-discovery problem where the certificates are distributed over a number of sites, which then have to cooperate to identify the proof of authorization for a given request. We propose two protocols for this purpose. These protocols can also handle cases where certificates are labeled with weights and where multiple <b>certificate</b> <b>chains</b> must be combined to form a proof of authorization. We have implemented these protocols in a prototype and report preliminary results of our evaluation. 1...|$|R
5000|$|It {{would be}} {{possible}} to have the hardware check the suitability (signature) for every single piece of software. However, this would not produce the flexibility that a [...] "chain" [...] provides. In a chain, any given link can be replaced with a different version to provide different properties, without having {{to go all the way}} back to the trust anchor. This use of multiple layers is an application of a general technique to improve scalability, and is analogous to the use of multiple certificates in a <b>certificate</b> <b>chain.</b>|$|E
50|$|The Signature RTD 2.0's {{primary purpose}} is the protect the {{integrity}} and authenticity of NDEF records. Thus NFC tag contents using the Signature RTD 2.0 is protected. The security {{of the system is}} tied to a certificate authority and the associated <b>Certificate</b> <b>Chain.</b> The NFC Forum Signature RTD Certificate Policy defines the policies under which certificate authorities can operate in the context of NFC. Root certificates are carried in verification devices and are not contained in the signature record. This separation is important for the security of the system just as web browser certificates are separated from web server certificates in TLS.|$|E
5000|$|One way {{to detect}} and block many kinds of man-in-the-middle attacks is [...] "certificate pinning", {{sometimes}} called [...] "SSL pinning", but more accurately called [...] "public key pinning".A client that does key pinning adds an extra step beyond the normal X.509 certificate validation: After obtaining the server's certificate in the standard way, the client checks the public key(s) in the server's <b>certificate</b> <b>chain</b> against a set of (hashes of) public keys for the server name. Typically the public key hashes are bundled with the application. For example, Google Chrome includes public key hashes for the *.google.com certificate that detected fraudulent certificates in 2011. (Chromium does not enforce the hardcoded key pins.) Since then, Mozilla has introduced public key pinning to its Firefox browser.|$|E
40|$|A {{sequential}} aggregate signature {{scheme is}} a digital signature that supports aggregation: A single sequential aggregate, {{the same length}} as an ordinary signature, along with the n original messages, convinces a verifier that the n users did indeed sign the n original messages (i. e., user i signed message M i for i = 1, [...] ., n). Sequential aggregate signatures are useful for reducing the size of <b>certificate</b> <b>chains</b> by aggregating all signatures in the chain. For sequential aggregate signatures, unlike the aggregate signatures given by Boneh, Gentry, Lynn, and Shacham, signing and aggregation are a single operation; each signer adds his signature into a sequential aggregate, which is inherently ordered; this makes them a natural primitive for <b>certificate</b> <b>chains.</b> In this paper we introduce {{the concept of a}} sequential aggregate signature scheme and present a security model for such signatures. We also show how to construct them from any family of homomorphic trapdoor one-way permutations; previous aggregate signatures required the use of a bilinear map. Finally, we discuss how to instantiate the scheme using the trapdoor permutations generated by the RSA function...|$|R
5000|$|A new {{option that}} allows an {{application}} to be updated {{from an old}} certificate to a new one while preserving {{the identity of the}} application (for example from a self-signed <b>certificate</b> to a <b>chained</b> <b>certificate)</b> ...|$|R
5000|$|XAdES-X (extended), adding {{timestamps}} on {{the references}} introduced by XAdES-C {{to protect against}} possible compromise of <b>certificates</b> in <b>chain</b> in future; ...|$|R
3000|$|... {{included}} in the message M 3 (14). Then, it requests the validation of CertS as the authentication server’s certificate to the certificate validation server (15). The certification validation server performs the validation of the certificate or the <b>certificate</b> <b>chain</b> (16). The validation of the certificate or the <b>certificate</b> <b>chain</b> includes verifying the signature data of each certificate in the <b>certificate</b> <b>chain</b> and validating whether each certificate in the <b>certificate</b> <b>chain</b> has expired or been revoked by their issuer. Finally, the TMZ system verifies the signature data SignS(R [...]...|$|E
30|$|Finding a <b>certificate</b> <b>chain.</b>|$|E
3000|$|... 10 is invalid. This {{naturally}} {{leads to}} a DoS and consequently, the nodes must repeat the <b>certificate</b> <b>chain</b> discovery procedure from the ground up.|$|E
40|$|In {{this note}} we {{consider}} how {{role-based access control}} can be managed {{on a large scale}} over the Internet and across organizational boundaries. We take a PKI approach, in which users are identified using public key certificates, as are the servers. The main features of our approach are: access control by (client, role) pair; implied revocation based on the role hierarchy; automatic generation of certificate validity tickets; and <b>certificate</b> <b>chains</b> to prove a client role hierarchy to a server. ...|$|R
5000|$|Since both cert1 and cert3 {{contain the}} same public key (the old one), {{there are two}} valid <b>certificate</b> <b>chains</b> for cert5: [...] "cert5 → cert1" [...] and [...] "cert5 → cert3 → cert2", and analogously for cert6. This allows that old user {{certificates}} (such as cert5) and new certificates (such as cert6) can be trusted indifferently by a party having either the new root CA certificate or the old one as trust anchor during {{the transition to the}} new CA keys.|$|R
30|$|Verifying the <b>certificates</b> in the <b>chain.</b>|$|R
