100|74|Public
5000|$|In his 1984 MSc thesis {{and prior}} work he {{investigated}} and formalized the CERES <b>compiler</b> <b>generator</b> (with Neil D. Jones), and showed that(1) a <b>compiler</b> <b>generator</b> {{is itself a}} compiler from language definitions to compilers; and (2) under suitable assumptions thereexists a language definition that, when applied to itself, generates a <b>compiler</b> <b>generator.</b> This has close connections to self-application in partial evaluation.|$|E
5000|$|Coco/R, <b>compiler</b> <b>generator</b> {{accepting}} an attributed grammar in EBNF ...|$|E
5000|$|SYNTAX <b>compiler</b> <b>generator</b> (used {{to build}} many CADP compilers and translators) ...|$|E
40|$|The {{current state}} of the art for {{ensuring}} finite unfolding of logic programs consists of a number of online techniques where unfolding decisions are made at specialisation time. Introduction of a static termination analysis phase into a partial deduction algorithm permits unfolding decisions to be made offline, before the actual specialisation phase itself. This separation improves specialisation time and facilitates the automatic construction of <b>compilers</b> and <b>compiler</b> <b>generators.</b> The main contribution of this paper i...|$|R
40|$|Language {{design and}} {{implementation}} are {{still one of the}} challenges in computer science. Programmers use a variety of languages in their daily work, and new languages appear frequently. With formal methods for programming language description a language designer has a chance to automatically generate a compiler or an interpreter. Unfortunately, <b>compiler</b> <b>generators</b> nowadays use linear textual specifications, which are less suitable then visual presentation. In the paper a language development in a visual manner is described...|$|R
5000|$|Many {{integrated}} development environments (IDEs) support {{some form}} of automatic source code generation, often using algorithms in common with <b>compiler</b> code <b>generators,</b> although commonly less complicated. (See also: Program transformation, Data transformation.) ...|$|R
5000|$|A <b>Compiler</b> <b>Generator</b> (with W. M. Mckeeman and D. B. Wortman), Prentice Hall (1970)[...]|$|E
50|$|Coco/R is a <b>compiler</b> <b>generator</b> {{that takes}} an L-attributed Extended Backus-Naur Form (EBNF) grammar of a source {{language}} and generates a scanner and a parser for that language.|$|E
50|$|SableCC is an {{open source}} <b>compiler</b> <b>generator</b> (or {{interpreter}} generator) in Java. Stable version is licensed under the GNU Lesser General Public License (LGPL). Rewritten version 4 is licensed under Apache License 2.0.|$|E
50|$|For example, the {{language}} of even-length palindromes on the alphabet of 0 and 1 has the unambiguous context-free grammar S → 0S0 | 1S1 | ε. An arbitrary string of this language cannot be parsed without reading all its letters first which means that a pushdown automaton has to try alternative state transitions to accommodate for the different possible lengths of a semi-parsed string. Nevertheless, removing grammar ambiguity may produce a deterministic context-free grammar and thus allow for more efficient parsing. <b>Compiler</b> <b>generators</b> such as YACC include features for resolving some kinds of ambiguity, such as by using the precedence and associativity constraints.|$|R
50|$|Wilhelm's {{research}} {{focuses on}} programming languages, compiler construction, static program analysis and embedded real time systems, but also includes animation and visualization of algorithms and data structures. Wilhelm discovered connections between code selection and the theory of regular tree automata, which is relevant for code generation using tree automata. He {{is one of the}} co-developers of the MUG1, MUG2 and OPTRAN <b>compiler</b> <b>generators,</b> which are based on attribute grammars. Together with Ulrich Möncke, he proposed grammar flow analysis as a generalization of interprocedural data flow analysis. He invented a popular shape analysis based on three-valued logic together with Mooly Sagiv and Tom Reps.|$|R
50|$|In computing, code {{generation}} {{is the process}} by which a <b>compiler's</b> code <b>generator</b> converts some intermediate representation of source code into a form (e.g., machine code) that can be readily executed by a machine.|$|R
5000|$|XPL Analyzer, a tool which accepts {{simplified}} BNF for {{a language}} and produces a parser for that language in XPL; {{it may be}} integrated into the supplied SKELETON program, with which the language may be debugged (SHARE contributed program, which was preceded by A <b>Compiler</b> <b>Generator,</b> [...] ) ...|$|E
50|$|XPL was {{designed}} and implemented by William McKeeman and David B. Wortman at University of California, Santa Cruz and James J. Horning and others at Stanford University. XPL was first announced at the 1968 Fall Joint Computer Conference. The methods and compiler are described in detail in the 1971 textbook A <b>Compiler</b> <b>Generator.</b>|$|E
50|$|Johnson {{worked on}} Yacc {{in the early}} 1970s at Bell Labs. He was {{familiar}} with TMG and its influence {{can be seen in}} Yacc and the design of the C programming language. Because Yacc was the default <b>compiler</b> <b>generator</b> on most Unix systems, it was widely distributed and used. Derivatives such as GNU Bison are still in use.|$|E
2500|$|For example, the {{language}} of even-length palindromes on the alphabet of 0 and 1 has the unambiguous context-free grammar S → 0S0 | 1S1 | ε. [...] An arbitrary string of this language cannot be parsed without reading all its letters first which means that a pushdown automaton has to try alternative state transitions to accommodate for the different possible lengths of a semi-parsed string. Nevertheless, removing grammar ambiguity may produce a deterministic context-free grammar and thus allow for more efficient parsing. <b>Compiler</b> <b>generators</b> such as YACC include features for resolving some kinds of ambiguity, such as by using the precedence and associativity constraints.|$|R
50|$|Sieve {{has been}} shown http://www.codeplay.com/technology/sievebenchmarks.html {{successfully}} operating on multi-core x86 systems, the Ageia PhysX Physics Processing Unit, and the IBM Cell microprocessor. ANSI C is generated if a <b>compiler</b> code <b>generator</b> is not available for a certain target platform. This allows for autoparallelization using existing C compilation toolkits http://mgrid.feis.herts.ac.uk/wp-content/scott.ppt.|$|R
50|$|The code is {{portable}} and, {{like many}} other open source compiler projects such as GCC or LCC the <b>compiler</b> backend (code <b>generator)</b> is retargetable.|$|R
50|$|Defense Advanced Research Projects Agency DARPA {{sponsored}} a compiler project with Wulf's CMU research team in 1970. The Production Quality Compiler-Compiler PQCC design {{would produce a}} Production Quality Compiler (PQC) from formal definitions of source language and the target. PQCC tried to extend the term compiler-compiler beyond the traditional meaning as a parser generator (e.g., YACC) without much success. PQCC might more properly {{be referred to as}} a <b>compiler</b> <b>generator.</b>|$|E
50|$|In {{computer}} science, a compiler-compiler or <b>compiler</b> <b>generator</b> is a {{programming tool}} {{that creates a}} parser, interpreter, or compiler from some form of formal description of a language and machine. The input may be a text file containing the grammar written in BNF or EBNF that defines the syntax of a programming language, and whose generated output is some source code of the parser for the programming language, although other definitions exist.|$|E
40|$|We {{have been}} {{developing}} a <b>Compiler</b> <b>Generator</b> {{which makes a}} system designer evaluate his/her architecture easily. In this paper, {{the performance of the}} <b>compiler</b> <b>generator</b> is presented. Experimental results show that the <b>compiler</b> <b>generator</b> produces a relatively good backend compiler from the formal architecture information. These results imply the automatic generation of optimizing compilers from architecture descriptions written in HDLs will be possible...|$|E
40|$|Programming of {{technical}} tasks {{can often be}} viewed as translation from one formal language into another. Thus suitable translators can improve productivity. Depot 4 is a metasystem for rapid development of translators. Its unique translation centered metalanguage is for efficiency {{and ease of use}} by non-experts. The implementation, which is by preprocessing, benefits from the innovative features of the Oberon System. A generalisation of the language notion accompanied by extensibility of the metasystem offer new ways of application. Some are illustrated by example. Keywords: Object-Oriented Programming; Automatic Programming; Compiling Techniques; Tools and Techniques; Metasystems; Oberon 1. Introduction The translator-generator Depot 4 is the latest outcome in a line of projects. It was undertaken to combine practical experience and new software technologies into a state-of-the-art tool. Metasystems of the Depot family are closely related to <b>compiler</b> <b>generators.</b> They translate a gr [...] ...|$|R
40|$|Actress is a semantics-directed {{compiler}} {{generation system}} based on action semantics. Its aim is to generate compilers whose performance is closer to hand-written compilers than the ones generated by other semantics-directed <b>compiler</b> <b>generators.</b> Actress generates a compiler for a language {{based solely on the}} language's action semantic description. We describe the process by which this is achieved. A compiler for action notation, the formal notation used in action semantic descriptions, is the core of the generated compilers. We specify and implement a code generator for the action notation compiler. We also present the design and implementation of an action notation interpreter. A conventional hand-written compiler eliminates, whenever possible, references to identifiers at compile time. Some storage allocation is often performed at compile-time too. We can see both steps as transformations whose main objective is {{to improve the quality of}} the object code. The compiler writer, based o [...] ...|$|R
40|$|In David Schmidts PhD work he {{explored}} {{the use of}} denotational semantics as a programming lan-guage. It {{was part of an}} effort to not only treat formal semantics as specifications but also as inter-preters and input to <b>compiler</b> <b>generators.</b> The semantics itself can be seen as a program and one may examine different programming styles and ways to represent states. Abstract interpretation is primarily a technique for derivation and specification of program anal-ysis. As with denotational semantics we may also view abstract interpretations as programs and examine the implementation. The main focus in this paper is to show that results from higher-order strictness analysis may be used more generally as fixpoint operators for higher-order functions over lattices and thus provide a technique for immediate implementation of a large class of abstract inter-pretations. Furthermore, it may be seen as a programming paradigm and be used to write programs in a circular style. ...|$|R
40|$|Recently, {{due to the}} {{progress}} of CAD and device technologies, hardware/software codesign has attracted large attention. But lack of a compiler for the designed application specified processor makes it trouble to evaluate hardware and software together and to develop application programs. We have been developing a <b>compiler</b> <b>generator</b> for user designed processors. In this paper, we present the implementation and experimental results of the <b>compiler</b> <b>generator.</b> The <b>compiler</b> <b>generator</b> is based on tree-pattern matching and parameterized functions. Experimental results show that a compiler generated by the <b>compiler</b> <b>generator</b> have quality as good as an existing popular retargetable compiler, and that the <b>compiler</b> <b>generator</b> reduces description of processors to generate a compiler. 1 Introduction Hardware/Software codesign is an effective approach to designing a digital system which contains micro processor units(MPU's). In order to optimize the system, it is effective to design an application s [...] ...|$|E
40|$|The {{concept of}} grammar {{inheritance}} is introduced. Grammar inheritance is a structural organization of grammar rules {{by which a}} grammar inherits rules from ancestor grammars or may have its own rules inherited by descendant grammars. Grammar inheritance supports reusability and extensibility of grammar rules. The concept of grammar inheritance is especially useful in combination with a <b>compiler</b> <b>generator.</b> A <b>compiler</b> <b>generator</b> tool for the SMALLTALK language which supports grammar inheritance is discussed. This tool was implemented on a Sun 3 workstation and extensively tested...|$|E
40|$|We report {{progress}} {{on the development of}} Actress, a <b>compiler</b> <b>generator</b> based on action semantics. It consists of a number of modules, written in SML, that can be composed to construct either an action notation compiler or a simple <b>compiler</b> <b>generator.</b> We also outline current and future developments that will improve the quality of the generated compilers. 1 Introduction We define a <b>compiler</b> <b>generator</b> to be a tool that constructs a compiler automatically, given a syntactic and semantic description of the source language. This definition emphasizes the fact that the compiler is not written by a programmer, but generated from a formal description of the language. Ideally, this formal description is one that was written by the language designer and is consulted by users of the language. We can generate an efficient syntactic analyser automatically from a syntactic description, using tools such as lex and yacc. However, generating a code generator from a semantic description is much more d [...] ...|$|E
40|$|This paper {{describes}} the LISA system {{which is a}} generic interactive environment for programming language development. From the formal language specifications of a particular programming language LISA produces a language specific environment that includes a language-knowledgable editor, a compiler/interpreter and other graphic tools. The paper focuses on design decisions, implementation issues and tools integration in the system LISA. The main reasons for developing a new compiler/interpreter generator system were: support for incremental language development, support for language design in a visual manner and the portability {{of the system and}} the generated environment. LISA is a set of related tools such as scanner <b>generators,</b> parser <b>generators,</b> <b>compiler</b> <b>generators,</b> graphic tools, editor and conversion tools, which are integrated by well designed interfaces. Therefore, it has the advantages of a single system and federated environment. LISA and the generated environment are written in Java which enables high portability to different platforms...|$|R
40|$|The {{current state}} of the art for {{ensuring}} finite unfolding of logic programs consists of a number of online techniques where unfolding decisions are made at specialisation time. Introduction of a static termination analysis phase into a partial deduction algorithm permits unfolding decisions to be made offline, before the actual specialisation phase itself. This separation improves specialisation time and facilitates the automatic construction of <b>compilers</b> and <b>compiler</b> <b>generators.</b> The main contribution of this paper is how this separation may be achieved in the context of logic programming, while providing non-trivial support for partially static datastructures. The paper establishes a solid link between the fields of static termination analysis and partial deduction enabling existing termination analyses to be used to ensure finiteness of the unfolding process. This is the first offline technique which allows arbitrarily partially instantiated goals to be sufficiently unfolded to ac [...] ...|$|R
40|$|Abstract. A {{system called}} BURS {{that is based}} on term rewrite systems and a search {{algorithm}} A are combined to produce a code generator that generates optimal code. The theory underlying BURS is re-developed, formalised and explained in this work. The search algorithm uses a cost heuristic that is derived from the term rewrite system to direct the search. The advantage of using a search algorithm {{is that we need to}} compute only those costs that may be part of an optimal rewrite sequence. Key words: <b>compiler</b> <b>generators,</b> code generation, term rewrite systems, search algorithms, formal techniques Compiler building is a time-consuming and error-prone activity. Building the frontend (i. e. scanner, parser and intermediate-code generator) is straightforward—the theory is well established, and there is ample tool support. The main problem lies with the back-end, namely the code generator and optimiser—there is little theory and even less tool support. Generating a code generator from an abstract specification, also called automatic code generation, remains a very difficult problem...|$|R
40|$|This paper {{describes}} the structure of, and the ideas behind, a self-applicable specializer of programs, {{as well as}} the principles of operation of a <b>compiler</b> <b>generator</b> that has been produced automatically by specializing the specializer with respect to itself. It has been found that the structure of the compilers produced can be improved by making use of such devices as introducing different representations for the values of K- and U-parameters, splitting the subject program into K-and U-program, and automatically raising the arity of functions in the residual program. KEY WORDS AND PHRASES: <b>Compiler</b> <b>generator,</b> partial evaluation, mixed computation, non-partial evaluation, self-applicability, specializer, unmixed computation...|$|E
40|$|This paper {{describes}} {{a system that}} resolves conflicts in LR(l) parsing {{by taking advantage of}} information in the parse tree. The system, which functions as part of a <b>compiler</b> <b>generator,</b> rewrites the user's grammar to remove parsing conficts. It then places code into the generated compiler that rewrites the parse tree during parsing so as to produce the tree of the original grammar. The compiler writer can then write the semantic attribution to fit his or her original grammar without any knowledge of the changes made. The method is expected to be efficient in most cases, even in parsing systems that do not explicitly build the entire parse tree. The method complements previous work in its capabilities and advantages. The system has been implemented and integrated into a <b>compiler</b> <b>generator</b> syste...|$|E
40|$|The {{design and}} {{implementation}} of the FORTRAN/ 8 compiler for the PDP- 8 computer is described. This compiler was written using the XPL <b>Compiler</b> <b>Generator</b> System and runs on an IBM System 360. FORTRAN/ 8 accepts FORTRAN as the source language and generates code acceptable for execution on a PDP- 8 computer. [URL]...|$|E
40|$|Testing {{tools are}} {{software}} analyzers that use information from particular executions {{of a program}} {{as well as information}} about a specification and the program text itself. Research prototypes of such tools are essential to investigate the ideas they embody. Often, hand calculation is so tedious and error-prone that an investigator cannot obtain any intuition about his or her ideas without an implementation to aid in experiments. Traditionally, such tools have been implemented in conventional high-level languages (e. g., C, Pascal), a process that takes more time than a prototype should. The technology of <b>compiler</b> <b>generators</b> and logic programming, applied to the idea of self-instrumenting programs, drastically shortens the prototype cycle. This paper describes a general method for implementing prototype tools, gives examples of several old and new testing techniques fitted into the method, and discusses the ease with which such prototypes may be changed. KEY WORDS Instrumented programs Test coverage Testing tool...|$|R
40|$|The goal of {{this thesis}} is to design and {{implement}} the support for generators within the Peachpie framework, a PHP to CIL <b>compiler.</b> <b>Generators</b> are the simplest form of methods that resume from the same state in which they returned earlier when called repeatedly. The reference PHP interpreter Zend engine supports generators natively. Due to that fact that generators in PHP support a number of features that are not common in other languages. CIL, on the other hand, {{does not have a}} native support for generators. Therefore, languages built on top of CIL (e. g. C#, F#) have to implement them by other means, such as by rewriting the original generator methods into state machines. In this thesis, we will design and implement the support for generators through semantic tree transformations. All this is handled with the intention of keeping the maximum possible compatibility with reference PHP generators. We will also make a comparison to generators in C#, whose main implementation also uses CIL as a backend. ...|$|R
40|$|The paper {{investigates the}} status quo of {{technology}} and science for compiler safety methods. We consider specific requirements for <b>compilers</b> and <b>generators</b> for automotive applications and discuss established and newly emerging methods of compiler safety in this context. We put the main focus on compiler verification methods {{on the one hand}} and testing technology on the other hand and discuss their applicability in the automotive context...|$|R
