80|8181|Public
50|$|Beyond {{the basic}} Prolog data types, the {{following}} are available: strings,unlimited precision integer and rational numbers,and floating point intervals.Array syntax and structures with field namesare also supported and especially useful in <b>constraint</b> <b>modelling.</b>|$|E
50|$|The entire {{design process}} was {{conducted}} using 3D digital and physical modelling, {{and the design}} development was completed using rigorous <b>constraint</b> <b>modelling</b> and scripting to control over 850 individually different profiles and 2000 joints. Finally, the elements were manufactured directly from digital models on CNC cutting equipment using standard sized 13mm thick flat sheets of Fibre-C concrete and 15mm thick mild steel plate.|$|E
40|$|This {{work was}} {{supported}} by UK EPSRC EP/K 015745 / 1. Jefferson {{is supported by a}} Royal Society University Research Fellowship. Many constraint problems contain symmetry, which can lead to redundant search. If a partial assignment is shown to be invalid, we are wasting time if we ever consider a symmetric equivalent of it. A particularly important class of symmetries are those introduced by the <b>constraint</b> <b>modelling</b> process: model symmetries. We present a systematic method by which the automated <b>constraint</b> <b>modelling</b> tool CONJURE can break conditional symmetry as it enters a model during refinement. Our method extends, and is compatible with, our previous work on automated symmetry breaking in CONJURE. The result is the automatic and complete removal of model symmetries for the entire problem class represented by the input specification. This applies to arbitrarily nested conditional symmetries and represents a significant step forward for automated <b>constraint</b> <b>modelling.</b> Publisher PD...|$|E
40|$|<b>Constraint</b> <b>modeling</b> {{could be}} a very {{important}} system validation method, because its abilities are complementary to both testing and code inspection. In particular, even though the ability of <b>constraint</b> <b>modeling</b> to find errors is limited by the simplifications which are introduced when making a <b>constraint</b> <b>model,</b> <b>constraint</b> <b>modeling</b> can locate important classes of errors which are caused by non-local faults (i. e., are hard to find with code inspection) and manifest themselves as failures only in unusual situations (i. e., are hard to find with testing) ...|$|R
40|$|We {{present a}} planner named Transition Constraints for Parallel Planning (TCPP). TCPP {{constructs}} a new <b>constraint</b> <b>model</b> from domain transition graphs (DTG) {{of a given}} planning problem. TCPP encodes the <b>constraint</b> <b>model</b> by using table constraints that allow don't cares or wild cards as cell values. TCPP uses Minion the constraint solver to solve the <b>constraint</b> <b>model</b> and returns the parallel plan. Empirical results exhibit the efficiency of our planning system over state-of-the-art constraint-based planners. No Full Tex...|$|R
40|$|Abstract. We {{develop a}} module-based {{framework}} for <b>constraint</b> <b>modeling</b> {{where it is}} possible to combine different <b>constraint</b> <b>modeling</b> languages and exploit their strengths in a flexible way. In the framework a <b>constraint</b> <b>model</b> consists of modules with clear input/output interfaces. When combining modules, apart from the interface, a module is a black box whose internals are invisible to the outside world. Inside a module a chosen constraint language (approaches such as CP, ASP, SAT, and MIP) can be used. This leads to a clear modular semantics where the overall semantics of the whole <b>constraint</b> <b>model</b> is obtained from the semantics of individual modules. The framework supports multi-language modeling without the need to develop a complicated joint semantics and enables the use of alternative semantical underpinnings such as default negation and classical negation in the same model. Furthermore, computational aspects of the framework are considered and, in particular, possibilities of benefiting from the known module structure in solving <b>constraint</b> <b>models</b> are studied. ...|$|R
40|$|Compared to the {{proprietary}} programming {{languages of}} systems like ILOG Solver, SICStus Prolog and Mozart Oz, <b>constraint</b> <b>modelling</b> languages offer {{a lot of}} benefits, such as usability and portability. This report presents the design and a prototype implementation of the “Tiny <b>Constraint</b> <b>Modelling</b> Language ” (TCML). The data types and control structures of TCML {{have been designed to}} make the modelling of constraint problems intuitive and declarative; they include powerful iterators and arrays of dynamic size. The prototype implementation currently includes backends for Mozart Oz and ILOG solver...|$|E
40|$|The {{modelling}} bottleneck in <b>Constraint</b> <b>Modelling</b> {{prevents the}} widespread use of Constraint Programming techniques. Automated <b>Constraint</b> <b>Modelling</b> addresses this problem. To enhance automatically generated models, we eliminate common subexpressions during the modelling process, as compilers do when compiling source code. Common subexpression elimination can lead to a dramatic reduction in the size of a constraint problem, as well as a reduction in solving time and the same number of search nodes. Furthermore, it can lead to enhanced propagation and reduced search. Thus we propose common subexpression elimination as an important technique for Constraint Programming...|$|E
40|$|This paper {{describes}} how <b>constraint</b> <b>modelling</b> can support design innovation. Furthermore, it lays out how constraints {{are employed in}} the construction and exploration of a modelis design space. The paper places this approach within {{the larger context of}} design exploration using computational and conceptual representations of design. Four general constraint types are identified and examples from several workshops and design studios are presented for each of the constraint types. The examples range from product design to structural design to fabrication issues in architecture. Based on {{a review of the literature}} the most common constraints are of geometric, topologic, functional, and quantitative type. Based on the case studies the paper {{describes how}} the different types of constraints can be used as design drivers and help in the exploration of solution space. In conclusion the paper identifies the addition of bi-directional properties to <b>constraint</b> <b>modelling</b> as the next challenge in improving the application of <b>constraint</b> <b>modelling</b> in design exploration. Furthermore, the paper demonstrates the necessity to develop better constraint models for cross domain design...|$|E
40|$|The paper {{describes}} a constraint programming approach for validating and finishing partially ordered plans with durative actions. We propose a Boolean <b>constraint</b> <b>model</b> of planning graphs, a numerical <b>constraint</b> <b>model</b> of durative actions and precedence relations, and channeling <b>constraints</b> connecting both <b>models.</b> We also discuss solving techniques, in particular using binary decision diagrams versus constraint propagation...|$|R
30|$|The network power <b>constraint</b> <b>model</b> is {{applicable}} when the node configuration {{in the network}} is not fixed [11]. Note that, when the node configuration is fixed, the individual power <b>constraint</b> <b>model</b> reflects the practical scenarios more than the network model. However, the power allocation problem is, in general, more tractable under network power constraint.|$|R
40|$|This memo defines an Experimental Protocol for the Internet community. It {{does not}} specify an Internet {{standard}} of any kind. Discussion {{and suggestions for}} improvement are requested. Distribution of this memo is unlimited. Copyright Notice Copyright (C) The Internet Society (2005). This document complements the Diffserv-aware MPLS Traffic Engineering (DS-TE) requirements document by giving a functional specification for the Maximum Allocation with Reservation (MAR) Bandwidth <b>Constraints</b> <b>Model.</b> Assumptions, applicability, and examples of {{the operation of the}} MAR Bandwidth <b>Constraints</b> <b>Model</b> are presented. MAR performance is analyzed relative to the criteria for selecting a Bandwidth <b>Constraints</b> <b>Model,</b> in order to provide guidance to user implementation of the model in their networks...|$|R
40|$|Key words: <b>constraint</b> <b>modelling,</b> {{channelling}} constraints, channels, channelled models, representations, redundant representations, automatic modelling, refinement Solving {{a problem}} with finite-domain constraint programming requires generating a model from the informal description of the problem such that this model can be accepted by a constraint solver. This generation process, called <b>constraint</b> <b>modelling,</b> is considered a hard task due {{to the number of}} choices and decisions it includes. Experience of skilled modellers in handcrafting many effective models has allowed identifying numerous patterns. One of these patterns is the addition of redundant information to a model. When this addition takes place, the consistency between all the redundant information needs to be maintained. The special constraints inserted to carry out this consistency maintenance are called channelling constraints (channels) and the model...|$|E
40|$|Abstract. Symmetry {{is often}} {{introduced}} {{in the formulation of}} constraint models. This paper shows how an automated <b>constraint</b> <b>modelling</b> system can recognise when it takes modelling decisions that introduce symmetry, and build up a description of the symmetry present in the final model of a whole problem class. ...|$|E
40|$|Abstract. Many {{constraint}} problems contain symmetry, {{which can}} lead to redundant search. If a partial assignment is shown to be in-valid, we are wasting time if we ever consider a symmetric equiv-alent of it. A particularly important class of symmetries are those introduced by the <b>constraint</b> <b>modelling</b> process: model symmetries. We present a systematic method by which the automated <b>constraint</b> <b>modelling</b> tool CONJURE can break conditional symmetry as it en-ters a model during refinement. Our method extends, and is com-patible with, our previous work on automated symmetry breaking in CONJURE. The result is the automatic and complete removal of model symmetries for the entire problem class represented by the in-put specification. This applies to arbitrarily nested conditional sym-metries and represents a significant step forward for automated con-straint modelling. ...|$|E
40|$|Abstract. <b>Constraint</b> <b>models</b> {{contain a}} number of common patterns. For example, many <b>constraint</b> <b>models</b> involve an array of {{decision}} variables with symmetric rows and/or columns. By documenting such constraint patterns, we can share <b>modelling</b> expertise. <b>Constraint</b> solvers can also be extended to exploit such patterns. For example, we can develop specialized methods like the global lexicographical ordering constraint for breaking such row and column symmetry...|$|R
40|$|In {{this paper}} we {{address the problem of}} {{encoding}} of planspace planning problems as a CSP. We propose a <b>constraint</b> <b>model</b> for expressing plan-space partial plans. As an enrichment of the notion of partial plans we propose a world state management within the partial plan. We incorporate the world state management into our CSP model too. Next we propose a specialized algorithm for solving the CSP model. The algorithm builds the <b>constraint</b> <b>model</b> dynamically as conflicts are resolved in the model. The performed preliminary experiments showed the usefulness of state management in the <b>constraint</b> <b>model.</b> The usage of state management allows the additional search space pruning compared to the model without states...|$|R
30|$|Where β_MV^* and β_MV {{represent}} {{respectively the}} estimator of the <b>constraint</b> <b>model</b> and the estimator of the non-contraint model.|$|R
40|$|Constraint Programming (CP) is a {{powerful}} technique for solving large-scale combinatorial (optimisation) problems. However, CP is often inaccessible to users without expert knowledge in the area, precluding its widespread use. One of the key difficulties lies in formulating an effective constraint model of an input problem for input to a constraint solver. Automated <b>Constraint</b> <b>Modelling</b> tools address this issue by providing assistance in model formulation. TAI-LOR is one such modelling tool. It incorporates a number of highly effective model optimisations, which can compensate for {{a wide selection of}} poor modelling choices that novices (but also experts) often make. In the context of TAILOR, this paper presents new constraint model optimisation techniques concerned with optimising quantified expressions, constructs that are commonly used in high-level <b>constraint</b> <b>modelling</b> languages, similar to for-loops in programming languages. Our experimental results show that quantified expression optimisations can reduce solving time very considerably...|$|E
40|$|Developments in {{semantic}} web technologies have promoted ontological encoding of knowledge from diverse domains. However, modelling many practical domains requires more expressiveness {{than what the}} standard description logics (most prominently SROIQ) support. In this paper, we extend the expressive DL SROIQ with constraint networks (resulting in the logic SROIQc) and grounded circumscription (resulting in the logic GC-SROIQ). Applications of <b>constraint</b> <b>modelling</b> include embedding ontologies with temporal or spatial information, while those of grounded circumscription include defeasible inference and closed world reasoning. We describe the syntax and semantics of the logic formed by including <b>constraint</b> <b>modelling</b> constructs in SROIQ, and provide a sound, complete and terminating tableau algorithm for it. We further provide an intuitive algorithm for Grounded Circumscription in SROIQc, which adheres to the general framework of grounded circumscription, and which {{can be applied to}} a whole range of expressive logics for which no such specific algorithm presently exists...|$|E
40|$|The goal of {{this paper}} is to provide a strong {{integration}} between <b>constraint</b> <b>modelling</b> and relational DBMSs. To this end we propose extensions of standard query languages such as relational algebra and SQL, by adding <b>constraint</b> <b>modelling</b> capabilities to them. In particular, we propose non-deterministic extensions of both languages, which are specially suited for combinatorial problems. Non-determinism is introduced by means of a guessing operator, which declares a set of relations to have an arbitrary extension. This new operator results in languages with higher expressive power, able to express all problems in the complexity class NP. Some syntactical restrictions which make data complexity polynomial are shown. The effectiveness of both extensions is demonstrated by means of several examples. The current implementation, written in Java using local search techniques, is described. To appear in Theory and Practice of Logic Programming (TPLP) Comment: 30 pages, 5 figure...|$|E
30|$|Finally, the {{influence}} of the cross-section radius of beams is analyzed. Since the equivalent <b>constraint</b> <b>model</b> subjects to its ratio of the length to the radius, for the equivalent wire <b>constraint</b> <b>model</b> as used in this paper, {{there is no doubt that}} the smaller the radius of the beam is, the more ideal the wire flexure approximation is. Nevertheless, significantly reducing the radius of flexure beam is not economic because of the manufacturing cost.|$|R
40|$|Constraint Programming is an {{attractive}} approach for solving AI planning problems by <b>modelling</b> them as <b>Constraint</b> Satisfaction Problems (CSPs). However, formulating effective <b>constraint</b> <b>models</b> of complex planning problems is challenging, and CSPs resulting from standard approaches often require further enhancement to perform well. Common subexpression elimination is a computationally cheap and general technique for improving CSPs, {{which can lead to}} a great reduction in instance size, solving time and search space. In this work we identify general causes of common subexpressions from three modelling techniques often used to encode planning problems into constraints We present four case studies of <b>constraint</b> <b>models</b> of AI planning problems. In each, we describe the <b>constraint</b> <b>model,</b> highlight the sources of common subexpressions, and present an empirical analysis of the effects of eliminating common subexpressions. 1...|$|R
40|$|Abstract: This paper {{presents}} {{an approach to}} representing and manipulating plans and other synthesised artifacts {{in the form of}} a set of constraints. The (Issues- Nodes- Orderings/Variables/Auxiliary) <b>constraints</b> <b>model</b> is used to characterise plans and processes. The more general (Issues- Nodes- Critical/Auxiliary) <b>constraints</b> <b>model</b> can be used for wider applications in design, configuration and other tasks which can be characterised as the synthesis and maintenance of an artifact or product. The and <b>constraint</b> <b>models</b> are intended to support a number of different uses: for automatic manipulation of plans and other synthesised artifacts and to act as an ontology to underpin such use; as a common basis for human communication about plans and other synthesised artifacts; as a target for principled and reliable acquisition of plans, models and product information; to support formal reasoning about plans and other synthesised artifacts...|$|R
40|$|Abstract. <b>Constraint</b> <b>modelling</b> {{requires}} considerable {{expertise and}} therefore automating {{this process is}} highly desirable to encourage {{the widespread use of}} constraint programming techniques. One approach is to refine a high-level problem specification into a solver-independent constraint model that is then tailored to a particular solver. We further investigate tailoring, the last step of the modelling process, and present reformulations to enhance the constraint model’s quality. ...|$|E
40|$|Abstract. 1 <b>Constraint</b> <b>modelling</b> is difficult, {{particularly}} for novices. Hence, automated methods for improving models are valuable. The {{context of this}} paper is tailoring, a process where a solver-independent constraint model is adapted to a target solver. Tailoring is augmented with automated enhancement techniques, in particular common subexpression detection and elimination, which, while powerful, can be performed inexpensively if applied selectively. Experimental results show very substantial improvements in search performance of tailored models. ...|$|E
40|$|Abstract. Any {{sufficiently}} complex finite-domain <b>constraint</b> <b>modelling</b> {{language has}} the ability to express undefined values, for example division by zero, or array index out of bounds. This paper gives the first systematic treatment of undefinedness for finite-domain constraint languages. We present three alternative semantics for undefinedness, and for each of the semantics show how to map models that contain undefined expressions into equivalent models that do not. The resulting models can be implemented using existing constraint solving technology. ...|$|E
40|$|Computer trading {{systems are}} {{essential}} for today's financial markets where the trading systems' correctness is of paramount economical significance. Automated random testing is a useful technique to find bugs in these systems, but it requires an independent system to decide the correctness of the system under test (known as oracle problem). This paper introduces a constraint-based oracle for random testing of a real-world trading system. The oracle provides the expected results by generating and solving <b>constraint</b> <b>models</b> of the trading system's continuous double auction. Constraint programming {{is essential for the}} correctness of the test oracle as the logic for calculating trades can be mapped directly to <b>constraint</b> <b>models.</b> The paper shows that the generated <b>constraint</b> <b>models</b> can be solved efficiently. Most importantly, the approach is shown to be successful by finding errors in a deployed financial trading system and in its specification...|$|R
5000|$|... "Real life" [...] {{examples}} include automated planning and resource allocation. An example for puzzle solution {{is using a}} <b>constraint</b> <b>model</b> as a Sudoku solving algorithm.|$|R
40|$|Many {{operations}} research (OR) textbooks have not tackled {{the problem of}} converting {{the various types of}} Linear Programming (LP) models (i. e. Maximization, Minimization and mixed <b>Constraint</b> <b>Model)</b> from its primal form to dual form. Furthermore, little attention has paid for showing how to extract the dual optimal solution. Extracting duality is of great importance when we tackle problems with mixed <b>constraints</b> <b>models.</b> The primary goal of this research is to demonstrate the methodology adopted in extracting all types of dual models and its optimal solution...|$|R
40|$|Current-generation {{constraint}} programming {{languages are}} considered by many, especially in industry, {{to be too}} low-level, di- cult, and large. We argue that solver-independent, high-level relational <b>constraint</b> <b>modelling</b> leads to a simpler and smaller language, to more concise, intuitive, and analysable models, {{as well as to}} more ecient and eective model formulation, maintenance, reformulation, and veri- cation, and all this without sacri cing the possibility of ecient solving, so that even lazy or less competent modellers can be well assisted...|$|E
40|$|A {{high-level}} abstract-datatype-based <b>constraint</b> <b>modelling</b> language {{opens the}} door to an automat-able empirical determination — by a compiler — of how to ‘best ’ represent the variables of a com-binatorial optimisation problem, based on (real-life) training instances of the problem. In the ex-treme case where no such training instances are provided, such a compiler would simply be non-deterministic. A first-order relational calculus with sets is a good candidate for such a language, as it gives rise to very natural and easy-to-maintain models of combinatorial optimisation problems. ...|$|E
40|$|Abstract. Essence is a {{syntactically}} rich {{language for}} specifying search and optimization problems. We show how to applying descriptive complexity theory {{to study the}} expressive power of Essence, and present several results on the expressive power of fragments incorporating certain features. The same approach {{can be applied to}} a number of other constraint specification or modelling languages. We believe this approach forms is an appropriate theoretical formalization for scientific development and study of <b>constraint</b> <b>modelling</b> languages and the tools and techniques used in their application. ...|$|E
40|$|Abstract. Planning {{problems}} with durative actions represent {{one of the}} hot research topics {{in the area of}} AI planning. Because durative actions introduce numerical aspects to planning, constraint satisfaction technology is becoming more popular in solving this new type of planning problems. The paper describes a constraint programming approach for validating and finishing partially ordered plans with durative actions. In particular, we propose a Boolean <b>constraint</b> <b>model</b> of the planning graph, a numerical <b>constraint</b> <b>model</b> of durative actions and precedence relations, and channeling <b>constraints</b> connecting both <b>models.</b> We also briefly discuss solving techniques for such integrated model, in particular using binary decision diagrams versus constraint propagation. 1...|$|R
40|$|This paper {{presents}} {{an approach to}} representing and manipulating plans and other synthesised artifacts {{in the form of}} a set of constraints. The 1 (Issues [...] Nodes [...] Orderings /Variables/Auxiliary) <b>constraints</b> <b>model</b> is used to characterise plans and processes. The more general (Issues [...] Nodes [...] Critical /Auxiliary) <b>constraints</b> <b>model</b> can be used for wider applications in design, configuration and other tasks which can be characterised as the synthesis and maintenance of an artifact or product. The and <b>constraint</b> <b>models</b> are intended to support a number of di#erent uses:. for automatic manipulation of plans and other synthesised artifacts and to act as an ontology to underpin such use;. as a common basis for human communication about plans and other synthesised artifacts;. as a target for principled and reliable acquisition of plans, models and product information;. to support formal reasoning about plans and other sy [...] ...|$|R
5000|$|Meta-modeling is the analysis, {{construction}} {{and development of}} the frames, rules, <b>constraints,</b> <b>models</b> and theories applicable and useful for the modeling in a predefined class of problems.|$|R
