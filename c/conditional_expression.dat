494|296|Public
25|$|Tamoxifen {{is used as}} a {{research}} tool to trigger tissue-specific gene expression in many <b>conditional</b> <b>expression</b> constructs in genetically modified animals including a version of the Cre-Lox recombination technique.|$|E
500|$|Statements {{cannot be}} a part of an expression, so list and other comprehensions or lambda expressions, all being expressions, cannot contain statements. A {{particular}} case of this is that an assignment statement such as a = 1 cannot form part of the <b>conditional</b> <b>expression</b> of a conditional statement. This has the advantage of avoiding a classic C error of mistaking an assignment operator = for an equality operator == in conditions: if (c = 1) { ... } is syntactically valid (but probably unintended) C code but if c = 1: ... causes a syntax error in Python.|$|E
2500|$|Observe {{also that}} the abacus model {{combines}} two instructions, JZ then DEC: e.g. { INC ( [...] r, z [...] ), JZDEC ( [...] r, ztrue, zfalse [...] ) }.See McCarthy Formalism for more about the <b>conditional</b> <b>expression</b> [...] "IF r=0 THEN ztrue ELSE [...] zfalse" [...] (cf McCarthy (1960)).|$|E
40|$|It {{is known}} that Japanese <b>conditional</b> <b>expressions</b> often require {{particular}} modal expressions in the sentence-final position. Roughly speaking, {{it has been said}} that among those sentence-final modal expressions, the epistemic modal expressions are assigned the most important status in Japanese <b>conditional</b> <b>expressions.</b> However, in Ainu <b>conditional</b> <b>expressions,</b> although they often have modal restrictions on sentence-final moods just like Japanese, the nature is rather different between them: in Ainu, some <b>conditional</b> <b>expressions</b> require the interrogative and imperative modal expressions only, so the epistemic mood does not necessarily play a crucial role. This fact may cast doubts about the generality of the "conception level" often used in the study of the Japanese <b>conditional</b> <b>expressions.</b> In addition, by contrasting Japanese and Ainu, it is shown that yakun is the most important among the Ainu <b>conditional</b> <b>expressions</b> since it has extremely wider usage corresponding to that of at least three different <b>conditional</b> <b>expressions</b> of Japanese. 北大文学研究科北方研究教育センター公開シンポジウム「サハリンの言語世界」. 平成 20 年 9 月 6 日. 札幌...|$|R
5000|$|<b>Conditional</b> <b>expressions</b> with [...] For an example, see Case (SQL).|$|R
50|$|The {{following}} table {{describes the}} operators {{that can be}} used to create <b>conditional</b> <b>expressions.</b>|$|R
5000|$|... #Subtitle level 3: McCarthy's {{notion of}} <b>conditional</b> <b>expression</b> ...|$|E
5000|$|Assignment using a <b>conditional</b> <b>expression</b> in Common Lisp:(setf result (if (> a b) x y)) ...|$|E
5000|$|This <b>conditional</b> <b>expression</b> [...] [...] [...] {{has also}} {{the power of}} the {{minimization}} operator[...] [...].|$|E
5000|$|... {{keywords}} (e.g., if, then, else, and, or, not, implies) {{that are}} used to specify <b>conditional</b> <b>expressions.</b>|$|R
40|$|We present ACPc, {{a process}} algebra with <b>conditional</b> <b>expressions</b> {{in which the}} {{conditions}} are taken from a Boolean algebra, and extensions of this process algebra with mechanisms for condition evaluation. We confine ourselves to finitely branching processes. This restriction {{makes it possible to}} presentc in a concise and intuitively clear way, and to bring the notion of splitting bisimulation equivalence and the issue of condition evaluation in process algebras with <b>conditional</b> <b>expressions</b> to the forefront...|$|R
40|$|Abstract. We present ACP c, {{a process}} algebra with <b>conditional</b> <b>expressions</b> {{in which the}} {{conditions}} are taken from a Boolean algebra, and extensions of this process algebra with mechanisms for condition evaluation. We confine ourselves to finitely branching processes. This restriction {{makes it possible to}} present ACP c in a concise and intuitively clear way, and to bring the notion of splitting bisimulation equivalence and the issue of condition evaluation in process algebras with <b>conditional</b> <b>expressions</b> to the forefront. ...|$|R
5000|$|In Visual Basic {{and some}} other languages, a {{function}} called [...] is provided, {{which can be used}} as a <b>conditional</b> <b>expression.</b> However, it does not behave like a true <b>conditional</b> <b>expression,</b> because both the true and false branches are always evaluated; it is just that the result of one of them is thrown away, while the result of the other is returned by the IIf function.|$|E
5000|$|It {{is notable}} that ALGOL's <b>conditional</b> <b>expression</b> {{in the form}} [...] has an {{equivalent}} in C but not in Pascal.|$|E
50|$|The HTML shown {{inside the}} syntax block {{in each of}} the {{conditional}} comments denotes any block of HTML content, including script. Both types of conditional comment use a <b>conditional</b> <b>expression</b> to indicate whether the content inside the comment block should be parsed or ignored. The <b>conditional</b> <b>expression</b> is formed from a combination of feature, operator, and/or value, depending on the feature. The following table shows the supported features and describes the values each feature supports.|$|E
500|$|<b>Conditional</b> <b>expressions</b> in Python {{are written}} as x if c else y (different {{in order of}} operands from the [...] {{operator}} common to many other languages).|$|R
2500|$|<b>Conditional</b> <b>expressions</b> and <b>conditional</b> {{constructs}} are {{features of}} a programming language which perform different computations or actions depending on whether a programmer-specified boolean condition evaluates to true or false.|$|R
50|$|The ?: {{operator}} {{is similar}} to the way <b>conditional</b> <b>expressions</b> (if-then-else constructs) work in functional programming languages, like Scheme, ML, and Haskell, since if-then-else forms an expression instead of a statement in those languages.|$|R
5000|$|The {{short-circuit}} expression [...] (using [...] {{to denote}} the short-circuit variety) {{is equivalent to}} the <b>conditional</b> <b>expression</b> the expression [...] is equivalent to [...]|$|E
50|$|Tamoxifen {{is used as}} a {{research}} tool to trigger tissue-specific gene expression in many <b>conditional</b> <b>expression</b> constructs in genetically modified animals including a version of the Cre-Lox recombination technique.|$|E
5000|$|If {{the second}} sub-expression {{can be a}} further simple <b>conditional</b> <b>expression,</b> we can give more {{alternatives}} to try before the last fall-through: (x>0) -> 1/x; (x<0) -> -1/x; 0 ...|$|E
500|$|SQL {{provides}} two flavours of <b>conditional</b> <b>expressions.</b> One {{is called}} [...] "simple CASE" [...] and operates like a switch statement. The other {{is called a}} [...] "searched CASE" [...] in the standard, and operates like an if...elseif.|$|R
50|$|In 1958, McCarthy {{served on}} an ACM Ad hoc Committee on Languages that {{became part of}} the {{committee}} that designed ALGOL 60. In August 1959 he proposed the use of recursion and <b>conditional</b> <b>expressions,</b> which became part of ALGOL.|$|R
5000|$|C and C-like {{languages}} has {{a special}} ternary operator (?:) for <b>conditional</b> <b>expressions</b> with a function that may be described by a template like this: This means {{that it can be}} inlined into expressions, unlike if-statements, in C-like languages: ...|$|R
5000|$|Parentheses: If {{there is}} parenthesized {{expression}} in a statement, it is a <b>conditional</b> <b>expression,</b> and {{the statement is}} processed only if the test has a value of 'true'. Example: ...|$|E
50|$|There {{is also a}} <b>conditional</b> <b>expression,</b> {{which works}} much like the ?:-operator in C-like languages, albeit with a {{slightly}} different syntax. For example, one can write if a > b then 0 else 1 end where a > b is the condition, and 0 and 1 are the expressions that are evaluated in case the condition is true or false, respectively. Note that the <b>conditional</b> <b>expression</b> is different from operators {{not only in the}} number of expressions it contains (three instead of one or two), but also in the way it evaluates those expressions. If the condition is true, then only the then-branch expression matters for the result of the <b>conditional</b> <b>expression,</b> and therefore it is guaranteed to be defined even if the else-branch expression, for instance, is not. For example, if a = 0 then null else 1/a end will produce a defined value (null) if a is zero, even though the else-branch expression is undefined in that case.|$|E
50|$|Unlike C, perl {{allows the}} use of the <b>conditional</b> <b>expression</b> as an Lvalue, e.g.$a > $b ? $x : $y = $result;will assign '$result' to either '$x' or '$y' {{depending}} on the logical expression.|$|E
5000|$|Python's limited {{support for}} {{anonymous}} functions is the [...] construct.Lambdas {{are limited to}} containing an expression rather than statements, although control flow can still be implemented less elegantly within lambda by using short-circuiting, and more idiomatically with <b>conditional</b> <b>expressions.</b>|$|R
40|$|AbstractBoolean {{expressions}} of Boolean algebras are logically equivalent to conditional logic expressions; we define and give theorems about equivalences of general conditional expressions; moreover, <b>conditional</b> <b>expressions</b> are properly contained in n-valued Post algebras. Theorems are given regarding equivalences of conditional logic in Post logic...|$|R
50|$|A notationally {{distinctive}} feature of ISWIM is {{its use of}} “where” clauses. An ISWIM program is a single expression qualified by “where” clauses (auxiliary definitions including equations among variables), <b>conditional</b> <b>expressions</b> and function definitions. Along with CPL, ISWIM {{was one of the}} first programming languages to use “where” clauses.|$|R
50|$|Constant {{propagation}} {{can also}} cause conditional branches to simplify {{to one or more}} unconditional statements, when the <b>conditional</b> <b>expression</b> can be evaluated to true or false at compile time to determine the only possible outcome.|$|E
5000|$|The McCarthy {{formalism}} is {{like the}} general recursive (Kleene) system, in being based on some basic functions, composition, and equality, but with the <b>conditional</b> <b>expression</b> alone replacing both the primitive-recursive scheme and the minimization operator." [...] (Minsky 1967:192-193) ...|$|E
5000|$|A simple <b>conditional</b> <b>expression,</b> {{already present}} in CPL in 1963, has a guard on first sub-expression, and another sub-expression {{to use in}} case the first one cannot be used. Some common ways to write this: (x>0) -> 1/x; 0 x>0 ? 1/x : 0 ...|$|E
50|$|Whitespace in {{a program}} is also not stored {{as part of the}} source code, and each {{programmer}} working on a project can choose an indentation display of the source. More radical visualizations include showing statement lists as nested boxes, editing <b>conditional</b> <b>expressions</b> as logic gates, or re-rendering names in Chinese.|$|R
25|$|The Network-Free Stochastic Simulator (NFSim) {{differs from}} those {{described}} above by {{allowing for the}} definition of reaction rates as arbitrary mathematical or <b>conditional</b> <b>expressions</b> and thereby facilitates selective coarse-graining of models. RuleMonkey and NFsim implement distinct but related simulation algorithms. A detailed review and comparison of both tools is given by Yang and Hlavacek.|$|R
50|$|In {{computer}} science, <b>conditional</b> statements, <b>conditional</b> <b>expressions</b> and <b>conditional</b> constructs are {{features of}} a programming language, which perform different computations or actions depending on whether a programmer-specified boolean condition evaluates to true or false. Apart from the case of branch predication, this is always achieved by selectively altering the control flow based on some condition.|$|R
