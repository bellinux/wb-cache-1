55|78|Public
5000|$|Danny Cohen (PhD '69) - {{internet}} pioneer, {{developed the}} first real-time visual flight simulator and the Cohen-Sutherland line <b>clipping</b> <b>algorithm</b> ...|$|E
50|$|The Nicholl-Lee-Nicholl {{algorithm}} is a fast line <b>clipping</b> <b>algorithm</b> {{that reduces the}} chances of clipping a single line segment multiple times, as may happen in the Cohen-Sutherland algorithm.|$|E
50|$|In {{computer}} graphics, the Liang-Barsky algorithm (named after You-Dong Liang and Brian A. Barsky) {{is a line}} <b>clipping</b> <b>algorithm.</b> The Liang-Barsky algorithm {{uses the}} parametric equation of a line and inequalities describing {{the range of the}} clipping window to determine the intersections between the line and the clip window. With these intersections it knows which portion of the line should be drawn. This algorithm is significantly more efficient than Cohen-Sutherland. The idea of the Liang-Barsky <b>clipping</b> <b>algorithm</b> is to do as much testing as possible before computing line intersections.|$|E
40|$|In {{this paper}} several {{different}} digital soft <b>clipping</b> <b>algorithms</b> are described and analysed. It is discussed how {{the quality of}} each algorithm can be estimated. A testing methodology is devised to show the levels of nonlinearities produced {{as a function of}} the input signal amplitude. It is proposed that, while all soft <b>clipping</b> <b>algorithms</b> produce higher order nonlinearities, the instability of the produced harmonics plays a crucial role in the transparency of the effect. Existing and novel <b>clipping</b> <b>algorithms</b> are thus compared and classified based on their measured properties, including total harmonic distortion and inter-modulation distortion estimates. This paper proposes a conclusion related to the quality and properties of different algorithms...|$|R
40|$|The {{presentation}} {{will examine}} the current research experience {{in the field of}} fundamental algorithms complexity and line <b>clipping</b> <b>algorithms.</b> Line <b>clipping</b> <b>algorithms</b> can be taken as an example for a demonstration how some fundamental algorithms can be improved significantly and how their complexity can be changed. Many algorithms have been developed so far and some algorithms were developed for some very special cases. In spite of the simplicity of the line clipping problem it seems to be quite difficult to make appropriate tests that prove the efficiency or properties of the given algorithm. Also experiments published elsewhere seem to be difficult to repeat. The aim of this presentation is to show thoughts and developments made in the past that lead to new line <b>clipping</b> <b>algorithms</b> in E 2 and E 3 that proved some general approaches to algorithms design...|$|R
50|$|In 1967, flight-simulation work by Danny Cohen {{led to the}} {{development}} of the Cohen-Sutherland computer graphics two- and three-dimensional line <b>clipping</b> <b>algorithms,</b> created with Ivan Sutherland.|$|R
50|$|The Greiner-Hormann {{algorithm}} {{is used in}} computer graphics for polygon clipping. It performs better than the Vatti <b>clipping</b> <b>algorithm,</b> but cannot handle degeneracies. It can process both self-intersecting and non-convex polygons. It can be trivially generalized to compute other Boolean operations on polygons, such as union and difference.|$|E
50|$|From 1965 to 1968, Sutherland was an Associate Professor of Electrical Engineering at Harvard University. Work {{with student}} Danny Cohen in 1967 {{led to the}} {{development}} of the Cohen-Sutherland computer graphics line <b>clipping</b> <b>algorithm.</b> In 1968, with the help of his student Bob Sproull, he created the first virtual reality and augmented reality head-mounted display system, named The Sword of Damocles.|$|E
50|$|The Vatti <b>clipping</b> <b>algorithm</b> {{is used in}} {{computer}} graphics. It allows clipping of any number of arbitrarily shaped subject polygons by any number of arbitrarily shaped clip polygons. Unlike the Sutherland-Hodgman and Weiler-Atherton polygon clipping algorithms, the Vatti algorithm does not restrict the types of polygons {{that can be used}} as subjects or clips. Even complex (self-intersecting) polygons, and polygons with holes can be processed. The algorithm is generally applicable only in 2D space.|$|E
40|$|In this paper, a semiactive modal neuro-control scheme which {{combines}} the modal neuro-control algorithm and semiactive control device (MR damper) is proposed. The efficacy and feasibility of the semiactive modal neuro-control scheme has been experimentally investigated through a shaking table experiment. In the experiment, a scaled three-story shear building model including an MR damper attached between {{ground and the}} first floor is considered as target structure. A Kalman filter is also adopted for estimating the modal coordinates from the measurements by various sensors. The <b>clipped</b> <b>algorithm</b> which induces the MR damper to generate approximately the desired control force is adopted in the proposed scheme. The cost function based neuro-controller produces the desired control force, then by using the <b>clipped</b> <b>algorithm</b> the appropriate command voltage for MR damper is selected in order to cause the MR damper to generate the desired control force. The performance of a semiactive modal neuro-control algorithm is {{compared with that of}} passively MR damper-based control systems...|$|R
40|$|New {{algorithms}} Point-in-Polygon {{and line}} <b>clipping</b> <b>algorithms</b> are very often used especially in computer graphics applications. Algorithms usually have O(N) or O(lg N) complexities. New algorithms with O(l) expected complexity {{has been developed}} using pre-processing. The interesting feature of presented algorithms is that memory requirements depend on geometrical properties of polygons. The presented approach {{can be considered as}} an alternative method to parallel processing...|$|R
5000|$|In 1967, he {{developed}} the first real-time visual flight simulator on a general purpose computer and also developed the first real-time radarsimulator. Flight simulation work by Cohen {{led to the development}} of the Cohen-Sutherland computer graphics line <b>clipping</b> <b>algorithms,</b> created with Ivan Sutherland at Harvard University.He received a PhD from Harvard in 1969 as a student of Sutherland. His thesis was titled: [...] "Incremental Methods for Computer Graphics".|$|R
50|$|The {{most common}} {{technique}} is the Sutherland-Hodgman <b>clipping</b> <b>algorithm.</b> In this approach, {{each of the}} 4 edges of the image plane is tested at a time. For each edge, test all points to be rendered. If the point is outside the edge, the point is removed. For each triangle edge that is intersected by the image plane’s edge, that is, one vertex of the edge is inside the image and another is outside, a point is inserted at the intersection and the outside point is removed.|$|E
5000|$|He invented Sketchpad in 1962 {{while at}} MIT. Professor Claude Shannon {{signed on to}} {{supervise}} Sutherland’s computer drawing thesis. Among others on his thesis committee were Marvin Minsky and Steven Coons. Sketchpad was an innovative program that influenced alternative forms of interaction with computers. Sketchpad could accept constraints and specified relationships among segments and arcs, including the diameter of arcs. It could draw both horizontal and vertical lines and combine them into figures and shapes. Figures could be copied, moved, rotated, or resized, retaining their basic properties. Sketchpad also had the first window-drawing program and <b>clipping</b> <b>algorithm,</b> which allowed zooming. Sketchpad ran on the Lincoln TX-2 computer and influenced Douglas Engelbart's oN-Line System. Sketchpad, in turn, {{was influenced by the}} conceptual Memex as envisioned by Vannevar Bush in his influential paper [...] "As We May Think".|$|E
5000|$|... typedef int OutCode;const int INSIDE = 0; // 0000const int LEFT = 1; // 0001const int RIGHT = 2; // 0010const int BOTTOM = 4; // 0100const int TOP = 8; // 1000// Compute the bit {{code for}} a point (x, y) using the clip {{rectangle}}// bounded diagonally by (xmin, ymin), and (xmax, ymax)// ASSUME THAT xmax, xmin, ymax and ymin are global constants.OutCode ComputeOutCode(double x, double y){ OutCode code; code = INSIDE; // initialised as being inside of clip window if (x < xmin) // {{to the left}} of clip window code |= LEFT; else if (x > xmax) // to the right of clip window code |= RIGHT; if (y < ymin) // below the clip window code |= BOTTOM; else if (y > ymax) // above the clip window code |= TOP; return code;}// Cohen-Sutherland <b>clipping</b> <b>algorithm</b> clips a line from// P0 = (x0, y0) to P1 = (x1, y1) against a rectangle with // diagonal from (xmin, ymin) to (xmax, ymax).void CohenSutherlandLineClipAndDraw(double x0, double y0, double x1, double y1){ // compute outcodes for P0, P1, and whatever point lies outside the clip rectangle OutCode outcode0 = ComputeOutCode(x0, y0); OutCode outcode1 = ComputeOutCode(x1, y1); bool accept = false; while (true) { if (!(outcode0 | outcode1)) { // Bitwise OR is 0. Trivially accept and get out of loop accept = true; break; } else if (outcode0 & outcode1) { // Bitwise AND is not 0. (implies both end points are in the same region outside the window). Reject and get out of loop break; } else { // failed both tests, so calculate the line segment to clip // from an outside point to an intersection with clip edge double x, y; // At least one endpoint is outside the clip rectangle; pick it. OutCode outcodeOut = outcode0 ? outcode0 : outcode1; // Now find the intersection point; // use formulas: // slope = (y1 - y0) / (x1 - x0) // x = x0 + (1 / slope) * (ym - y0), where ym is ymin or ymax // y = y0 + slope * (xm - x0), where xm is xmin or xmax if (outcodeOut & TOP) { // point is above the clip rectangle x = x0 + (x1 - x0) * (ymax - y0) / (y1 - y0); y = ymax; } else if (outcodeOut & BOTTOM) { // point is below the clip rectangle x = x0 + (x1 - x0) * (ymin - y0) / (y1 - y0); y = ymin; } else if (outcodeOut & RIGHT) { // point is to the right of clip rectangle y = y0 + (y1 - y0) * (xmax - x0) / (x1 - x0); x = xmax; } else if (outcodeOut & LEFT) { // point is {{to the left of}} clip rectangle y = y0 + (y1 - y0) * (xmin - x0) / (x1 - x0); x = xmin; } // Now we move outside point to intersection point to clip // and get ready for next pass. if (outcodeOut == outcode0) { x0 = x; y0 = y; outcode0 = ComputeOutCode(x0, y0); } else { x1 = x; y1 = y; outcode1 = ComputeOutCode(x1, y1); } } } if (accept) { // Following functions are left for implementation by user based on // their platform (OpenGL/graphics.h etc.) DrawRectangle(xmin, ymin, xmax, ymax); LineSegment(x0, y0, x1, y1); }} ...|$|E
5000|$|Given polygon A as the {{clipping}} {{region and}} polygon B {{as the subject}} polygon to be <b>clipped,</b> the <b>algorithm</b> consists of the following steps: ...|$|R
50|$|Clipping {{is defined}} as the {{interaction}} of subject and clip polygons. While clipping usually involves finding the intersections (regions of overlap) of subject and <b>clip</b> polygons, <b>clipping</b> <b>algorithms</b> can also be applied with other boolean clipping operations: difference, where the clipping polygons remove overlapping regions from the subject; union, where clipping returns the regions covered by either subject or clip polygons, and; xor, where clipping returns the regions covered by either subject or clip polygons except where they are covered by both subject and clip polygons.|$|R
40|$|Two {{new line}} <b>clipping</b> <b>{{algorithm}}s,</b> the opposite-corner algorithm and the perpendicular-distance algorithm, {{that are based}} on simple geometric observations are presented. These algorithms do not require computation of outcodes nor do they depend on the parametric representations of the lines. It is shown that the opposite-corner algorithm perform consistently better than an algorithm due to Nicholl, Lee, and Nicholl which is claimed to be better than the classic algorithm due to Cohen-Sutherland and the more recent Liang-Barsky algorithm. The pseudo-code of the opposite-corner algorithm is provided in the Appendix...|$|R
40|$|Three {{dimensional}} clipping is {{a critical}} component of the 3 D graphics pipeline. A new 3 D <b>clipping</b> <b>algorithm</b> is presented in this paper. An efficient 2 D clipping routine reported earlier {{has been used as a}} submodule. This algorithm uses a new classification scheme for lines of all possible orientations with respect to a rectangular parallelopiped view volume. The performance of this algorithm has been evaluated using exact arithmetic operation counts. It is shown that our algorithm requires less arithmetic operations than the Cyrus-Beck 3 D <b>clipping</b> <b>algorithm</b> in all cases. It is also shown that for lines that intersect the clipping volume, our algorithm performs better than the Liang-Barsky 3 D <b>clipping</b> <b>algorithm...</b>|$|E
40|$|ABSTRACT: Demonstration {{of various}} Line {{clipping}} algorithms {{on the basis}} of their working principles. One way for improving the efficiency of a line <b>clipping</b> <b>algorithm</b> is to reduce the repetition of algorithm. In this region codes are used to identify the position of line. One algorithm reduces intersection calculations. An efficient <b>clipping</b> <b>algorithm</b> is presented here to achieve this goal. One is based on testing xy plane to reduce intersection calculation. Our algorithm with reducing the confluence point can avoid the repetition of algorithm...|$|E
40|$|Abstract—This paper {{describes}} a clipping engine, which processes the view clipping, perspective division, and view-port mapping of 3 D graphics. Complexity of polygon <b>clipping</b> <b>algorithm</b> causes difficulties to implement hardware. We propose a <b>clipping</b> <b>algorithm</b> that shows 3. 07 times higher performance than a conventional algorithm. In addition, we propose {{a scheme to}} improve performance up to 57 % by eliminating redundant calculations of overlapped vertices without additional hardware. We implement the clipping engine in 0. 13 um CMOS technology. It processes 11 M-triangles/sec at 166 MHz and has 156 kgates counts...|$|E
40|$|This paper {{describes}} {{the process of}} designing and verifying a hardware/software co-designed system. This is done by going through a complete case study involving polygon <b>clipping</b> <b>algorithms</b> as applied to computer graphics. As {{is the case in}} many software and hardware/software design processes, verification of the software part of the system is done using test scenarios while the hardware partition is verified using the SystemC Verification Standard methodology. This case study carries the design process through to a partial integration of the hardware and software partitions using SystemC simulation. ...|$|R
40|$|Several <b>clipping</b> <b>algorithms</b> are in wide use. These are {{separated}} into broad classes. They include subdivision algorithms {{of which the}} best known is the midpoint subdivision algorithm; the Cohen-Sutherland algorithm which uses outcodes generators and line window intersection calculations to determine what portion(s) of line segments may be contained in the window. Outcode determination/redetermination for the stages of the algorithm can dominate the clipping process. There are algorithms {{that are based on}} parametric expressions for lines, and which are comparatively more efficient than the simple Cohen-Sutherland algorithm. The Skala 2 D line <b>clipping</b> <b>algorithms</b> use a parameter value to determine the intersection of a line segment with a convex or non-convex polygon window. The Rappoport <b>algorithm</b> <b>clips</b> any subject polygon against a convex polygonal window. The work of Weiler and Atherton <b>algorithm</b> allows the <b>clipping</b> of any subject polygon against any clip polygon. However, it is base on some assuptions. This work presents an efficient method for clipping a polygon against an arbitrary two-dimensional polygonal windows and a modification of the algorithm can also be applied to clip a polygon against a non-convex volume on 3 D. The basic idea based on geometry and parametric representation of the lines, determines if an edge of a subject polygon should be totally rejected, or is totally visible. On the other hand, if an edge of a polygon has intersections with the boundary of a simple polygon window, it is easy to decide which parts of the edge are visible after sorting these intersections...|$|R
40|$|Computational {{efficiencies}} {{of traditional}} vector computing-based polygon <b>clipping</b> <b>algorithms</b> will decrease rapidly when handling polygons contain {{large amount of}} vertices. The computing flows of traditional polygon <b>clipping</b> <b>algorithms</b> are tightly coupled with special data structures, which difficult to be optimized in the underlying of them. Under the premise of meeting {{a certain degree of}} area errors, the polygon clipping problem can be solved by introducing the idea of rasterization processing. In this research, we proposed a new rasterization processing-based polygon clipping algorithm: the RaPC algorithm, on the basis of analyzing the characteristics of existing algorithms. The area errors of results of the new algorithm are also analyzed and discussed. Experimental results show that the efficiencies of the RaPC algorithm can be enhanced significantly when using large grid cells, and it shows a linear trend growth with the increase of amount of polygon vertices. Compared with the Vatti algorithm, the RaPC algorithm represents more efficiencies on dealing clipping issues between polygons with large amount of vertices, the former shows lower time costs when handling polygons with less vertices. The area error of computing results of the RaPC algorithm is closely related with the grid size, and errors can be reduced using smaller grid sizes. Therefore the RaPC algorithm showed higher efficiencies on processing polygons with large amount of vertices than the Vatti algorithm and presented practical values to some degree...|$|R
40|$|The {{most popular}} lines {{clipping}} algorithms are Cohen-Sutherland and Liang-Barsky line <b>clipping</b> <b>algorithm.</b> These algorithms {{are complex and}} the steps of calculation are very high. This paper proposes a simple new line <b>clipping</b> <b>algorithm</b> for 2 D space which uses the parametric equation of the line. This algorithm further easily extended to the polygon clipping by considering {{the edge of the}} polygon as a line. The proposed algorithm is numerically tested for a numbers of random line segments and the results show the simplicity and less complex behavior of the algorithm...|$|E
40|$|Abstract: Aparallel line <b>clipping</b> <b>algorithm</b> and its {{implementation}} on a parallel clipping hardware environment are presented. We first develop a simple theory {{to show that}} parallel clipping is possible {{for all types of}} line segments. We then present the architecture of a hardware environment based on which parallel clipping is to be implemented. The parallel line <b>clipping</b> <b>algorithm</b> and {{its implementation}} on the parallel clipping hardware environment are presented finally. Based on our approach, only 141 cycles are required to clip a line segment. The corresponding figure for the famous J. Clark’s Geometry Engine is 160 cycles...|$|E
40|$|Maximum 200 words) Three-dimensional {{pictorial}} displays incorporating depth cues {{by means}} of stereopsis offer a potential means of presenting information in a natural way to enhance situational awareness and improve operator performance. Conventional computational techniques rely on asymptotic projection transformations and symmetric clipping to produce the stereo display. Implementation of two new computational techniques, an asymmetric <b>clipping</b> <b>algorithm</b> and piecewise linear projection transformation, provides the display designer with more control and better utilization of the effective depth-viewing volume to allow full exploitation of stereopsis cuing. Asymmetric clipping increases the perceived field of view (FOV) for the stereopsis region. The total horizontal FOV provided by the asymmetric <b>clipping</b> <b>algorithm</b> is greater throughout the scene viewing envelope {{than that of the}} symmetric algorithm. The new piecewise linear projection transformation allows the designer to creativel [...] ...|$|E
40|$|Abstract. Line {{intersection}} with convex and un-convex polygons or polyhedron algorithms {{are well}} known as line <b>clipping</b> <b>algorithms</b> and very often used in computer graphics. Rendering of geometrical problems often leads to ray tracing techniques, when an intersection of many lines with spheres or quadrics is a critical issue due to ray-tracing algorithm complexity. A new formulation of detection and computation of the intersection of line (ray) with a quadric surface is presented, which separates geometric properties {{of the line and}} quadrics that enables pre-computation. The presented approach is especially convenient for implementation with SSE instructions or on GPU...|$|R
50|$|The Cohen-Sutherland {{algorithm}} is a computer-graphics algorithm used for line <b>clipping.</b> The <b>algorithm</b> divides a two-dimensional space into 9 regions and then efficiently determines {{the lines and}} portions of lines that are visible in the central region of interest (the viewport).|$|R
40|$|Pattern {{matching}} is {{a well-known}} pattern recognition technique. This paper proposes a novel pattern matching algorithm that searches transformation space by sequential subdivision. The algorithm subdivides the transformation space in depth-first manner by conducting boolean operations on the constraint sets that are defined by pairs of template points and target points. For constrained polynomial transformations that have {{no more than two}} parameters on each coordinate, a constraint set can be represented as a 2 D polygon or a Cartesian product of 2 D polygons. Then, the boolean operations can be computed through generic polygon <b>clipping</b> <b>algorithms.</b> Preliminary experiments on randomly generated point patterns show that the algorithm is effective and efficient under practical conditions. 1...|$|R
40|$|This {{research}} {{describes a}} parallel implementation of Liang-Barsky <b>clipping</b> <b>algorithm</b> on a pipeline network configuration. The implemented configuration uses pipeline of four transputers and programmed under Occam 2 language. In {{order to achieve}} the concurrency, to improve the performance and to cut down the hold-ups caused by the calculation of intersection, data buffering is used...|$|E
40|$|A new O(lg N) line <b>clipping</b> <b>algorithm</b> in E 2 {{against a}} convex window is presented. The main {{advantage}} of the presented algorithm is the principal acceleration of the line clipping problem solution. A comparison of the proposed algorithm with others shows a significant improvement in run-time. Experimental results for selected known algorithms are also shown...|$|E
40|$|Abstract [...] A {{new line}} <b>clipping</b> <b>algorithm</b> against convex window {{based on a}} new {{approach}} for intersection detection is presented. Theoretical comparisons with Cyrus-Beck's algorithm are shown together with experimental results obtained by simulations. The main advantage of the presented algorithm is the substantial acceleration of the line clipping problem solution and that edges can be oriented clockwise or anti-clockwise. I...|$|E
40|$|In this paper, a {{semi-active}} {{control strategy}} for seismic response reduction in base isolated benchmark structure using neuro-controller and magnetorheological(MR) damper is proposed. The neuro-controller {{of the proposed}} control system adopts a training algorithm based on a cost function and sensitivity evaluation algorithm to produce the desired control force. A <b>clipped</b> <b>algorithm</b> is then employed to induce the MR damper to generate approximately the desired control force by selecting appropriate command voltage. The proposed semi-active neuro-controller was applied to a base isolated benchmark structure installed with linear elastomeric isolation system. Comparing with passive and sample controller those are provided by benchmark problem definition paper, numerical simulation results {{have shown that the}} proposed semi-active control strategy can significantly reduce the floor acceleration, base shear and building corner drift with a slight increase of base displacement...|$|R
40|$|Blocking and {{shadowing}} {{is one of}} the key {{effects in}} designing and evaluating a thermal central receiver solar tower plant. Therefore it is convenient to develop efficient algorithms to compute the area of an heliostat blocked or shadowed by the rest of the field. In this paper we explore the possibility of using very efficient <b>clipping</b> <b>algorithms</b> developed for the video game and imaging industry to compute the blocking and shadowing efficiency of a solar thermal plant layout. We propose an algorithm valid for arbitrary position, orientation and size of the heliostats. This algorithm turns out to be very accurate, free of assumptions and fast. We show the feasibility of the use of this algorithm to the optimization of a solar plant by studying a couple of examples in detail. Comment: LaTeX. 8 pages, 8 figure...|$|R
40|$|The HDL (Hardware Description Language) helps {{designers}} of modern digital systems {{to compete with}} the increasing size and complexity of VLSI circuits. Simulation is usually used for verification in the design process, which tends to be a bottleneck. Distributed simulation on a network of workstations tries to provide a cost-effective solution. The partitioning of the circuit is a critical factor to the performance of the distributed simulation. This study presents the design and implementation of a partitioning framework which is incorporated into the DVS (Distribute Verilog Simulator) framework. A number of well-known partitioning algorithms are implemented including a new algorithm CAKE. The classical FM and popular <b>CLIP</b> <b>algorithms</b> and their recursive bisection version are implemented. The partitioning results are studied for large circuits in ISPD 98 benchmark suite. The effect of partitioning results on the performance of the distributed simulation is analyzed with a multiplier circuit in ISCAS 85...|$|R
