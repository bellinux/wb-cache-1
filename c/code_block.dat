236|5409|Public
5|$|The pass statement, {{which serves}} as a NOP. It is {{syntactically}} needed to create an empty <b>code</b> <b>block.</b>|$|E
5|$|The try statement, {{which allows}} {{exceptions}} raised in its attached <b>code</b> <b>block</b> {{to be caught}} and handled by except clauses; it also ensures that clean-up code in a finally block will always be run regardless of how the block exits.|$|E
5|$|The with {{statement}} (from Python 2.5), which encloses a <b>code</b> <b>block</b> {{within a}} context manager (for example, acquiring a lock before the block of code is run and releasing the lock afterwards, or opening a file and then closing it), allowing Resource Acquisition Is Initialization (RAII)-like behavior.|$|E
30|$|From Eq. (12), we {{see that}} if PML[*]=[*]PMU[*]=[*]PMUL, the flagCB is set to 1 and the current <b>coding</b> <b>block</b> is {{determined}} to belong to KPL. Otherwise, flagCB is set to 0 and the current <b>coding</b> <b>block</b> is determined to belong to HPL. The main reason is that if PML[*]=[*]PMU[*]=[*]PMUL, the current <b>coding</b> <b>block</b> {{is likely to have}} the same prediction mode as its neighboring blocks (left neighboring block, up neighboring block, and up-left neighboring block), which indicates that the current <b>coding</b> <b>block</b> and its neighboring blocks have a similar texture information and structural characteristics and they belong to the homogenous texture areas. Therefore, the current <b>coding</b> <b>block</b> is grouped into KPL. If the flagCB is equal to 0, which means that the current <b>coding</b> <b>block</b> is quite different from its neighboring <b>blocks,</b> the current <b>coding</b> <b>block</b> is grouped into HPL.|$|R
30|$|For {{homogenous}} texture areas, the <b>coding</b> <b>blocks</b> {{and their}} neighboring blocks are closed linked. In most cases, {{they have the}} similar texture information and structural characteristics. As a results, the prediction modes of the <b>coding</b> <b>blocks</b> should be similar to their neighboring known blocks in the homogenous texture areas. Consequently, we can apply the prediction mode information {{to decide whether the}} <b>coding</b> <b>block</b> belongs to the homogenous texture areas and further determine whether the <b>coding</b> <b>block</b> belongs to HPL or KPL. Since the prediction mode information of the current <b>coding</b> <b>block</b> is unknown, the prediction mode information of its neighboring known blocks are utilized in the decision criterion.|$|R
30|$|It is {{composed}} of a preprocessing block, a decorrelation block, of the vector quantization, a SPIHT <b>coding</b> <b>block</b> and followed by another arithmetic <b>coding</b> <b>block.</b>|$|R
25|$|Each item in {{the given}} {{collection}} will be returned and reachable {{in the context of}} the <b>code</b> <b>block.</b> When the block has been executed the next item will be returned until there are no items remaining.|$|E
25|$|On {{the second}} attempt, Wendel {{solved the problem}} by tapping the aircraft's brakes at takeoff speed, lifting the {{horizontal}} tail out of the wing's turbulence. The aforementioned initial four prototypes (V1-V4) were built with the conventional gear configuration. Changing to a tricycle arrangement—a permanently fixed undercarriage on the fifth prototype (V5, code PC+UE), with the definitive fully retractable nosewheel gear on the V6 (with Stammkennzeichen code VI+AA, from a new <b>code</b> <b>block)</b> and subsequent aircraft corrected this problem.|$|E
500|$|Written by Philip Martin, {{this story}} was {{submitted}} on 28 December 1983 and dealt with an alien race returning to Earth to discover their [...] "humanity" [...] experiment has failed. The story involved the TARDIS alerting the Doctor {{to the fact that}} a regeneration is in progress nearby, suggesting the presence of a fellow Timelord. The Doctor instead find the elite of the Doomwraiths emerging, reconstituted, as shimmering metal columns with many moving strips and a deadly purpose. The Wraiths find that human evolution has failed, and mankind has not taken on their form; they will thus release a plague to destroy humanity, relocate the missing section of genetic code and repopulate Earth themselves. The Doctor and Peri discover that the Doomwraiths themselves have a genetic flaw which gives them the impulse to destroy. The Doctor manages to destroy the discovered <b>code</b> <b>block,</b> but says that the Doomwraiths may have left their legacy on other worlds. On 9 March 1984, Saward noted that the story idea would need further development before he could assess it for commissioning.|$|E
30|$|In this paper, {{we propose}} a {{scalable}} kernel-based MMSE estimation method to effectively compress the LF image. The <b>coding</b> <b>blocks</b> {{are divided into}} three layers. In the HPL, a hybrid kernel-based MMSE estimation and IntraBC method are proposed to predict the <b>coding</b> <b>blocks</b> to improve the prediction accuracy of <b>coding</b> <b>blocks</b> in non-homogenous texture area, which explores {{the idea of using}} the IntraBC scheme or intra-directional prediction to find the best prediction of the <b>coding</b> <b>block</b> when K-MMSE estimation method fails based on the rate-distortion optimization (RDO) procedure. In the KPL, we propose to use the K-MMSE estimation method to predict the <b>coding</b> <b>blocks</b> to ensure the coding efficiency for homogenous texture area. In the LPL, we propose to predict the <b>coding</b> <b>blocks</b> by directly using a linear prediction method and do not compute the correction vector. The linear prediction method {{can be seen as a}} simplified form of the K-MMSE estimation method. In order to decide which layer is belonged to for the current <b>coding</b> <b>block</b> accurately, we propose to use the prediction mode correlation to decide which blocks belong to HPL and use the gradient information to measure the visual flatness.|$|R
5000|$|RS Coding is a {{fault-tolerant}} {{encoding method}} in a distributed storage environment, It stores data into [...] blocks, each block is size , and generating [...] <b>coded</b> <b>blocks</b> in [...] data <b>blocks</b> via <b>coding</b> matrix, where [...] Each <b>coded</b> <b>block</b> {{is stored in}} a storage node, when the loss number of encoded blocks is not greater than , the system can fix all the data {{from any of the}} [...] <b>coded</b> <b>blocks.</b>|$|R
40|$|Reconfigurations of {{downlink}} dedicated {{channels are}} often necessary during call setup to eliminate <b>code</b> <b>blocking</b> encountered in 3 G WCDMA systems. Orthogonal Variable Spreading Factor (OSVF) is the management scheme {{used to assign}} codes. Considering single code operation, {{the performance of a}} code selection scheme called Recursive Fewer <b>Codes</b> <b>Blocked</b> scheme (RFCB) has been studied. RFCB manages to mitigate <b>code</b> <b>blocking</b> and thus minimizes the fragmentation of the OVSF code tree capacity...|$|R
2500|$|A <b>code</b> <b>block</b> can {{be passed}} to a method as an {{optional}} block argument. [...] Many built-in methods have such arguments: ...|$|E
2500|$|The Geek <b>Code</b> <b>Block</b> formatting, {{which is}} {{optional}} (though not in Robert Hayden's opinion), is {{a parody of}} the output produced by the encryption program PGP. Within the Geek <b>Code</b> <b>Block</b> there is a line specifying the version of Geek Code being used. The next line starts with the letter G (for Geek) followed by the geek's occupation(s): GMU for a geek of music, then the geek code proper begins. For geeks with multiple occupations, a slash or slashes are used: GMD/TW, for instance, for a geek of medicine and technical writing. There are 28 occupations that can be represented. These are: ...|$|E
2500|$|The {{operators}} [...] {{are used}} to signify a <b>code</b> <b>block</b> and a new scope. Class members and {{the body of a}} method are examples of what can live inside these braces in various contexts.|$|E
50|$|<b>Code</b> <b>blocks</b> are {{the actions}} {{completed}} when the <b>blocks</b> are triggered, <b>code</b> <b>blocks</b> fall into 6 categories: abilities, movement, drawing, looks & sounds, values, and control flow. Drag these {{into and out}} of the scripts to modify them.|$|R
30|$|Given {{that the}} HPL {{is used to}} improve the whole coding efficiency, to decide {{accurately}} which <b>coding</b> <b>blocks</b> belong to this layer is of great importance. The decision criterion should {{take into account the}} contents of the <b>coding</b> <b>blocks.</b>|$|R
3000|$|... 2. For simplicity, we let {{the size}} of the <b>coding</b> <b>block</b> be 126. Then, {{the size of the}} <b>coded</b> output <b>block</b> will be 2 ×(126 + 2)= 256 where the two {{additional}} bits are for tail bits. Without any puncturing, we can then fit each <b>coded</b> <b>block</b> into one QPSK OFDM symbol with size of M= 128. Also let the interleaver be a 16 × 16 block interleaver.|$|R
50|$|Support include macro, custom shader <b>code</b> <b>block,</b> dynamic {{definition}} in shader compiling.|$|E
5000|$|Control {{dependencies}} {{must also}} be considered when analyzing dependencies between different statements in a loop. Control dependencies are dependencies introduced by the code or the programming algorithm itself. They control the order in which instructions occur within the execution of code. One common example is an [...] "if" [...] statement. [...] "if" [...] statements create branches in a program. The [...] "then" [...] portion of the [...] "if" [...] statement explicitly directs or controls actions to be taken. // <b>Code</b> <b>block</b> 1 (CORRECT) // <b>Code</b> <b>block</b> 2 (INCORRECT) // <b>Code</b> <b>block</b> 3 (INCORRECT) if(a == b) then { if(a == b) then { if(a == b) then { [...] c = [...] "controlled"; } c = [...] "controlled"; } c = [...] "controlled"; d = [...] "not controlled"; d = [...] "not controlled"; d = [...] "not controlled"; }In this example, the constraints on control flow are illustrated. <b>Code</b> <b>block</b> 1 shows the correct ordering when using an if statement in the C programming language. <b>Code</b> <b>block</b> 2 illustrates a problem where a statement that is supposed to be controlled by the if statement is no longer controlled by it. <b>Code</b> <b>block</b> 3 illustrates a problem where a statement that is not supposed to be controlled by the [...] "if" [...] statement has now been moved under its control. Both of these two possibilities could lead to improper program execution and must be considered when parallelizing these statements within a loop.|$|E
50|$|Loop-carried {{dependencies}} and loop independent dependencies {{are determined}} by the relationships between statements in iterations of a loop. When a statement in one iteration of a loop depends in some way on a statement in a different iteration of the same loop, a loop-carried dependence exists. However, if a statement in one iteration of a loop depends only on a statement in the same iteration of the loop, this creates a loop independent dependence. // <b>Code</b> <b>block</b> 1 // <b>Code</b> <b>block</b> 2 for(i = 0; i < 4; i++) for(i = 0; i < 4; i++) S1: bi = 8; S1: bi = 8; S2: ai = bi-1 + 10; S2: ai = bi + 10;In this example, <b>code</b> <b>block</b> 1 shows loop-dependent dependence between statement S2 iteration i and statement S1 iteration i+1. This is to say that statement S2 cannot proceed until statement S1 in the previous iteration finishes. <b>Code</b> <b>block</b> 2 show loop independent dependence between statements S1 and S2 in the same iteration.|$|E
30|$|The kernel-based MMSE {{estimation}} method aims {{to predict the}} current <b>coding</b> <b>block</b> given its neighbor known context under a kernel-based point of view by constructing a statistical model and calculating a kernel-based MMSE estimation. In order to construct the statistical model, the pixel values in the <b>coding</b> <b>block</b> and its neighbor known context are arranged into a multidimensional formalism. Kernel density estimation (KDE) is used to estimate the probability density function (PDF) of the statistical model {{with a set of}} observed vectors. The <b>coding</b> <b>block</b> is then predicted from an MMSE estimator given the PDF.|$|R
40|$|Abstract—In recent years, {{cloud storage}} systems {{have emerged as}} the primary {{solution}} for online storage and information sharing. Due to efficient storage and bandwidth utilization, the use of erasure codes and network coding is proven to effectively provide fault tolerance and fast content retrieval in cloud storage systems. In a nutshell, <b>coded</b> <b>blocks</b> are distributed among storage nodes, and file retrieval is accomplished by downloading sufficient <b>coded</b> <b>blocks</b> from any group of storage nodes. However, due to high correlation between <b>coded</b> <b>blocks</b> and the original file, even a single-byte update invalidates all <b>coded</b> <b>blocks</b> in the system. In this paper, we introduce DeltaNC, a new differential update algorithm that keeps all <b>coded</b> <b>blocks</b> in a network-coding-based cloud storage system synchronized by transmitting only {{the changes in the}} file. Our experimental results, from a trace-driven simulator, show that DeltaNC significantly reduces the bandwidth and CPU usage and its performance is comparable to that offered by the Diff program, the common tool for updating files. Keywords—cloud computing; storage system; network coding I...|$|R
30|$|Adaptive layer {{management}} mechanism. We use the prediction mode clue and the gradient information {{to decide which}} layer belongs for the current <b>coding</b> <b>block.</b> The adaptive {{layer management}} mechanism is designed to select which layer is belong to for a <b>coding</b> <b>block</b> based on how complex its surrounding area is.|$|R
5000|$|BCH code, {{which can}} be {{designed}} to correct any arbitrary number of errors per <b>code</b> <b>block.</b>|$|E
5000|$|The <b>code</b> <b>block</b> below {{shows the}} JSON {{representation}} of an instantiation of the [...] data model.|$|E
5000|$|The {{following}} code demonstrates this:result := a > b ifTrue:'greater' [...] ifFalse:'less or equal' Blocks {{are also}} used to implement user-defined control structures, enumerators, visitors, pluggable behavior and many other patterns.For example:| aString vowels |aString := 'This is a string'.vowels := aString select: | aCharacter isVowel.In the last line, the string is sent the message select: with an argument that is a <b>code</b> <b>block</b> literal. The <b>code</b> <b>block</b> literal {{will be used as}} a predicate function that should answer true if and only if an element of the String {{should be included in the}} Collection of characters that satisfy the test represented by the <b>code</b> <b>block</b> that is the argument to the [...] "select:" [...] message.|$|E
5000|$|... sections: {{assigning}} consecutive but independent <b>code</b> <b>blocks</b> {{to different}} threads ...|$|R
50|$|Now, both CPU's execute {{separate}} <b>code</b> <b>blocks</b> simultaneously, performing different tasks simultaneously.|$|R
5000|$|The Hopscotch app uses a UI {{very similar}} to that of Scratch. Use of the editor is simple, all one has to do is open the editor, tap the object and script you wish to edit, open one of the block tabs, and drag out <b>code</b> <b>blocks.</b> Most <b>code</b> <b>blocks</b> can have numeric, text, or math inputs. e.g. the [...] "move" [...] block.|$|R
5000|$|... single: specifying a <b>code</b> <b>block</b> that is {{executed}} {{by only one}} thread, a barrier is implied in the end ...|$|E
5000|$|A <b>code</b> <b>block</b> can {{be passed}} to a method as an {{optional}} block argument. Many built-in methods have such arguments: ...|$|E
5000|$|In Unicode, the [...] "hammer and sickle" [...] symbol is U+262D (☭). It {{is part of}} the Miscellaneous Symbols (2600-26FF) <b>code</b> <b>block.</b>|$|E
40|$|Dynamic binary optimizers store altered {{copies of}} {{original}} program instructions in softwaremanaged code caches {{in order to}} maximize reuse of transformed code. Code caches store <b>code</b> <b>blocks</b> that may vary in size, reference other <b>code</b> <b>blocks,</b> and carry a high replacement overhead. These unique constraints reduce the effectiveness of conventional cache management policies. Our work directly addresses these unique constraints and presents several contributions to the code-cache management problem. First, we show that evicting more than the minimum number of <b>code</b> <b>blocks</b> from the <b>code</b> cache results in less run-time overhead than the existing alternatives. Such granular evictions reduce overall execution time, as the fixed costs of invoking the eviction mechanism are amortized across multiple cache insertions. Second, a study of the ideal lifetimes of dynamically generated <b>code</b> <b>blocks</b> illustrates the benefit of a replacement algorithm based on a generational heuristic. We describe and evaluate a generational approach to code cache management that makes it easy to identify long-lived <b>code</b> <b>blocks</b> and simultaneously avoid any fragmentation because of the eviction of short-lived blocks. Finally, we present results from an implementation of our generational approach in the DynamoRIO framework and illustrate that, as dynamic optimization systems become more prevalent, effective code cache-management policies will be essential for reliable, scalable performance of modern applications...|$|R
3000|$|... }, {{within a}} <b>coded</b> <b>block</b> of the transmission. Minimization is done over N {{independent}} channel realizations.|$|R
5000|$|CBP — <b>Coded</b> <b>Block</b> Pattern, this is {{bit mask}} {{indicating}} for which blocks coefficients are present.|$|R
