6|12|Public
50|$|The in {{clause of}} the <b>catch</b> <b>statement</b> is {{optional}} (this means that the error itself may be discarded).|$|E
50|$|The <b>catch</b> <b>statement</b> {{mimics the}} select statement, {{which can be}} used to switch on the type or class of a given variable.|$|E
5000|$|The <b>catch</b> <b>statement</b> {{can be used}} {{to catch}} any type of item, a certain type (i.e. strings or integers), or {{instances}} from a certain class. Caught classes are organized on a hierarchical base, so {{that it is possible to}} provide more generic error handlers like the following example (TypeError is a library class derived from Error): ...|$|E
5000|$|The Mozilla {{implementation}} {{allows for}} multiple <b>catch</b> <b>statements,</b> {{as an extension}} to the ECMAScript standard. They follow a syntax {{similar to that used}} in Java: ...|$|R
50|$|Falcon {{supports}} {{error handling}} via the raise, try and <b>catch</b> <b>statements.</b> The raise statement can throw any Falcon item, including nil, numbers, strings, objects and so on. Library functions and external modules will usually raise instances of the Error class, or instances {{of a class}} derived from that.|$|R
50|$|Alternatively TRY <b>CATCH</b> FINALLY <b>statements</b> are {{available}} on xhb library working like the SEQUENCE construct.|$|R
50|$|The TRY {{construct}} is {{very similar}} to the BEGIN SEQUENCE construct, except it automatically integrates error handling, so that any error will be intercepted, and recovered by means of the <b>CATCH</b> <b>statement</b> or forwarded to an outer CATCH handler otherwise. The FINALLY section is guaranteed to be executed before the TRY or CATCH sections forward flow control by means of RETURN, BREAK, or THROW.|$|E
50|$|In many {{languages}} {{that use}} the try{...}catch(...){...} syntax the error is returned via the <b>catch</b> <b>statement</b> and this can make the operational flow of the code awkward in situations where some errors are recoverable. TScript uses the if(...){...} else{...} notation that allows calling code to filter the error, potentially recovering from the error and returning to normal operation, or returning the error to the its own calling function.|$|E
40|$|Introduction The Java Architecture for Bytecode Analysis (JABA) of the Aristotle Research Group at Georgia Tech {{provides}} {{static analysis}} of Java programs. Besides others, JABA uses algorithms that determine inter-procedural control flow caused by exceptions [3]. This means that JABA determines for each throw {{statement of the}} program the methods visited {{on the way to}} the finally statement or <b>catch</b> <b>statement</b> deactivating the thrown exception. Note that for a given pair of throw catch statements there may be multiple control flow paths through a program. This Mini Project provides a general mechanism to visualize such interprocedural control flow information, for example provided by JABA's static analysis. The mechanism is general in the sense that also other data sources like the result of a dynamic analysis could be used. 2 Motivation Let's assume that most Java programmers, testers, and maintainers do not leverage static or dynamic analysis tools to explore inter-procedural contro...|$|E
40|$|Abstract. JESP is a {{tool for}} statically {{examining}} the usage of user thrown exceptions in Java source code. Reported here are the first findings over a dataset of 31 publicly available Java codes, including the JavaSpecs. Of greatest interest to compiler writers are the findings that most Java exceptions are thrown across method boundaries, trys and catches occur in equal numbers, finallys are rare, and programs {{fall into one of}} two categories, those dominated by throw statements and those dominated by <b>catch</b> <b>statements.</b> The research reported here was supported, in part, by NSF grant CCR- 9808607. ...|$|R
5000|$|The [...] <b>statement</b> <b>catches</b> {{exceptions}} {{resulting from}} an error or a throw statement. Its syntax is as follows: ...|$|R
40|$|JESP is a {{tool for}} statically {{examining}} the usage of user thrown exceptions in Java source code. Reported here are the first findings over a dataset of 31 publicly available Java codes, including the JavaSpecs. Of greatest interest to compiler writers are the findings that most Java exceptions are thrown across method boundaries, trys and catches occur in equal numbers, finallys are rare, and programs {{fall into one of}} two categories, those dominated by throw statements and those dominated by <b>catch</b> <b>statements.</b> # The research reported here was supported, in part, by NSF grant CCR- 9808607. 2 1 Introduction Java already has been embraced as a Web programming language and is beginning to gain acceptance as a language for general applications. In response to the acceptance and use of this and other OO languages, compile-time analysis and code transformations that produce optimized code for features found in such languages(e. g., polymorphism, exceptions, etc.) are being studied [...] . ...|$|R
40|$|This paper {{presents}} a new visualization technique {{for supporting the}} understanding of exception-handling constructs in Java programs. To understand the requirements for such a visualization, we sur-veyed a group of software developers, and used {{the results of that}} survey to guide the creation of the visualizations. The technique presents the exception-handling information using three views: the quantitative view, the flow view, and the contextual view. The quan-titative view provides a high-level view that shows the throw-catch interactions in the program, along with relative numbers of these interactions, at the package level, the class level, and the method level. The flow view shows the type-throw-catch interactions, illus-trating information such as which exception types reach particular throw <b>statements,</b> which <b>catch</b> <b>statements</b> handle particular throw statements, and which throw statements are not caught in the pro-gram. The contextual view shows, for particular type-throw-catch interactions, the packages, classes, and methods that contribute to that exception-handling construct. The paper also {{presents a}} case study in which we evaluated a prototype of the visualization system on a small set of developers...|$|R
5000|$|Marshall once bluntly {{described}} his legal philosophy as this: [...] "You {{do what you}} think is right and let the law <b>catch</b> up", a <b>statement</b> which his conservative detractors argued was a sign of his embracement of judicial activism.|$|R
40|$|Exception {{analysis}} and points-to analysis are typically done in complete separation. Past algorithms for precise exception analysis (e. g., pairing throw clauses with <b>catch</b> <b>statements)</b> use precomputed points-to information. Past points-to analyses either unsoundly ignore exceptions, or conservatively compute a crude approximation of exception throwing (e. g., considering an exception throw as an assignment {{to a global}} variable, accessible from any catch clause). We show that this separation results in significant slowdowns or vast imprecision. The two kinds of analyses are interdependent: neither can be performed accurately without the other. The interdependency leads us to propose a joint handling for performance and precision. We show that our exception analysis is expressible highly elegantly in a declarative form, and can apply to points-to analyses of varying precision. In fact, our specification of exception analysis is “fully precise”, as it models closely the Java exception handling semantics. The necessary approximation is provided only through whichever abstractions are used for contexts and objects in the base points-to analysis. Our combined approach achieves similar precision relative to exceptions (exception-catch links) as the best past precise exception analysis, with a runtime of seconds instead of tens of minutes. At the same time, our analysis achieves much higher precision of points-to information (an average of half as many values for each reachable variable {{for most of the}} DaCapo benchmarks) than points-to analyses that treat exceptions conservatively, all {{at a fraction of the}} execution time...|$|R
5000|$|On 20 August 2007, Flight 120, a Boeing 737-800 inbound from Taipei {{caught fire}} shortly after landing at Naha Airport in Okinawa Prefecture, Japan. After {{stopping}} on the tarmac, the engine started smoking and burning, and later exploded causing the aircraft to <b>catch</b> fire. A <b>statement</b> from the airline confirmed that all {{passengers and crew}} members were safely evacuated, and a ground engineer knocked off his feet by the blast was unhurt. The cause of the explosion {{has been attributed to}} a fuel leak caused by a bolt from the right wing slat puncturing the fuel tank.|$|R
40|$|Maintains a {{high-level}} expert in Finland: Local food {{has grown into}} something like a social movement. The <b>statement</b> <b>catches</b> poignantly the broad social support for the concept of local food. However, public food represents a societal concept, loaded with expanding responsibilities {{of the welfare state}} not only to provide citizens with healthy but also sustainable meals. These include aspects of supporting local economy, more equitable trading relations and decreasing environmental impacts. Here the welfare state supports through its policies developmental trajectories for sustainable food systems. This paper analyses the concept of local food as it is understood by public procurers and examines the structural match of the supply and demand in public procurement. The paper is based on qualitative and quantitative data about public procurement of local food during the first decade of 21 st millennium. The qualitative data stem from public caterers representing organizations across Finland, offering a valid view about the dependency {{of the size of the}} organization and its understanding of the concept of local food. The quantitative data have been collected by a survey covering the Finnish municipalities, and it shows the proportion of local food used by public catering in different parts of the country. The results suggest issues of structural development both in supply and demand and possibilities to understand the concept of local food in more functional ways than currently is the case. vo...|$|R

