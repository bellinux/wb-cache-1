2|3963|Public
40|$|Part 2 : WorkshopInternational audienceBoth dynamic binary {{translation}} {{systems and}} optimization systems store the translated or optimized code {{in the software}} maintained code cache for reuse. The performance of the code cache is crucial. Translated code is usually organized as code blocks in the code cache and each code block transfer control {{to the next one}} through a <b>control</b> <b>transfer</b> <b>instruction.</b> As the target address of a <b>control</b> <b>transfer</b> <b>instruction</b> {{is in the form of}} its source program counter, the conventional code cache system has to check the address mapping table for the translated target address to find the required target code block, which will cause considerable performance degradation. Control transfer instructions can be divided into two categories as direct control transfer instructions and indirect control transfer instructions. For indirect control transfer instructions, the target address is hold in the register or memory element whose content can be changed during the execution of the program. It is difficult to chain the indirect control transfer instructions with a fixed translated target address through pure software approaches. A novel indirect control transfer chaining approach is proposed in this paper. The principle of the technique is to insert custom chaining instructions into the translated code block while translating the indirect control transfer instructions and execute those chaining instructions to implement dynamical chaining. Some special hardware and software assists are proposed in this paper. Evaluation of the proposed approach is conducted on a code cache simulator. Experiment results show that our hardware assisted indirect <b>control</b> <b>transfer</b> <b>instruction</b> chaining approach can improve the performance of the code cache system dramatically...|$|E
30|$|Marker {{verification}} A {{group of}} markers are verified {{together for a}} <b>control</b> <b>transfer</b> <b>instruction.</b> Since they have complete information for the control transfer, the same verification process can be performed {{regardless of whether they}} come from fragments or a whole code. Thus, we can use the code watchdogs, which monitor the wireless network to detect attacks from binary code fragments. The recipient devices also have a whole updated program binary code. The program binary code with semantics markers can be repeatedly checked in the software attestation process. To prevent the attacker from illegally generating semantics markers, the marker is protected by a key. We assume the key is shared with the payload generator, code watchdogs, and the recipient devices.|$|E
30|$|Current Intel PT {{implementations}} record only <b>control</b> <b>transfer</b> <b>instructions</b> like conditional {{jumps and}} indirect function calls, and simply ignore all memory access events. Future Intel processor releases will reportedly include a new instruction named PTWRITE to insert software-defined value into the trace to enhance debuggers (Strong et al. 2015). As PTWRITE is still unavailable on current processor releases yet (Hunter 2017), DTrace emulates PTWRITE by encoding the memory data load and store events with <b>control</b> <b>transfer</b> <b>instructions</b> and synthesizes the events from the trace.|$|R
50|$|Processors usually fetch {{instructions}} sequentially from memory, but <b>control</b> <b>transfer</b> <b>instructions</b> {{change the}} sequence {{by placing a}} new value in the PC. These include branches (sometimes called jumps), subroutine calls, and returns. A transfer that is conditional on the truth of some assertion lets the computer follow a different sequence under different conditions.|$|R
30|$|Two-step marker {{injection}} Injecting markers into program {{binary code}} may alter {{the address of}} program text, and it skews the target address of <b>control</b> <b>transfer</b> <b>instructions.</b> Thus, binary rewriting requires a painful job to update all the address of <b>control</b> <b>transfer</b> <b>instructions</b> even in the position-independent code (PIC). This {{is the reason why}} binary rewriting on a code is being used in limited ways. In order to avoid the problem, we first inject empty slots to a source code to prepare space for the semantics markers and compile the source code. At the binary code, the slots will then occupy spaces for markers. We fill the slots by computing semantics markers for that position. Since space for markers already exists at compile time, no address of the program code needs to be changed; thus, no additional binary rewriting is required.|$|R
5000|$|This is {{the only}} {{technique}} provided for many RISC processors, but CISC architectures such as x86 support additional techniques. For example, the x86 instruction set contains the instructions SYSCALL/SYSRET and SYSENTER/SYSEXIT (these two mechanisms were independently created by AMD and Intel, respectively, but in essence they do the same thing). These are [...] "fast" [...] <b>control</b> <b>transfer</b> <b>instructions</b> {{that are designed to}} quickly <b>transfer</b> <b>control</b> to the kernel for a system call without the overhead of an interrupt. Linux 2.5 began using this on the x86, where available; formerly it used the INT instruction, where the system call number was placed in the EAX register before interrupt 0x80 was executed.|$|R
30|$|Intel PT records all <b>control</b> flow <b>transfer</b> <b>instructions</b> by default, which {{fill the}} Trace Buffer with large {{quantities}} of uninteresting packets to DTrace like conditional branch taken-not-taken. The irrelevant packets increase the burden of packet decoding {{and the number of}} interrupts for the Trace Buffer filling events.|$|R
40|$|Xidian UniversityDLLs (Dynamic Link Libraries) {{are usually}} {{protected}} by various anti-reversing engineering techniques. One technique commonly used is code packing as packed DLLs hinder static code analysis such as disassembly. In this paper, we propose {{a technique to}} reconstruct a binary file for static analysis by loading a DLL and triggering and monitoring {{the execution of the}} entry-point function and exported functions of packed DLLs. By monitoring all memory operations and <b>control</b> <b>transfer</b> <b>instructions,</b> our approach extracts the original hidden code which is written into the memory at run-time and constructs a binary based on the original DLL, the codes extracted and the records of <b>control</b> <b>transfers.</b> To demonstrate its effectiveness, we implemented our prototype ReconPD based on QEMU. The experiments show that ReconPD is able to analyze the packed DLLs, yet practical in terms of performance. Moreover, the reconstructed binary files can be successfully analyzed by static analysis tools, such as IDA Pro. © 2009 Springer Berlin Heidelberg...|$|R
40|$|Current taint {{checking}} architectures monitor tainted {{data usage}} mainly with <b>control</b> <b>transfer</b> <b>instructions.</b> An alarm is raised once the program counter becomes tainted. However, such architectures are not effective against non-control data attacks. In this paper {{we present a}} generic instructionlevel runtime taint checking architecture for handling noncontrol data attacks. Under our architecture, instructions are classified as either Taintless-Instructions or Tainted-Instructions prior to program execution. An instruction is called a Tainted-Instruction if {{it is supposed to}} deal with tainted data. Otherwise it is called a Taintless-Instruction. A security alert is raised whenever a Taintless-Instruction encounters tainted data at runtime. The proposed architecture is implemented on the SimpleScalar simulator. The preliminary results from experiments on SPEC CPU 2000 benchmarks show that there are a significant amount of Taintless-Instructions. We also demonstrate effective usages of our architecture to detect buffer overflow and format string attacks...|$|R
40|$|High-performing on-chip {{instruction}} caches {{are crucial}} to keep fast processors busy. Unfortunately, while on-chip caches are usually successful at intercepting instruction fetches in loop-intensive engineering codes, they are less {{able to do so}} in large systems codes. To improve the performance of the latter codes, the compiler can be used to lay out the code in memory for reduced cache conflicts. Interestingly, such an operation leaves the code in a state that can be exploited by a new type of instruction prefetching: guarded sequential prefetching. The idea is that the compiler leaves hints in the code as to how the code was laid out. Then, at run time, the prefetching hardware detects these hints and uses them to prefetch more effectively. This scheme can be implemented very cheaply: one bit encoded in <b>control</b> <b>transfer</b> <b>instructions</b> and a prefetch module that requires minor extensions to existing next-line sequential prefetchers. Furthermore, the scheme can be turned off and on at ru [...] ...|$|R
40|$|Abstract- We {{address the}} problem of {{automatically}} verifying large digital designs at the logic level, against high-level specifications. In this paper, we present a methodology which allows for the verification of a specific class of synchronous machines, namely pipelined microprocessors. The specification is the instruction set of the microprocessor with respect to which the correctness property is to be verified. A relation, namely the β-relation, is established between the input/output behavior of the implementation and specification. The relation corresponds to changes in the input/output behavior that result from pipelining, and takes into account data hazards and <b>control</b> <b>transfer</b> <b>instructions</b> that modify pipelined execution. The correctness requirement is that the β-relation hold between the implementation and specification. We use symbolic simulation of the specification and implementation to verify their functional equivalence. We characterize the pipelined and unpipelined microprocessors as definite machines (i. e. a machine in which for some constant k, the output of the machine depends only on the last k inputs) for verification purposes. We show that {{only a small number of}} cycles, rather than exhaustive state transition graph traversal and state enumeration, have to be simulated for each machine to verify whether the implementation is in β-relation with the specification. Experimental results are presented. ...|$|R
40|$|We present program shepherding, {{a method}} for {{monitoring}} <b>control</b> flow <b>transfers</b> during program execution in order {{to enforce a security}} policy. Program shepherding provides three basic techniques as building blocks for security policies. First, program shepherding can restrict execution privileges on the basis of code origins. This distinction can ensure that malicious code masquerading as data is never executed, thwarting a large class of security attacks. Second, shepherding can restrict <b>control</b> <b>transfers</b> based on <b>instruction</b> type, source, and target. Finally, shepherding guarantees that sandboxing checks around any program operation will never be bypassed...|$|R
40|$|We {{introduce}} program shepherding, {{a method}} for monitoring <b>control</b> flow <b>transfers</b> during program execution {{to enforce a security}} policy. Program shepherding provides three techniques as building blocks for security policies. First, shepherding can restrict execution privileges on the basis of code origins. This distinction can ensure that malicious code masquerading as data is never executed, thwarting a large class of security attacks. Second, shepherding can restrict <b>control</b> <b>transfers</b> based on <b>instruction</b> class, source, and target. For example, shepherding can forbid execution of shared library code except through declared entry points, and can ensure that a return instruction only targets the instruction after a call. Finally, shepherding guarantees that sandboxing checks placed around any type of program operation will never be bypassed. We have implemented these capabilities efficiently in a runtime system with minimal or no performance penalties. This system operates on unmodified native binaries, requires no special hardware or operating system support, and runs on existing IA- 32 machines under both Linux and Windows. ...|$|R
40|$|We present program shepherding, {{a method}} for {{monitoring}} <b>control</b> flow <b>transfers</b> dur-ing program execution in order {{to enforce a security}} policy. Program shepherding provides three basic techniques as building blocks for security policies. First, pro-gram shepherding can restrict execution privileges on the basis of code origins. This distinction can ensure that malicious code masquerading as data is never executed, thwarting a large class of security attacks. Second, shepherding can restrict <b>control</b> <b>transfers</b> based on <b>instruction</b> type, source, and target. Finally, shepherding guaran-tees that sandboxing checks around any program operation will never be bypassed. Security attacks use inevitable bugs in trusted binaries to coerce a program into performing actions that it was never intended to perform. We use static and dynamic analyses to automatically build a custom security policy for a target program, which specifies the program's execution model. An accurate execution model restricts <b>control</b> flow <b>transfers</b> only to the intended ones and can thwart attacker attempts to alter program execution. For example, shepherding will allow execution of shared librar...|$|R
40|$|This study {{investigated}} ways to support young children’s STEM learning {{and ability to}} generalize their knowledge across informal learning experiences. Participants were 128 parents and their 4 - to 8 -year-old children (Mage = 6. 63, SD = 1. 38). Families {{were randomly assigned to}} receive engineering <b>instructions,</b> <b>transfer</b> <b>instructions,</b> both engineering and <b>transfer</b> <b>instructions,</b> or neither. They were then observed working together to solve an engineering problem, and immediately afterward, the children were invited to solve a second engineering problem on their own. Families who received engineering instructions – either alone or in combination with the <b>transfer</b> <b>instructions</b> - were more successful at solving the first engineering problem than those who received only <b>transfer</b> <b>instructions</b> or no instructions. Moreover, parents asked more open-ended questions and talked more about science and mathematics if they received both engineering and <b>transfer</b> <b>instructions.</b> Lastly, children who received both engineering and <b>transfer</b> <b>instructions</b> were better at solving the second engineering problem than those who received only one set of instructions or no instructions. Implications of the work for research in the field and for informal educational environments and their visitors are discussed...|$|R
5000|$|... {{international}} funds <b>transfer</b> <b>instructions,</b> either into {{or out of}} Australia, of any amount, and ...|$|R
50|$|The 1973 Xerox Alto, {{where the}} term bit blit originated, {{had a bit}} block <b>transfer</b> <b>instruction</b> {{implemented}} in microcode, making it much faster than the same operation written on the CPU. The microcode was implemented by Dan Ingalls.|$|R
40|$|This {{paper has}} {{researched}} {{the issue of}} corporate <b>control</b> <b>transfer</b> failed in china capital market, which is completely different from existing studies in corporate <b>control</b> <b>transfer</b> field. The conclusion has shown that corporate <b>control</b> <b>transfer</b> very likely fails {{when there is a}} great difference between two sides of deals. And the equity nature is another affection factor. The corporate <b>control</b> <b>transfer</b> is not likely to fail when the equity nature is state-owned. The conclusion implies that we should make more improvement for institutions of corporate <b>control</b> <b>transfer,</b> {{because of the lack of}} market voluntary trade rule in china capital market...|$|R
40|$|<b>Control</b> <b>transfer</b> is the {{fundamental}} activity in an operating system kernel. The resource management functionality and application programmer interfaces of an operating system may be delegated to other system components, but the kernel must manage <b>control</b> <b>transfer.</b> The current trend towards increased modularity in operating systems only increases the importance of <b>control</b> <b>transfer.</b> My thesis is that a programming language abstraction, continuations, can be adapted for use in operating system kernels to achieve increased flexibility and performance for <b>control</b> <b>transfer.</b> The flexibility that continuations provide allows the kernel designer when necessary to choose implementation performance over convenience, without affecting {{the design of the}} rest of the kernel. The continuation abstraction generalizes existing operating system <b>control</b> <b>transfer</b> optimizations. This dissertation also makes two practical contributions, an interface for machine-independent <b>control</b> <b>transfer</b> management inside [...] ...|$|R
50|$|CPU: 8-bit HuC6280A, a {{modified}} 65SC02 running at 1.79, or 7.16 MHz (switchable by software). Features integrated bankswitching hardware (driving a 21-bit {{external address bus}} from a 6502-compatible 16-bit address bus), an integrated general-purpose I/O port, a timer, block <b>transfer</b> <b>instructions,</b> and dedicated move instructions for communicating with the HuC6270A VDC.|$|R
50|$|Experts {{see a real}} {{possibility}} that operational <b>control</b> <b>transfer</b> could be pushed {{back as far as}} 2020 given the continued potential for an inter-Korean conflict. As long as South Korea’s KAMD and Kill Chain pre-emptive strike system remain in development, full operational <b>control</b> <b>transfer</b> will likely be postponed.|$|R
500|$|The <b>control</b> <b>transfer</b> {{exchange}} {{consist of}} three distinct stages: ...|$|R
50|$|The <b>control</b> <b>transfer</b> {{exchange}} {{consist of}} three distinct stages.|$|R
40|$|This study {{examines}} changes in block ownership {{for a large}} sample of listed and non-listed German firms. The frequency of block trading is similar to other countries, {{and the vast majority}} of block trades leads to changes in ultimate ownership (<b>control</b> <b>transfers).</b> Such changes are more likely for firms with high leverage, while they are less likely for larger firms and firms with high ownership concentration. Only for listed firms poor performance is related to more frequent <b>control</b> <b>transfers.</b> <b>Control</b> <b>transfers</b> are followed by increased management turnover, and for listed firms also by asset divestitures and employee layoffs. [...] Corporate governance,ownership structure,management turnover,restructuring...|$|R
5000|$|... #Subtitle level 2: <b>Control</b> <b>transferred</b> to the National Policing Improvement Agency in 2007 ...|$|R
5000|$|... the <b>control</b> <b>transfers</b> {{which allow}} two {{different}} protocols named version A and version B; ...|$|R
40|$|<b>Control</b> <b>transfer</b> {{is a major}} measure {{taken by}} {{companies}} to improve the performance. However, it still remains inconclusive that performance will be effectively enhanced after <b>control</b> <b>transfer.</b> Based on agreement transfer, it uses factor analysis method and analyzes performance indicators in sequent five years from 2006 to 2008 with the samples of Chinese stock markets. The results showed that, the performance of listed companies will be increased after the <b>transfer</b> of <b>control</b> rights, {{but it is only}} a short-term effect; as to the company’s ownership structure, ownership concentration has a positive effect to firm performance, and the proportion of state-owned shares does not show a positive impact to it. Company’s performance and market value will be enhanced with the resource optimization and resource integration. Finally, it is necessary for company and the whole market to strengthen and standardize <b>control</b> <b>transfer</b> behaviors and optimize equity structure in order to improve the market construction of <b>control</b> <b>transfer</b> system...|$|R
5000|$|<b>Control</b> <b>transfers.</b> Other {{than the}} skip {{instructions}} previously mentioned, {{there are only}} two: [...] and [...]|$|R
30|$|In a whole program code, the {{semantics}} markers {{can detect}} all the illegitimate <b>control</b> <b>transfers</b> modified by attackers. On the other hand, in a fragment, a code watchdog {{can find the}} modification of a <b>control</b> <b>transfer</b> statement only if it can check all the markers that correspond tot the statement together. Therefore, we evaluate the rate of successful validation of markers in a fragmented binary code.|$|R
50|$|ICICI Bank UK PLC, Germany branch {{provides}} money {{transfer and}} tracking service (Money2India Europe, Money2India.EU) in 20 European countries. The platform facilitates money transfer to India by allowing remitter to initiate money <b>transfer</b> <b>instruction</b> on M2E. Depending {{on the country}} of residence and the financial institution with which the user is holding the bank account, he / she has an option to transfer money through payment gateway integrated with the platform—with guaranteed exchange rate.|$|R
5000|$|The Hudson Soft HuC6280 is a {{modified}} 65C02 with an effective clock rate of 1.79 or 7.16 MHz (switchable by software). The integrated components of this 8-bit processor include a timer, general-purpose I/O port, and bankswitching hardware (which drives a 21-bit {{external address bus}} from a 6502-compatible 16-bit address bus). It is capable of block <b>transfer</b> <b>instructions,</b> as well as dedicated move instructions for communicating with the TurboDuos video display controller, the HuC6270A.|$|R
50|$|ISO/IEC 7816-12:2005 {{provides}} two protocols for <b>control</b> <b>transfers.</b> This is {{to support}} the protocol T=0 (version A) or to use the transfer on APDU level (version B). ISO/IEC 7816-12:2005 provides the state diagrams for the USB-ICC {{for each of the}} <b>transfers</b> (bulk <b>transfers,</b> <b>control</b> <b>transfers</b> version A and version B). Examples of possible sequences which the USB-ICC must be able to handle are given in an informative annex.|$|R
5|$|Status stage: Dummy IN or OUT transaction, {{which is}} {{probably}} for indicating {{the end of a}} <b>control</b> <b>transfer</b> exchange.|$|R
5000|$|Status Stage: Dummy IN or OUT transaction. Which is {{probably}} for indicating {{the end of}} a <b>control</b> <b>transfer</b> exchange.|$|R
5000|$|... 18 (Thunder Bay) Service Company (18 Svc Coy) Note: Operational Command and <b>Control</b> <b>transferred</b> to Lake Superior Scottish Regiment ...|$|R
25|$|In {{taking into}} {{consideration}} such an application, {{emphasis is placed on}} the ability of a foreign court to follow due process. The Act also requires the Secretary of Treasury to take all reasonable steps to encourage foreign governments make it a requirement to include the name of the originator in wire <b>transfer</b> <b>instructions</b> sent to the United States and other countries, with the information to remain with the transfer from its origination until the point of disbursement.|$|R
