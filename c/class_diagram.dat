805|1416|Public
5|$|In 1933, Bengt Strömgren {{introduced}} the term Hertzsprung–Russell diagram to denote a luminosity-spectral <b>class</b> <b>diagram.</b> This name reflected the parallel {{development of this}} technique by both Hertzsprung and Russell earlier in the century.|$|E
25|$|The meta-data {{model of}} the control sub-process {{is based on a}} UML <b>class</b> <b>diagram.</b> Figure 2.1.2 shows the {{metamodel}} of the control sub-process.|$|E
25|$|It {{supports}} UML activity diagram, component diagram, (logical) <b>class</b> <b>diagram,</b> sequence diagram, and {{use case}} diagram. Visual Studio Ultimate 2010 also includes Test Impact Analysis which provides hints on which test cases are impacted by {{modifications to the}} source code, without actually running the test cases. This speeds up testing by avoiding running unnecessary test cases.|$|E
50|$|Object <b>diagrams</b> and <b>class</b> <b>diagrams</b> {{are closely}} related and use almost {{identical}} notation. Both diagrams are meant to visualize static structure of a system. While <b>class</b> <b>diagrams</b> show <b>classes,</b> object <b>diagrams</b> display instances of <b>classes</b> (objects). Object <b>diagrams</b> are more concrete than <b>class</b> <b>diagrams.</b> They are often used to provide examples or act as test cases for <b>class</b> <b>diagrams.</b> Only aspects of current interest in a model are typically shown on an object diagram.|$|R
40|$|AbstractAutomatic {{debugging}} of UML <b>class</b> <b>diagrams</b> {{helps in}} the visual specification of software systems because users cannot detect errors in logical consistency easily. This study focuses on the tractable consistency checking of UML <b>class</b> <b>diagrams.</b> We accurately identify inconsistencies in these diagrams by translating them into first-order predicate logic that is generalized by counting quantifiers and classify their expressivities by eliminating certain components. We introduce optimized algorithms that compute the respective consistencies of <b>class</b> <b>diagrams</b> of different expressive powers in P, NP, PSPACE, or EXPTIME {{with respect to the}} size of the <b>class</b> <b>diagrams.</b> In particular, owing to the restrictions imposed on attribute value types, the complexities of consistency checking of <b>class</b> <b>diagrams</b> decrease from EXPTIME to P and PSPACE in two cases: (i) when the <b>class</b> <b>diagrams</b> contain disjointness constraints and overwriting/multiple inheritances and (ii) when the <b>class</b> <b>diagrams</b> contain both these components along with completeness constraints. Additionally, we confirm the existence of a restriction of <b>class</b> <b>diagrams</b> that prevents any logical inconsistency...|$|R
40|$|Abstract—The {{trend towards}} {{the use of}} {{object-oriented}} methods for software systems development has made it necessary {{for the use of}} object-oriented approaches in object-oriented software systems development. <b>Class</b> <b>diagrams</b> represent an essential component in any object-oriented system design. The development of such <b>class</b> <b>diagrams</b> in a systematic way is very crucial in an object-oriented development methodology. The main principles used in obtaining these <b>class</b> <b>diagrams</b> in a systematic way are described since <b>class</b> <b>diagrams</b> are very essential in object-oriented development practice. Keywords- <b>Class</b> <b>diagrams,</b> software requirements, objectoriented methods I...|$|R
2500|$|... for {{any small}} (i.e., indexed {{by a set}} I, {{as opposed to a}} <b>class)</b> <b>diagram</b> of objects in [...]|$|E
5000|$|<b>Class</b> <b>diagram</b> derivation: Now it {{is fairly}} {{straightforward}} to derive a <b>class</b> <b>diagram</b> from the object diagrams {{used in the}} storyboards.Note, the <b>class</b> <b>diagram</b> serves as a common reference for all object diagrams. This ensures that overall the same types and attributes are used. Using a UML tool, you may generate a first implementation from this <b>class</b> <b>diagram.</b>|$|E
50|$|An Executable UML <b>class</b> <b>diagram</b> {{is meant}} to expose {{information}} about the domain. Too much complexity in the statechart diagrams is a good indicator that the <b>class</b> <b>diagram</b> should be reworked.|$|E
40|$|Visualization of {{object-oriented}} {{programs by}} <b>class</b> <b>diagrams</b> {{is a widely}} used technique. So far no commonly agreed aesthetic criteria have been recorded in order to standardize and measure the quality of <b>class</b> <b>diagrams.</b> In this paper we focus on UML <b>class</b> <b>diagrams,</b> the standard notation for <b>class</b> <b>diagrams</b> in software engineering. We propose some aesthetic criteria which reflect the highly sophisticated features of UML <b>class</b> <b>diagrams,</b> a layout algorithm which respects all these features and an implementation of a graph drawing framework which is able to produce drawings according to these criteria...|$|R
40|$|UML is {{the most}} widely {{accepted}} formalism for the analysis and design of software {{and one of its}} most important components are UML <b>class</b> <b>diagrams.</b> In this paper we discuss how to encode UML <b>class</b> <b>diagrams</b> in the Description Logics DLR ifd and ALCQI: the rst fully captures the semantics of UML <b>class</b> <b>diagrams,</b> while the second is directly supported by state-of-the-art DL reasoning systems. We also show some results obtained by reasoning on UML <b>class</b> <b>diagrams</b> of industrial interest...|$|R
40|$|The {{trend towards}} {{the use of}} {{object-oriented}} methods for software systems development has made it necessary {{for the use of}} object-oriented approaches in object-oriented software systems development. <b>Class</b> <b>diagrams</b> represent an essential component in any object-oriented system design. The development of such <b>class</b> <b>diagrams</b> in a systematic way is very crucial in an object-oriented development methodology. The main principles used in obtaining these <b>class</b> <b>diagrams</b> in a systematic way are described since <b>class</b> <b>diagrams</b> are very essential in object-oriented development practice...|$|R
5000|$|Navigable Association (<b>Class</b> <b>Diagram,</b> UseCase Diagram, Deployment Diagram) ...|$|E
5000|$|... #Caption: UML <b>class</b> <b>diagram</b> {{describing}} the prototype design pattern ...|$|E
5000|$|... #Caption: <b>Class</b> <b>diagram</b> {{example of}} {{association}} between two classes ...|$|E
5000|$|Story-driven {{modeling}} [...] is an Object-oriented modeling technique. Other {{forms of}} Object-oriented modeling focus on <b>class</b> <b>diagrams.</b> <b>Class</b> <b>diagrams</b> describe the static {{structure of a}} program, i.e. {{the building blocks of}} a program and how they relate to each other. <b>Class</b> <b>diagrams</b> also model data structures, but with an emphasis on rather abstract concepts like types and type features.|$|R
40|$|Developers use <b>class</b> <b>diagrams</b> to {{describe}} the architecture of their programs intensively. <b>Class</b> <b>diagrams</b> represent the structure and global behaviour of programs. They show the programs classes and interfaces and their relationships of inheritance, instantiation, use, association, aggregation and composition. <b>Class</b> <b>diagrams</b> could provide useful data during programs maintenance. However, they often are obsolete and imprecise: They {{do not reflect the}} real implementation and behaviour of programs. We propose a reverse-engineering tool suite, Ptidej, to build precise <b>class</b> <b>diagrams</b> from Java programs, with respect to their implementation and behaviour. We describe static and dynamic models of Java programs and algorithms to analyse these models and to build <b>class</b> <b>diagrams.</b> In particular, we detail algorithms to infer use, association, aggregation, and composition relationships, because these relationships do not have precise definitions. We show that <b>class</b> <b>diagrams</b> obtained semi-automatically are similar to those obtained manually and more precise than those provided usually...|$|R
30|$|Formalization of the {{prognosis}} objects and data. <b>Classes</b> <b>diagrams</b> are presented for prognosis data and objects {{based on the}} OSA-CBM standards [13]. This presentation is created using UML <b>classes</b> <b>diagram</b> representation.|$|R
5000|$|<b>Class</b> <b>diagram</b> (Object, Package, Subsystem and Robustness Diagrams are included) ...|$|E
50|$|NClass {{supports}} only <b>class</b> <b>diagram</b> of {{the standard}} UML diagram types.|$|E
5000|$|... #Caption: Hierarchy of UML 2.2 Diagrams, {{shown as}} a <b>class</b> <b>diagram</b> ...|$|E
40|$|Unified {{modelling}} language (UML) diagrams {{have become}} increasingly important in engineering and re-engineering processes for software systems. Of particular interest are UML <b>class</b> <b>diagrams</b> whose purpose is to display generalizations, associations, aggregations, and compositions in one picture. The combination of directed and undirected relations poses a special challenge to a graph layout tool. Current approaches for the automatic layout of <b>class</b> <b>diagrams</b> {{are based on the}} layered graph drawing paradigm. These algorithms produce good results for <b>class</b> <b>diagrams</b> with large and deep structural information, that is, diagrams with a large and deep inheritance hierarchy. However, they do not perform satisfactorily in absence of this information. We suggest to use the topology-shape-metrics paradigm for automatic layout of <b>class</b> <b>diagrams,</b> which has been used very successfully for drawing undirected graphs in orthogonal style. Moreover, we introduce the algorithms UML-Kandinsky and GoVisual fitting into this paradigm. Both algorithms work for <b>class</b> <b>diagrams</b> with rich structural information as well as for <b>class</b> <b>diagrams</b> with few or no structural information. Therefore, they improve the existing algorithms significantly...|$|R
40|$|UML <b>class</b> <b>diagrams</b> {{are helpful}} for {{understanding}} {{the structure of a}} software system. Algorithms and tools have been developed to generate UML <b>class</b> <b>diagrams</b> automatically for program understanding purposes. However, many tools often ignore perceptual factors in the layout of these diagrams. Therefore, users still have to spend much time and effort rearranging boxes and lines to make the diagram understandable. This paper presents key criteria and guidelines for the effective layout of UML <b>class</b> <b>diagrams</b> from the perspective of perceptual theories. Two UML tools have been analyzed and evaluated to illustrate how the criteria can be applied to improve the readability of <b>class</b> <b>diagrams...</b>|$|R
40|$|It {{is vital}} for any {{developer}} {{to keep track of}} changes during his project. Thus, it is common practice to take static snapshots of single <b>class</b> <b>diagrams.</b> But to preserve the mental map, the layout of a <b>class</b> <b>diagrams</b> sequence is necessary. Therefore, we present in this paper requirements to layout a sequence of <b>class</b> <b>diagrams</b> and an approach for a layout algorithm to fulfill them. Our main idea was to see a sequence of <b>class</b> <b>diagrams</b> as the evolution of one graph over time. We expressed the graph‘s evolution via a graph transformations sequence and enriched this with the concept of node aging. We extended also the well-known spring-embedder layout algorithm to layout single graphs from this new sequence with the concept of layout pattern to integrate apriori-knowledge. The resulting algorithm has been integrated into the AGG-Tool, an environment for Attributed Graph Grammars, and produced good results on various <b>class</b> <b>diagrams</b> and general graph grammars. 1...|$|R
5000|$|... #Caption: UML <b>Class</b> <b>diagram</b> {{showing an}} example of the Facade design pattern.|$|E
5000|$|... #Caption: A sample UML <b>class</b> <b>diagram</b> for the Factory Method design pattern.|$|E
5000|$|The <b>class</b> <b>diagram</b> {{defines the}} classes and class {{associations}} for the domain.|$|E
50|$|There are two model types {{supported}} by ECO: <b>class</b> <b>diagrams</b> and state <b>diagrams.</b> <b>Class</b> <b>diagrams</b> {{are used to}} define static description of a system. On the other hand, state diagrams describe possible states of an object and transitions between them. Thus state diagrams describe behavioral aspects of a system.|$|R
40|$|Abstract. UML <b>class</b> <b>diagrams,</b> internationally {{specified}} {{and widely}} used in software engineering, are a great challenge in automatic drawing of graphs. Due to the complex nature of UML <b>class</b> <b>diagrams</b> and the requirements of software engineers, who need to read these diagrams, layout rules and algorithms for general graphs can not be applied without adaptions, extensions and modifications. In this paper, we present layout rules, a hierarchical layout algorithm and an edge crossing reduction strategy tailored for UML <b>class</b> <b>diagrams.</b> Furthermore, the problem of measuring aesthetic quality is discussed. ...|$|R
40|$|Defining {{semantics}} for UML is {{a difficult}} task. Disagreements in the meaning of UML constructs {{as well as the}} size of UML are major obstacles. In this report, we describe our approach to define the semantics for UML. Semantics is defined denotationally as a mapping into our semantics domain called the system model [4, 5, 6]. We demonstrate our approach by defining the semantics for a comprehensive version of <b>class</b> <b>diagrams.</b> The semantics definition is detailed for UML/P <b>class</b> <b>diagrams,</b> a variant of <b>class</b> <b>diagrams</b> which restricts the use of a few methodologically and semantically involved concepts. <b>Class</b> <b>diagrams</b> are well-known and rather easy to understand and thus perfect to examine the usability of the system model for precise semantic mappings. Comment: 32 pages, Informatik-Bericht 2008 - 05 Technische Universität Braunschweig, Carl-Friedrich-Gauss-Fakultät, 200...|$|R
5000|$|Defining objects, {{creating}} <b>class</b> <b>diagram</b> from conceptual diagram: Usually map entity to class.|$|E
5000|$|The {{following}} diagram {{displays a}} <b>class</b> <b>diagram</b> for segmental morphemes incorporating a Komo verb: ...|$|E
5000|$|Class diagram: A <b>class</b> <b>diagram</b> {{is a type}} {{of static}} {{structure}} UML diagram that describes the structure of a system by showing the system's classes, their attributes, and the relationships between the classes. The messages and classes identified through the development of the sequence diagrams can serve as input to the automatic generation of the global <b>class</b> <b>diagram</b> of the system.|$|E
40|$|In {{this paper}} we study how {{automated}} reasoning systems based on Description Logics (DLs) {{can be used}} for reasoning about UML <b>class</b> <b>diagrams.</b> The ability of reasoning automatically on UML <b>class</b> <b>diagrams</b> makes it possible to provide computer aided support during the application design phase in order to automatically detect relevant properties, such as inconsistencies and redundancies. We show that UML <b>class</b> <b>diagrams</b> can be formalized as knowledge bases expressed in the DL DLR. DLR knowledge bases can be translated into knowledge bases expressed in the variants of ALCQI accepted by state-of-the-art DL-based systems. Hence, in principle, the reasoning capabilities of such systems can be used to reason on UML <b>class</b> <b>diagrams.</b> However, we report some experiments indicating that state-of-the-art systems have still difficulty in dealing with the resulting knowledge bases...|$|R
40|$|UML (Unified Modeling Language) <b>class</b> <b>diagrams,</b> {{which are}} widely used for specifying aspects of {{object-oriented}} software systems, can be laid out by our tool SugiBib. In 1998 J. Seemann described how to apply the Sugiyama algorithm to <b>class</b> <b>diagrams</b> and {{the first version of}} SugiBib was implemented as a masters thesis...|$|R
40|$|Abstract: With {{the launch}} of Visual Studio 2005, {{developers}} got a modelling tool which produces <b>class</b> <b>diagrams</b> from the code or generates code from diagrams. At first sight it hardly varies from UML <b>class</b> <b>diagrams.</b> Besides presenting <b>Class</b> Designer I will show that this difference stems from different software development strategies...|$|R
