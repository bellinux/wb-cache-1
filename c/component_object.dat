354|1012|Public
5|$|While Microsoft largely {{failed to}} {{participate}} in the rise of the Internet in the early 1990s, some of the key technologies in which the company had invested to enter the Internet market started to pay off by the mid-90s. One of the most prominent of these was ActiveX, an application programming interface built on the Microsoft <b>Component</b> <b>Object</b> Model (COM); this enabled Microsoft and others to embed controls in many programming languages, including the company's own scripting languages, such as JScript and VBScript. ActiveX included frameworks for documents and server solutions. The company also released the Microsoft SQL Server 6.5, which had built-in support for internet applications. Later in 1997, Microsoft Office 97 as well as Internet Explorer 4.0 were released, marking the beginning of the takeover of the browser market from rival Netscape, and by agreement with Apple Computer, Internet Explorer was bundled with the Apple Macintosh operating system as well as with Windows. Windows CE 2.0, the handheld version of Windows, was released this year, including a host of bug fixes and new features designed to make it more appealing to corporate customers. In October, the Justice Department filed a motion in the federal district court in which they stated that Microsoft had violated an agreement signed in 1994, and asked the court to stop the bundling of Internet Explorer with Windows.|$|E
25|$|OLE 1.0 later {{evolved to}} become an {{architecture}} for software components known as the <b>Component</b> <b>Object</b> Model (COM), and later DCOM.|$|E
25|$|OLE {{objects and}} {{containers}} are implemented {{on top of}} the <b>Component</b> <b>Object</b> Model; they are objects that can implement interfaces to export their functionality. Only the IOleObject interface is compulsory, but other interfaces may also need to be implemented if the functionality exported by those interfaces is required.|$|E
40|$|This article {{introduces}} {{the concept of}} combining both form (CAD models) and behavior (simulation models) of mechatronic system <b>components</b> into <b>component</b> <b>objects.</b> By composing these <b>component</b> <b>objects,</b> designers automatically create a virtual prototype of the system they are designing. This virtual prototype, in turn, can provide immediate feedback about design decisions by evaluating whether the functional requirements are met in simulation. To achieve the composition of behavioral models, we introduce a port-based modeling paradigm where systems consist of <b>component</b> <b>objects</b> and interactions between <b>component</b> <b>objects.</b> To maintain the consistency between the form and behavior of <b>component</b> <b>objects,</b> we introduce parametric relations between these two descriptions. In addition, we develop algorithms that determine the type and parameter values of the interaction models; these models depend on the form of both components that are interacting. The composable simulation environment has been implemented as a distributed system in Java and C++, enabling multiple users to collaborate {{on the design of}} a single system...|$|R
40|$|This {{paper was}} {{presented}} at the 2000 IEEE/ACM International Workshop on Behavioral Modeling and Simulation, Orlando, FL, 19 - 20 October. The definitive paper is located at [URL] (DOI: 10. 1109 /BMAS. 2000. 888361). © IEEEThis article introduces the concept of combining both form (CAD models) and behavior (simulation models) of mechatronic system <b>components</b> into <b>component</b> <b>objects.</b> By composing these <b>component</b> <b>objects,</b> designers automatically create a virtual prototype of the system they are designing. This virtual prototype, in turn, can provide immediate feedback about design decisions by evaluating whether the functional requirements are met in simulation. To achieve the composition of behavioral models, we introduce a port-based modeling paradigm where systems consist of <b>component</b> <b>objects</b> and interactions between <b>component</b> <b>objects.</b> To maintain the consistency between the form and behavior of <b>component</b> <b>objects,</b> we introduce parametric relations between these two descriptions. In addition, we develop algorithms that determine the type and parameter values of the interaction models; these models depend on the form of both components that are interacting. The composable simulation environment has been implemented as a distributed system in Java and C++, enabling multiple users to collaborate on the design of a single system...|$|R
50|$|The SK8 system {{includes}} the object system, the graphics and <b>component</b> <b>objects,</b> the SK8Script language, and the Project Builder environment.|$|R
25|$|OLE 2.0 was {{the next}} {{evolution}} of OLE, sharing {{many of the same}} goals as version 1.0, but was re-implemented on top of the <b>Component</b> <b>Object</b> Model (COM) instead of using VTBLs directly. New features were OLE automation, drag-and-drop, in-place activation and structured storage. Monikers evolved from OLE 1 object names, and provided a hierarchical object and resource naming system similar to URLs or URIs, which were independently invented. Windows now has merged the two technologies supporting a URL Moniker type, and a Moniker URL scheme.|$|E
25|$|Background Intelligent Transfer Service (BITS) is a {{component}} of Microsoft Windows 2000 and later iterations of the operating systems, which facilitates asynchronous, prioritized, and throttled transfer of files between machines using idle network bandwidth. It is most commonly used by recent versions of Windows Update, Microsoft Update, Windows Server Update Services, and System Center Configuration Manager to deliver software updates to clients, Microsoft's anti-virus scanner Microsoft Security Essentials (a later version of Windows Defender) to fetch signature updates, and is also used by Microsoft's instant messaging products to transfer files. BITS is exposed through the <b>Component</b> <b>Object</b> Model (COM).|$|E
25|$|Internet Explorer exposes {{a set of}} <b>Component</b> <b>Object</b> Model (COM) {{interfaces}} {{that allows}} add-ons to extend the functionality of the browser. Extensibility {{is divided into two}} types: Browser extensibility and content extensibility. Browser extensibility involves adding context menu entries, toolbars, menu items or Browser Helper Objects (BHO). BHOs are used to extend the feature set of the browser, whereas the other extensibility options are used to expose that feature in the user interface. Content extensibility adds support for non-native content formats. It allows Internet Explorer to handle new file formats and new protocols, e.g. WebM or SPDY. In addition, web pages can integrate widgets known as ActiveX controls which run on Windows only but have vast potentials to extend the content capabilities; Adobe Flash Player and Microsoft Silverlight are examples. Add-ons can be installed either locally, or directly by a web site.|$|E
50|$|Within that year, she {{was able}} to create new art using the new <b>components,</b> <b>objects</b> and {{compositions}} - inspired by the German environment.|$|R
30|$|In {{the third}} phase, {{foreground}} object segmentation, the foreground pixels are grouped into objects, by applying morphological operators {{to filter out}} scattered error points and then finding the connected <b>components.</b> <b>Objects</b> whose pixel count is under a threshold are discarded.|$|R
5000|$|If {{the larger}} object is being stored {{in an area}} with limited space, such as the stack, then we can prevent running out of storage by storing large <b>component</b> <b>objects</b> in another memory region and {{referring}} to them using references.|$|R
2500|$|Internet Explorer uses a componentized {{architecture}} {{built on}} the <b>Component</b> <b>Object</b> Model (COM) technology. It consists of several major components, {{each of which is}} contained in a separate Dynamic-link library (DLL) and exposes a set of COM programming interfaces hosted by the Internet Explorer main executable, iexplore.exe: ...|$|E
2500|$|Because {{computer}} systems commonly require interaction between newer and older applications, [...]NET Framework provides means to access functions implemented in newer and older programs that execute outside [...]NET environment. Access to <b>Component</b> <b>Object</b> Model (COM) components {{is provided in}} System.Runtime.InteropServices and System.EnterpriseServices namespaces of the framework. Access to other functions is via Platform Invocation Services (P/Invoke). Access to [...]NET functions from native applications is via reverse P/Invoke function.|$|E
2500|$|A UMDF Driver is a DLL {{based on}} Microsoft's <b>Component</b> <b>Object</b> Model (COM). [...] However, UMDF {{does not use}} COM for loading, unloading, or {{controlling}} concurrency; it only uses COM as a programming pattern, for example exploiting COM's IUnknown interface. At startup, UMDF calls DllGetClassObject to get a pointer to an IClassFactory interface in the driver and then uses the CreateInstance method of the IClassFactory interface to create an instance of the driver callback object.|$|E
50|$|An object has an identity. In general two {{objects with}} {{identical}} properties, other than position at an instance in time, may be distinguished as two objects {{and may not}} occupy the same space {{at the same time}} (excluding <b>component</b> <b>objects).</b> An object's identity may be tracked using the continuity of the change in its boundary over time. The identity of objects allows objects to be arranged in sets and counted.|$|R
40|$|We {{present a}} {{simulation}} and design framework for simultaneously designing and modeling electromechanical systems. By instantiating <b>component</b> <b>objects</b> and connecting them {{to each other}} via ports, a designer can configure complex systems. This configuration information is then used to automatically generate a corresponding system-level simulation model...|$|R
40|$|This article {{introduces}} {{the concept of}} combining both form (CAD models) and behavior (simulation models) of mechatronic system <b>components</b> into <b>component</b> <b>objects.</b> By composing these <b>component</b> <b>objects,</b> designers automatically create a virtual prototype of the system they are designing. This virtual prototype, in turn, can provide immediate feedback about design decisions by evaluating whether the functional requirements are met in simulation. To achieve the composition of behavioral models, we introduce a port-based modeling paradigm in which components interactions are defined by connections between ports. The port-based models are reconfigurable, so that the same physical component can be simulated at multiple levels of detail without having to modify the system-level model description. This allows the virtual prototype to evolve during the design process and to achieve the accuracy required for the simulation experiments at each design stage. To maintain the consistency between the [...] ...|$|R
2500|$|For {{some time}} object {{libraries}} held {{the status of}} the [...] "next big thing" [...] in the programming world. There were a number of efforts to create systems that would run across platforms, and companies competed to try to get developers locked into their own system. Examples include IBM's System Object Model (SOM/DSOM), Sun Microsystems' Distributed Objects Everywhere (DOE), NeXT's Portable Distributed Objects (PDO), Digital's ObjectBroker, Microsoft's <b>Component</b> <b>Object</b> Model (COM/DCOM), and any number of CORBA-based systems.|$|E
2500|$|The Windows API is {{designed}} mostly for {{the interaction between}} the operating system and an application. For communication among different Windows applications, Microsoft has developed a series of technologies alongside the main Windows API. This started out with Dynamic Data Exchange (DDE), which was superseded by Object Linking and Embedding (OLE) and later by the <b>Component</b> <b>Object</b> Model (COM), Automation Objects, ActiveX controls, and the [...]NET Framework. There is not always a clear distinction between these technologies, and there is much overlap.|$|E
2500|$|DirectShow (sometimes {{abbreviated}} as DS or DShow), codename Quartz, is {{a multimedia}} framework and API produced by Microsoft for software developers to perform various operations with media files or streams. It is the replacement for Microsoft's earlier Video for Windows technology. [...] Based on the Microsoft Windows <b>Component</b> <b>Object</b> Model (COM) framework, DirectShow provides a common interface for media across various programming languages, {{and is an}} extensible, filter-based framework that can render or record media files on demand {{at the request of}} the user or developer. The DirectShow development tools and documentation were originally distributed as part of the DirectX SDK. Currently, they are distributed as part of the Windows SDK (formerly known as the Platform SDK).|$|E
40|$|The {{software}} world – <b>components,</b> <b>objects,</b> languages Aspects in {{the software}} world – the need for aspects – what are aspects – when to use them – {{how to work with}} aspects • implementation techniques available tools The impact of aspects – throughout a components lifetime – community-specific adaptations Outline – application-aware environments (or contexts...|$|R
40|$|Component-based {{software}} engineering means constructing new systems from already existing, service-providing components. Object-based {{software engineering}} means constructing {{a new system}} in terms of interacting, distinct units of information and services called <b>objects.</b> Both <b>components</b> and <b>objects</b> have encapsulation properties and are accessed via well-de ned interfaces. Both <b>components</b> and <b>objects</b> are considered to improve the reuse of software and to alleviate its evolution phase. Finally, both notions are thought of being natural abstractions of real-world entities. Moreover, a real-world entity can be modelled or implemented using either notion. Their similar appearance in abstract modelling gives rise to confusion in distinguishing between these two notions. In this paper we examine the conceptual di erence between <b>components</b> and <b>objects,</b> and aim at clarifying it. Based on this, we also propose a guideline for a software engineering process that incorporates both notions and exploits <b>components</b> and <b>objects</b> at their real potential...|$|R
40|$|In {{this thesis}} I {{introduce}} visual phrases, complex visual composites like “a person riding a horse”. Visual phrases often display significantly reduced visual complexity {{compared to their}} <b>component</b> <b>objects,</b> because the ap-pearance of those objects can change profoundly when they participate in relations. I introduce a dataset suitable for phrasal recognition that uses fa-miliar PASCAL object categories, and demonstrate significant experimental gains resulting from exploiting visual phrases. I show that a visual phrase detector significantly outperforms a baseline which detects <b>component</b> <b>objects</b> and reasons about relations, even though visual phrase training sets tend to be smaller than those for objects. I ar-gue that any multi-class detection system must decode detector outputs to produce final results; this is usually done with non-maximum suppression. I describe a novel decoding procedure that can account accurately for local context without solving difficult inference problems. I show this decodin...|$|R
2500|$|OLE DB (also called OLEDB or OLE-DB) allows MDAC {{applications}} {{access to}} {{different types of}} (...) stores in a uniform manner. Microsoft has used this technology to separate the application from data can store in the website the data store {{that it needs to}} access. This was done because different applications need access to different types and sources of data, and do not necessarily {{need to know how to}} access technology-specific functionality. The technology is conceptually divided into consumers and providers. The consumers are the applications that need access to the data, and the provider is the software component that exposes an OLE DB interface through the use of the <b>Component</b> <b>Object</b> Model (or COM).|$|E
5000|$|Microsoft Interface Definition Language (MIDL): the Microsoft {{extension}} of OMG IDL to add support for <b>Component</b> <b>Object</b> Model (COM) and Distributed <b>Component</b> <b>Object</b> Model (DCOM) ...|$|E
50|$|Aggregation {{is a kind}} of {{association}} that specifies a whole/part relationship between the aggregate (whole) and component part. This relationship between the aggregate and component is a weak “has a” relationship, as the component may survive the aggregate object. The <b>component</b> <b>object</b> may be accessed through other objects without going through the aggregate object. The aggregate object does not take part in the lifecycle of the <b>component</b> <b>object,</b> meaning the <b>component</b> <b>object</b> may outlive the aggregate object. The state of the <b>component</b> <b>object</b> still forms part of the aggregate object.|$|E
40|$|This article {{introduces}} {{the concept of}} combining both form (CAD models) and behavior (simulation models) of mechatronic system <b>components</b> into <b>component</b> <b>objects.</b> By connecting these <b>component</b> <b>objects</b> to each other through their ports, designers can create both a systemlevel design description and a virtual prototype of the system. This virtual prototype, in turn, can provide immediate feedback about design decisions by evaluating whether the functional requirements are met in simulation. To achieve the composition of behavioral models, we introduce a port-based modeling paradigm. The port-based models are reconfigurable, so that the same physical component can be simulated at multiple levels of detail without having to modify the system-level model description. This allows the virtual prototype to evolve during the design process and to achieve the accuracy required for the simulation experiments at each design stage. To maintain the consistency between the form and behavior of compone [...] ...|$|R
40|$|We specify an {{abstract}} model for dynamic {{distributed control systems}} in which the <b>component</b> <b>objects</b> make local decisions based on system-wide constraints and approximate global state. We focus {{on the issue of}} distributed resource management, exploring a solution that is both compositional and scalable because it builds global events into the Java infrastructure by exploiting its multicast facilities. 1 Introduction A distributed control system consists of interacting <b>component</b> <b>objects,</b> each of which have persistent local state and one or more threads of control. Abstractly, a simple specification of a distributed control system consists of the descriptions of several components: state, computation, events, and constraints. State. The state of a distributed system is defined in terms of its components. In our context, the components are the system's participating objects, as well as the communication infrastructure itself. The objects are persistent, communicate with other objects, an [...] ...|$|R
40|$|Aggregation and {{containment}} {{are important}} concepts in object-oriented modeling. In component-based approaches to software development, aggregation and containment are touted {{as one of}} the primary mechanisms for component reuse. Containment relationships are typically implemented with object references in most object-oriented programming languages. This encourages sharing of <b>component</b> <b>objects</b> between aggregates, but does not yield faithful representations of the containment relationships...|$|R
5000|$|Microsoft's ActiveX, <b>Component</b> <b>Object</b> Model (COM), Microsoft Transaction Server (COM+), Distributed <b>Component</b> <b>Object</b> Model (DCOM), Dynamic Data Exchange (DDE), Object Linking and Embedding (OLE), {{anonymous}} pipes, named pipes, Local Procedure Call, MailSlots, Message loop, MSRPC, [...]NET Remoting, and Windows Communication Foundation (WCF) ...|$|E
5000|$|XPCOM Mozilla {{applications}} cross-platform <b>Component</b> <b>Object</b> Model ...|$|E
5000|$|Distributed <b>Component</b> <b>Object</b> Model (DCOM) - Microsoft, inter-language ...|$|E
40|$|Abstract—We {{build on}} recent fast and {{accurate}} 3 -D re-construction techniques to segment objects during scene re-construction. We take object outline information from change detection to build 3 -D models of rigid objects {{and represent the}} scene as static and dynamic <b>components.</b> <b>Object</b> models are updated online during mapping, and can integrate segmentation information from sources other than change detection. I...|$|R
50|$|An {{alternative}} layering from Bieberstein et al., involves five layers, namely enterprise, process, service, <b>component</b> and <b>object.</b>|$|R
40|$|Object-oriented {{conceptual}} models {{strive to}} capture more semantics {{in order to}} better represent requirements of real-world applications. Aggregation is a powerful construct for semantic modeling. Intuitively, it relates a composite <b>object</b> to its <b>component</b> <b>objects.</b> This paper presents a new version of aggregation, with a generalized version of cardinality constraints and a new subcategorization of part relationships, with an associated transitivity rule. An implementation in C++ is also presented...|$|R
