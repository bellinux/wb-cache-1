3|94|Public
40|$|International audienceThis paper {{introduces}} a new method to reduce in-use energy consumption of electr(on) ic equipment {{from the earliest}} design stage {{to the beginning of}} manufacturing stage. This method is based on 3 main tools which are energy indicator, guidelines and an environmental <b>checking</b> <b>loop.</b> The following paper is focused on a presentation of each tool and how it is used by two industrial partners, NEOPOST and SAGEMCOM...|$|E
40|$|There {{are various}} {{techniques}} for speech watermarking based on modifying the linear prediction coefficients (LPCs); however, the estimated and modified LPCs vary {{from each other}} even without attacks. Because line spectral frequency (LSF) has less sensitivity to watermarking than LPC, watermark bits are embedded into {{the maximum number of}} LSFs by applying the least significant bit replacement (LSBR) method. To reduce the differences between estimated and modified LPCs, a <b>checking</b> <b>loop</b> is added to minimize the watermark extraction error. Experimental results show that the proposed semifragile speech watermarking method can provide high imperceptibility and that any manipulation of the watermark signal destroys the watermark bits since manipulation changes it to a random stream of bits...|$|E
40|$|Processors for trigger {{calculations}} and data compression in high energy physics {{are characterized by}} a high data input capability combined with fast execution of relatively simple routines. In order to achieve the required performance it is advantageous to replace the classical computer instruction-set by microcoded instructions, the various fields of which control the internal subunits in parallel. The fast processor called ESOP is based on such a principle: the different operations are handled step by step by dedicated optimized modules under control of a central instruction unit. Thus, the arithmetic operations, address calculations, conditional <b>checking,</b> <b>loop</b> counts and next instruction evaluation all overlap in time. Based upon the experience from ESOP the architecture of a new processor "XOP" is beginning to take shape which will be faster and easier to use. In this context the most important innovations are: easy handling of operands in the arithmetic unit by means of three data buses and large data files, a powerful data addressing unit for easy handling of vectors, as well as single operands, and a very flexible logic for conditional branching. Input/Output will be made transparent through the introduction of internal fast processors, which {{will be used in}} conjunction with powerful firmware as a software debugging aid...|$|E
50|$|Roundabout is an {{acoustic}} instrumental album by the guitarist Phil Keaggy, released in July 2006. The songs were compiled from sound <b>check</b> <b>loops</b> of guitar improvisations recorded before his concerts.|$|R
40|$|AbstractIn the {{framework}} of Lloyd and Shepherdson [16], partial deduction involves the creation of SLDNF-trees for a given program and some goals up to certain halting points. This paper identifies the relation between halting criteria for partial deduction and <b>loop</b> <b>checking</b> (as formalized in [1]). For simplicity, we consider only positive programs and SLD-resolution here. It appears that <b>loop</b> <b>checks</b> for partial deduction must be complete, whereas traditionally, the soundness of a <b>loop</b> <b>check</b> is more important. However, it is also shown that sound <b>loop</b> <b>checks</b> can contribute to improve partial deduction. Finally, a class of complete <b>loop</b> <b>checks</b> suitable for partial deduction is identified...|$|R
40|$|AbstractLoop {{checking}} is {{a mechanism}} for pruning infinite SLD-derivations. In (Bol, Apt and Klop, 1991) simple <b>loop</b> <b>checks</b> were introduced and their soundness, completeness and relative strength was studied. Since no sound and complete simple <b>loop</b> <b>check</b> exists {{even in the absence}} of function symbols, subclasses of programs were determined for which the (sound) <b>loop</b> <b>checks</b> introduced by Bol are complete. In this paper, the Generalization Theorem is proved. This theorem presents a method to extend (under certain conditions) a class of programs for which a given <b>loop</b> <b>check</b> is complete to a larger class, for which the <b>loop</b> <b>check</b> is still complete. Then this theorem is applied to the results of Bol, giving rise to stronger completeness theorems. It appears that unnecessary complications in the proof of the theorem can be avoided by introducing a normal form for SLD-derivations, allowing only certain most general unifiers. This normal form might have other applications than those in the area of <b>loop</b> <b>checking...</b>|$|R
40|$|AbstractWe {{systematically}} study <b>loop</b> <b>checking</b> {{mechanisms for}} logic programs by considering their soundness, completeness, relative strength and related concepts. We introduce a natural {{concept of a}} simple <b>loop</b> <b>check</b> and prove that no sound and complete simple <b>loop</b> <b>check</b> exists, even for programs without function symbols. Then we introduce a number of sound simple <b>loop</b> <b>checks</b> and identify natural classes of Prolog programs without function symbols {{for which they are}} complete. In these classes a limited form of recursion is allowed. As a by-product we obtain an implementation of the closed world assumption of Reiter (1978) and a query evaluation algorithm for these classes of logic programs...|$|R
40|$|Description Logic (DL) formalisms {{have gained}} success in many {{application}} areas such as knowledge representation, database reasoning, multi-agent systems, semantic web, and ontology reasoning. The most explored reasoning approach for DLs is the tableau approach. Existing tableau-based DL systems essentially exploit the various kinds of the tree-model properties of DLs. It is known that the (standard) <b>loop</b> <b>checking</b> procedure is avoidable only in tableau algorithms for inexpressive DLs. <b>Loop</b> <b>checking</b> mechanisms are vital for logics with universal modalities, TBox reasoning, and/or transitive roles. However, the standard <b>loop</b> <b>checking</b> rule has various disadvantages. From a practical perspective implementation in a DL prover usually requires quite considerable effort. The standard <b>loop</b> <b>checking</b> mechanism is very sensitive to a notion of a finite type in a particular DL. Since {{the notion of a}} type varies from one logic to another, small changes {{in the language of the}} underlying DL and/or in the tableau procedure can force considerable redesign and refactoring of the code related to the <b>loop</b> <b>checking.</b> In this paper we propose and study alternative <b>loop</b> <b>checking</b> mechanisms. Our facilitation of <b>loop</b> <b>checking</b> uses inference rules which while being simple are also more general than standard <b>loop</b> <b>checking</b> mechanisms implemented in DL systems and remedy the mentioned problems. We focus on the description logic ALCIO(U). This is an extension of the basic DL ALC with inverse operator on roles, nominals (or objects/ABox elements) and the top role. As the language includes nominals and the universal modality, concept satisfiability with respect to (non-empty) TBox and (non-empty) ABox can be reduced to plain concep...|$|R
40|$|AbstractLoop {{checking}} {{mechanisms are}} used to detect and prune infinite SLD derivations, through run time checks which are introduced in logic program interpreters. Simple <b>loop</b> <b>checks,</b> i. e. checks which do {{not depend on the}} specific logic program, have been widely studied in literature. Since no sound and complete <b>loop</b> <b>check</b> exists even in the case of function-free programs, several subclasses have been characterized for which sound and complete <b>loop</b> <b>checks</b> can be determined. In this paper a theoretical framework for analysing properties of <b>loop</b> <b>check</b> mechanisms for logic programs is proposed, which exploits general mathematical results about well-quasi-ordered (wqo) sets. In a way, the method {{can be viewed as a}} counterpart of well known techniques based on well-founded partial-ordering, used in termination proofs for rewriting systems and for logic programs. The main results are obtained on the basis of a combinatorial analysis of properties of wqo sets of goals. As shown in the paper, subclasses of programs, for which sound and complete simple <b>loop</b> <b>checks</b> exist, can be easily framed in the wqo approach. Reasons for the different behaviours of subsumption <b>loop</b> <b>checks</b> based on list and multiset goal comparisons are also plainly highlighted...|$|R
40|$|Two {{complete}} <b>loop</b> <b>checking</b> mechanisms {{have been}} presented in the literature for logic programs with functions: OS-check and EVA-check. OS-check is computationally ecient but quite unreliable in that it often mis-identies innite loops, whereas EVA-check is reliable {{for a majority of}} cases but quite expensive. In this paper, we develop a series of new complete <b>loop</b> <b>checking</b> mechanisms, called VAF-checks. The key technique we introduce is the notion of expanded variants, which captures a key structural characteristic of innite loops. We show that our approach is superior to both OS-check and EVA-check in that it is as ecient as OS-check and as reliable as EVA-check. Keywords: <b>Loop</b> <b>checking,</b> logic programming. ...|$|R
40|$|Most of the sequent/tableau based proof {{systems for}} the modal logic S 4 need to {{duplicate}} formulas and thus are required to adopt some method of <b>loop</b> <b>checking</b> [7, 13, 10]. In what follows we present a tableau-like proof system for S 4, based on D’Agostino and Mondadori’s classical KE [3], which is free of duplication and <b>loop</b> <b>checking.</b> The ke...|$|R
30|$|While CEP {{provides}} several {{benefits for}} data stream processing, such as continuous query, pattern detection, and temporal windows, {{it is difficult}} to express iterative controls, e.g., while and for repetition structures, using its primitives. Typically, CEP-based applications follow a pipeline stage topology, with data flow in a given direction from one stage to one or more stages, but without returning to previous stages. This can be troublesome when describing iterative algorithms, such as K-means, which require iterations to converge. To overcome this problem, we simulated the <b>loop</b> <b>check</b> by using two EPL rules. If the <b>loop</b> <b>check</b> is false, i.e., if evidence has not change its centroid, we push the event to the next processing stages. However, if the <b>loop</b> <b>check</b> is true, i.e., evidence has changed its centroid, we reinsert these events into the initial loop stage, which recomputes the centroid distance. We do so by translating the events to EvidenceStreamEvents, the event type that the initial loop phase (distance computation) expects.|$|R
5000|$|... memcpy -- Copy a {{block of}} memory from one {{location}} to another. Called as a subroutine, note return to saved PC addr on exit Entry parameters cnt - Number of bytes to copy src - Address of source data block dst - Address of target data block cnt dw $0000 sets aside space for memory addr src dw $0000 sets aside space for memory addr dst dw $0000 sets aside space for memory addr memcpy public ldab cnt+1Set B = cnt.L beq checkIf cnt.L=0, goto <b>check</b> <b>loop</b> ldx srcSet IX = src ldaa ixLoad A from (src) inxSet src = src+1 stx src ldx dstSet IX = dst staa ixStore A to (dst) inxSet dst = dst+1 stx dst decbDecr B bne loopRepeat the loop stab cnt+1Set cnt.L = 0 check tst cnt+0If cnt.H=0, beq doneThen quit dec cnt+0Decr cnt.H loop back and do 256*(cnt.H+1) more copies (B=0) [...] bra loopRepeat the loop done rtsReturn ...|$|R
40|$|In nite {{loops and}} {{redundant}} computations are long recognized open problems in Prolog. Two ways have been explored {{to resolve these}} problems: <b>loop</b> <b>checking</b> and tabling. <b>Loop</b> <b>checking</b> can cut innite loops, but it cannot be both sound and complete even for function-free logic programs. Tabling {{seems to be an}} eective way to resolve in-nite loops and redundant computations. However, existing tabulated resolutions, such as OLDT-resolution, SLG-resolution, and Tabulated SLS-resolution, are non-linear because they rely on the solution-lookup mode in formulating tabling. The principal disadvantage of non-linear resolutions is that they cannot be implemented using a simple stack-based memory structure like that in Prolog. Moreover, some strictly sequential operators such as cuts may not be handled as easily as in Prolog. In this paper, we propose a hybrid method to resolve innite loops and redundant computations. We combine the ideas of <b>loop</b> <b>checking</b> and tabling to establish a linear tabulated resolution called TP-resolution. TP-resolution has two distinctive features: (1) It makes linear tabulated derivations {{in the same way as}} Prolog except that innite loops are broken and redundant computations are reduced. It handles cuts as eectively as Prolog. (2) It is sound and complete for positive logic programs with the bounded-term-size property. The underlying algorithm can be implemented by an extension to any existing Prolog abstract machines such as WAM or ATOAM...|$|R
40|$|AbstractIn a {{communication}} system, we consider two models of error control policies to transmit data more accurately: Model 1 {{is a double}} transfer checking policy which sends two data, and Model 2 is a <b>loop</b> <b>checking</b> policy which sends back data. For two models, the transmission fails with probability qj at its number j and stops at a maximum number N. The expected cost rates are derived and optimal numbers N∗ to minimize them are discussed. We compare two costs and show that a double transfer checking {{is better than a}} <b>loop</b> <b>checking</b> under some reasonable conditions...|$|R
50|$|In {{computer}} telecommunications, echo is {{the display}} or return of sent data at {{or to the}} sending end of a transmission. Echo can be either local echo, where the sending device itself displays the sent data, or remote echo, where the receiving device returns the sent data that it receives to the sender (which is of course simply no local echo {{from the point of}} view of the sending device itself). That latter, when used as a form of error detection to determine that data received at the remote end of a communications line are the same as data sent, is also known as echoplex, echo <b>check,</b> or <b>loop</b> <b>check.</b> When two modems are communicating in echoplex mode, for example, the remote modem echoes whatever it receives from the local modem.|$|R
40|$|Infinite {{loops and}} {{redundant}} computations are long recognized open problems in Prolog. Two ways have been explored {{to resolve these}} problems: <b>loop</b> <b>checking</b> and tabling. <b>Loop</b> <b>checking</b> can cut infinite loops, but it cannot be both sound and complete even for function-free logic programs. Tabling {{seems to be an}} effective way to resolve infinite loops and redundant computations. However, existing tabulated resolutions, such as OLDT-resolution, SLG- resolution, and Tabulated SLS-resolution, are non-linear because they rely on the solution-lookup mode in formulating tabling. The principal disadvantage of non-linear resolutions is that they cannot be implemented using a simple stack-based memory structure like that in Prolog. Moreover, some strictly sequential operators such as cuts may not be handled as easily as in Prolog. In this paper, we propose a hybrid method to resolve infinite loops and redundant computations. We combine the ideas of <b>loop</b> <b>checking</b> and tabling to establish a linear tabulated resolution called TP-resolution. TP-resolution has two distinctive features: (1) It makes linear tabulated derivations {{in the same way as}} Prolog except that infinite loops are broken and redundant computations are reduced. It handles cuts as effectively as Prolog. (2) It is sound and complete for positive logic programs with the bounded-term-size property. The underlying algorithm can be implemented by an extension to any existing Prolog abstract machines such as WAM or ATOAM. Comment: To appear as the first accepted paper in Theory and Practice of Logic Programming ([URL]...|$|R
40|$|AbstractA simple {{analysis}} of the arguments developed by Bol et al. (Theoret. Comput. Sci. 86, 35 - 79 (1991)) shows that an actual reason for the nonexistence of a complete sound simple check for all function-free programs is the presence in the resolvents of potentially unlimited sequences of atoms chained by common variables. This hints that a limitation {{of the number of}} variables generating this kind of chain could guarantee the applicability of complete simple <b>loop</b> <b>checks.</b> This line is followed in the paper, and quite general classes of logic programs are characterized, without any direct imposition on the structures of the rules. This objective is accomplished by exploiting a variant of SLD-resolution, which is able to perform a systematic elimination of redundant atoms from resolvents. As a notable result, {{it turns out that the}} equality <b>loop</b> <b>check</b> is complete for our class of logic programs. This seems to suggest that the necessity of using subsumption <b>loop</b> <b>checks</b> instead of equality checks is essentially due to the presence of redundant atoms in resolvents...|$|R
40|$|AbstractTwo {{complete}} <b>loop</b> <b>checking</b> mechanisms {{have been}} presented in the literature for logic programs with functions: OS-check and EVA-check. OS-check is computationally efficient but quite unreliable in that it often mis-identifies infinite loops, whereas EVA-check is reliable {{for a majority of}} cases but quite expensive. In this paper, we develop a series of new complete <b>loop</b> <b>checking</b> mechanisms, called VAF-checks. The key technique we introduce is the notion of expanded variants, which captures a key structural characteristic of infinite loops. We show that our approach is superior to both OS-check and EVA-check in that it is as efficient as OS-check and as reliable as EVA-check...|$|R
5000|$|The inner <b>loop</b> <b>checks</b> {{every point}} in the set S, and the outer loop repeats for each point on the hull. Hence the total run time is [...] The run time depends {{on the size of}} the output, so Jarvis's march is an output-sensitive algorithm.|$|R
40|$|AbstractIn {{this paper}} we extend {{the concept of}} <b>loop</b> <b>checking</b> from {{positive}} programs (as described in [1]) to locally stratified programs. Such an extension is not straightforward: the introduction of negation requires a (re) consideration of the choice of semantics, the description of a related search space, and new soundness and completeness results handling floundering in a satisfactory way. Nevertheless, an extension is achieved {{that allows us to}} generalize the <b>loop</b> <b>checking</b> mechanisms from positive programs to locally stratified programs, while preserving most soundness and completeness results. The conclusion is that negative literals cannot give rise to loops, and must be simply ignored. Note: the material presented in this paper is contained in [5, ch. 5], in which also [1, 4] can be found...|$|R
40|$|AbstractWe {{propose a}} generic tableau prover {{extending}} Lotrec, called LotrecScheme: the tool enables to enrich tableau method rules with executable code. The user can graphically design its own tableau method and can {{solve the problem}} of model construction. This new system provides a way to merge two worlds when the system <b>check</b> a <b>loop</b> (for instance for S 4) : merging instead of blocking has the benefit of providing a real model and not just a skeleton of the model. The system generalizes also the notion of satisfiability to labeled graphs...|$|R
40|$|Most of the sequent/tableau based proof {{systems for}} the modal logic S 4 need to {{duplicate}} formulas and thus are required to adopt some method of <b>loop</b> <b>checking.</b> In what follows we present a tableau-like proof system for S 4, based on D 2 ̆ 7 Agostino and Mondadori 2 ̆ 7 s classical KE, which is free of duplication and <b>loop</b> <b>checking.</b> The key feature of this system (let us call it KES 4) consists in its use of (i) a label formalism which models the semantics of the modal operators according to the usual conditions for S 4; and (ii) a label unification scheme which tells us when two labels "denote" the same world in the S 4 -model(s) generated {{in the course of}} proof search. Moreover, it uses special closure conditions to check models for putative contradictions...|$|R
40|$|Abstract — When {{applications}} contain large loops, {{high level}} synthesis often {{takes advantage of}} software pipelining technique {{in order to improve}} the performance. High level synthesis with pipelining utilization needs complicated algorithms. So it is desired to check its correctness. In this paper, we propose a novel approach for equivalence <b>checking</b> of <b>loops</b> before and after pipelining. The proposed approach applies a combination of symbolic simulation technique and induction method. We develop a prototype equivalence checker based on the approach. The experimental results show that our proposed method can verify the equivalence of loops before and after pipelining. I...|$|R
40|$|AbstractTemporal {{logic is}} widely used for specifying {{hardware}} and software systems. Typically two types of properties are distinguished, safety and liveness properties. While safety can easily be checked by reachability analysis, and many efficient checkers for safety properties exist, more sophisticated algorithms have always been considered to be necessary for checking liveness. In this paper we describe an efficient translation of liveness checking problems into safety checking problems. A counter example is detected by saving a previously visited state in an additional state recording component and <b>checking</b> a <b>loop</b> closing condition. The approach handles fairness and thus extends to full LTL...|$|R
40|$|This paper {{reports a}} data {{abstraction}} algorithm that is targeted {{to minimize the}} contribution of the loop executions to the program state space. The loop abstraction is defined as the syntactic program transformation that results in the sound representation of the concrete program. The abstraction algorithm is defined and implemented {{in the context of the}} integrated software design, testing and model <b>checking.</b> The <b>loop</b> abstraction technique was applied to verification of NASA robot control software. The abstraction enabled model checking for realistic robot configurations where all other state space reduction approaches, including BDD-based verification, predicate abstraction and partial order reduction, failed...|$|R
40|$|Temporal {{logic is}} widely used for specifying {{hardware}} and software systems. Typically two types of properties are distinguished, safety and liveness properties. While safety can easily be checked by reachability analysis, and many e#cient checkers for safety properties exist, more sophisticated algorithms have always been considered to be necessary for checking liveness. In this paper we describe an e#cient translation of liveness checking problems into safety checking problems. A counter example is detected by saving a previously visited state in an additional state recording component and <b>checking</b> a <b>loop</b> closing condition. The approach handles fairness and thus extends to full LTL...|$|R
40|$|We {{develop a}} general {{technique}} for computing functional integrals with fixed area and boundary length constraints. The correct quantum dimensions for the vertex functions are recovered by properly regularizing the Green function. Explicit computation is {{given for the}} one point function providing the first one <b>loop</b> <b>check</b> of the bootstrap formula. Comment: LaTeX 26 page...|$|R
40|$|This work {{provides}} the full proofs {{of the properties}} of the tableaux calculus for hybrid logic with the global and converse modalities presented in [3], which focuses on the HL(@) fragment of the calculus. While such a fragment terminates without <b>loop</b> <b>checks,</b> when the converse and global modalities are added to the language, and the corresponding rules to the system, termination is achieved by means of a <b>loop</b> <b>checking</b> mechanism. The peculiarity of the system is the treatment of nominal equalities by means of a substitution rule. The main advantage of such a rule, compared with other approaches, is its efficiency, that has been experimentally verified for the HL(@) fragment. Such an advantage should persist in the extended calculus. In this work we give the detailed termination and completeness proofs for the entire calculus. Although the main guidelines are the same as the corresponding proofs fo...|$|R
40|$|Plausible Logic is a {{non-monotonic logic}} with an {{efficient}} implementation. Plausible Logic has five proof algorithms, one is monotonic and four are non-monotonic. These five proof algorithms form a hierarchy. Ambiguity propagating proof algorithms are less risky than ambiguity blocking proof algorithms. The hierarchy {{shows that the}} benefit of using the riskier algorithms is that more formulas can be proved. Unlike previous Plausible Logics, the Plausible Logic in this paper is relatively consistent, <b>checks</b> for <b>loops,</b> can prove all its facts and all tautologies, and allows countably many formulas and rules to be considered. Griffith Sciences, School of Information and Communication TechnologyNo Full Tex...|$|R
40|$|The {{termination}} {{problem of}} a logic program can be addressed in either a static or a dynamic way. A static approach performs termination analysis at compile time, while a dynamic approach characterizes and tests termination of a logic program by applying a <b>loop</b> <b>checking</b> technique. In this paper, we present a novel dynamic approach to termination analysis for general logic programs with moded queries. We address several interesting questions, including how to formulate an SLDNF-derivation for a moded query, how to characterize an infinite SLDNF-derivation with a moded query, and how to apply a <b>loop</b> <b>checking</b> mechanism to cut infinite SLDNF-derivations {{for the purpose of}} termination analysis. The proposed approach is very powerful and useful. It can be used (1) to test if a logic program terminates for a given concrete or moded query, (2) to test if a logic program terminates for all concrete or moded queries, and (3) to find all (most general) concrete/moded queries that are most likely terminating (or non-terminating) ...|$|R
50|$|In {{quantum field}} theory the sine-Gordon model {{contains}} a parameter, it can be identified with Planck constant. The particle spectrum consists of a soliton, an anti-soliton and a finite (possibly zero) number of breathers. The number of the breathers depends {{on the value of}} the parameter. Multi particle productions cancels on mass shell. Vanishing of two into four amplitude was explicitly <b>checked</b> in one <b>loop</b> approximation.|$|R
40|$|Abstract –In this paper, {{the design}} and {{implementation}} of the H controller for flexible joint robot (FJR) is presented and the capability of the controller to deal with actuator saturation is investigated in practice. The new procedure of design is introduced to avoid an instability caused by unmodeled phase behaviour which can not be encapsulated in multiplicative uncertainty. In order to avoid instability caused by unmodeled phase behaviour, the robust controller design is divided into two stages: H controller design and <b>checking</b> closed <b>loop</b> sensitivity function. Simulation results reveal the capability of the controller to stabilize the closed loop system and to reduce the tracking error {{in the presence of the}} actuator limitation. I...|$|R
40|$|Using a {{calculus}} of goals, {{we define}} the {{success and failure}} of a goal for propositional programs {{in the presence of}} <b>loop</b> <b>checking.</b> The calculus is sound with respect to the well-founded semantics; for finite programs, it is also complete. A Prolog-style proof search strategy for a modification of this calculus provides a query evaluation algorithm for finite propositional programs under the well-founded semantics. This algorithm is implemented as a meta-interpreter. ...|$|R
40|$|Introduction Most of the sequent/tableau based proof {{systems for}} the modal logic S 4 need to {{duplicate}} formulas and thus are required to adopt some method of <b>loop</b> <b>checking</b> [7, 13, 10]. In what follows we present a tableau-like proof system for S 4, based on D'Agostino and Mondadori's classical KE [3], which is free of duplication and <b>loop</b> <b>checking.</b> The key feature of this system (let us call it KES 4) consists in its use of (i) a label formalism which models the semantics of the modal operators according to the usual conditions for S 4; and (ii) a label unification scheme which tells us when two labels "denote" the same world in the S 4 -model(s) generated {{in the course of}} proof search. Moreover, it uses special closure conditions to check models for putative contradictions. 2 Label Formalism Let #C = 1, w 2,... be a non empty set of constant world symbols, and let # V = {W 1, W 2,... be a non empty set of variable world symbols. The set is now defined as follows...|$|R
40|$|Using a {{calculus}} of goals, {{we define}} the {{success and failure}} of a goal for propositional programs {{in the presence of}} <b>loop</b> <b>checking.</b> The calculus is sound with respect to the well-founded semantics; for finite programs, it is also complete. A Prolog-style proof search strategy for a modification of this calculus provides a query evaluation algorithm for finite propositional programs under the well-founded semantics. This algorithm is implemented as a meta-interpreter. 1 Introduction A "loop check" in a logic programming system is a mechanism that allows the system to avoid some infinite loops. For instance, the execution of the program p / not q; not r; q / r; p; r / q; p (1) under Prolog would lead to an infinite loop, because Prolog would attempt to "derive" q from r and then r from q. A system with a <b>loop</b> <b>check</b> may be able to recognize this fact and to conclude that the goals q and r fail, and, accordingly, the goal p succeeds. In this paper, we make the idea of loop ch [...] ...|$|R
