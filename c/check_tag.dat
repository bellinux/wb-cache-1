5|87|Public
50|$|Strollers and {{car seats}} can be checked without a bag but {{companies}} do not assume any liability for damage {{so it is}} advised to use a special bag. Passengers {{have to make sure}} that the gate <b>check</b> <b>tag</b> is visibly displayed on the bag if they need their stroller or car seat returned at the gate upon arrival.|$|E
30|$|In a {{duplicate}} faking attack, {{an honest}} user might {{be unable to}} retrieve his original file, since it can {{be replaced by a}} fake one and the replacement cannot be detected. That is, suppose that users Alice and Bob possess two different files F_a and F_b, respectively. The malicious user Alice may upload a modified ciphertext C_a=(E(H(F_b), F_a)) and the corresponding tag T_a=H(E(H(F_b), F_b)) into the CSP. Later, when the honest user Bob uploads the ciphertext C_b=(E(H(F_b), F_b)) and its tag T_b=H(E(H(F_b), F_b)), the CSP wrongly determines that the plaintexts of C_b and C_a are identical, and thus deletes C_b. As a result, Bob cannot retrieve his original plaintext. The main reason is that the CSP cannot <b>check</b> <b>tag</b> consistency [6] without knowing the hash value of the file.|$|E
40|$|Abstract-The {{electronic}} {{toll collection}} using RFID & android application is a technology that will allow user to make the payment of highway tolls automatically. This terminology will in turn save the {{time as well as}} the money by decreasing the waiting time as well as the queues of vehicles at the tollbooth. The RFID tag will be deployed by the toll authority by embedding unique identification number (UIN) and customer’s details into the tag. The deployed active RFID tag will be attached to the windshield of the vehicle. Whenever the vehicle passes through the tollbooth, tag data will be read by RFID reader & same will be sent to the server for verification. Server will <b>check</b> <b>tag</b> details & depending upon the type of the vehicle, the toll amount will be deducted from the user’s account. The notification about the toll amount deduction will be sent to the customer via SMS and email as well. The developed android application will be used to recharge the customer’s account...|$|E
40|$|<b>Check</b> <b>tags</b> against {{dictionaries}} <b>Check</b> syntax <b>tag</b> {{for each}} value check types (numbers, character strings) Build CIF-aware applications Handle the CIF characteristics free fields arbitrary ordering data_block 1 _tag 1 value 1 _tag 2 value 2 loop_ _col 1 _col 2 val 11 val 12 val 21 val 22 data_block 2 _tag 3 value 3 _tag 4 value 4 data_block...|$|R
40|$|A direct {{addressed}} cache is a hardware-software {{design for}} an energy-efficient microprocessor data cache. Direct addressing allows software to access cache data without a hardware cache <b>tag</b> <b>check.</b> These tag-unchecked loads and stores save {{the energy of}} a <b>tag</b> <b>check</b> when the compiler can guarantee an access will be to the same line as an earlier access. We have added support for tag-unchecked loads and stores to C and Java compilers. For Mediabench C programs, the compiler eliminates 16 [...] 76 % of data cache tag accesses, {{with half of the}} benchmarks avoiding over 40 % of the data <b>tag</b> <b>checks.</b> For SPECjvm 98 Java programs, the compiler eliminates 18 [...] 63 % of data cache <b>tag</b> <b>checks.</b> These <b>tag</b> <b>check</b> reductions translate into data cache energy savings of 9 [...] 40 %, and overall processor and cache energy savings of 2 [...] 8 %. 1...|$|R
40|$|The English {{language}} {{offers a}} complex and ambiguous grammar that is readily understood by its natural users, but at times {{can be difficult to}} grasp by beginners/learners, and no less, by machines. This paper discusses research and implementation o several techniques towards algorithmically analyzing and verifying the grammatical correctness of sentences in written English. Keywords natural language processing, grammar <b>checking,</b> <b>tagging...</b>|$|R
30|$|To {{fill the}} above gap, {{convergent}} encryption (CE) [19], an elegant cryptographic primitive, is proposed. Essentially speaking, CE is a deterministic symmetric encryption scheme and its encryption key {{is derived from}} the cryptographic hash value of the file content. Then, each identical data item generates the same ciphertext, which achieves deduplication and encryption simultaneously. Bellare et al. [6] defined a new cryptographic primitive called message-locked encryption (MLE), which {{can be viewed as a}} generalization of CE. Furthermore, to enhance performance of deduplication, a randomized convergent encryption (RCE) scheme has been proposed. It is characterized by the efficiency of the relevant operations, i.e., key generation, message encryption, and tag production. However, RCE is vulnerable to what is called duplicate faking attack. Specifically, an honest user cannot retrieve his original message because it can be undetectably replaced by a fake one. To tackle this problem, an interactive version of RCE, called interactive randomized convergent encryption (IRCE) [4], has been proposed. In IRCE, an honest user can <b>check</b> <b>tag</b> consistency by interacting with the server and thus verify that the original ciphertext is stored. If an adversary may upload a modified ciphertext, this ciphertext will be inconsistent with respect to the corresponding file tag. Such a mismatch allows one to detect that the ciphertext is incorrect.|$|E
40|$|Supply {{chain is}} a network {{involving}} multiple parties such as suppliers, transporters, storage facilities, distributors, and retailers that {{participate in the}} production, delivery, and sale of a product. It is difficult to monitor a supply chain since the involving parties are distributed at multiple locations or even across countries. RFID technology, when combined with networking technology, enables product information to be collected, integrated, shared, and queried in supply chains at various levels (e. g., item, pallet, case, and container) in real time manner. While RFID technology has greatly facilitated the supply chain management, it is still challenging to design a secure, privacy-preserving, and efficient RFIDenabled supply chain system. The wireless communications between RFID readers and tags are subject {{to a variety of}} attacks. An adversary may eavesdrop, replay, and manipulate RFID communications to obtain tag identifier, track tag location, impersonate tag and reader, and trigger denial of service. This dissertation focuses on secure and privacy-preserving tag authentication in various supply chain application scenarios. Our first work is on attacks and improvements of an existing mutual authentication protocol and a tag secret update protocol for RFID-enabled supply chains. Our second work improves the efficiency of an RFID-enabled supply chain system by designing the system in two security modes. In the weak security mode, the tagged products can be processed in a highly efficient way. In the strong security mode, our system guarantees a high level of security, while its efficiency is lower than that in the weak security mode. Our third work addresses the tag authentication problem in the scenario of third-party logistics(3 PL). We firstly formalize the security and privacy requirements of RFID systems for 3 PL supply chains considering the existence of the internal adversaries as well as the external adversaries. We propose two different protocols, one is based on aggregate message authentication codes, the other is based on aggregate signature scheme. Our solutions enable a third-party to <b>check</b> <b>tag</b> existence without knowing tag secrets. Our fourth work focuses on path authentication in RFID-enabled supply chains. We propose a single-game-based privacy notion for RFID-enabled path authentication which has been proven to be stronger than existing privacy notions for path authentication. We also propose two new path authentication schemes, one for closed supply chains, and another for dynamic supply chains...|$|E
50|$|Phing support (autocompletion, <b>checks</b> {{standard}} <b>tags,</b> properties, target names, path attribute {{values in}} build files).|$|R
40|$|Objective As {{large-scale}} {{medical imaging}} studies {{are becoming more}} common, there is an increasing reliance on automated software to extract quantitative information from these images. As {{the size of the}} cohorts keeps increasing with large studies, there is a also a need for tools that allow results from automated image processing and analysis to be presented in a way that enables fast and efficient quality <b>checking,</b> <b>tagging</b> and reporting on cases in which automatic processing failed or was problematic...|$|R
40|$|Institut Lavoisier de Versailles, CNRS-UMR 8180, PRES UniverSud, Universite de Versailles Saint-Quentin-en-Yvelines, 45 Avenue des Etats-Unis, 78035 Versailles Cedex, France FIELD Email Address: EnglishGold {{nanorods}} synthesized by radiolysis were selectively end-functionalized by a fully conjugated thiol {{bearing a}} pendant terpyridine group; addition of ferrous ions {{led to the}} end-to-end 1 D self-assembly of the nanorods. Similar results have been obtained when the preformed [(HStpy) Fe(tpySH) ](2 +) dithiol complex was directly added to the gold nanorods. [on SciFinder (R) ] FIELD <b>Check</b> <b>Tags...</b>|$|R
40|$|This paper compares bibliographic {{retrieval}} using current MeSH (Medical Subject Headings) to bibliographic retrieval using explicitly coded semantic {{relationships between}} index terms. In a previous study, 10 lists of abstracts, each list containing 20 - 40 papers discussing a specific pair of terms, were analyzed {{to identify the}} specific relationship(s) between those terms discussed in each paper. In the present study, we analyze how well current MeSH coding, using topical subheadings and <b>check</b> <b>tags,</b> can selectively retrieve those papers discussing each semantic relationship...|$|R
40|$|UPMC Univ. Paris 6 and CNRS, Laboratoire de Chimie des Polymeres, UMR 7610, 4 place Jussieu, Tour 44 - 54, 75252 Paris cedex 05, France FIELD Email Address: EnglishSelf-assembled block {{copolymer}} nanofibers are attractive materials for multiple applications. We propose here a novel, very simple and straightforward method to prepare polymeric nanofibers at high solids contents directly in water. It {{is based on}} an aqueous emulsion polymerization process performed under living radical polymerization conditions, using the RAFT method. [on SciFinder (R) ] FIELD <b>Check</b> <b>Tags...</b>|$|R
50|$|The MANTIS Database (Manual, Alternative and Natural Therapy Index System) is {{an index}} of English-language and {{selected}} other-language biomedical journal articles. The database has a primary focus on chiropractic, osteopathic and manual medicine, although it includes citations and abstracts from all alternative medicine disciplines. Each record within the MANTIS Database contains a complete citation, {{the language of the}} abstract, the language of the article, and the headings and subheadings which describe the article. Approximately 70% of the references include abstracts. The database is indexed using standard Medical Subject Headings (MeSH). This includes the use of headings, subheadings, and <b>check</b> <b>tags.</b>|$|R
40|$|This report gives {{a simple}} {{implementation}} of A. Baars and S. D. Swier-stra’s “Typing Dynamic Typing ” [5] using modern (GHC) Haskell fea-tures, and {{shows that the}} technique is especially beneficial in a composi-tional setting, where parts of the expression are defined separately. Evaluating expressions that are represented as algebraic data types typically requires using tagged unions to represent values. Tagged unions can introduce runtime overhead due to <b>tag</b> <b>checking,</b> and this overhead is unnecessary if the evaluated expression is well-typed. Likewise, pattern matching on the constructors of the expression causes overhead which is unnecessary if the same expression is evaluated multiple times. Typ-ing Dynamic Typing solves both of these problems by deferring all <b>tag</b> <b>checking</b> to an initial “dynamic compilation ” phase after which evaluation proceeds without any <b>tag</b> <b>checking</b> or pattern matching. The problems of <b>tag</b> <b>checking</b> and pattern matching are worse in a compositional set-ting, and our measurements show that the technique gives especially good performance gains for compositional expressions...|$|R
40|$|We give an {{efficient}} and compositional implementation of evaluation for an untyped representation of expressions. Building on Baars and Swierstra's "Typing Dynamic Typing", all <b>tag</b> <b>checking</b> is deferred to an initial dynamic compilation phase after which evaluation proceeds without any <b>tag</b> <b>checking.</b> The technique lends itself particularly well to a compositional implementation, where {{parts of the}} expression are defined separately, and this is also where we see the highest performance gains...|$|R
40|$|We {{present a}} type-based {{approach}} to eliminating array bound <b>checking</b> and list <b>tag</b> <b>checking</b> by conservatively extending Standard ML with a restricted form of dependent types. This enables the programmer to capture more invariants through types while type-checking remains decidable {{in theory and}} can still be performed efficiently in practice. We illustrate our approach through concrete examples and present the result of our preliminary experiments which support support the feasibility and effectiveness of our approach. ...|$|R
40|$|This paper {{proposes a}} history-based tag-comparison scheme for {{reducing}} energy consumption of direct-mapped instruction caches. The proposed cache efficiently exploits programexecution footprints {{recorded in the}} Branch Target Buffer (BTB), and attempts to detect and eliminate unnecessary <b>tag</b> <b>checks</b> at run time. Simulation results show that our approach can eliminate up to 95 % of <b>tag</b> <b>checks,</b> saving the cache energy by 17 %, while affecting the processor performance by only 0. 2 %...|$|R
40|$|We {{present a}} dependently typed {{assembly}} language (DTAL) {{in which the}} type system supports {{the use of a}} restricted form of dependent types, reaping some benefits of dependent types at the assembly level. DTAL improves upon TAL, enabling certain important compiler optimizations such as run-time array bound <b>check</b> elimination and <b>tag</b> <b>check</b> elimination. Also, DTAL formally addresses the issue of representing sum types at assembly level, making it suitable for handling not only datatypes in ML but also dependent datatypes in Dependent ML (DML) ...|$|R
40|$|This paper proposes an {{architecture}} for low-power direct-mapped instruction caches, called “history-based tag-comparison (HBTC) cache”. The HBTC cache attempts {{to detect and}} omit unnecessary <b>tag</b> <b>checks</b> at run time. Execution footprints are recorded in an extended BTB (Branch Target Buffer), and are used to know the cache residence of target instructions before starting cache access. In our simulation, {{it is observed that}} our approach can reduce the total count of <b>tag</b> <b>checks</b> by 90 %, resulting in 15 % of cache-energy reduction, with less than 0. 5 % performance degradation...|$|R
40|$|Photograph {{used for}} {{a story in the}} Oklahoma Times newspaper. Caption: "When Oklahoma City's Aristophanean Club {{observed}} its 40 th anniversary, some of the charter members were present for the festive luncheon at the home of Mrs. Charles T. Sivalls, 7213 Country Club Drive N. Displaying the ribbon marking the anniversary are, left photo, Katherine Daugherty and Frances Hessman and <b>checking</b> name <b>tags,</b> right photo are Audrain Whitlock and Grace Willits. ...|$|R
50|$|At any point, {{the user}} can create {{partially}} translated {{versions of the}} source files. Note that OmegaT copies source segments verbatim if {{they have yet to}} be translated. Before doing so, however, the user is advised to use the Validate menu command to <b>check</b> for <b>tag</b> and other errors. Version 3.1 added a menu command (and keyboard shortcut) for limiting operation to the current file—for partial delivery or quick update, for example.|$|R
30|$|Such {{sentences}} were discarded, {{since there}} was no way to recover the missing word. Repeated sentences were also removed. Tag mistypes were easily found <b>checking</b> for any <b>tag</b> not in the corpus tagset and could be manually corrected.|$|R
40|$|The span cache is a hardware-software {{design for}} {{a new kind of}} {{energy-efficient}} microprocessor data cache which has two key features. The first is direct addressing which allows software to access cache data without the hardware performing a cache <b>tag</b> <b>check.</b> These tag-unchecked loads and stores save the energy of performing a <b>tag</b> <b>check</b> when the compiler can guarantee an access will be to the same line as an earlier access. The second key feature is software controlled line size. This lets the compiler specify how much data to fetch on a miss, allowing greater cache utilization and reducing memory bandwidth requirements. Two possible hardware implementations of software controlled line size are sketched and discussed...|$|R
40|$|Vegetable oils differ {{significantly}} for their lipid profile and are mainly constituted by triacylglycerols (TAGs). These are esters formed bonding glycerol to three fatty acids (FAs). To {{the best of}} our knowledge, FA and TAG profiles in oils and fats are obtained using at least two different experimental techniques. In particular, FA determination requires elaborated procedures for sample preparation and analyte derivatization. In this work, we propose a one-pot analysis able to determine both TAG and FA contents of edible oils, using experimental data obtained from a simple liquid chromatography/mass spectrometry determination of TAGs. This experimental procedure is followed by an in silico saponification process, carried out using a purposely developed software (Tag-Check), able to produce the requested FA profiles. The in silico saponification procedure has been applied on experimental TAG composition data of several vegetable oils, showing always a good agreement with FA profiles obtained by traditional hydrolysis-GC/FID determination of FA methyl esters. The procedure and related software have been further tested by processing literature data reported for TAG in a series of edible oils. Results evidenced the reliability of the in silico saponification approach and its usefulness for <b>checking</b> <b>TAG</b> data results...|$|R
50|$|In November 2013 BC Kosher {{was renamed}} Kosher <b>Check</b> with the <b>tag</b> line Kosher <b>Checked.</b> Globally Accepted. This new symbol is only {{available}} to manufacturers {{of food that}} have enhanced food-safety protocols. Today Kosher Check certifies thousands of products produced by manufacturers all around the World.|$|R
50|$|As long as {{the union}} fields are only {{accessed}} through the functions, the accesses will be safe and correct. The same approach {{can be used for}} encoded tags; we simply decode the <b>tag</b> and then <b>check</b> it on each access. If the inefficiency of these <b>tag</b> <b>checks</b> is a concern, they may be automatically removed in the final version.|$|R
40|$|We {{present a}} type-based {{approach}} to eliminating array bound <b>checking</b> and list <b>tag</b> <b>checking</b> by conservatively extending Standard ML with a restricted form of dependent types. This enables the programmer to capture more invariants through types while type-checking remains decidable {{in theory and}} can still be performed efficiently in practice. We illustrate our approach through concrete examples and present the result of our preliminary experiments which support support the feasibility and effectiveness of our approach. 1 Introduction The absence of run-time array bound checks is an infamous source of fatal errors for programs in languages such as C. Nonetheless, compilers offer the option to omit array bound checks, since they can {{turn out to be}} expensive in practice (Chow 1983; Gupta 1994). In statically typed languages such as ML, one would like to provide strong guarantees about the safety of all operations, so array bound checks cannot be omitted in general. The same is true for Ja [...] ...|$|R
40|$|As the <b>tag</b> <b>check</b> may be {{executed}} {{in a specific}} pipeline stage, cache pipelining allows to reach the same processor cycle time with a set-associative cache or a direct-mapped cache. On a direct-mapped cache, the data or the instruction flowing out from the cache {{may be used in}} parallel with the <b>tag</b> <b>check.</b> When using a pipelined cache, such an optimistic execution results in load and branch delays one cycle shorter than on a associatifs parv ensemble cache with the same pipeline depth. In this paper, pipelined set-associative caches and pipelined direct-mapped caches using optimistic execution are compared. Our experiments show that for cache sizes in the 4 K- 16 Kbytes range, the set-associative caches outperform the direct-mapped caches with current microprocessor miss penalty and a cache pipeline depth lower than 4 cycles. The gap between performance levels respectively obtained with set-associative caches and direct-mapped caches is particularly significant when a dynamic prediction [...] ...|$|R
40|$|In {{this paper}} we propose a new mechanism, called Store Buffering, for {{implementing}} single-cycle store instructions in a pipelined processor. Store instructions are difficult to implement as single-cycle instructions because in most caches a <b>tag</b> <b>check</b> must be performed on the cache location before data can be stored. Store buffering allows a store instruction to <b>check</b> the cache <b>tag</b> during the cache access pipe stage and buffer the store data until the data cache is free to accept it. The data cache can accept data in the background of normal pipe execution. With multiple store buffers consecutive store instructions can execute without stalling the pipe. This strategy guarantees single-cycle execution without increasing the hit access time or degrading the performance of the data cache for simple direct-mapped caches, as well as for more complex set associative and write-back caches. Other single-cycle store strategies either require considerable silicon area or are limited to simple dir [...] ...|$|R
50|$|One of the {{advantages}} of a direct mapped cache is that it allows simple and fast speculation. Once the address has been computed, the one cache index which might have a copy of that location in memory is known. That cache entry can be read, and the processor can continue to work with that data before it finishes <b>checking</b> that the <b>tag</b> actually matches the requested address.|$|R
5000|$|... 1. Animals must be examined, with a {{focus on}} {{hydration}} status, cuts and abrasions and paw/hoof/foot health. Other important examinations include ear health, oral injuries, vomiting and/or diarrhea, respiratory disease and evidence of parasite infestation.2. Animals should be bathed upon admission, Dawn dish soap may be used to remove toxic chemicals and petroleum.3. A health record and history should be established and updated as needed. Owned animals should be marked to avoid mix-ups with abandoned/unidentified animals.4. Animals should be scanned for microchip information with all available scanners. If ownership of the animal is not established through microchips, it should be <b>checked</b> for <b>tags</b> or tattoos. 5. Animals of different species should not be housed together.|$|R
50|$|Although {{primarily}} only functional languages such as ML and Haskell (from 1990s) give {{a central}} role to tagged unions and {{have the power to}} check that all cases are handled, other languages have support for tagged unions as well. However, in practice they can be less efficient in non-functional languages due to optimizations enabled by functional language compilers that can eliminate explicit <b>tag</b> <b>checks</b> and avoid explicit storage of tags.|$|R
40|$|This diploma paper {{introduces}} {{development and}} implementation of access control system. It is made of STM 32 F 4 microcontroller based on ARM Cortex-M 4 processor, TFT touch screen, RFID card reader and RS 232 /TCP converter module. Part of the system are also two programms which are running outside of the controller. First, the server side program is used to <b>check</b> RFID <b>tags</b> and belonging PINs, the second one does the logging. Beside logging, its functionality is also adding or removing users from the database. Operating system we are using on microcontroller is FreeRTOS, one of the free versions of real time operating systems. We used programming language C for coding the microcontroller and programming language Java in combination with C# for the rest...|$|R
40|$|Radio Frequency Identification (RFID) is {{a growing}} {{technology}} which is increasingly utilized throughout industry. This senior project identifies an RFID alternative to the checkout system in the tool crib of the Cal Poly Aero Hanger. A new database is designed and built to interface with an RFIDeas AIR enroll reader. The system realizes vast time savings in check in times and increases student accountability for the tools which are <b>checked</b> out by <b>tagging</b> tools...|$|R
40|$|SUMMARY In this paper, {{we propose}} a novel {{architecture}} for low-power direct-mapped instruction caches, called “history-based tag-comparison (HBTC) cache”. The cache attempts to reuse tag-comparison results for avoiding unnecessary <b>tag</b> <b>checks.</b> Execution footprints are recorded into an extended BTB (Branch Target Buffer). In our evaluation, {{it is observed}} that the energy for tag comparison can be reduced by more than 90 % in many applications. key words: cache, low power, look up, run time 1...|$|R
