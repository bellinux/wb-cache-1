2|15|Public
50|$|In {{computer}} operating systems, {{a stream}} socket {{is a type}} of interprocess <b>communications</b> <b>socket</b> or network socket which provides a connection-oriented, sequenced, and unique flow of data without record boundaries, with well-defined mechanisms for creating and destroying connections and for detecting errors.|$|E
50|$|In {{computer}} operating systems, a datagram socket {{is a type}} of interprocess <b>communications</b> <b>socket</b> or {{network socket}} which provides a connectionless point for sending or receiving data packets. Each packet sent or received on a datagram socket is individually addressed and routed. Order and reliability are not guaranteed with datagram sockets, so multiple packets sent from one machine or process to another may arrive in any order or might not arrive at all.|$|E
5000|$|X.509 {{certificates}} (i.e., Single Sign-On) via Secure Network <b>Communications</b> or Secure <b>Socket</b> Layer ...|$|R
40|$|The project {{database}} handler dbCCP 4 i {{is a small}} server {{program that}} handles interactions between the job database and other programs. The handler is written in Python but <b>communications</b> are via <b>sockets,</b> so the clients can be written in any language. Tcl and Python â€œclient API " libraries are provided to hide {{the details of the}} <b>socket</b> <b>communications</b> and simplify access to the database. The system runs on both UNIX/Linux and MS Windows platforms. dbCCP 4 i: Tracking data in PX Structure Determination Software Pipeline...|$|R
50|$|In 2002 GeoVector {{contracted}} <b>Socket</b> <b>Communications</b> to make PCMCIA cards {{equipped with}} GPS and Compass, GeoVector Pointing Cards, {{for use in}} Pocket PCs. See the card in action here.|$|R
50|$|Server-to-server {{communications}} can be encrypted {{with the}} SAP cryptographic library. With the recent acquisition of relevant parts of SECUDE, SAP can now provide cryptography libraries with SAP R/3 for Secure Network <b>Communications</b> and Secure <b>Socket.</b>|$|R
5000|$|A TCP {{connection}} is managed by an operating system through a programming interface {{that represents the}} local end-point for <b>communications,</b> the Internet <b>socket.</b> During the lifetime of a TCP connection the local end-point undergoes a series of state changes: ...|$|R
5000|$|The SAP NetWeaver Application Server's {{connectivity}} layer supports HTTPS {{which is}} required for encrypted <b>communications</b> via Secure <b>Socket</b> Layer. It is possible to enable SSL using the SAP Cryptographic Library. If a company is running with traditional SAP systems that only uses RFC and DIAG protocols, Secure Network Communications {{is required for}} encrypted communications as well ...|$|R
40|$|Abstract: The aim of {{the paper}} is to {{introduce}} sockets, its deployment pertaining to network programming. Sockets {{play a vital role}} in client server applications. The client and server can communicate with each other by writing to or reading from these sockets. They were invented in Berkeley as part of the BSD flavor of UNIX operating systems. And they spread like wildfire with the Internet. This paper introduces elements of network programming and concepts involved in creating network applications using sockets. One of the most basic network programming tasks likely to be faced as a java programmer is performing the socket functions/methods because java has been preferred mostly for establishing client server <b>communications</b> using <b>sockets...</b>|$|R
5000|$|In IETF Request for Comments, Internet Standards, in many textbooks, {{as well as}} in this article, {{the term}} socket refers to an entity that is uniquely {{identified}} by the socket number. In other textbooks, the term socket refers to a local socket address, i.e. a [...] "combination of an IP address and a port number". In the original definition of socket given in RFC 147, as it was related to the ARPA network in 1971, [...] "the socket is specified as a 32 bit number with even sockets identifying receiving sockets and odd sockets identifying sending sockets." [...] Today, however, <b>socket</b> <b>communications</b> are bidirectional.|$|R
40|$|A Computing Community is a {{group of}} {{cooperating}} machines that behave like a single system and runs all general-purpose applications [...] -without any modifications to the shrink-wrapped binary applications or the operating system. In order to realize such a system, we inject a wrapper DLL into an application at runtime that manages the execution of the application and endows it with features such as virtualization and mobility. This paper describes the concept of virtualization, and the mechanism of injection and the implementation of a wrapper DLL. We focus on one kind of applications, those that use sockets to communicate with other processes. We show how these processes can migrate between machines without disrupting the <b>socket</b> <b>communications.</b> We have implemented the software that needs to be injected into the application to enable this feature. Handling more application types is part of the continued research in the Computing Communities project. 1. Introduction The [...] ...|$|R
40|$|This paper {{describes}} {{the design and}} development of the modeling and simulation environment for the robotic manipulators named ROBOMOSP (Robotics Modeling and Simulation Platform), which addresses important limitations of existing software for this purpose, under a highly parametric interface ideal for academics and research. The ROBOMOSP software platform adds novel characteristics and functions that are not found in other commercial and noncommercial robot modeling and simulation packages available today, including solution to the multibody dynamics problem using automatic calculation of the mass properties of robot multibodies, offline programming using a standard language, an API interface to allow experimentation with new algorithms, and support for remote/distributed use of the platform via <b>socket</b> <b>communications.</b> ROBOMOSP is ideal for training robotic operators, as a research aid, and for studying the mathematical and physical foundations of robotic manipulators, thanks to its ability to permit the expression of models that closely simulate the behavior of real systems within a feature-packed user-friendly interface...|$|R
40|$|AbstractThe {{increasing}} {{failure rate}} in High Performance Computing encourages {{the investigation of}} fault tolerance mechanisms to guarantee the execution of an application in spite of node faults. This paper presents an automatic and scalable fault tolerant model designed to be transparent for applications and for message passing libraries. The model consists of detecting failures in the communication socket caused by a faulty node. In those cases, the affected processes are recovered in a healthy node and the connections are reestablished without losing data. The Redundant Array of Distributed Independent Controllers architecture proposes a decentralized model for all the tasks required in a fault tolerance system: protection, detection, recovery and masking. Decentralized algorithms allow the application to scale, which is a key property for current HPC system. Three different rollback recovery protocols are defined and discussed {{with the aim of}} offering alternatives to reduce overhead when multicore systems are used. A prototype has been implemented to carry out an exhaustive experimental evaluation through Master/Worker and Single Program Multiple Data execution models. Multiple workloads and an increasing number of processes have been taken into account to compare the above mentioned protocols. The executions take place in two multicore Linux clusters with different <b>socket</b> <b>communications</b> libraries...|$|R
40|$|All {{simulations}} {{require some}} type of user interface to be functional. The problem is that this interface is sometimes written as a tightly coupled part of the simulation itself, buried in {{the main body of}} code. This makes the interface very difficult to create, and once created, more difficult to alter. Thus these tightly coupled simulations do not support a simple way to prototype new interface models and incorporate them into the application. The solution is to segregate the interface from the main simulation in a loosely coupled system. Communication with the application is through a well-defined interface. By separating the two, changes can easily be incorporated into either module without significant impact on the other. The approach taken was to create the interface as a separate program. Communication with the main simulation is through data structures passed over a <b>socket</b> <b>communications</b> link. The resulting application displays a control panel on a separate monitor. Using object- oriented techniques, components are defined, incorporated, rearranged, and deleted from the panel as needed. The loose coupling to NPSNET means that changes made to one application have little effect on the other. New interfaces can now be quickly and easi y created without effecting the core NPSNET application to any significant degree. NANAU. S. Navy (U. S. N.) author...|$|R
40|$|The {{increasing}} {{failure rate}} in High Performance Computing encourages {{the investigation of}} fault tolerance mechanisms to guarantee the execution of an application in spite of node faults. This paper presents an automatic and scalable fault tolerant model designed to be transparent for applications and for message passing libraries. The model consists of detecting failures in the communication socket caused by a faulty node. In those cases, the affected processes are recovered in a healthy node and the connections are reestablished without losing data. The Redundant Array of Distributed Independent Controllers architecture proposes a decentralized model for all the tasks required in a fault tolerance system: protection, detection, recovery and masking. Decentralized algorithms allow the application to scale, which is a key property for current HPC system. Three different rollback recovery protocols are defined and discussed {{with the aim of}} offering alternatives to reduce overhead when multicore systems are used. A prototype has been implemented to carry out an exhaustive experimental evaluation through Master/Worker and Single Program Multiple Data execution models. Multiple workloads and an increasing number of processes have been taken into account to compare the above mentioned protocols. The executions take place in two multicore Linux clusters with different <b>socket</b> <b>communications</b> libraries...|$|R
40|$|La demanda de major rendiment de les aplicacions cient ques es satisf a incrementant la quantitat de {{components}}. No obstant aix o, un major nombre de components implica una major probabilitat de fallada. L'abrupta caiguda dels temps mitjans entre fallades en els sistemes actuals impulsa la investigaci o de mecanismes de toler ancia a fallades per garantir l'execuci o d'una aplicaci o a un cost raonable. Message-Passing Interface (MPI), l'est andard de programaci o m es utilitzat per les aplicacions cient ques, t e un comportament fail-stop, realitzant una parada segura de tots els processos en cas de detectar una fallada en qualsevol dels nodes del cl uster. Com a consequ encia, es perd l'execuci o que s'hagu es fet en tots els nodes de processament. Els sistemes de c omput d'altes prestacions, han anat implementat mecanismes per a garantir el servei, normalment basades en t ecniques de rollback-recovery mitjan cant l' us de Checkpoint/Restart. Aquestes solucions s'han implementat a nivell d'aplicaci o, la qual cosa no es transparent, o b e, a nivell de llibreria, la qual cosa no es generalitzable a altres llibreries i es deixen fora del camp de soluci o a un divers nombre d'aplicacions. Es proposa un sistema de toler ancia a fallades transparent i autom atic per l'aplicaci o paral lela de manera que pugui utilitzar-se sense modi car l'aplicaci o i amb la llibrer a de pas de missatge que prefereixi l'usuari. Es basa en detectar els errors en las comunicacions de sockets causats per les fallades de nodes i recon gurar-los en forma autom atica per a comunicar-se amb la nova adre ca a on es migra el proc es. Funciona en conjunt amb un sistema que protegeix l'estat de c omput dels processos i, en cas de fallades, els recupera en un altre node de c omput mitjan cant t ecniques de rollback-recovery. S'ha realitzat una validaci o experimental utilitzant aplicacions Master/Worker i Single Program Multipla Data (SPMD) amb comunicacions basades en sockets i en pas de missatges Message Passing Interface (MPI). Les execucions es van realitzar en un cl uster multicore, obtenint els nivells desitjats de funcionalitat i prestacions. La demanda de mayor rendimiento de las aplicaciones cient cas se satisface incrementando la cantidad de componentes. Sin embargo, un mayor n umero de componentes implica una mayor probabilidad de fallo. La abrupta ca da de los tiempos medios entre fallos en los sistemas actuales de altas prestaciones impulsa la investigaci on de mecanismos de tolerancia a fallos para {{garantizar la}} ejecuci on de una aplicaci on a un coste razonable. Message-Passing Interface (MPI), el est andar de programaci on m as utilizado por las aplicaciones cient cas, tiene un comportamiento fail-stop, realizando una parada segura de todos los procesos si se detecta un fallo en un nodo del cl uster. Como consecuencia, se pierde la ejecuci on que se hubiera hecho en todos los nodos de procesamiento. Los sistemas de c omputo de altas prestaciones han implementado mecanismos para garantizar el servicio, normalmente basados en t ecnicas de rollback-recovery mediante uso de Checkpoint/Restart. Estas soluciones se han implementado a nivel de aplicaci on lo cual no es transparente, o bien, a nivel de librer a, lo cual no es generalizable a otras librer as y dejan fuera del campo de soluci on a un n umero diverso de aplicaciones. Se propone un sistema de tolerancia a fallos transparente y autom atico de modo que pueda utilizarse sin modi car la aplicaci on y con la librer a de paso de mensaje que pre era el usuario. Se basa en detectar los errores en las comunicaciones de socket causados por fallos de nodos y recon gurarlos en forma autom atica para comunicarse con la nueva direcci on a donde se migra el proceso. Funciona en conjunto con un sistema que protege el estado de c omputo de los procesos y en caso de fallos, los recupera en otro nodo de c omputo {{por medio de}} t ecnicas de rollback-recovery. Se ha realizado una validaci on experimental utilizando aplicaciones Master/Worker y Single Program Multipla Data (SPMD), con comunicaciones basadas en sockets y en paso de mensajes Message Passing Interface (MPI). Las ejecuciones se realizaron en un cluster multicore, obteniendo los niveles deseados de funcionalidad y de prestaciones. The demand of more performance of scienti c applications is achieved by {{increasing the amount of}} components. However, a growing number of components implies that the probability of failure increases as well. The remarkable decrease of average times between failures in the current High Performance Computing systems encourages the investigation of mechanisms of fault tolerance suitable for new architectures which allow to guarantee the execution of an application at a reasonable cost. Message Passing Interface (MPI), the standard of programming more used by scienti c application, has a fail-stop behavior, by carrying out a safe stop of all the processes in case of detecting a failure in any of the nodes of the cluster. As a consequence, the execution which could have been done in all the processing nodes until that moment is lost. High Performance Computing has implemented mechanisms in order to guarantee service, usually based on techniques of rollback-recovery by using the Checkpoint/Restart. Those solutions have been implemented at an application level which is not transparent, or, at library level, which is not extended to other libraries and leave out several applications. A transparent and automatic fault tolerance system in proposed in this thesis, {{in such a way that}} the application can be used without being modi ed and with the message passing library preferred by the user. It is based on detecting failures in the <b>communications</b> of the <b>socket</b> caused by failures of nodes and recon gure them in an automatic way to communicate with the new direction where the process is migrated. This method works along with a system which protects the status of computation of the processes and in the case of failure, they are recovered in other node of computation by using techniques of rollback-recovery. An experimental validation has been carried out by using applications Master/Worker and Single Program Multipla Data (SPMD), with <b>communications</b> based on <b>sockets</b> and on Message Passing Interface (MPI). The executions were made in a multicore cluster, obtaining the desirable levels of functionality and performance. The demand of more performance of scienti c applications is achieved by increasing the amount of components. However, a growing number of components implies that the probability of failure increases as well. The remarkable decrease of average times between failures in the current High Performance Computing systems encourages the investigation of mechanisms of fault tolerance suitable for new architectures which allow to guarantee the execution of an application at a reasonable cost. Message Passing Interface (MPI), the standard of programming more used by scienti c application, has a fail-stop behavior, by carrying out a safe stop of all the processes in case of detecting a failure in any of the nodes of the cluster. As a consequence, the execution which could have been done in all the processing nodes until that moment is lost. High Performance Computing has implemented mechanisms in order to guarantee service, usually based on techniques of rollback-recovery by using the Checkpoint/Restart. Those solutions have been implemented at an application level which is not transparent, or, at library level, which is not extended to other libraries and leave out several applications. A transparent and automatic fault tolerance system in proposed in this thesis, in such a way that the application can be used without being modi ed and with the message passing library preferred by the user. It is based on detecting failures in the <b>communications</b> of the <b>socket</b> caused by failures of nodes and recon gure them in an automatic way to communicate with the new direction where the process is migrated. This method works along with a system which protects the status of computation of the processes and in the case of failure, they are recovered in other node of computation by using techniques of rollback-recovery. An experimental validation has been carried out by using applications Master/Worker and Single Program Multipla Data (SPMD), with <b>communications</b> based on <b>sockets</b> and on Message Passing Interface (MPI). The executions were made in a multicore cluster, obtaining the desirable levels of functionality and performance. The demand of more performance of scienti c applications is achieved by increasing the amount of components. However, a growing number of components implies that the probability of failure increases as well. The remarkable decrease of average times between failures in the current High Performance Computing systems encourages the investigation of mechanisms of fault tolerance suitable for new architectures which allow to guarantee the execution of an application at a reasonable cost. Message Passing Interface (MPI), the standard of programming more used by scienti c application, has a fail-stop behavior, by carrying out a safe stop of all the processes in case of detecting a failure in any of the nodes of the cluster. As a consequence, the execution which could have been done in all the processing nodes until that moment is lost. High Performance Computing has implemented mechanisms in order to guarantee service, usually based on techniques of rollback-recovery by using the Checkpoint/Restart. Those solutions have been implemented at an application level which is not transparent, or, at library level, which is not extended to other libraries and leave out several applications. A transparent and automatic fault tolerance system in proposed in this thesis, in such a way that the application can be used without being modi ed and with the message passing library preferred by the user. It is based on detecting failures in the <b>communications</b> of the <b>socket</b> caused by failures of nodes and recon gure them in an automatic way to communicate with the new direction where the process is migrated. This method works along with a system which protects the status of computation of the processes and in the case of failure, they are recovered in other node of computation by using techniques of rollback-recovery. An experimental validation has been carried out by using applications Master/Worker and Single Program Multipla Data (SPMD), with <b>communications</b> based on <b>sockets</b> and on Message Passing Interface (MPI). The executions were made in a multicore cluster, obtaining the desirable levels of functionality and performance...|$|R
40|$|Fusion {{blankets}} {{are required}} to operate in a harsh environment {{under the influence of}} a number of synergistic physical phenomena, working across several length scales. The ability to model the thermal-hydraulics of a blanket effectively is key for analysis and design purposes. For magnetic confinement reactor blanket designs using a conducting fluid as a coolant and tritium breeder, the difficulties in flow modelling are particularly challenging due to interactions with the large magnetic field. Blanket analysis is an ideal candidate for the application of a code coupling methodology, with a thermal-hydraulic systems code modelling portions of the blanket amenable to 1 D analysis, and a CFD or rather CMHD (Computational Magnetohydrodynamics) solver providing detail where necessary. It is the aim of this study to develop a coupled systems code - CMHD based approach to the modelling of fusion blanket thermal-hydraulics. In particular, it addresses some of the problems associated with the flow of electrically conducting fluids in a high magnetic field. This will enable extensive thermal-hydraulic simulations of the blanket and associated systems to be performed, accounting for MHD effects in a computationally efficient manner that lends itself to the design process. Novel analytical solutions have been developed {{to address the problem of}} the electromagnetic coupling of flows between adjacent conducting walled ducts, and for the related heat transfer problem. The resulting correlations have been used in the development of a one dimensional thermal-hydraulic systems code, MHD-SYS. The code has been coupled via TCP <b>socket</b> <b>communications</b> to a CMHD solver (mhdFoam) and the resulting coupled solver has been validated for several test cases. Studies have been performed on simple blanket relevant geometries, comprised of a manifold and several ducts, in order to demonstrate the potential of the coupled solver to capture MHD effects such as modified velocity profiles, increased pressure drops and flow redistribution. Open Acces...|$|R

