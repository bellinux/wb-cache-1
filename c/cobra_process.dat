1|2|Public
40|$|This project thesis {{deals with}} the {{development}} of software tool to support the CoBRA method. CoBRA is a Cost Estimation, Benchmarking and Risk Analysis method for software projects developed by Fraunhofer IESE. The goal is to support the whole <b>CoBRA</b> <b>Process</b> including the building and application of CoBRA models as well as the maintenance of existing CoBRA models. Unlike the rudimentary excel sheet solution that exists and must be time-consuming adapted for every new context this tool should be applicable universally. During this thesis we first elaborated the key requirements for such a tool in an analysis of its functional and nonfunctional requirements. Next we build a design for the tool including an adequate architecture, database schema for the application data and class diagrams, followed by documenting vertical traceability between requirements and design. Finally we coded the tool including automated test cases. During the requirements analysis it showed that the complexity of such a tool was greater than expected, so we present in the last chapter {{the current state of the}} development and open items for future work...|$|E
40|$|Both the CoBRA {{method and}} its {{presentation}} {{are driven by}} and aimed at industrial practice - A complete and comprehensible specification of all relevant <b>CoBRA</b> <b>processes</b> is presented - The methodological concepts and their usage are illustrated by numerous practical examples and case studies from various software organizations Software effort estimation {{is a key element}} of software project planning and management. Yet, in industrial practice, the important role of effort estimation is often underestimated and/or misunderstood. In this book, Adam Trendowicz presents the CoBRA method (an abbreviation for Cost Estimation, Benchmarking, and Risk Assessment) for estimating the effort required to successfully complete a software development project, which uniquely combines human judgment and measurement data in order to systematically create a custom-specific effort estimation model. CoBRA goes far beyond simply predicting the development effort; it supports project decision-makers in negotiating the project scope, managing project risks, benchmarking productivity, and directing improvement activities. To illustrate the method's practical use, the book reports several real-world cases where CoBRA was applied in various industrial contexts. These cases represent different estimation contexts in terms of software project environment, estimation objectives, and estimation constraints. This book {{is the result of a}} successful collaboration between the process management division of Fraunhofer IESE and many software companies in the field of software engineering technology transfer. It mainly addresses software practitioners who deal with planning and managing software development projects as part of their daily work, and is also of interest for students or courses specializing in software engineering or software project management...|$|R
40|$|ISBN: 0080334385 Concerns {{the design}} of a {{microprocessor}} dedicated to safety applications and more particularly to automatic train control. This microprocessor is self-checking i. e. able to detect its own errors. Its name is COBRA (controller with built-in selfchecking for real-time applications). In {{the design of}} this circuit, low-level fault hypotheses for the N-MOS technology are considered. In this case redundant faults, i. e. undetectable faults, generally exist in any design and thus fault detecting capabilities must be provided for sequences of faults. The functional circuits will process with coded data and will be checked by strongly code-disjoint checkers. <b>COBRA's</b> data path <b>processes</b> independently 19 different signals, and supervises 14 level inputs (binary values). 7 independent outputs could be binary values, and 3 could be clocks. The data path communicates with an external PROM, used as program storage for COBRA. This PROM is addressed with 14 bits, multiplexed over the 8 -bit address/data internal bus of the data path. It also contains one serial I/O, a 64 byte RAM, and 3 independent 14 bits counters. An 8 bit ALU could be used for arithmetical or logical operations. A set of 42 instructions processes all these operations...|$|R

