1045|379|Public
5|$|The NTFS {{file system}} used by recent {{versions}} of Windows stores the file with a UTC time stamp, but displays it corrected to local—or seasonal—time. However, the FAT filesystem commonly used on removable devices stores only the local time. Consequently, when a file is copied {{from the hard}} disk onto separate media, its time will be set to the current local time. If the time adjustment is changed, the timestamps of the original file and the copy will be different. The same effect can be observed when compressing and uncompressing files with some file archivers. It is the NTFS file that changes seen time. This effect {{should be kept in}} mind when trying to determine if a file is a duplicate of another, although there are other methods of comparing files for equality (such as using a <b>checksum</b> algorithm).|$|E
25|$|This field {{provides}} a CRC32 <b>checksum</b> {{of the data}} in the entire page (including the page header, calculated with the <b>checksum</b> field set to 0). This allows verification that the data has not been corrupted since it was created. Pages that fail the <b>checksum</b> should be discarded. The <b>checksum</b> is generated using a polynomial value of 0x04C11DB7.|$|E
25|$|For ZFS, data {{integrity}} {{is achieved by}} using a Fletcher-based <b>checksum</b> or a SHA-256 hash throughout the file system tree. Each block of data is checksummed and the <b>checksum</b> value is then saved in the pointer to that block—rather than at the actual block itself. Next, the block pointer is checksummed, with the value being saved at its pointer. This checksumming continues {{all the way up}} the file system's data hierarchy to the root node, which is also checksummed, thus creating a Merkle tree. In-flight data corruption or phantom reads/writes (the data written/read checksums correctly but is actually wrong) are undetectable by most filesystems as they store the <b>checksum</b> with the data. ZFS stores the <b>checksum</b> of each block in its parent block pointer so the entire pool self-validates.|$|E
50|$|The {{recipient}} splits its copy of {{the file}} into chunks and computes two <b>checksums</b> for each chunk: the MD5 hash, and a weaker but easier to compute 'rolling checksum'. It sends these <b>checksums</b> to the sender.|$|R
5000|$|A common {{implementation}} is to pass <b>checksums</b> of {{the current}} replica State and recent Outputs among servers. An Audit process at each server restarts the local replica if a deviation is detected. [...] Cryptographic security is not required for <b>checksums.</b>|$|R
50|$|Thus {{for such}} backdoors to avoid detection, all extant {{copies of a}} binary must be subverted, and any {{validation}} <b>checksums</b> must also be compromised, and source must be unavailable, to prevent recompilation. Alternatively, these other tools (length checks, diff, <b>checksumming,</b> disassemblers) can themselves be compromised to conceal the backdoor, for example detecting that the subverted binary is being <b>checksummed</b> and returning the expected value, not the actual value. To conceal these further subversions, the tools must also conceal the changes in themselves - for example, a subverted checksummer must also detect if it is <b>checksumming</b> itself (or other subverted tools) and return false values. This leads to extensive changes {{in the system and}} tools being needed to conceal a single change.|$|R
25|$|CVN (calibration {{verification}} number): Number used {{to verify}} {{the integrity of the}} vehicle software. The manufacturer is responsible for determining the method of calculating CVN(s), e.g. using <b>checksum.</b>|$|E
25|$|Each Nintendo 64 Game Pak {{contains}} a lockout chip (conceptually {{similar to the}} 10NES) to prevent manufacturers from creating unauthorized copies of games and discourage production of unlicensed games. Unlike previous versions, the N64 lockout chip {{contains a}} seed value {{which is used to}} calculate a <b>checksum</b> of the game's boot code. To discourage playing of copied games by piggybacking on a real Game Pak, Nintendo produced five different versions of the chip. During the boot process, and occasionally while the game is running, the N64 computes the <b>checksum</b> of the boot code and verifies it with the lockout chip in the Game Pak, failing to boot if the check fails.|$|E
25|$|The first {{character}} of the serial number is a letter which uniquely identifies the country that issues the note. The remaining 11 characters are numbers which, when their digital root is calculated, give a <b>checksum</b> also particular to that country.|$|E
50|$|Create <b>checksums</b> {{for data}} {{verification}} of ISOs.|$|R
5000|$|... uses {{cryptographic}} <b>checksums</b> {{of files}} to detect modifications, ...|$|R
5000|$|Error {{detection}} with <b>checksums</b> {{generation and}} verification, like CRC ...|$|R
25|$|A CRC is a <b>checksum</b> in {{a strict}} {{mathematical}} sense, {{as it can}} be expressed as the weighted modulo-2 sum of per-bit syndromes, but that word is generally reserved more specifically for sums computed using larger moduli, such as 10, 256, or 65535.|$|E
25|$|The mapping between {{messages}} and barcodes {{is called a}} symbology. The specification of a symbology includes the encoding of the message into bars and spaces, any required start and stop markers, {{the size of the}} quiet zone required to be before and after the barcode, and the computation of a <b>checksum.</b>|$|E
25|$|<b>Checksum</b> – Each note has {{a unique}} serial number. The {{remainder}} from dividing the serial number by 9 gives <b>checksum</b> corresponding to the initial letter indicated on the note. Using {{a variation of the}} divisibility rule shortcut, the remainder from division by 9 can easily be found by adding the constituent digits and, if the sum still does not make the remainder obvious, adding the digits of the sum. Alternatively, substituting the letter with its ASCII value makes the resulting number exactly divisible by 9. Taking the same example, Z10708476264, the ASCII code for Z is 90, so the resulting number is 9010708476264. Dividing by 9 yields a remainder of 0. Using the divisibility rule again, the result can be checked speedily since the addition of all digits gives 54; 5 + 4 = 9—so the number is divisible by 9, or 9010708476264 modulo 9 is 0.|$|E
5000|$|<b>Checksums</b> on both {{data and}} metadata, and {{background}} scrubbing.|$|R
2500|$|... fsck cannot always {{validate}} {{and repair}} data when <b>checksums</b> are stored with data (often {{the case in}} many file systems), because the <b>checksums</b> may also be corrupted or unreadable. ZFS always stores <b>checksums</b> separately from the data they verify, improving reliability {{and the ability of}} scrub to repair the volume. ZFS also stores multiple copies of data – metadata in particular may have upwards of 4 or 6 copies (multiple copies per disk and multiple disk mirrors per volume), greatly improving the ability of scrub to detect and repair extensive damage to the volume, compared to fsck.|$|R
5000|$|Besides <b>checksumming,</b> {{features}} of modern file systems that HFS+ lacks include: ...|$|R
25|$|NAND flash {{architecture}} {{was introduced}} by Toshiba in 1989. These memories are accessed much like block devices, such as hard disks. Each block consists {{of a number of}} pages. The pages are typically 512 or 2,048 or 4,096 bytes in size. Associated with each page are a few bytes (typically 1/32 of the data size) {{that can be used for}} storage of an error correcting code (ECC) <b>checksum.</b>|$|E
25|$|Every Lotto ticket has a 16-digit Winning Wheel number (e.g. 123-45678901-20XX) {{which is}} the same as the ticket's serial number, except that the two digit <b>checksum</b> is {{replaced}} with XX for security reasons. Every draw, a serial number is drawn at random. The winner is awarded an all expenses paid trip to the studio in Auckland where they appear on the show and spin the eponymous wheel to determine their prize.|$|E
25|$|Hierarchical checksumming of {{all data}} and metadata, {{ensuring}} that the entire storage system can be verified on use, and confirmed to be correctly stored, or remedied if corrupt. Checksums are stored with a block's parent block, rather than with the block itself. This contrasts with many file systems where checksums (if held) are stored with the data so that if the data is lost or corrupt, the <b>checksum</b> {{is also likely to}} be lost or incorrect.|$|E
50|$|Check digits and parity bits {{are special}} cases of <b>checksums,</b> {{appropriate}} for small {{blocks of data}} (such as Social Security numbers, bank account numbers, computer words, single bytes, etc.). Some error-correcting codes are based on special <b>checksums</b> which not only detect common errors but also allow the original data to be recovered in certain cases.|$|R
5000|$|Calculate files <b>checksums</b> in MD5, CRC32, SHA, SHA-256, SHA-384, SHA-512, Adler32, MD2 ...|$|R
5000|$|... sv4crc - The System V release 4 cpio with file crc <b>checksums.</b>|$|R
25|$|SQL Server buffers {{pages in}} RAM to {{minimize}} disk I/O. Any 8KB page can be buffered in-memory, and {{the set of}} all pages currently buffered is called the buffer cache. The amount of memory available to SQL Server decides how many pages will be cached in memory. The buffer cache is managed by the Buffer Manager. Either reading from or writing to any page copies it to the buffer cache. Subsequent reads or writes are redirected to the in-memory copy, rather than the on-disc version. The page is updated on the disc by the Buffer Manager only if the in-memory cache has not been referenced for some time. While writing pages back to disc, asynchronous I/O is used whereby the I/O operation is done in a background thread so that other operations {{do not have to}} wait for the I/O operation to complete. Each page is written along with its <b>checksum</b> when it is written. When reading the page back, its <b>checksum</b> is computed again and matched with the stored version to ensure the page has not been damaged or tampered with in the meantime.|$|E
25|$|As {{all stripes}} are of {{different}} sizes, RAID-Z reconstruction has to traverse the filesystem metadata {{to determine the}} actual RAID-Z geometry. This would be impossible if the filesystem and the RAID array were separate products, whereas it becomes feasible {{when there is an}} integrated view of the logical and physical structure of the data. Going through the metadata means that ZFS can validate every block against its 256-bit <b>checksum</b> as it goes, whereas traditional RAID products usually cannot do this.|$|E
25|$|As the {{standard}} definition interface carries no <b>checksum,</b> CRC, or other data integrity check, an EDH (Error Detection and Handling) packet may be optionally {{placed in the}} vertical interval of the video signal. This packet includes CRC values for both the active picture, and the entire field (excluding those lines at which switching may occur, and which should contain no useful data); equipment can compute their own CRC and compare it with the received CRC in order to detect errors.|$|E
40|$|Data copying and <b>checksumming</b> are {{the most}} {{expensive}} operations on hosts performing high-bandwidth network I/O over a high-speed network. Under some conditions, outboard buffering and <b>checksumming</b> can eliminate accesses to the data, thus making communication less expensive and faster. One of the scenarios in which outboard buffering and <b>checksumming</b> pays off is the common case of applications accessing the network using the Berkeley sockets interface and the Internet protocol stack. In this paper we describe the host software for a host interface with outboard buffering and <b>checksumming</b> support. The platform used is DEC Alpha workstations with a Turbochannel I/O bus and running the DEC OSF/ 1 operating system. Our implementation does not only achieve "single copy" communication for applications that use sockets, but it also interoperates efficiently with in-kernel applications and other network devices. Measurements show that for large reads and writes the single-copy path thr [...] ...|$|R
40|$|We have {{developed}} an automated, compile time approach to generating error-detecting parallel programs. The compiler is used to identify statements implementing affine transformations within the program and automatically insert code for computing, manipulating, and comparing <b>checksums</b> in order to check the correctness of the code implementing affine transformations. Statements which do not implement affine transformations are checked by duplication. <b>Checksums</b> are reused from one loop to the next if this is possible, rather than recomputing <b>checksums</b> for every statement. A global dataflow analysis is performed {{in order to determine}} points at which <b>checksums</b> need to be recomputed. We also use a novel method of specifying the data distributions of the check data using directives provided by the High Performance Fortran (HPF) standard so that the computations on the original data and the corresponding check computations are performed on different processors. Results are presented on an Intel Paragon distributed memory multicomputer...|$|R
2500|$|NILFS a Linux {{file system}} with <b>checksumming</b> (but not scrubbing), also {{supporting}} snapshots ...|$|R
25|$|Periodic {{explicit}} object packing: Git stores each {{newly created}} object {{as a separate}} file. Although individually compressed, this takes {{a great deal of}} space and is inefficient. This is solved by the use of packs that store a large number of objects in one file (or network byte stream) called packfile, delta-compressed among themselves. Packs are compressed using the heuristic that files with the same name are probably similar, but do not depend on it for correctness. A corresponding index file is created for each packfile, telling the offset of each object in the packfile. Newly created objects (newly added history) are still stored singly, and periodic repacking is needed to maintain space efficiency. The process of packing the repository can be very computationally costly. By allowing objects to exist in the repository in a loose, but quickly generated format, Git allows the costly pack operation to be deferred until later, when time matters less, e.g., the end of a work day. Git does periodic repacking automatically but manual repacking is also possible with the git gc command. For data integrity, both packfile and its index have SHA-1 <b>checksum</b> inside, and also the file name of packfile contains a SHA-1 <b>checksum.</b> To check integrity, run the git fsck command.|$|E
25|$|This {{abstraction}} {{also allows}} upper layers {{to provide services}} that the lower layers do not provide. While the original OSI model was extended to include connectionless services (OSIRM CL), IP is not designed to be reliable and is a best effort delivery protocol. This means that all transport layer implementations must choose whether or how to provide reliability. UDP provides data integrity via a <b>checksum</b> but does not guarantee delivery; TCP provides both data integrity and delivery guarantee by retransmitting until the receiver acknowledges the reception of the packet.|$|E
25|$|The stolen passwords, {{which were}} hashed (i.e. just a <b>checksum</b> was stored, {{allowing}} testing whether a given password {{is the correct}} one), were cracked and posted on a Russian password forum later on that day. By the morning of June 6, passwords for thousands of accounts were available online in plain text. Graham Cluley of the internet security firm Sophos warned that the leaked passwords {{could be in the}} possession of criminals by 6 June. LinkedIn said, in an official statement, that they would email all its members with security instructions and instructions on how they could reset their passwords.|$|E
5000|$|ZFS — a {{file system}} which {{performs}} automatic file integrity checking using <b>checksums</b> ...|$|R
50|$|Metalink support {{which contain}} {{multiple}} URLs for downloads, along with <b>checksums</b> and other information.|$|R
5000|$|... uswsusp {{supports}} image <b>checksumming,</b> data compression, disk encryption, {{and integration}} with Splashy and fbsplash.|$|R
