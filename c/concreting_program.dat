0|385|Public
5000|$|After {{this initial}} phase, more <b>concrete</b> <b>programs</b> were developed, including: ...|$|R
40|$|Compilation (e. g.,see [35, 53]) [...] From a given source (<b>concrete)</b> <b>program,</b> {{obtain an}} {{abstract}} <b>program.</b> [...] <b>Concrete</b> semantics of abstract programjabstract semantics of <b>concrete</b> <b>program.</b> [...] Evaluate abstract program using some complete evaluationstrategy. 34 Applications: Program AnalysisExample: Groundness Analysis (from [25]) append([],Ys,Ys). append([X [...] -Xs],Ys,[X [...] -Zs]) :- append(Xs,Ys,Zs). +gappend(g,Y,Y). gappend(X 1,Ys,Z 1) :- iff(X 1,X,Xs), iff(Z 1,X,Zs), [...] ...|$|R
40|$|Abstract. This paper {{concerns}} automatically verifying safety {{properties of}} concurrent programs. In our work, the safety {{property of interest}} is to check for multi-location data races in concurrent Java programs, where a multi-location data race arises when a program is supposed to maintain an invariant over multiple data locations, but accesses/updates are not protected correctly by locks. The main technical challenge that we address is how to generate a program model that retains (at least some of) the synchronization operations of the <b>concrete</b> <b>program,</b> when the <b>concrete</b> <b>program</b> uses dynamic memory allocation. In the presence of dynamic memory allocation, the finite number of abstract objects of the abstract program must represent the unbounded number of concrete objects that the <b>concrete</b> <b>program</b> may allocate, and thus by the pigeon-hole principle some o...|$|R
40|$|The goal {{of program}} {{verification}} {{is to ensure}} software reliability by establishing a mathematical proof which guarantees that the software behaves correctly. Program analysis tools assist the developer in the verification process. Ideally a program analysis should be applicable {{to a wide range}} of verification problems without imposing a high burden on its users, i. e., without requiring deep mathematical knowledge and experience in program verification. A big step forward towards this ideal has been achieved by combining abstract interpretation with techniques for automated reasoning. In abstract interpretation one transforms the <b>concrete</b> <b>program</b> into an abstract program. The abstract program enables the analysis to statically collect information over all possible executions of the <b>concrete</b> <b>program.</b> This information is used to automatically verify the correctness of the <b>concrete</b> <b>program.</b> Abstract interpretation increases the degree of automation in verification by shifting the burden of formally reasoning about programs from the developer to the designer of the program analysis. Automated reasoning pushes the degree of automation even further. It enables the automatic construction of the abstraction for a specific program and a specifi...|$|R
50|$|Alma-0 can {{be viewed}} {{not only as a}} {{specific}} and <b>concrete</b> <b>programming</b> language proposal, but also {{as an example of a}} generic method for extending any imperative programming language with features that support declarative programming.|$|R
50|$|The {{association}} also aims {{at making}} <b>concrete</b> <b>programs</b> of exchange between Namibian artists and their French counterparts. The {{purpose is to}} support cross-country understanding through culture, art and music, and encourage the broadest possible participation in cultural activities for members.|$|R
40|$|Linearisability {{has become}} the {{standard}} safety criterion for concurrent data structures ensuring {{that the effect of}} a concrete operation takes place after the execution some atomic statement (often referred to as the linearisation point). Identification of linearisation points is a non-trivial task and it is even possible for an operation to be linearised by the execution of other concurrent operations. This paper presents a method for verifying linearisability that does not require identification of linearisation points in the concrete code. Instead, we show that the <b>concrete</b> <b>program</b> is a refinement of some coarse-grained abstraction. The linearisation points in the abstraction are straightforward to identify and the linearisability proof itself is simpler due to the coarse granularity of its atomic statements. The <b>concrete</b> fine-grained <b>program</b> is a refinement of the coarse-grained program, and hence is also linearisable because every behaviour of the <b>concrete</b> <b>program</b> is a possible behaviour its abstraction. Comment: 37 pages, 13 figure...|$|R
40|$|This Paper Focuses on the <b>concrete</b> {{industry}} and <b>programs</b> that prepare college students {{for their future}} in it and to try and implement some sort of <b>concrete</b> <b>program</b> at Cal Poly. The idea to make Concrete Industry Management first came along at Middle Tennessee State University in 1996, {{but only a few}} other programs have started at other schools since then. These programs focus on skills for graduates to enter the concrete industry in production, project management, sales, and marketing. They are structured similar to the way Construction Management programs are structured and have similar courses like estimating, sustainability, and project management as well. Data on program curriculum, industry support, and entry level jobs after graduation was collected from the four schools around the country that have <b>Concrete</b> Industry Management <b>programs.</b> A survey was given to Cal Poly Students in Construction Management. Their responses helped conclude the research that was needed to lay out the structure of a <b>concrete</b> <b>program</b> that could be implemented for Cal Poly students...|$|R
50|$|The {{study of}} computability theory in {{computer}} science {{is closely related to}} the study of computability in mathematical logic. There is a difference of emphasis, however. Computer scientists often focus on <b>concrete</b> <b>programming</b> languages and feasible computability, while researchers in mathematical logic often focus on computability as a theoretical concept and on noncomputability.|$|R
40|$|We {{introduce}} a proof method for safety {{properties in the}} setting of refinement of imperative programs `a la Hoare-He-Sanders and Kinoshita-Power. In order to show that the safety property of the abstract programs implies the corresponding safety property of the <b>concrete</b> <b>program,</b> we {{introduce a}} notion of 'semantic cumulative'. This leads to a hybrid method of verification which consists of model checking and theorem proving. To show the safety of the <b>concrete</b> <b>program,</b> our main result says that one has only to show the safety of the abstract program, and that can be done by the model checking technique, thanks to the extraordinary reduction of the number of states. Our main theorem, in turn, can be shown by a theorem prover, if one wants a machine checked verification. As an example, we report our validation of on-the-fly garbage collection using the proposed method...|$|R
40|$|International audienceWe {{propose a}} language-independent {{symbolic}} execution framework for languages endowed with a formal operational semantics based on term rewriting. Starting from a given {{definition of a}} language, a new language definition is generated, with the same syntax as the original one, but whose semantical rules are transformed in order to rewrite over logical formulas denoting possibly infinite sets of program states. Then, the symbolic execution of <b>concrete</b> <b>programs</b> is, by definition, {{the execution of the}} same programs with the symbolic semantics. We prove that the symbolic execution thus defined has the properties naturally expected from it (with respect to <b>concrete</b> <b>program</b> execution). A prototype implementation of our approach was developed in the K Framework. We demonstrate the tool's genericity by instantiating it on several languages, and illustrate it on the reachability analysis and model checking of several programs...|$|R
40|$|Abstract. Meta {{programming}} can be {{facilitated by}} the ability to represent <b>program</b> fragments in <b>concrete</b> syntax instead of abstract syntax. The resulting meta programs are more self-documenting. One caveat in <b>concrete</b> meta <b>programming</b> is the syntactic separation between the meta language and the object language. To solve this problem, many meta programming systems use quoting and anti-quoting to indicate precisely where level switches occur. These “syntactic hedges ” can obfuscate the <b>concrete</b> <b>program</b> fragments. This paper describes an algorithm for inferring quotes, such that the meta programmer no longer needs to explicitly indicate transitions between the meta and object languages. ...|$|R
5000|$|Flowers in <b>Concrete,</b> Design <b>Program,</b> Fine Arts Dept., Indiana University, 1966 ...|$|R
2500|$|The {{study of}} computability theory in {{computer}} science {{is closely related to}} the study of computability in mathematical logic. [...] There is a difference of emphasis, however. [...] Computer scientists often focus on <b>concrete</b> <b>programming</b> languages and feasible computability, while researchers in mathematical logic often focus on computability as a theoretical concept and on noncomputability.|$|R
5000|$|All {{participants}} of the Forum have signed a declaration entitled [...] "CISM Aosta Call-to-Action 2010 on Sport for Peace" [...] summarizing the common wishes and asking all institutions to formally establish a bilateral and mutual agreement {{in order to}} undertake <b>concrete</b> <b>programs</b> aimed at sharing good practices and effectively implementing Sport for Peace programs.|$|R
40|$|Writing correct shared-memory {{concurrent}} {{programs is}} hard. Not only must a programmer reason about the correctness of the sequential execution of code, {{but also about}} the possible side effects caused by interleaved execution of concurrently executing threads. Incorrect use of synchronization primitives can lead to data-consistency errors, which can have drastic consequences (cf. ~the Northeast Blackout of 2003). This dissertation presents techniques to verify statically that the programmer's use of synchronization primitives preserves data consistency. The notion of data consistency used throughout the dissertation is atomic-set serializability (AS-serializability), which was first proposed by Vaziri et al. (2006). AS-serializability is a property of a program execution, and is a relaxation of serializability. An execution is serializable if its outcome is equivalent to an execution where all transactions are executed serially. AS-serializability relaxes serializability to be only with respect to specific memory locations. The approach taken is to use software model checking to verify that every possible execution of a concurrent program is AS-serializable. First, an abstract program is generated from a <b>concrete</b> <b>program.</b> The abstract program is defined such that it over-approximates the set of behaviors of the <b>concrete</b> <b>program.</b> Second, a software model checker explores all possible executions of the abstract program. The challenge is to define abstractions and techniques that account for the multitude of sources of unboundedness in a <b>concrete</b> <b>program.</b> <b>Concrete</b> <b>programs</b> have dynamic memory allocation, recursion, dynamic thread creation, and reentrant locks, to name a few. The contributions of the dissertation are generic techniques to permit model checking to be performed in the presence of several sources of unboundedness. My research addressed the problem of determining whether all possible executions of a certain class of models of concurrent Java programs are AS-serializable. Somewhat surprisingly, given the many sources of unboundedness allowed in the models considered, I was able to show that the problem is decidable, and gave a practical algorithm for the problem. The technique has been implemented in a tool called Empire, which has been used to find known bugs in concurrent Java programs...|$|R
40|$|These {{proceedings}} {{are divided}} into two sections that explore collaboration between schools and communities. In Part I, the first four papers, analytic frameworks are described that provide different perspectives on collaboration. In Part II, descriptions of <b>concrete</b> <b>programs</b> and advice for developing better school-community relations are offered. The following papers are included: (1) "Policy Options for Building School-Communit...|$|R
40|$|Meta {{programming}} can be {{facilitated by}} the ability to represent <b>program</b> fragments in <b>concrete</b> syntax instead of abstract syntax. The resulting meta programs are more self-documenting. One caveat in <b>concrete</b> meta <b>programming</b> is the syntactic separation between the meta language and the object language. To solve this problem, many meta programming systems use quoting and anti-quoting to indicate precisely where level switches occur. These 2 ̆ 2 syntactic hedges 2 ̆ 2 can obfuscate the <b>concrete</b> <b>program</b> fragments. This paper describes an algorithm for inferring quotes, such that the meta programmer no longer needs to explicitly indicate transitions between the meta and object languages...|$|R
40|$|One of {{the most}} {{important}} events {{in the life of the}} Soviet people was the 22 nd Congress of the Communist Party of the Soviet Union, which adopted a <b>concrete</b> <b>program</b> for the comprehensive building of communism. The Party Program shows that a decisive condition for the triumph of communism is the creation of the material and technical base for communist society. ...|$|R
40|$|This article {{describes}} {{a simple and}} ecient way of using a logic programming language with built-in tabulation for general purpose semantics-based program analysis. The simplicity of the method {{is based on a}} clear separation of abstraction and control: conceptually, a <b>concrete</b> <b>program</b> is executed over an abstract domain and the tabulation mechanism avoids recomputation, ensures termination and collects the result...|$|R
40|$|We {{give the}} {{description}} of a verification tool taking boolean programs of guarded commands as input; internal representation of programs are sets of Binary Decision Diagrams (BDD) (one for each guarded command). It allows to construct an abstract program of the same form obtained using an abstraction relation given by a boolean expression on "concrete" and "abstract" variables. The tool allows the verification of CTL formulas on programs. We illustrate its possibilities on an example. 1 Introduction In the domain of program verification an obvious idea is to verify some abstract program instead of the complete specification (called <b>concrete</b> <b>program)</b> depending on the properties to be verified. The motivation {{is to make the}} representation of the program model smaller and this for two reasons: one is to make the verification faster; the other is that in most practical cases the model of the <b>concrete</b> <b>program</b> is too large to be verified, whereas an abstraction of it may be sufficiently sma [...] ...|$|R
40|$|In {{this paper}} we explain, {{independent}} of any formalism, how {{to construct an}} expression in a formal system that ‘does something with itself’. As an application of this procedure we show how to construct a program that writes its own text, lay-out included. The emphases is on the systematic development in <b>concrete</b> <b>programming</b> languages, {{rather than on the}} abstract theory or the end result (which, indeed, are not new at all) ...|$|R
40|$|We {{describe}} {{our work}} on the prototype AutoJML tool which automatically derives JML (Java Modelling Language) specifications from UML state diagrams. UML is widely used for modelling Object-Oriented systems on an abstract level. It {{should be possible to}} test whether <b>concrete</b> <b>program</b> code actually implements a UML model. The generated JML specifications can be used for this. There exist tools to verify whether Java code conforms to a JML specification. ...|$|R
40|$|We {{present an}} {{automated}} technique for generating compiler optimizations from examples of <b>concrete</b> <b>programs</b> {{before and after}} improvements {{have been made to}} them. The key technical insight of our technique is that a proof of equivalence between the original and transformed <b>concrete</b> <b>programs</b> informs us which aspects of the programs are important and which can be discarded. Our technique therefore uses these proofs, which can be produced by translation validation or a proof-carrying compiler, as a guide to generalize the original and transformed programs into broadly applicable optimization rules. We present a category-theoretic formalization of our proof generalization technique. This abstraction makes our technique applicable to logics besides our own. In particular, we demonstrate how our technique {{can also be used to}} learn query optimizations for relational databases or to aid programmers in debugging type errors. Finally, we show experimentally that our technique enables programmers to train a compiler with application-specific optimizations by providing concrete examples of original programs and the desired transformed programs. We also show how it enables a compiler to learn efficient-to-run optimizations from expensive-to-run super-optimizers...|$|R
40|$|We {{present a}} program logic for verifying the heap {{consumption}} of programs written in an abstract {{representation of the}} Java virtual machine language. The logic is defined by an expansion into the more general program logic presented in [2], but <b>concrete</b> <b>program</b> program verification may be performed purely on the abstract level, without recourse to the base logic. Format and interpretation of assertions closely match the interpretation of [8]'s type system for functional programs where the consumption of heap space is bounded by a linear function on the input size. The derived proof rules enable us to replay typing derivations in a theorem prover, given assertions about individual methods. The resulting verification conditions are of limited complexity, and may be discharged without significant programmer intervention...|$|R
40|$|This book {{illustrates}} how modern media and internet applications facilitate collaboration {{on the job}} and make work easier. After detailing the requirements of work organization, the book discusses easily implementable solution strategies and <b>concrete</b> <b>programs.</b> Chapter topics include: an introduction to Web 2. 0, monitoring, time management, managing notes and bibliographies, mind maps, collaboration, and content sharing.; Julia Bergmann, Freiberufliche Trainerin für Informationskompetenz, Bremen und Jürgen Plieninger, Leiter der Bibliothek des Instituts für Politikwissenschaft, Tübinge...|$|R
40|$|Abstract. RP {{programs}} are imperative programs with parallelism and recursion {{and only a}} limited way of synchronizing parallel processes. The formal framework we propose here combines (1) a formal operational model of abstract programs (or RP schemes), (2) a set of decision meth-ods {{for the analysis of}} RP schemes, (3) a formal operational model for the interpreted programs, and (4) translation results stating how some behavioural properties of the <b>concrete</b> <b>programs</b> can be correctly checked on the corresponding scheme. ...|$|R
40|$|The use of {{the formal}} design method FOCUS is {{illustrated}} by an example development of the so-called Stenning-protocol. The development process starts from global, non-constructive service specifications and ends in executable programs of the protocol entities. The four abstraction levels of FOCUS [...] trace specification, functional specification, abstract <b>program,</b> and <b>concrete</b> <b>program</b> [...] are covered. Special emphasis is put on the design steps within and between the first two abstraction levels, which are also proven correct...|$|R
40|$|The goal of {{the paper}} is to demystify supercompilation by {{presenting}} the complete source code of a simple, yet operational supercompiler. This may be helpful for a working programmer giving him an opportunity to familiarize himself with supercompilation formulated {{in terms of his}} "native language", i. e. in form of <b>concrete</b> <b>programs.</b> Besides, these programs are complete and ready to run, so that the supercompilation techniques described in the paper can be immediately tried in practice...|$|R
5000|$|Molmann defines his “socialism” as {{responding}} to five vicious {{circles in the}} world today: poverty, force, racial and cultural alienation, industrial pollution of nature, senselessness and godforsakenness. Thus socialism no longer rests on a <b>concrete</b> <b>program</b> but becomes a “symbol for large and grand ideals.”(p270) He “exhibits high confidence in governmental control over life... commends the distribution of wealth and a no-growth economy... respects political and moral-cultural liberties, but not economic liberties... a return to premodern conceptions.”(p270) ...|$|R
40|$|This thesis {{will deal}} with the issues of {{education}} and development of human resources in the Czech republic. There will be defined a developnemnt of human resources and its support by the Czech republic {{in the first part}} of the thesis. Information about funds of European Union together with structural funds created for period 2007 - 2013 will be discussed. The second part of this thesis will be focused on a <b>concrete</b> <b>program,</b> which will be analyzed by quantitative and qualitative research...|$|R
40|$|The paper {{summarizes}} good {{experiences with}} motivating students for special activities, students' research projects (donated by the Grant Agency of Czech Ministry of Education, Culture and Youth {{and by the}} Grant Agency of the Faculty of Mechanical Engineering, VSB-TU Ostrava), students competitions (organized by our Department {{for the last seven}} years), student exchange programs, etc. All these activities are helpful for increasing the number of engineering students and helps for their study process and professional goals. The paper shoves <b>concrete</b> <b>programs</b> and results acquired at the Department of Control Systems and Instrumentation...|$|R
40|$|The point free {{relational}} calculus has proved quite {{successful in the}} derivation of general programming principles [1, 5]. When applied to specific examples, however, it can be somewhat painful to use, due to {{the large number of}} combinators required. In this note, we explore the suggestion that for specific examples, it may be preferable to conduct relational derivations of <b>concrete</b> <b>programs</b> in a pointwise calculus of nondeterministic mappings. The presentation is is largely informal: we introduce concepts and notations through an example, and we do not spell out a formal semantics of the calculus...|$|R
40|$|Some {{institutions}} of higher education have begun to implement agile operational strategies as they work to take advantage of new technologies and respond to new demands made from their various constituencies. Key to the success of these agile strategies is the ability of the faculty to create an agile learning environment. This paper focuses {{on the role of the}} faculty developer in creating that agile environment. It presents <b>concrete</b> <b>programming</b> suggestions and a model for faculty developers to follow as they assume the role of helping faculty become agile...|$|R
5000|$|On April 13, 1980, {{at the age}} of 22, Mario Vega {{was sent}} to Santa Ana for a church of the Mision Cristiana Elim Internacional. [...] In July, he was ordained pastor by Sergio Daniel Solórzano Aldana.In 1997, Mario Vega became senior pastor of Mision Cristiana Elim Internacional, San Salvador. He is {{considered}} as a resource person to shed light on certain social issues. It is also involved in the fight against poverty by setting up <b>concrete</b> <b>programs</b> with the Church; Training in employment, environmental education, testing for HIV.|$|R
40|$|Dynamic {{invariant}} detection is {{a software}} analysis technique that uses traces of function entry and exit from executing programs and infers partial specifications {{that characterize the}} observed behavior. The specifications are reported as logical precondition and postcondition expressions (invariants) that relate arguments, instance variables, and results. Detectors typically generate large collections of invariants, among which most are true but few are interesting or useful. Refining this flood of invariants into a useful subset often requires manual tuning through configuration options and modification of the program under analysis. Our research asks whether we can improve dynamic invariant detection by enabling explicit abstractions to be declared and applied to a program under analysis and whether this is practical; this dissertation shows that it is indeed practical and useful. Given a <b>concrete</b> <b>program</b> we can synthesize a model program composed of functions and modules that are abstractions of selected concrete modules. When we execute the model program in parallel with its underlying <b>concrete</b> <b>program</b> and apply dynamic invariant detection, we obtain abstracted invariants that can reveal {{the behavior of the}} underlying <b>concrete</b> <b>program.</b> We developed the Alembic system to support and experiment with the above technique, enabling a practical method for steering the invariant detection process and shaping the analysis to produce more refined results than obtainable via traditional means. Alembic provides a simple language for defining abstractions and managing detection experiments; the system generates the necessary instrumentation, representation classes, and functions, freeing the analyst to focus on the expression of abstractions and detection experiments. Alembic currently leverages the invariant detection capability of Daikon, a powerful first-generation detector, to analyze synthetic traces on abstractions. However, the principles we demonstrate apply to any detector and language that observes function entry and exit. We present some applications of this technique to example problems and then evaluate Alembic on production code such as the Guava class library. Our research suggests new uses for existing detectors and enables the design and evaluation of features to inform the next generation of dynamic invariant detection systems. This dissertation includes previously unpublished co-authored material...|$|R
