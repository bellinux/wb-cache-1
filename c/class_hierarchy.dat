720|725|Public
25|$|While a <b>class</b> <b>hierarchy</b> is {{reflected}} in stratified housing structures, military classism differs from traditional class structures in some significant ways - namely, schooling and access to quality healthcare. Children of military personnel attend the same base schools regardless of rank, creating peer cultures that are usually not class-based, and providing equal access to educational resources. Similarly, all military personnel receive the same quality of healthcare by the same providers.|$|E
25|$|After the Industrial Revolution, {{there was}} a {{dramatic}} decline in young men working in agriculture. Instead they were attracted by the higher wages available in industries such as iron. In 1829, the depression strongly affected Merthyr. Workers' rights did not exist; and sudden dismissal, wage reductions and short-term working had always been imposed by the ironmasters to maximise their profits. The sudden downturn in the market saw the ironmasters quickly dismiss surplus workers and cut the wages of those in work. The working classes were then immediately plunged into hardship, widening the gap in <b>class</b> <b>hierarchy.</b>|$|E
2500|$|In an interview, Monson {{expressed}} his political views as follows: [...] "I am an anarchist, {{someone who would}} like to do away with all <b>class</b> <b>hierarchy</b> in society and the institutions that promote this inequality." [...] Monson has received sponsorship from AK Press and has several anarchist symbols and Communist images tattooed on his body.|$|E
50|$|Note that in {{object-oriented}} programming languages, such as Java, a disjoint union {{can be expressed}} by designing <b>class</b> <b>hierarchies.</b> However, as opposed to <b>class</b> <b>hierarchies,</b> ADTs are closed. This makes ADT extensible {{in a way that}} is orthogonal to the extensibility of <b>class</b> <b>hierarchies.</b> <b>Class</b> <b>hierarchies</b> can be extended with new subclasses but no new methods, while ADTs can be extended to provide new behavior for all existing constructors, but do not allow defining new constructors.|$|R
5000|$|... an {{algorithm}} {{needs to}} work across several independent <b>class</b> <b>hierarchies.</b>|$|R
40|$|This paper {{discusses}} how facet-like structures {{occur as}} a commonplace feature {{in a variety of}} computer science disciplines as a means for structuring <b>class</b> <b>hierarchies.</b> The paper then focuses on a mathematical model for facets (and <b>class</b> <b>hierarchies</b> in general), called formal concept analysis, and discusses graphical representations of faceted systems based on this model...|$|R
2500|$|Society in the Japanese [...] "Tokugawa period" [...] (Edo society), {{unlike the}} shogunates before it, {{was based on}} the strict <b>class</b> <b>hierarchy</b> {{originally}} established by Toyotomi Hideyoshi. The daimyōs (feudal lords) were at the top, followed by the warrior-caste of samurai, with the farmers, artisans, and traders ranking below. In some parts of the country, particularly smaller regions, daimyōs and samurai were more or less identical, since daimyōs might be trained as samurai, and samurai might act as local lords. Otherwise, the largely inflexible nature of this social stratification system unleashed disruptive forces over time. Taxes on the peasantry were set at fixed amounts which did not account for inflation or other changes in monetary value. As a result, the tax revenues collected by the samurai landowners were worth less and less over time. This often led to numerous confrontations between noble but impoverished samurai and well-to-do peasants, ranging from simple local disturbances to much bigger rebellions. None, however, proved compelling enough to seriously challenge the established order until the arrival of foreign powers.|$|E
50|$|Understand and {{implement}} a given <b>class</b> <b>hierarchy.</b>|$|E
5000|$|... {{the class}} that is the base class of the {{exception}} <b>class</b> <b>hierarchy.</b>|$|E
40|$|In this report, we {{establish}} essential closures in <b>class</b> <b>hierarchies</b> of database {{systems that}} support set operations, such as union and intersection, in their query language. In particular, we rigorously demonstrate that multiple inheritance is an implementation requirement, {{as is the}} formal treatment of the <b>class</b> <b>hierarchies</b> as lattices with defined least upper, and greatest lower, bound operators...|$|R
40|$|Inheritance {{reasoning}} is ubiquitous. Hierarchies provide a concise encoding {{of much of}} our common sense knowledge. Despite standard class libraries, such as Java Collections Framework (JCF) and C++ Standard Template Libraries (STD), are widely used for software construction, there have been notably few efforts {{to make use of}} design knowledge embodied in standard <b>class</b> <b>hierarchies</b> to assist software development. We describe an approach to developing an abstract model of software component through successive model transformations with standard <b>class</b> <b>hierarchies</b> as guidance. We also demonstrate that reasoning with standard <b>class</b> <b>hierarchies</b> helps the software developer seek a feasible solution to address design concerns at the component level...|$|R
5000|$|Doxygen uses Graphviz to {{generate}} diagrams including <b>class</b> <b>hierarchies</b> and collaboration for source code.|$|R
5000|$|The {{following}} diagram {{illustrates the}} <b>class</b> <b>hierarchy</b> {{of the various}} graphic templates defined by the UML. Structure diagrams define the static structure of an object: {{its place in the}} <b>class</b> <b>hierarchy,</b> its relation to other objects, etc. Behavior diagrams specify the dynamic aspects of the model, business process logic, coordination and timing of distributed objects, etc.|$|E
5000|$|Source browser: browse single files or whole {{project by}} module or <b>class</b> <b>hierarchy.</b>|$|E
5000|$|The keyword [...] denotes that {{a method}} {{can be called}} from code in other classes, or that a class may be used by classes outside the <b>class</b> <b>hierarchy.</b> The <b>class</b> <b>hierarchy</b> {{is related to the}} name of the {{directory}} in which the [...]java file is located. This is called an access level modifier. Other access level modifiers include the keywords [...] and [...]|$|E
5000|$|In ADO.NET, IDbCommand.CreateParameter is {{an example}} of the use of factory method to connect {{parallel}} <b>class</b> <b>hierarchies.</b>|$|R
50|$|Parallel <b>class</b> <b>hierarchies</b> {{often require}} objects from one {{hierarchy}} {{to be able}} to create appropriate objects from another.|$|R
40|$|Abstract. <b>Class</b> <b>hierarchies,</b> though {{theoretically}} reusable, {{have generally}} not seen much practical reuse in applications, {{due in part}} to the inflexibility of the inheritance relationship. We present a technique, base class injection, that allows the creation of generative <b>class</b> <b>hierarchies</b> that may be adapted by adding new methods, data members, and ancestor classes without modification to the class library code; an implementation of this technique in the C++ language is given. ...|$|R
50|$|Provides a package-based {{browsing}} {{environment as}} an alternative to a conventional Smalltalk <b>class</b> <b>hierarchy</b> browser.|$|E
5000|$|... #Caption: Promotional poster from 1993 showing {{parts of}} the <b>class</b> <b>hierarchy</b> for the IUICL v2.01 ...|$|E
50|$|Using {{factories}} {{instead of}} constructors or prototypes {{allows one to}} use polymorphism for object creation, not only object use. Specifically, using factories provides encapsulation, and means the code is not tied to specific classes or objects, and thus the <b>class</b> <b>hierarchy</b> or prototypes can be changed or refactored without needing to change code that uses them - they abstract from the <b>class</b> <b>hierarchy</b> or prototypes.|$|E
40|$|International audienceObject-oriented {{software}} {{may show}} signs of procedural thinking {{because of lack of}} design or due to design erosion over a period of time. We refer to such a software as procedural object-oriented code. Huge <b>classes,</b> scarce <b>class</b> <b>hierarchies</b> and absence of classes for domain entities are hallmarks of procedural object-oriented code. Due to huge amount of investment in such systems, software restructuring becomes necessary to search for useful domain abstractions to modularize the code. In this paper, we present a tool-assisted technique to search for useful abstractions and <b>class</b> <b>hierarchies</b> from procedural object-oriented code. For this purpose, principal classes of methods are identified and composition and association links are inferred for principal classes. In the second phase, formal Concept Analysis (FCA) is used to analyze <b>class</b> <b>hierarchies</b> within principal <b>classes...</b>|$|R
50|$|Prolog++ is an {{object-oriented}} toolkit for the Prolog {{logic programming}} language. It allows <b>classes</b> and <b>class</b> <b>hierarchies</b> {{to be created}} within Prolog programs.|$|R
40|$|We {{address the}} problem of {{integrating}} classes that are developed independently. We propose to factorise the intensional and extensional dimensions of classes and let them be organised in separate <b>hierarchies.</b> <b>Class</b> integration becomes the problem of integrating extent graphs, and to describe relations between the properties of the classes to be integrated. Our approach may be seen as extending <b>class</b> <b>hierarchies</b> towards the semantics of views, making them more suited for class integration. 1 INTRODUCTION A part of the problem of distributed object management, {{is to be able to}} integrate classes that are developed independently, either within the same or from distinct <b>class</b> <b>hierarchies.</b> The most common approach to class integration is to use views (ViewSystem [Kaul, 1990] is an excellent example). Here, an integrating view is defined as a query towards classes in existing <b>class</b> <b>hierarchies.</b> The views often exist only for the purpose of integrating classes, and have behaviour different fr [...] ...|$|R
50|$|Being {{dependent}} {{is indicated}} with +D, being independent with -D. +D (but not -D) is inherited down the <b>class</b> <b>hierarchy.</b>|$|E
5000|$|The above rules {{also apply}} to all the base classes and to all non-static data members in the <b>class</b> <b>hierarchy</b> ...|$|E
5000|$|Apart {{from normal}} ("primary") methods, {{there also are}} , , and [...] "auxiliary" [...] methods. The former two are invoked prior to, or after the primary method, in a {{particular}} order based on the <b>class</b> <b>hierarchy.</b> An [...] method can control whether the primary method is executed at all. Additionally, the programmer can specify whether all possible primary methods along the <b>class</b> <b>hierarchy</b> should be called or just the one providing the closest match.|$|E
40|$|Abstract: The reverse {{inheritance}} class {{relationship has}} several potential uses. It can be exploited {{as a mechanism}} integrated {{in one of the}} object-oriented programming languages or as a mean for reengineering <b>class</b> <b>hierarchies</b> in order to obtain locally adapted software releases. The limited local adaptations and restricted enhancements can be encapsulated in the superclass of the reverse inheritance class relationship and using a software tool they can be applied automatically to each software release. The implementation of the software tool works on Java <b>class</b> <b>hierarchies...</b>|$|R
5000|$|Types that do {{not have}} any {{associated}} classes are called non-classed. These types, together with all types that correspond to some form of root class, are known as fundamental types: the types from which all other types are derived. These make up a relatively closed set, but although the average user is not expected to create his own fundamental types, the possibility does exist and has been exploited to create custom <b>class</b> <b>hierarchies</b> [...] - [...] i.e., <b>class</b> <b>hierarchies</b> not based on the [...] class.|$|R
40|$|Abstract. <b>Class</b> <b>hierarchies</b> are {{commonly}} used to reduce {{the complexity of the}} classification problem. This is crucial when dealing with a large number of categories. In this work, we evaluate <b>class</b> <b>hierarchies</b> currently constructed for visual recognition. We show that top-down as well as bottom-up approaches, which {{are commonly}} used to automatically construct hierarchies, incorporate assumptions about the separability of classes. Those assumptions do not hold for visual recognition {{of a large number of}} object categories. We therefore propose a modification which is appropriate for most top-down approaches. It allows to construct <b>class</b> <b>hierarchies</b> that postpone decisions in the presence of uncertainty and thus provide higher recognition accuracy. We also compare our method to a one-against-all approach and show how to control the speed-foraccuracy trade-off with our method. For the experimental evaluation, we use the Caltech- 256 visual object classes dataset and compare to stateof-the-art methods. ...|$|R
50|$|The {{composite}} reuse {{principle is}} an alternative to inheritance. This technique supports polymorphism and code reuse by separating behaviors from the primary <b>class</b> <b>hierarchy</b> and including specific behavior classes as required in any business domain class. This approach avoids the static nature of a <b>class</b> <b>hierarchy</b> by allowing behavior modifications at run time and allows one class to implement behaviors buffet-style, instead of being restricted to the behaviors of its ancestor classes.|$|E
50|$|The {{underclass}} is {{the segment}} of the population that occupies the lowest possible position in a <b>class</b> <b>hierarchy,</b> below the core body of the working class.|$|E
5000|$|Because static imports {{apply only}} to the current file (and not the whole <b>class</b> <b>hierarchy)</b> {{it is easier to}} {{discover}} where each static member is declared.|$|E
40|$|This paper {{presents}} concept lattices as {{a natural}} representation of <b>class</b> <b>hierarchies</b> in object-oriented databases and frame based knowledge representations. We show how to extend concept lattices by uncertainty {{in the form of}} conditional probabilities. We illustrate that uncertain reasoning within the hierarchical structure of concept lattices can be performed efficiently and makes uncertain conclusions more precise. 1 Introduction The aim {{of this paper is to}} integrate uncertainty into <b>class</b> <b>hierarchies</b> of objectoriented databases and frame based knowledge representations. Extensional subclass relationships and disjointness statements are characteristic of <b>class</b> <b>hierarchies.</b> They can naturally be represented by concept lattices (see e. g. [14]). A concept is a pair consisting of a set of objects and a set of properties that all these objects share. The concept order is based on a coupled extensional and intensional order. For our purpose it is sufficient to concentrate just on the [...] ...|$|R
50|$|The Web Ontology Language (OWL) is {{a family}} of {{knowledge}} representation languages for authoring ontologies. Ontologies are a formal way to describe taxonomies and classification networks, essentially defining the structure of knowledge for various domains: the nouns representing classes of objects and the verbs representing relations between the objects. Ontologies resemble <b>class</b> <b>hierarchies</b> in object-oriented programming but there are several critical differences. <b>Class</b> <b>hierarchies</b> are meant to represent structures used in source code that evolve fairly slowly (typically monthly revisions) whereas ontologies are meant to represent information on the Internet {{and are expected to}} be evolving almost constantly. Similarly, ontologies are typically far more flexible as they are meant to represent information on the Internet coming from all sorts of heterogeneous data sources. <b>Class</b> <b>hierarchies</b> on the other hand are meant to be fairly static and rely on far less diverse and more structured sources of data such as corporate databases.|$|R
40|$|C++ {{directly}} {{supports a}} variety of programming styles. In this, C++ deliberately differs from languages designed to support a single way of writing programs. This paper briefly presents key programming styles directly supported by C++ and argues that the support for multiple styles {{is one of its}} major strengths. The styles presented include: traditional C-style, concrete classes, abstract <b>classes,</b> traditional <b>class</b> <b>hierarchies,</b> abstract <b>classes</b> and <b>class</b> <b>hierarchies,</b> and generic programming. To provide a context for this overview, I discuss criteria for a reasonable and useful definition of ‘‘object-oriented programming. ’’...|$|R
