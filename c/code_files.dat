283|832|Public
25|$|In 1999, in {{an effort}} towards compatibility, several Unix system vendors agreed on SVR4's Executable and Linkable Format (ELF) as the {{standard}} for binary and object <b>code</b> <b>files.</b> The common format allows substantial binary compatibility among Unix systems operating on the same CPU architecture.|$|E
25|$|Solution Explorer: In Visual Studio parlance, a {{solution}} {{is a set}} of <b>code</b> <b>files</b> and other resources that are used to build an application. The files in {{a solution}} are arranged hierarchically, which might or might not reflect the organization in the file system. The Solution Explorer is used to manage and browse the files in a solution.|$|E
25|$|Renames {{are handled}} implicitly rather than explicitly. A common {{complaint}} with CVS {{is that it}} uses {{the name of a}} file to identify its revision history, so moving or renaming a file is not possible without either interrupting its history, or renaming the history and thereby making the history inaccurate. Most post-CVS revision control systems solve this by giving a file a unique long-lived name (analogous to an inode number) that survives renaming. Git does not record such an identifier, and this is claimed as an advantage. Source <b>code</b> <b>files</b> are sometimes split or merged, or simply renamed, and recording this as a simple rename would freeze an inaccurate description of what happened in the (immutable) history. Git addresses the issue by detecting renames while browsing the history of snapshots rather than recording it when making the snapshot. to show code moved between source files (Briefly, given a file in revision N, a file of the same name in revision N−1 is its default ancestor. However, when there is no like-named file in revision N−1, Git searches for a file that existed only in revision N−1 and is very similar to the new file.) However, it does require more CPU-intensive work every time history is reviewed, and several options to adjust the heuristics. This mechanism does not always work; sometimes a file that is renamed with changes in the same commit is read as a deletion of the old file {{and the creation of a}} new file. Developers can work around this limitation by committing the rename and changes separately.|$|E
5000|$|Signals and <b>Code</b> (<b>File,</b> MP3) - Umbrella Noize Collective 2006 ...|$|R
5000|$|A {{preprocessor}} performs macro definition, source <b>code</b> <b>file</b> inclusion, and conditional compilation.|$|R
50|$|Copy {{and paste}} {{programming}} is an antipattern {{arising from the}} blind pasting of pre-existing code into another source <b>code</b> <b>file.</b>|$|R
2500|$|SCO {{also claimed}} line-for-line literal copying of code from UNIX <b>code</b> <b>files</b> to Linux kernel files and {{obfuscated}} copying of code, but originally refused to publicly identify which code was in violation. [...] SCO {{submitted to the}} court evidence of their claims under seal but {{much of it was}} excluded from the case after it was challenged by IBM as not meeting the specificity requirements to be included.|$|E
5000|$|Web {{pages are}} {{constructed}} from <b>code</b> <b>files</b> such JavaScript and Hypertext Markup Language (HTML). As web pages grow in complexity, so do their <b>code</b> <b>files</b> and subsequently their load times. File compression can reduce <b>code</b> <b>files</b> {{by as much}} as 80%, thereby improving site responsiveness.|$|E
5000|$|Compiled Java <b>code</b> <b>files</b> are {{generally}} smaller than <b>code</b> <b>files</b> in C++ as Java bytecode is usually more compact than native machine code and Java programs are never statically linked.|$|E
50|$|This is {{a module}} definition. Modules are a {{division}} of code, which can contain any kind of object, like constants or variables, functions or methods, or classes, but can't be instantiated as objects like classes and cannot inherit from other modules. Modules serve as containers of code that can be referenced {{from other parts of}} a program.It is common practice for a module and the <b>code</b> <b>file,</b> which contains it, to have the same name; however, this is not required, as a single <b>code</b> <b>file</b> may contain more than one module and/or class definition.|$|R
5000|$|If {{a source}} <b>code</b> <b>file</b> is changed then it suffices to re-run [...] which only re-compiles {{that part of}} the body of the source code {{affected}} by the change.|$|R
30|$|After {{defining}} the mathematical expressions which represent {{each one of}} the primitive elements, it is time to convert it to the VHDL-AMS language description. A VHDL-AMS <b>code</b> <b>file</b> is written for each primitive element/architecture.|$|R
5000|$|Assembly <b>code</b> <b>files</b> for TI's MSP430 {{series of}} microcontrollers.|$|E
5000|$|Codnar is {{an inverse}} literate {{programming}} tool {{available as a}} Ruby Gem. Instead of the machine-readable source code being extracted out of the literate documentation sources, the literate documentation is extracted out of the normal machine-readable source <b>code</b> <b>files.</b> This allows these source <b>code</b> <b>files</b> to be edited and maintained as usual. The approach {{is similar to that}} used by popular API documentation tools, such as JavaDoc. Such tools, however, generate API reference documentation, while Codnar generates a linear narrative describing the code, similar to that created by classical LP tools. Codnar can co-exist with API documentation tools, allowing both a reference manual and a linear narrative to be generated from the same set of source <b>code</b> <b>files.</b> https://github.com/orenbenkiki/codnar ...|$|E
50|$|A web-based {{slide show}} is {{typically}} generated to or authored in HTML, JavaScript and CSS <b>code</b> (<b>files).</b>|$|E
2500|$|The [...] {{statement}} loads {{a specific}} namespace from a referenced assembly. It is usually {{placed in the}} top (or header) of a <b>code</b> <b>file</b> {{but it can be}} placed elsewhere if wanted, e.g. inside classes.|$|R
50|$|Since {{the source}} <b>code</b> <b>file</b> is already updated, touch {{can be used}} to {{simulate}} a file update, so make will run and recompile the software. $ touch project.c $ makeThen make will rebuild the project.|$|R
40|$|Abstract: Source code size is an {{estimator}} {{of software}} effort. Size is also {{often used to}} calibrate models and equations to estimate the cost of software. The distribution of source <b>code</b> <b>file</b> sizes {{has been shown in}} the literature to be a lognormal distribution. In this paper, we measure {{the size of a large}} collection of software (the Debian GNU/Linux distribution version 5. 0. 2), and we find that the statistical distribution of its source <b>code</b> <b>file</b> sizes follows a double Pareto distribution. This means that large files are to be found more often than predicted by the lognormal distribution, therefore the previously proposed models underestimate the cost of software. ...|$|R
50|$|VBdocman allows commenting and the {{automatic}} generation of technical documentation from Visual Basic 6 source <b>code</b> <b>files.</b>|$|E
5000|$|... a parser: this {{component}} converts QVT <b>code</b> <b>files</b> into model {{representations of}} the QVT programs (abstract syntax).|$|E
50|$|Derived {{from the}} Mozilla Public License 1.1, the CDDL tries {{to address some}} of the {{problems}} of the MPL. Like the MPL, the CDDL is a weak copyleft license in-between GPL license and BSD/MIT permissive licenses, requiring only source <b>code</b> <b>files</b> under CDDL to remain under CDDL. Unlike strong copyleft licenses like the GPL, mixing of CDDL licensed source <b>code</b> <b>files</b> with source <b>code</b> <b>files</b> under other licenses is permitted without relicensing. The resulting compiled software product ("binary") can be licensed and sold under a different license, as long as the source code is still available under CDDL, which should enable more commercial business cases, according to Sun. Like the MPL the CDDL includes a patent grant to the licensee from all contributors ("patent peace").|$|E
50|$|Branching, in {{revision}} control and software configuration management, is the duplication {{of an object}} under {{revision control}} (such as a source <b>code</b> <b>file</b> or a directory tree) so that modifications can happen in parallel along both branches.|$|R
5000|$|The [...] {{statement}} loads {{a specific}} namespace from a referenced assembly. It is usually {{placed in the}} top (or header) of a <b>code</b> <b>file</b> {{but it can be}} placed elsewhere if wanted, e.g. inside classes.using System;using System.Collections; ...|$|R
50|$|For most compilers, each object file is {{the result}} of {{compiling}} one input source <b>code</b> <b>file.</b> When a program comprises multiple object files, the linker combines these files into a unified executable program, resolving the symbols as it goes along.|$|R
5000|$|The {{following}} command will {{extract the}} source <b>code</b> <b>files</b> from the file project.xml {{and place it}} into the directory project: ...|$|E
50|$|The file type {{indicates}} if {{the file}} is character data, or source code written in particular languages, binary data, or <b>code</b> <b>files.</b>|$|E
50|$|PVCS Version Manager (originally named Polytron Version Control System) is a {{software}} package by Serena Software Inc., for version control of source <b>code</b> <b>files.</b>|$|E
50|$|The srcML format {{consists}} of all text {{from the original}} source <b>code</b> <b>file</b> plus XML tags. Specifically, the text is wrapped with srcML elements that indicate the syntactic structure of the code. In short, this explicitly identifies all syntactic structures in the code.|$|R
50|$|There is a plug-in/module {{system in}} Octopussy, which is mainly geared towards the {{modification}} of Octopussy reports. Such a plug-in consists {{out of a}} description file, which defines the plug-in name and functions, and a <b>code</b> <b>file</b> with perl <b>code</b> to process the actual data.|$|R
5000|$|The {{version of}} Ratfor in Software Tools {{is written in}} Ratfor, as are the sample programs, and inasmuch as its own {{translation}} to Fortran is available, it can be ported to any Fortran system. Ratfor source <b>code</b> <b>file</b> names end in [...]r or [...]rat.|$|R
5000|$|Google: monolithic, 1 billion files, 9 million source <b>code</b> <b>files,</b> 2 billion {{lines of}} source code, 35 million commits in total, 86 TB total size (January 2015) ...|$|E
50|$|The code {{base of a}} {{computer}} programming project is the larger collection of all the source code of all the computer programs which make up the project. It has become common practice to maintain code bases in version control systems. Moderately complex software customarily requires the compilation or assembly of several, sometimes dozens or even hundreds, of different source <b>code</b> <b>files.</b> In these cases, instructions for compilations, such as a Makefile, are included with the source code. These describe the programming relationships among the source <b>code</b> <b>files,</b> and contain information about how {{they are to be}} compiled.|$|E
5000|$|Android, Apple Resources, ASP, [...]desktop files, Gettext (PO/POT), Microsoft.NET, <b>Code</b> <b>files</b> (C, Java, PHP, Qt Linguist), Joomla INI files, Mozilla DTD, Plain text, PO/POT files, Subtitles, Web pages, XLIFF files, XML files, YAML,… ...|$|E
30|$|E is {{the set of}} edges, {{identifying}} the connections between two developers if they have worked on the same software source <b>code</b> <b>file.</b> An edge will exist iff two developers have modified the same file during the release under study. Edges are both unweighted and undirected.|$|R
50|$|Plain {{text files}} are almost {{universal}} in programming; a source <b>code</b> <b>file</b> containing instructions in {{a programming language}} is almost always a plain text file. Plain text is also commonly used for configuration files, which are read for saved settings at the startup of a program.|$|R
50|$|Nibbles, {{also known}} by the source <b>code's</b> <b>file</b> name NIBBLES.BAS, is a simple variant of the snake video game concept used to {{demonstrate}} the QBasic programming language. Nibbles was written in QBasic by Rick Raddatz, who later went on to create small business companies such as Xiosoft and Bizpad.|$|R
