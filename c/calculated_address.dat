3|119|Public
50|$|The {{instruction}} set is very symmetrical. Every instruction {{consists of a}} 9-bit opcode, a 4-bit register code, and a 23-bit effective address field, which consists in turn of a 1-bit indirect bit, a 4-bit register code, and an 18-bit offset. Instruction execution begins by calculating the effective address. It adds {{the contents of the}} given register (if non-zero) to the offset; then, if the indirect bit is 1, fetches the word at the <b>calculated</b> <b>address</b> and repeats the effective address calculation until an effective address with a zero indirect bit is reached. The resulting effective address can be used by the instruction either to fetch memory contents, or simply as a constant. Thus, for example, MOVEI A,3(C) adds 3 to the 18 lower bits of register C and puts the result in register A, without touching memory.|$|E
40|$|We {{present the}} {{complete}} O(ff 2 s) corrections to the Wilson coefficient {{of the unit}} operator in the zero-recoil sum rule for the B ! D transition. We include both perturbative and power-suppressed nonperturbative effects {{in a manner consistent}} with the operator product expansion. The impact of these corrections on jV cb j extracted from semileptonic B ! D decays near zero recoil is discussed. The mixing of the heavy quark kinetic operator with the unit operator at the two loop level is obtained. O(ff s) corrections to a number of power-suppressed operators are <b>calculated.</b> <b>Address</b> after September 1997 : Physics Department, Brookhaven National Laboratory, Upton, New York 11973. y Permanent address: Petersburg Nuclear Physics Institute, Gatchina, St. Petersburg 188350, Russia I. INTRODUCTION Semileptonic decays of B mesons provide an opportunity to measure the CabibboKobayashi -Maskawa matrix parameter jV cb j with minimal theoretical uncertainties (for a recent review, se [...] ...|$|E
40|$|In {{industry}} many {{legacy systems}} exist which run mission or safety critical code {{which do not}} have adequate requirements documentation. This thesis demonstrates how {{the use of a}} functional programming language eases a flexible and modular approach to the construction of libraries and tool suites that allow the manipulation of assembly language programs. The tools and libraries created with this method are used in a larger project of reverse engineering requirements from legacy assembly programs. The modules presented operate from the assembled ". lst " format, which is the result of assembling the source files, and includes the <b>calculated</b> <b>address</b> in memory and the binary version of the given instructions. Our libraries provide representations of assembly programs in an abstract data type and as internal graph representations, and conversions to a GXL graph format and to other special-purpose XML represen-tations. The use of Haskell as an implementation language is explored {{in the context of a}} software engineering project, and some of the benefits and disadvantages of such...|$|E
5000|$|... (In the {{examples}} that follow, a, b, and c are (direct or <b>calculated)</b> <b>addresses</b> referring to memory cells, while reg1 {{and so on}} refer to machine registers.) ...|$|R
5000|$|RISC-V CPUs jump to <b>calculated</b> <b>addresses</b> using a [...] "jump and link-register," [...] instruction. [...] {{is similar}} to , but gets its {{destination}} address by adding a 12-bit offset to a base register. (In contrast, adds a larger 20-bit offset to the PC.) ...|$|R
50|$|An adder is {{a digital}} circuit that {{performs}} addition of numbers.In many {{computers and other}} kinds of processors adders are used in the arithmetic logic units. They are also utilized {{in other parts of the}} processor, where they are used to <b>calculate</b> <b>addresses,</b> table indices, increment and decrement operators, and similar operations.|$|R
5000|$|If G-bit is one limit has a {{granularity}} of 212 bytes, i.e. segment size may be 1 × 212, 2 × 212, ..., 220 × 212 bytes. If paging is off, the <b>calculated</b> linear <b>address</b> {{equals the}} physical memory address. If paging is on, the <b>calculated</b> linear <b>address</b> {{is used as}} input of paging.|$|R
5000|$|... <b>calculate</b> the <b>address</b> of both operands in memory, {{based on}} their {{positions}} within a data structure, ...|$|R
50|$|Address {{generation}} unit (AGU), sometimes also called address computation unit (ACU), is an execution unit inside {{central processing units}} (CPUs) that <b>calculates</b> <b>addresses</b> used by the CPU to access main memory. By having address calculations handled by separate circuitry that operates in parallel {{with the rest of}} the CPU, the number of CPU cycles required for executing various machine instructions can be reduced, bringing performance improvements.|$|R
5000|$|Hash {{functions}} <b>calculate</b> the <b>address</b> of {{the page}} in which the record is to be stored based on one or more fields in the record ...|$|R
25|$|Assembly {{languages}} eliminate {{much of the}} error-prone, tedious, {{and time-consuming}} first-generation programming needed with the earliest computers, freeing programmers from tedium such as remembering numeric codes and <b>calculating</b> <b>addresses.</b> They were once widely used {{for all sorts of}} programming. However, by the 1980s (1990s on microcomputers), their use had largely been supplanted by higher-level languages, in the search for improved programming productivity. Today assembly language is still used for direct hardware manipulation, access to specialized processor instructions, or to address critical performance issues. Typical uses are device drivers, low-level embedded systems, and real-time systems.|$|R
50|$|The FCS is <b>calculated</b> {{over the}} <b>Address,</b> Control, Protocol, Information and Padding fields after the message has been encapsulated.|$|R
50|$|Even {{with perfect}} randomization, leakage of memory {{contents}} {{will help to}} <b>calculate</b> the base <b>address</b> of a DLL at runtime.|$|R
5000|$|Loop-invariant code {{which has}} been hoisted out of a loop is {{executed}} less often, providing a speedup. Another effect of this transformation is allowing constants to be stored in registers and not having to <b>calculate</b> the <b>address</b> and access the memory (or cache line) at each iteration.|$|R
40|$|This {{thesis is}} a part of a bigger project which goal is to make a DSP that is {{instruction}} compatible with the Motorola DSP 56002. The goal of this part is to make a behavioural model with timing of the address generation unit in the DSP. The AGU unit can handle 4 different types of arithmetic’s including linear addressing, modulo addressing, wrap around modulo addressing and reverse carry addressing. It also handles several ways of <b>calculating</b> <b>addresses</b> as post/pre increment/decrement by a number. It can address 3 different memories, where 2 new <b>addresses</b> can be <b>calculated</b> {{at the same time in}} different memories. This model will be used as a golden model for the RTL model of the AGU that is one of the main parts in the DSP...|$|R
5000|$|Contrary to {{simplified}} descriptions {{found in}} early Intel manuals, a [...] "selector", i.e. a 16-bit [...] "segment number" [...] stored {{and kept in}} a (visible to the programmer) [...] "segment register", is not used to <b>calculate</b> <b>addresses.</b> HIMEM.SYS uses this feature to address extended memory. After the introduction of Windows 95, unreal mode quickly fell out of favor because programs using it cannot run in the DOS prompt of Microsoft Windows; they require a [...] "Restart in MS-DOS mode" [...] in Windows 95 and 98, and cannot be run at all on NT and later Windows systems, which run MS-DOS programs in virtual 8086 mode that is incompatible with unreal mode. For those operating systems, an emulator such as DOSBox {{is the only way}} to run programs designed for unreal mode.|$|R
25|$|Four-input address-adders {{enables the}} Pentium to further reduce the address {{calculation}} latency {{compared to the}} 80486. The Pentium can <b>calculate</b> full <b>addressing</b> modes with segment-base + base-register + scaled register + immediate offset in a single cycle; the 486 has a three-input address-adder only, and must therefore divide such calculations between two cycles.|$|R
50|$|The load store {{units are}} simple {{arithmetic}} logic units used to <b>calculate</b> virtual <b>addresses</b> for memory access. They are also capable of executing simple arithmetic and logic instructions. The Alpha 21264 instruction issue logic utilized this capability, issuing instructions to these units {{when they were}} available for use (not performing address arithmetic).|$|R
5000|$|Four-input address-adders {{enables the}} Pentium to further reduce the address {{calculation}} latency {{compared to the}} 80486. The Pentium can <b>calculate</b> full <b>addressing</b> modes with segment-base + base-register + scaled register + immediate offset in a single cycle; the 486 has a three-input address-adder only, and must therefore divide such calculations between two cycles.|$|R
50|$|While {{performing}} various operations, CPUs need to <b>calculate</b> memory <b>addresses</b> {{required for}} fetching {{data from the}} memory; for example, in-memory positions of array elements must be calculated before the CPU can fetch the data from actual memory locations. Those address-generation calculations involve different integer arithmetic operations, such as addition, subtraction, modulo operations, or bit shifts. Often, <b>calculating</b> a memory <b>address</b> involves more than one general-purpose machine instruction, which do not necessarily decode and execute quickly. By incorporating an AGU into a CPU design, together with introducing specialized instructions that use the AGU, various address-generation calculations can be offloaded {{from the rest of}} the CPU, and can often be executed quickly in a single CPU cycle.|$|R
50|$|Loads {{and stores}} can access {{constants}} in code, local {{variables in the}} stack, or items in a data structure. They <b>calculate</b> the <b>address</b> by adding a 12-bit signed offset to a base register. If the base register is zero, the data or constants can be in low memory, or high (negative offset) memory, such as ROM.|$|R
50|$|The segment address {{inside the}} {{descriptor}} table entry has {{a length of}} 24 bits so every byte of the physical memory {{can be defined as}} bound of the segment. The limit value inside the descriptor table entry has a length of 16 bits so segment length can be between 1 byte and 216 byte. The <b>calculated</b> linear <b>address</b> equals the physical memory address.|$|R
40|$|Abstract—This paper {{presents}} the behavioral model of an Address Generation Unit (AGU) in a DSP Processor whose instructions are almost {{compatible with the}} Motorola DSP 56002. The proposed AGU unit can handle 4 different types of arithmetic – linear addressing, modulo addressing, wrap around modulo addressing and reverse carry addressing. It also handles various means of <b>calculating</b> <b>addresses</b> as post/pre increment/decrement by a number. The novelty in this proposal {{is that it can}} address 2 different memories, where 2 new <b>addresses</b> are <b>calculated</b> concurrently. The central idea behind this design is address sequence generation by means of reverse carry addition, the use of modulo adder and offset adder. The designed AGU circuit generates the actual address as per the given set of inputs. Simulation results are compared with the theoretical data and found correct. The designed AGU may be implemented in a DSP Processor with optimized power and speed. Key words-VLSI design; Address Generation Unit; ALU; VHDL; DSP Processor. I...|$|R
3000|$|... [...]) {{location}} {{within that}} bank. The addressing scheme {{is a simple}} addressing scheme based on the pixel location. A hardware unit called the Address Processor (AP) handles the memory addressing. By providing the AP with the pixel location, it will <b>calculate</b> the <b>address</b> to retrieve that pixel value. This address will tell us which bank and location within that bank the pixel value is stored in.|$|R
50|$|AddressSanitizer {{does not}} prevent any uninitialized memory reads, and only {{prevents}} some use-after-return bugs. It is also not capable of preventing all arbitrary memory corruption bugs. Arbitrary write bugs due to integer underflow/overflows (when the integer with undefined behavior is used to <b>calculate</b> memory <b>address</b> offsets). Adjacent buffers in structs and classes are not protected from overflow, in part to prevent breaking backwards compatibility.|$|R
30|$|Different from LEACH, LEACH-C, and EE-LEACH, LEACH-M {{uses the}} network address of every node {{to modify their}} cluster-head threshold. In order to <b>calculate</b> the network <b>address</b> of them, DAAM of ZigBee is utilized.|$|R
50|$|Execution begins during stage nine. There are six {{execution}} units, two for integer, two for {{loads and}} stores, and two for floating-point. The two integer execution units are designated EXA and EXB. Both have an {{arithmetic logic unit}} (ALU) and a shift unit, but only EXA has multiply and divide units. Loads and stores are executed by two address generators (AGs) designated AGA and AGB. These are simple ALUs used to <b>calculate</b> virtual <b>addresses.</b>|$|R
3000|$|... {{that is used}} in [11], the FH scheme {{proposed}} in this paper invokes the use of only a length-one register to store the time index which in turn {{can be used to}} <b>calculate</b> current FH <b>address</b> of each user at the base station.|$|R
30|$|Step 1 : Reading the {{coordinate}} {{information of}} cargo address and road intersections was marked as distribution path points by the Arabic numeral. The distance was <b>calculated</b> between cargo <b>address</b> and other cargo address, cargo address and intersection, and intersection and another intersection.|$|R
50|$|Any of the {{addressing}} modes {{mentioned in this}} article could have an extra bit to indicate indirect addressing, i.e. the <b>address</b> <b>calculated</b> using some mode is in fact the address of a location (typically a complete word) which contains the actual effective address.|$|R
40|$|The authors {{present the}} design of a {{real-time}} imaging system, incorporating the correction of lens-distorted images. It may be used in medical applications (e. g. real-time X-ray image intensifiers), industrial robot vision products or consumer electronics. The system contains two different VLSI-circuits: a transformer and an interpolator. The transformer <b>calculates</b> an <b>address</b> that points to a pixel in the input image. Since this address hardly ever is an exact pixel position, a cube-spline interpolator is used to calculate the pixel-intensity at the desired positio...|$|R
40|$|The most {{fundamental}} arithmetic operation is addition {{which is used}} in a digital data path logic system. Arithmetic and logic units, Microprocessors,etc. are some examples {{where we need to}} use arithmetic operations for processing data, for <b>calculating</b> <b>addresses</b> respectively. There are different architectures for building adder circuit. For example: 1) carry look ahead adder(CLA), 2) carry propagate adder(CPA), 3) carry save adder(CSA), & 4) carry select adder(CSLA). Among these different architectures CSLA is a particular way of implementing adder that performs addition rapidly and are used for faster addition in many data processing processors. From observation of the carry select adder architecture we can see that there is scope for modification in order to significantly minimize the area and power consumed by the circuit. In this work we are going to propose simple and efficient modification at gate-level structure in CSLA. Based on this 16 -, 32 -bit square root CSLA (SQRT CSLA) have been developed & compared with regular structure. The proposed architecture design has reduced area & power consumption compared to regular structure with slight increase in delay. The evaluation of the proposed design is done based on delay, area & power performance metrics. The results show that proposed CSLA design is better than regular SQRT CSL...|$|R
5000|$|The complex {{instructions}} in heavily microcoded implementations {{may not take}} much extra machine resources, except for microcode space. For instance, the same ALU {{is often used to}} <b>calculate</b> an effective <b>address</b> as well as computing the result from the actual operands (e.g., the original Z80, 8086, and others).|$|R
50|$|CUDA is a {{parallel}} computing platform and programming model that higher level languages {{can use to}} exploit parallelism. In CUDA, the kernel is executed {{with the aid of}} threads. The thread is an abstract entity that represents the execution of the kernel. A kernel is a small program or a function. Multi threaded applications use many such threads that are running at the same time, to organize parallel computation. Every thread has an index, which is used for <b>calculating</b> memory <b>address</b> locations and also for taking control decisions.|$|R
40|$|Importance {{sampling}} {{is widely}} used in machine learning and statistics, but its power {{is limited by the}} restriction of using simple proposals for which the importance weights can be tractably <b>calculated.</b> We <b>address</b> this problem by studying black-box importance sampling methods that calculate importance weights for samples generated from any unknown proposal or black-box mechanism. Our method allows us to use better and richer proposals to solve difficult problems, and (somewhat counter-intuitively) also has the additional benefit of improving the estimation accuracy beyond typical importance sampling. Both theoretical and empirical analyses are provided...|$|R
5000|$|The {{majority}} of Coolock, excluding Ayrfield, was built-up by the then city authority, Dublin Corporation, {{as part of}} a programme of phased inner city slum clearance (between, roughly, 1952 and 1987). Dublin City Council <b>calculates</b> that <b>addresses</b> containing [...] "Coolock" [...] comprise the largest stock of local authority houses within its jurisdiction and the area is central to the linear range of local authority building that took place during between the 1960s and the 1980s across Dublin's Northside - i.e. Ballymun including Poppintree, Kilmore, Coolock, Edenmore, Kilbarrack and Donaghmede.|$|R
