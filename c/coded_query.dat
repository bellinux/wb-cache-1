1|200|Public
30|$|Query generation: Server {{should not}} be able to {{generate}} a <b>coded</b> <b>query.</b> The query can be generated by only those users with the relevant secret key.|$|E
40|$|International audienceThis paper {{describes}} a software development tool for automating {{the process of}} source <b>code</b> <b>querying</b> of Java programs together with an initial evaluation. It contains a catalogue of source <b>code</b> <b>queries</b> and streamlines the querying process. The GUI-driven Eclipse plugin called PwSOUL enables Java programmers to more easily check their source code for potential bugs, and find common programming idioms and design patterns. The tool should be useful to software developers as an aid for tasks such as debugging, refactoring, and software evolution and maintenance. A key aim of this work was to cut the effort required by a developer to run a suite of source <b>code</b> <b>queries</b> by simplifying and automating user actions. PwSOUL simplifies and automates aspects of Barista, an existing Eclipse plugin for Java runtime source <b>code</b> <b>querying</b> and query scheduling that uses an example-based extension of a program query language called SOUL. The main features of PwSOUL are a catalogue of 32 source <b>code</b> <b>queries,</b> and a GUI to aid navigation and automate the process of running queries and returning results...|$|R
40|$|Querying and {{analyzing}} source code interactively {{is a critical}} task in reverse engineering and program understanding. Current source <b>code</b> <b>query</b> systems lack sufficient formalism and offer limited query capabilities. In this paper, we introduce the formal framework of Source Code Algebra (SCA), and outline a source <b>code</b> <b>query</b> system based on it. SCA provides a formal data model for source code, an algebraic expression-based query language, and opportunities for query optimization. An algebraic model of source code addresses the issues of conceptual integrity, expressive power, and performance of a source <b>code</b> <b>query</b> system within a unified framework. Keywords: Reverse engineering, source <b>code</b> <b>query,</b> query language, many-sorted algebra. 1 Overview The answers are in the source code. Mark Weiser, in Source Code [28]. Software reverse engineering, code re-engineering, and program understanding have begun to emerge as the latest challenges {{in the field of}} software engineering. Interest in [...] ...|$|R
5000|$|The tool proposes live <b>code</b> <b>query</b> and <b>code</b> rule through LINQ query.This {{is one of}} the {{innovations}} of CppDepend. For example: ...|$|R
40|$|When {{analyzing}} software systems we {{are faced}} with the challenge of how to implement a particular analysis for different programming languages. A solution for this problem is to write a single analysis using a <b>code</b> <b>query</b> language abstracting from the specificities of languages being analyzed. Over the past ten years many <b>code</b> <b>query</b> technologies have been developed, based on different formalisms. Each technology comes with its own query language and set of features. To determine {{the state of the art}} of <b>code</b> <b>querying</b> we compare the languages and tools for seven <b>code</b> <b>query</b> technologies: Grok, Rscript, JRelCal, SemmleCode, JGraLab, CrocoPat and JTransformer. The specification of a package stability metric is used as a running example to compare the languages. The comparison involves twelve criteria, some of which are concerned with properties of the query language (paradigm, types, parametrization, polymorphism, modularity, and libraries), and some of which are concerned with the tool itself (output formats, interactive interface, API support, interchange formats, extraction support, and licensing). We contextualize the criteria in two usage scenarios: interactive and tool integration. We conclude that there is no particularly weak or dominant tool. As important improvement points, we identify the lack of library mechanisms, interchange formats, and possibilities for integration with source code extraction components...|$|R
40|$|Abstract. Source <b>code</b> <b>querying</b> tools allow programmers {{to explore}} {{relations}} between {{different parts of}} the code base. This paper describes such a tool, named CodeQuest. It combines two previous proposals, namely the use of logic programming and database systems. As the query language we use safe Datalog, which was originally introduced in the theory of databases. That provides just the right level of expressiveness; in particular recursion is indispensable for source <b>code</b> <b>queries.</b> Safe Datalog is like Prolog, but all queries are guaranteed to terminate, and {{there is no need for}} extra-logical annotations. Our implementation of Datalog maps queries to a relational database system. We are thus able to capitalise on the query optimiser provided by such a system. For recursive queries we implement our own optimisations in the translation from Datalog to SQL. Experiments confirm that this strategy yields an efficient, scalable <b>code</b> <b>querying</b> system. ...|$|R
40|$|The ever growing {{size and}} {{complexity}} of software projects demand good IDE support in order to assist the understanding and navigation of source code during implementation and maintenance. In the case of Aspect-oriented programming, additional supporting IDE tools are needed to make aspect-oriented structures explicit. However, existing tools struggle to provide easy-to-use navigation facilities when {{the size of the}} source code increases. This paper describes Lost a query and navigation tool for the AspectJ language, its integration with the eclipse IDE, and initial experiences with using the tool. The described tool not only provides features which are novel with respect to current aspect-oriented programming tools but also attempts to overcome deficiencies of existing <b>code</b> <b>querying</b> tools. Additionally, we briefly discuss the implementation of a framework for <b>code</b> <b>querying</b> tools, which was created in order to maintain high flexibility in implementing the <b>code</b> <b>querying</b> tool presented here. 1...|$|R
30|$|There are source <b>code</b> <b>query</b> {{languages}} {{adapted to}} architectural conformance, {{for example the}} SCQL [23]. This technique is very flexible in searching for undesirable code pattern (i.e., architectural violations). SCQL similarity to SQL facilitates its adoption, although the features design for object-oriented adds a significant complexity to the language. The language is counter-intuitive to model architectural definitions since every aspect of SCQL is expressed by source <b>code</b> <b>queries.</b> Another problem is that SCQL does not support abstraction for higher level components; it only works at source code level.|$|R
5000|$|All recent {{versions}} of the tool (after V4) proposes live <b>code</b> <b>queries</b> and <b>code</b> rules through LINQ queries. This {{is one of the}} main innovations of NDepend. For example: ...|$|R
5000|$|In September 2014 {{an update}} for NVivo for Mac was released. This allows users {{the ability to}} capture and import web pages using NCapture, run matrix <b>coding</b> <b>queries</b> and use text-to-speech options.|$|R
40|$|Industrial {{software}} {{systems are}} large and complex, {{both in terms of}} the software entities and their relationships. Consequently, understanding how a software system works requires the ability to pose queries over the design-level entities of the system. Traditionally, this task has been supported by simple tools (e. g., grep) combined with the programmer’s intuition and experience. Recently, however, specialized <b>code</b> <b>query</b> technologies have matured {{to the point where they}} can be used in industrial situations, providing more intelligent, timely, and efficient responses to developer queries. This working session aims to explore the state of the art in <b>code</b> <b>query</b> technologies, and discover new ways in which these technologies may be useful in program comprehension. The session brings together researchers and practitioners. We survey existing techniques and applications, trying to understand the strengths and weaknesses of the various approaches, and sketch out new frontiers that hold promise...|$|R
40|$|<b>Querying</b> source <b>code</b> interactively for {{information}} {{is a critical}} task in reverse engineering of software. However, current source <b>code</b> <b>query</b> systems succeed in handling only small subsets of {{the wide range of}} <b>queries</b> possible on <b>code,</b> trading generality and expressive power for ease of implementation and practicality. We attribute this to the absence of clean formalisms for modeling and <b>querying</b> source <b>code.</b> In this paper, we present an algebraic framework (Source Code Algebra or SCA) for modeling and <b>querying</b> source <b>code.</b> The framework forms the basis of our query system for C source code. An analogy can be drawn with relational algebra, which forms the basis for relational databases. The benefits of using SCA include the integration of structural and flow information into a single source code data model, the ability to process high-level source <b>code</b> <b>queries</b> (command-line, graphical, relational, or pattern-based) by translating them into SCA expressions which can be evaluated using th [...] ...|$|R
40|$|Abstract—Extracting {{information}} from the source code of a program {{is an important step}} in the way to program understanding, manipulation, development and maintenance. To this end, logic-based query languages provide a declarative manner in which to identify program elements of interest. In this paper we present BARISTA, a tool-suite for querying Java programs based on the Smalltalk Open Unification Language (SOUL). BARISTA offers programmers an advanced IDE to write queries and navigate their results. Tool builders can benefit from SOUL querying facilities by exploiting the on demand <b>code</b> <b>querying</b> and query scheduling services offered by BARISTA. I...|$|R
40|$|The paper {{describes}} {{an analysis of}} the translation events encountered when queries cross the language barrier in crosslanguage information retrieval. A study of a set of query source and target triples resulted {{in the creation of a}} translation taxonomy. The taxonomy was used to code 750 English target <b>queries.</b> The 750 <b>coded</b> <b>queries</b> are currently being used in retrieval experiments to assess the impact of the different translation problems on retrieval performance. 1...|$|R
40|$|Summary: This report covers Task 4. 3 of the CODE {{project and}} {{deals with the}} {{usability}} testing of the developed visual analytics interfaces. Evaluation of the components and user interfaces has been conducted by performing formative web-based usability testing with friendly users as well as summative in-depth evaluation of the user experience of the <b>CODE</b> <b>Query</b> Wizard and the CODE Visualization Wizard. Some of the evaluation results have already been published in international peer-reviewed conference articles...|$|R
40|$|This thesis {{proposes a}} <b>query</b> {{language}} for <b>code</b> selection. It {{is designed to}} work on virtual machine based languages and {{is intended to be}} used to nd regions of code that match a pattern dened by a query. Queries are dened by methods following the query-by-example approach and are performed using a query operator. The query operator we describe is perceived at high level language but performs queries at virtual machine intermediate language. The matching process and operators described are similar to the ones used in regular expression pattern matching but with some dierences, for example, these patterns have code instructions as symbols. We have developed a prototype (<b>Code</b> <b>Query)</b> that implements the query op- erator and provides an API to perform <b>queries.</b> <b>Code</b> <b>Query</b> is implemented in C# on CLI platform. Our approach allows cross-language queries with the only constraint that such languages must target the same virtual machine. Our work can be used to develop a framework for aspect oriented programming that does not require modication or extension to the virtual machine compiler and that can match not only join points but also any arbitrary portion of code...|$|R
40|$|We {{present a}} tool that helps C/C++ {{developers}} to estimate the effort and automate software porting. Our tool supports project leaders in planning a porting project by showing where a project must be changed, how many changes are needed, what kinds of changes are needed, and how these interact with the code. For developers, we {{provide an overview of}} where a given file must be changed, the structure of that file, and close interaction with typical code editors. To this end, we integrate <b>code</b> <b>querying,</b> program transformation, and software visualization techniques. We illustrate our solution with use-cases on real-world code bases. ...|$|R
40|$|<b>Code</b> <b>queries</b> focus {{mainly on}} the static {{structure}} of a system. To comprehend the dynamic behavior of a system however, a software engineer {{needs to be able}} to reason about the dynamics of this system, for instance by querying a database of dynamic information. Such a querying mechanism should be directly available in the IDE where the developers implements, navigates and reasons about the software system. We propose (i) concepts to gather dynamic information, (ii) the means to query this information, and (iii) tools and techniques to integrate querying of dynamic information in the IDE, including the presentation of results generated by queries...|$|R
50|$|Usually, the {{framework}} will expose some filtering and querying functionality, allowing subsets of the storage base to be accessed and modified. The <b>code</b> below <b>queries</b> {{for people in}} the database whose ID value is '10'.|$|R
50|$|The {{performance}} almost {{close to}} hand written <b>query</b> <b>code</b> with plain PDO statement.|$|R
40|$|Abstract. According to {{analysis}} of manufacturing enterprise coding requirements, Visual flexible coding system (VFCS) is proposed based on code classification theory. It has four function modules: code structure design, code segment & bit design, visual coding and interpreting, <b>code</b> <b>query.</b> Firstly, <b>code</b> rules are expressed by extendable XML format as data structure. Secondly, code design is regulated into two stages: code structure design and code segment design, {{so as to}} realize separation of code structure logical and contents. finally, code segment structure information is described as graphic nodes, using interactive graphics drawing for visual modeling, finite state machine algorithm are used implementing code structure interpreter...|$|R
50|$|MemSQL {{combines}} lock-free data {{structures and}} a just-in-time compilation (JIT) to process highly volatile workloads. More specifically, MemSQL implements lock-free hash tables and lock-free skip lists in memory for fast random access to data. SQL queries {{sent to the}} MemSQL server are converted into byte code and compiled through LLVM into machine <b>code.</b> <b>Queries</b> are then stripped of their parameters and the query template is stored as a shared object which is subsequently matched against incoming queries to the system. Executing pre-compiled query plans removes interpretation along hot code paths, providing highly efficient code paths that minimize the number of central processing unit (CPU) instructions required to process SQL statements.|$|R
40|$|Most {{software}} undoubtedly undergoes {{changes and}} needs maintenance due to environment, technologies and domain knowledge changes. A maintainer {{is responsible to}} analyze and understand the code occurrences prior to making any changes. The change {{in some parts of}} the codes will affect other parts within the same codes. Therefore, program understanding is one of the important factors to understand the code occurrences and its effectiveness in software maintenance. A program understanding activity involves browsing and exploring the source codes or the software documentations. However, in some cases not all the developed software has updated documentations. In this situation the documents tend to be more or less obsolete, while source code remains as the only reliable source left for maintainers to understand the software. In this case, maintainers need to spend more time traversing source code to understand the code occurrences. Thus, a flexible <b>codes</b> <b>query</b> method is proposed to enhance code occurrences understanding. This method applies parsing, pattern matching and regular expression techniques to extract software artifacts from source code. These extracted artifacts are analyzed and brought to light via multiple levels of abstraction. The results present multiple artifacts, relationship among the artifacts and their locations in the source code. In this research, a prototype was developed to provide a source <b>code</b> <b>query</b> method that supports structured program understanding in C programs. The method was then tested in a controlled experiment using a case study to prove effectiveness query of artifacts occurrences in source code to support program understanding...|$|R
50|$|The builder {{pattern has}} another benefit: It {{can be used}} for objects that contain flat data (HTML <b>code,</b> SQL <b>query,</b> X.509 certificate…), that is to say, data that can't be easily edited step by step and hence must be edited at once.|$|R
40|$|Programmers {{currently}} enjoy {{access to}} a very high number of code repositories and libraries of ever increasing size. The ensuing potential for reuse is however hampered {{by the fact that}} searching within all this code becomes an increasingly difficult task. Most code search engines are based on syntactic techniques such as signature matching or keyword extraction. However, these techniques are inaccurate (because they basically rely on documentation) {{and at the same time}} do not offer very expressive <b>code</b> <b>query</b> languages. We propose a novel approach that focuses on querying for semantic characteristics of code obtained automatically from the code itself. Program units are pre-processed using static analysis techniques, based on abstract interpretation, obtaining safe semantic approximations. A novel, assertion-based <b>code</b> <b>query</b> language is used to express desired semantic characteristics of the code as partial specifications. Relevant code is found by comparing such partial specifications with the inferred semantics for program elements. Our approach is fully automatic and does not rely on user annotations or documentation. It is more powerful and flexible than signature matching because it is parametric on the abstract domain and properties, and does not require type definitions. Also, it reasons with relations between properties, such as implication and abstraction, rather than just equality. It is also more resilient to syntactic code differences. We describe the approach and report on a prototype implementation within the Ciao system. Under consideration for acceptance in TPLP. Comment: Paper presented at the 32 nd International Conference on Logic Programming (ICLP 2016), New York City, USA, 16 - 21 October 2016, 15 pages, LaTeX, 4 PDF figures, 2 table...|$|R
40|$|An {{important}} {{challenge with}} respect to aspect-oriented programming is to make this technology easier to use, so that it becomes accessible to {{a larger number of}} developers. We address this challenge with a new pointcut language based on the concept of <b>code</b> <b>query</b> by example. Our framework can be used to denote code patterns, which are difficult to express using traditional join point languages. A further benefit of our approach is that {{it can be used to}} denote join points at almost arbitrary locations inside method bodies - without sacrificing obliviousness. Finally, a particularity of our pointcut language is that it is embedded in a general purpose language. We outline the benefits, and limitations of our framework, and we summarize the implementation of a prototyp...|$|R
40|$|For any non-trivial {{software}} project, architectural drift is {{a well-known}} problem. Over time, the design rules and guidelines governing the software project are no longer obeyed, resulting in that the software becomes more difficult to maintain. While there exist numerous tools — such as code checkers, architecture and design checkers, and source <b>code</b> <b>query</b> languages — that aid in alleviating this problem none of these approaches are tailored towards supporting {{one of the main}} languages still in use today in industry, namely Cobol. In this paper we present Cognac, an extension of the IntensiVE tool that allows for documenting and verifying design rules in Cobol systems. Next to discussing the architecture of Cognac, we present a validation of our tool on an industrial, large-scale Cobol system. 1...|$|R
40|$|We have {{investigated}} {{the possibility of using}} emerging <b>code</b> <b>query</b> technologies in industry. For that purpose we evaluated three alternatives: Crocopat, Rscript, and SemmleCode. We made a comparison with respect to eight criteria focussing on language features and tool integration issues. Although the available solutions are promising we found that none of them fully satisfies our requirements. In particular, we found that the combination of good abstraction and extension facilities lacks in all languages, and that an API is missing from all tools. We recognize a need for a solution that offers the language abstraction facilities offered by Rscript and the extendability of SemmleCode combined with an API to achieve a smooth integration with existing technologies. We expect that meeting these challenges will expedite industrial adoption. 1...|$|R
40|$|The International Conference on Information Retrieval and Knowledge Management (CIKM) brings {{together}} three avenues of data-oriented research, namely, Database Management, Information Retrieval and Knowledge Management. The confluence of these avenues becomes evident {{also in the}} PhD theses of doctoral students: Stream processing makes use of knowledge representation techniques, linked data is emerging as a research topic that bridges information retrieval and knowledge representation, and new forms of querying draw on techniques from both information retrieval and databases. In this paper, we survey new PhD theses at the meeting point of the three research avenues. Our survey {{is based on the}} 5 th PhD workshop at the ACM CIKM conference. The topics include themes as diverse as link prediction, source <b>code</b> <b>querying,</b> and video stream processing. 1...|$|R
40|$|Static {{analysis}} tools are a mature technology. They {{can be applied}} to large codebases and can find certain classes of errors in large code bases. However even if the tools have an internal AST-level view of the code analyzed, they do not allow custom queries of the AST. Instead, they are largely used to check certain “canned ” properties and either do not support user-extensible checks or provide limited domain-specific languages specialized for specifying automatons. This paper describes DeHydra, a code analysis tool that can specify automatons in addition to allowing other <b>code</b> <b>queries</b> and checks. It uses JavaScript which is a general purpose programming language as opposed to a specialized DSL. Additionally, the tool allows some inter-procedural analyses instead of just intra-procedural ones. ...|$|R
40|$|Abstract—To help {{developers}} {{understand and}} reuse programs, semantic queries on the source code itself is attractive. Although programs in heterogeneous languages are being controlled for collaborative software development, most queries supported by various source code repositories are based {{either on the}} metadata of the repositories, or on indexed identifiers and method signa-tures. Few provide full support to search for structures that are common across different programming languages and different viewpoints (hence heterogeneous). To facilitate understanding and reuses, in this paper, we propose a novel source <b>code</b> <b>query</b> syntax format, and handles heterogeneity (non-isomorphism) at the abstract syntax level; (2) stores source code on a cloud-based NoSQL storage in MongoDB; (3) rewrites semantic query pat-terns into the NoSQL form. The efficiency of the framework has been evaluated to support several open-source hosting platforms. I...|$|R
40|$|To help {{developers}} {{understand and}} reuse programs, semantic queries on the source code itself is attractive. Although programs in heterogeneous languages are being controlled for collaborative software development, most queries supported by various source code repositories are based {{either on the}} metadata of the repositories, or on indexed identifiers and method signatures. Few provide full support to search for structures that are common across different programming languages and different viewpoints (hence heterogeneous). To facilitate understanding and reuses, in this paper, we propose a novel source <b>code</b> <b>query</b> framework that (1) transforms source code to a unified abstract syntax format, and handles heterogeneity (non-isomorphism) at the abstract syntax level; (2) stores source code on a cloud-based NoSQL storage in MongoDB; (3) rewrites semantic query patterns into the NoSQL form. The efficiency of the framework has been evaluated to support several open-source hosting platforms...|$|R
40|$|Integrating {{data from}} autonomous, {{distributed}} and heterogeneous data sources {{to provide a}} unified vision is a common demand for many businesses. Since the data sources may evolve frequently to satisfy their own independent business needs, solutions which use hard <b>coded</b> <b>queries</b> to integrate participating databases may cause high maintenance costs when evolution occurs. Thus a new solution which can handle database evolution with lower maintenance effort is required. This thesis presents a new solution: Service Late binding Enabled Data Integration (SLEDI) which is set into a framework modeling the essential processes of the data integration activity. It integrates schematic heterogeneous relational databases with decreased maintenance costs for handling database evolution. An algorithm, named Information Provision Unit Describing (IPUD) is designed to describe each database {{as a set of}} Information Provision Units (IPUs). The IPUs are represented as Directed Acyclic Graph (DAG) structured data instead of hard <b>coded</b> <b>queries,</b> and further realized as data services. Hence the data integration is achieved through service invocations. Furthermore, a set of processes is defined to handle the database evolution through automatically identifying and modifying the IPUs which are affected by the evolution. An extensive evaluation based on a case study is presented. The result shows that the schematic heterogeneities defined in this thesis can be solved by IPUD except the relation isomorphism discrepancy. Ten out of thirteen types of schematic database evolution can be automatically handled by the evolution handling processes as long as the evolution is represented by the designed data model. The computational costs of the automatic evolution handling show a slow linear growth with the number of participating databases. Other characteristics addressed include SLEDI’s scalability, independence of application domain and databases model. The descriptive comparison with other data integration approaches shows that although the Data as a Service approach may result in lower performance under some circumstances, it supports better flexibility for integrating data from autonomous and evolving data sources. ...|$|R
40|$|Abstract — Understanding {{source code}} {{is crucial for}} a {{software}} engineer. To efficiently grasp the semantics of source code, an experienced engineer recognizes semantic chunks and relations (code patterns) in source code as clues. If a rich repository of searchable code patterns, together with human understandable meanings, is available, comprehension of unfamiliar source code would be easier. However, explicitly defining a source <b>code</b> <b>query</b> even for a simple code pattern can be prohibitively complex for human. In this paper, a tool for search-by-example through abstract syntax tree is presented. A programmer gives sets of desired and undesired nodes, then the system presents some candidate nodes resembling desired ones. This kind of implicit definition by examples is suitable for constructing and revising a repository socially. The method is supervised incremental learning of decision trees. The proposed system uses a set of primitive attributes to reflect domain-specific knowledge safely and easily. syntax tree I...|$|R
40|$|This thesis {{presents}} three {{approaches to}} improve {{the current state of}} Medical Information Retrieval. At the time of this writing, the health industry is experiencing a massive change in terms of introducing technology into all aspects of health delivery. The work in this thesis involves adapting existing established concepts in the field of Information Retrieval to the field of Medical Information Retrieval. In particular, we apply subtype filtering, ICD- 9 <b>codes,</b> <b>query</b> expansion, and re-ranking methods in order to improve retrieval on medical texts. The first method applies association rule mining and cosine similarity measures. The second method applies subtype filtering and the Apriori algorithm. And the third method uses ICD- 9 codes in order to improve retrieval accuracy. Overall, we show that the current state of medical information retrieval has substantial room for improvement. Our first two methods do not show significant improvements, while our third approach shows an improvement of up to 20 %...|$|R
40|$|Understanding {{source code}} {{is vital to}} many tasks in {{software}} engineering. Source <b>code</b> <b>querying</b> tools {{are designed to help}} such understanding, by allowing programmers to explore relations that exist between different parts of the codebase. The contribution of such a system- named CodeQuest- is the topic of this dissertation. One of the modern source <b>code</b> <b>querying</b> and browsing tools for Java is JQuery. This popular Eclipse IDE plug-in has been an inspiration {{for the development of the}} CodeQuest project- a similar instrument, but with some fundamental differences. We shall have a closer look at JQuery, its features and implementation and compare it in various aspects with CodeQuest as we proceed. This dissertation presents a novel approach to software querying and maintenance. Its main strategy is to combine the expressive power of a logic language and scalability properties of a relational database. We shall show how such a tool can be implemented, discuss improvements and optimisations that can be applied and illustrate the advantages of this proposal by running numerous tests and comparing various performance parameters between CodeQuest and other modern querying systems. i Acknowledgments I am very grateful to my supervisor, Professor Oege de Moor, for letting me work on such an interesting and challenging project within the Programming Tools Group, for his great motivation, diligent guidance and valuable comments. I would like to thank Mathieu Verbaere for his advice, help and friendly support; for the long hours and nights, that he has spent helping me to finish my poster before the deadline. I also want to express my gratitude to the IT manager of the St. Anne’s college Dr. Ian Burnell and his assistant Alex Stevens for their kind help and friendship from the very beginning of my studies in Oxford. My education in UK was funded by the Shell Oil Company and I owe them much appreciation for making one of my brightest dreams to come true. Finally, I am greatly indebted to the best parents in the whole world, whose warmest love and endless concern let me never down. I dedicate this thesis to my wonderful Mothe...|$|R
