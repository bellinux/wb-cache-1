0|741|Public
40|$|Abstract—Many {{applications}} of {{wireless sensor networks}} require precise knowledge of the locations of constituent nodes. In these applications, it is desirable for the nodes {{to be able to}} autonomously determine their locations before they start sensing and transmitting data. Most localization algorithms use anchor nodes with known locations to determine the positions of the remaining nodes. However, these existing techniques often fail in hostile environments where some of the nodes may be compromised by adversaries and used to transmit misleading information aimed at preventing accurate localization of the remaining sensors. In this paper, a <b>computationally</b> efficient <b>secure</b> localization <b>algorithm</b> that withstands such attacks is described. The proposed algorithm combines iterative gradient descent with selective pruning of inconsistent measurements to achieve high localization accuracy. Results show that the proposed algorithm utilizes fewer computational resources and achieves an accuracy better than or comparable to that of existing schemes. The proposed <b>secure</b> localization <b>algorithm</b> can also be used in mobile sensor networks, where all nodes are moving, to estimate the relative locations of the nodes without relying on anchor nodes. Simulations demonstrate that the proposed algorithm can find the relative location map oftheentiremobilesensornetworkevenwhensomenodesare compromised and transmit false information. Index Terms—Gradient descent, mobile sensor networks (MSNs), secure localization, wireless sensor networks (WSNs). I...|$|R
40|$|A <b>computationally</b> <b>secure</b> noised based {{cipher system}} is proposed. The {{advantage}} of this cipher system is that it operates above noise level. Therefore <b>computationally</b> <b>secure</b> communication can be done when error correction code fails. Another feature of this system is that minimum number of exhaustive key search can be made fixed. Comment: Revised, Latex, 4 page...|$|R
50|$|AONT may be {{combined}} with forward error correction to yield a <b>computationally</b> <b>secure</b> secret sharing scheme.|$|R
30|$|PKEBP {{performs}} <b>computationally</b> <b>secure</b> computation of exact {{private trust}} values assuming that an adversary cannot corrupt the initiator and several users {{at the same}} time.|$|R
3000|$|..., {{we present}} <b>computationally</b> <b>secure</b> schemes for trust computation. The first scheme, Accumulated Protocol AP computes the average trust {{attributed}} to a specific user, U [...]...|$|R
3000|$|MPKP {{performs}} <b>computationally</b> <b>secure</b> computation of {{the exact}} private trust values in the Additive Reputation System. No restriction is imposed on the initiator U [...]...|$|R
30|$|The {{security}} {{potential of}} compressed sensing was hinted by Candes and Tao [3], where the measurement samples {{were referred to}} as a weakly encrypted ciphertext. In [15], Rachlin and Baron proved that the CS-based cryptosystem cannot be perfectly secure but might be <b>computationally</b> <b>secure.</b> Orsdemir et al. [16] showed that it is <b>computationally</b> <b>secure</b> against a key search technique via an algebraic approach. Subsequently, many researchers have studied the security of CS-based cryptosystems for practical applications, which will be discussed with more details in Section 2.3. For a comprehensive review of CS techniques in information security, readers are referred to [17].|$|R
50|$|J.L. Massey and I. Ingemarsson. The Rip van Winkle cipher - {{a simple}} and provably <b>computationally</b> <b>secure</b> cipher with a finite key. In Proc. IEEE Int. Symp. Information Theory (Abstracts), page 146, 1985.|$|R
40|$|Abstract. We {{investigate}} {{the security of}} protocols with logarithmic communication complexity. We show that for the security definitions with environment, i. e., Reactive Simulatability and Universal Composability, computational security of logarithmic protocols implies statistical security. The same holds for advantage-based security definitions as commonly used for individual primitives. While this matches the folklore that logarithmic protocols cannot be <b>computationally</b> <b>secure</b> unless they are already statistically secure, we show that under realistic complexity assumptions, this folklore does surprisingly not hold for the stand-alone model without auxiliary input, i. e., there are logarithmic protocols that are statistically insecure but <b>computationally</b> <b>secure</b> in this model. The proof is conducted by showing how to transform an instance of an NP-complete problem into a protocol with two properties: There exists an adversary such that the protocol is statistically insecure in the stand-alone model, and given such an adversary {{we can find a}} witness for the problem instance, hence yielding a <b>computationally</b> <b>secure</b> protocol assuming the hardness of finding a witness. The proof relies on a novel technique that establishes a link between cryptographi...|$|R
40|$|Cryptography {{is one of}} {{the prime}} {{techniques}} of secured symbolic data transmission over any communication channel. Security is the most challenging and essential aspects in today’s internet and network applications. Thus, design of a <b>secure</b> encryption <b>algorithm</b> is very necessary which can protect the unauthorized attacks. An encryption <b>algorithm</b> is <b>computationally</b> <b>secure</b> if it cannot be intruded with the standard resources. The algorithm proposed here is graph based. Its efficiency surpasses the standard DES algorithm in general. Graphs can be used for designing block ciphers, stream ciphers or public-key ciphers. The algorithm is graph automorphism based partial symmetric key algorithm and it is not fully depended on secret key and produces different cipher text by applying same key on the same plain text...|$|R
30|$|A CS-based {{cryptosystem}} {{cannot be}} perfectly secure [15] but {{is believed to}} be <b>computationally</b> <b>secure</b> [15, 16]. In this section, we analyze the computational security of our CS-based cryptosystem by studying the notion of indistinguishability [19].|$|R
40|$|Yevgeniy DodisTo {{my family}} ii istically extract nearly b almost {{unbiased}} random bits from the key. In particular, the one-time pad scheme is essentially “universal”. Our technique also extends to related primitives which are sufficiently binding and hiding, including <b>computationally</b> <b>secure</b> commitments and public-key encryption...|$|R
40|$|Often {{the core}} {{difficulty}} in designing zero-knowledge protocols arises {{from having to}} consider every possible cheating verifier trying to extract additional information. We here consider a compiler which transforms protocols proven secure only {{with respect to the}} honest verifier into protocols which are secure against any (even cheating) verifier. Such a compiler, which preserves the zero-knowledge property of a statistically or <b>computationally</b> <b>secure</b> protocol was first proposed in [BMO] based on Discrete Logarithm problem. In this paper, we show how such a compiler could be constructed based on any one-way permutation using the recent method of interactive hashing [OVY- 91]. This applies to both statistically and <b>computationally</b> <b>secure</b> protocols, preserving their respective security. Our result allows us to utilize DES-like permutations for such a compiler...|$|R
3000|$|We derived {{a number}} of schemes for the private {{computation}} of trust in a given user by a community of users. Trust computation is performed in a fully distributed manner without involving a Trusted Authority. The proposed AP and WAP protocols are <b>computationally</b> <b>secure,</b> under the assumption of an uncompromised initiator, U [...]...|$|R
40|$|In a {{threshold}} signature scheme, {{a group of}} players share a secret information {{in such a way}} that only those subsets with a minimum number of players can compute a valid signature. We propose methods to construct some useful and <b>computationally</b> <b>secure</b> distributed protocols from threshold signature schemes satisfying some suitable properties...|$|R
40|$|We {{present a}} new {{technique}} for robust secret reconstruction with O(n) communication complexity. By applying this technique, we achieve O(n) communication complexity per multiplication for a wide class of robust practical Multi-Party Computation (MPC) protocols. In particular our technique applies to robust threshold <b>computationally</b> <b>secure</b> protocols {{in the case of}} t < n/ 2 in the pre-processing model. Previously in the pre-processing model, O(n) communication complexity per multiplication was only known in the case of <b>computationally</b> <b>secure</b> non-robust protocols in the dishonest majority setting (i. e. with t < n) {{and in the case of}} perfectly-secure robust protocols with t < n/ 3. A similar protocol was sketched by Damgard and Nielsen, but no details were given to enable an estimate of the communication complexity. Surprisingly our robust reconstruction protocol applies for both the synchronous and asynchronous settings...|$|R
40|$|The {{process of}} exchanging {{information}} is called Communication. The basic Communication system involvestransmitter, receiver and the channel. The data transmitted by the sender reaches receiver through thechannel. The unauthorized parties (cracker,hacker, eavesdropper, or attacker) {{should not be}} able to access the information at the channel. Therefore transmitting data securely from the sender to the receiver is a very important aspect. A cryptographic system is unconditionally secure if the cipher text produced by the system does not contain enough information to determine uniquely the corresponding plaintext, no matter how much cipher text is available. A cryptographic system is said to be <b>computationally</b> <b>secure</b> if the cost of breaking the cipher exceeds the value of the encrypted information and the time required to break the cipher exceeds the useful lifetime of the content. One time pad system can be called as unconditionally <b>secure</b> <b>algorithm,</b> if the keys (pad) usedare truly random in nature. In this paper, we are demonstrating that one-time pad can be used as an efficient encryption scheme by involving arithmetic and logical operations. Here we proposed a new key generation technique, to generate a key of any length just by providing a seed value, to encrypt the message. The problem generating key value has been solved by the use of key generation algorithm...|$|R
3000|$|The AP and WAP {{protocols}} preserve user {{privacy in}} a <b>computationally</b> <b>secure</b> manner. Our protocols cope with {{any number of}} curious but honest adversarial users. Moreover, the PKEBP (Section ‘Protocols for removal of outliers’) is resistant against semi-malicious users that return false trust values. The PKEBP supports the removal of outliers. The general case, when the initiator, U [...]...|$|R
3000|$|... (Section ‘Accumulated {{protocol}} AP’). The AP protocol {{is based}} on a <b>computationally</b> <b>secure</b> homomorphic cryptosystem, e.g., the Paillier cryptosystem [1], which provides a homomorphic encryption of the secure trust levels T 1,…,Tn− 1 calculated by each user U 1, U 2,…,Un− 1 from C. The AP satisfies the features of the Additive Reputation System [2] and does not take into consideration [...]...|$|R
40|$|Vehicle ad-hoc {{networks}} (VANETs) are {{a prominent}} form of mobile ad-hoc networks. This paper outlines {{the architecture of}} VANETs and discusses the security and privacy challenges {{that need to be}} overcome to make such networks practically viable. It compares the various security schemes that were suggested for VANETs. It then proposes an efficient implementation of an identity based cryptosystem that is robust and <b>computationally</b> <b>secure...</b>|$|R
40|$|The dining cryptographers {{protocol}} implements {{a multiple}} access channel in which senders and recipients are anonymous. A {{problem is that}} a malicious participant can disrupt communication by deliberately creating collisions. We propose a <b>computationally</b> <b>secure</b> dining cryptographers protocol with collision resolution that achieves a maximum stable throughput of 0. 924 messages per round and which allows to easily detect disruptors. Comment: 11 pages, 3 figure...|$|R
40|$|In {{this paper}} we focus our {{attention}} on private set intersection. We show impossibility and existential results, and we provide some explicit constructions. More precisely, we start {{by looking at the}} case in which both parties, client and server, in securely computing the intersection, would like to hide the sizes of their sets of secrets, and we show that: - It is impossible to realize an unconditionally secure size-hiding set intersection protocol. - In a model where a TTP provides set up information to the two parties and disappears, unconditionally secure size-hiding set intersection is possible. - There exist <b>computationally</b> <b>secure</b> size-hiding set intersection protocols. Then, we provide some explicit constructions for one-sided protocols, where only the client gets the intersection and hides the size of her set of secrets. In the model with the TTP, we design two protocols which are <b>computationally</b> <b>secure</b> under standard assumptions, and two very efficient protocols which are secure in the random oracle model. We close the paper with some remarks and by pointing out several interesting open problems...|$|R
40|$|AbstractSecurity {{and privacy}} of database-driven web {{applications}} are extremely multifaceted against web intruders. One {{of the most}} dangerous cyber attacks is the SQL-injection attack, which simply creates huge loss to commercial vendors. Research deliberates to provide SQL-injection free (SQL-IF) <b>secure</b> <b>algorithm</b> to detect and prevent SQL-injection attacks (SQLIAs). In this paper, we have re-addressed several detection methods to conflict against the proposed SQL-IF <b>secure</b> <b>algorithm.</b> The generated algorithm has been integrated into the runtime environment while the implementation has been done through Java. The algorithm describes the method that how we follow the procedures for preventing SQL-injection attacks. We presented the SQL-IF <b>secure</b> <b>algorithm</b> and logic of the generated code. Comparison of similar types of attack along with different features is performed. The empirical results and its evaluation prove that the algorithm works efficiently to detect the SQLIAs...|$|R
30|$|An {{enhanced}} {{model for}} reputation computation that extends {{the results of}} [2] is introduced in [3]. The main enhancement of [2] is that a non additive (weighted) trust and reputation can be computed privately. Three algorithms for computing non additive reputation are proposed in [3]. The algorithms have various degrees of privacy and different levels of protection against adversarial users. These schemes are <b>computationally</b> <b>secure</b> regardless {{of the number of}} dishonest users.|$|R
40|$|In [16], Naor, Pinkas and Reingold {{introduced}} schemes {{in which}} some groups of servers distribute keys among a set of users in a distributed way. They gave some specific proposals both in the unconditional and in the computational security framework. Their <b>computationally</b> <b>secure</b> scheme {{is based on the}} Decisional Diffie-Hellman Assumption. This model assumes secure communication between users and servers. Furthermore it requires users to do some expensive computations in order to obtain a key...|$|R
40|$|Abstract. As a {{modified}} version of GGH map, Gu map- 1 was successful in constructing multi-party key exchange (MPKE). In this short paper we present a result about the parameter setting of Gu map- 1, therefore we can reduce a key parameter from original O(n 2) down to O(n) (in theoretically secure case, where is the security parameter), and even down to O(2 n) (in <b>computationally</b> <b>secure</b> case). Such optimization greatly reduces the size of the map...|$|R
40|$|The {{access control}} {{problem in a}} {{hierarchy}} can be solved by using a hierarchical key assignment scheme, where each class is assigned an encryption key and some private information. A formal security analysis for hierarchical key assignment schemes has been traditionally considered in two different settings, i. e., the unconditionally <b>secure</b> and the <b>computationally</b> <b>secure</b> setting, and with respect to two different notions: security against key recovery (KR-security) and security with respect to key indistinguishability (KI-security), with the latter notion being cryptographically stronger. Recently, Freire, Paterson and Poettering proposed strong key indistinguishability (SKI-security) as a new security notion in the <b>computationally</b> <b>secure</b> setting, arguing that SKI-security is strictly stronger than KI-security in such a setting. In this paper we consider the unconditionally secure setting for hierarchical key assignment schemes. In such a setting {{the security of the}} schemes is not based on specific unproven computational assumptions, i. e., it relies on the theoretical impossibility of breaking them, despite the computational power of an adversary coalition. We prove that, in this setting, SKI-security is not stronger than KI-security, i. e., the two notions are fully equivalent from an information-theoretic point of view...|$|R
3000|$|Like {{any other}} <b>computationally</b> <b>secure</b> protocols, [...] "negligible knowledge" [...] {{used in the}} above {{definition}} should be interpreted as, given the available information to a party, the distribution of all possible values of the private input from the other party is computationally indistinguishable from the uniformly random distribution [48]. The first property in Definition 3.2 defines the concept of user anonymity, that is, Bob knows nothing about Alice except whether her probe matches one or more biometric signals in [...]...|$|R
40|$|Abstract. Sensitive {{electronic}} data {{may be required}} to remain confidential for long periods of time. Yet encryption under a <b>computationally</b> <b>secure</b> cryptosys-tem cannot provide a guarantee of long term confidentiality, due to potential advances in computing power or cryptanalysis. Long term confidentiality is ensured by information theoretically secure ciphers, but at the expense of im-practical key agreement and key management. We overview known methods to alleviate these problems, whilst retaining some form of information theoretic security relevant for long term confidentiality...|$|R
40|$|We give two impossibility results {{regarding}} {{strong encryption}} over an infinite enumerable domain. The first one relates to statistically secure one-time encryption. The second one relates to <b>computationally</b> <b>secure</b> encryption resisting adaptive chosen ciphertext attacks in streaming mode with bounded resources: memory, time delay or output length. Curiously, both impossibility {{results can be}} achieved with either finite or continuous domains. The latter result explains why known CCA-secure cryptosystem constructions require at least two passes to decrypt a message with bounded resources...|$|R
40|$|Quantum key {{distribution}} (QKD) promises secure key agreement by using quantum mechanical systems. We argue that QKD {{will be an}} important part of future cryptographic infrastructures. It can provide long-term confidentiality for encrypted information without reliance on computational assumptions. Although QKD still requires authentication to prevent manin-the-middle attacks, it can make use of either information-theoretically secure symmetric key authentication or <b>computationally</b> <b>secure</b> public key authentication: even when using public key authentication, we argue that QKD still offers stronger security than classical key agreement. ...|$|R
40|$|Sensitive {{electronic}} data {{may be required}} to remain confidential for long periods of time. Yet encryption under a <b>computationally</b> <b>secure</b> cryptosystem cannot provide a guarantee of long term confidentiality, due to potential advances in computing power or cryptanalysis. Long term confidentiality is ensured by information theoretically secure ciphers, but at the expense of impractical key agreement and key management. We overview known methods to alleviate these problems, whilst retaining some form of information theoretic security relevant for long term confidentiality...|$|R
40|$|In Journal of Cryptology 1 / 1 (1988) 65 - 75 (= [Chau_ 88]), David Chaum {{describes}} a beautiful technique, the DC-net, which should allow participants to {{send and receive}} messages anonymously in an arbitrary network. The untraceability of the senders is proved to be unconditional, but that of the recipients implicitly assumes a reliable broadcast network. This assumption is unrealistic in some networks, {{but it can be}} removed completely by using the fail-stop key generation schemes by Waidner (these proceedings, = [Waid_ 89]). In both cases, however, each participant can untraceably and permanently disrupt the entire DC-net. We present a protocol which guarantees unconditional untraceability, the original goal of the DC-net, on the inseparability assumption (i. e. the attacker must be unable to prevent honest participants from communicating, which is considerably less than reliable broadcast), and <b>computationally</b> <b>secure</b> serviceability: <b>Computationally</b> restricted disrupters can be identified and removed from the DC-net. On the one hand, our solution is based on the lovely idea by David Chaum [Chau_ 88 § 2. 5] of setting traps for disrupters. He suggests a scheme to guarantee unconditional untraceability and <b>computationally</b> <b>secure</b> serviceability, too, but on the reliable broadcast assumption. The same scheme seems to be used b...|$|R
40|$|We {{identify}} a generic construction of cryptosystems {{based on the}} subset sum problem and characterize the required homomorphic map. Using the homomorphism from the Damgård-Jurik cryptosystem, we then {{eliminate the need for}} a discrete logarithm oracle in the key generation step of the Okamoto, Tanaka and Uchiyama scheme to provide a practical cryptosystem based on the subset sum problem. We also analyze the security of our cryptosystem and show that with proper parameter choices, it is <b>computationally</b> <b>secure</b> against lattice-based attacks. Finally, we present a practical application of this system for RFID security and privacy...|$|R
40|$|We {{define the}} BQS-UC model, {{a variant of}} the UC model, that deals with {{protocols}} in the bounded quantum storage model. We present a statistically secure commitment protocol in the BQS-UC model that composes concurrently with other protocols and an (a-priori) polynomially-bounded number of instances of itself. Our protocol has an efficient simulator which is important if one wishes to compose our protocol with protocols that are only <b>computationally</b> <b>secure.</b> Combining our result with prior results, we get a statistically BQS-UC secure constant-round protocol for general two-party computation without the need for any setup assumption...|$|R
40|$|Abstract. Instantiations of the McEliece {{cryptosystem}} {{which are}} considered <b>computationally</b> <b>secure</b> {{even in a}} post-quantum era still require hardening against side channel attacks for practical applications. Recently, the first differential power analysis attack on a McEliece cryptosystem successfully recovered the full secret key of a state-of-the-art FPGA implementation of QC-MDPC McEliece. In this work we show how to apply masking countermeasures to the scheme and present the first masked FPGA implementation that includes these countermeasures. We validate the side channel resistance of our design by practical DPA attacks and statistical tests for leakage detection...|$|R
