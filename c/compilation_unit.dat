61|64|Public
25|$|The 6th Photographic Squadron, {{which was}} a {{photographic}} <b>compilation</b> <b>unit</b> located at Jefferson Barracks, and the 16th Photographic Squadron remained in the United States under the wing's control.|$|E
2500|$|Erlang {{supports}} language-level Dynamic Software Updating. To implement this, code {{is loaded}} and managed as [...] "module" [...] units; the module is a <b>compilation</b> <b>unit.</b> The system can keep {{two versions of}} a module in memory at the same time, and processes can concurrently run code from each. The versions {{are referred to as}} the [...] "new" [...] and the [...] "old" [...] version. A process will not move into the new version until it makes an external call to its module.|$|E
2500|$|Static storage {{duration}} objects are initialized in two phases. First, [...] "static initialization" [...] is performed, {{and only after}} all static initialization is performed, [...] "dynamic initialization" [...] is performed. [...] In static initialization, all objects are first initialized with zeros; after that, all objects that have a constant initialization phase are initialized with the constant expression (i.e. variables initialized with a literal or constexpr). Though it is not specified in the standard, the static initialization phase can be completed at compile time and saved in the data partition of the executable. [...] Dynamic initialization involves all object initialization done via a constructor or function call (unless the function is marked with constexpr, in C++11). The dynamic initialization order {{is defined as the}} order of declaration within the <b>compilation</b> <b>unit</b> (i.e. the same file). No guarantees are provided about the order of initialization between compilation units.|$|E
40|$|Many {{programming}} languages identify modular <b>units</b> with <b>compilation</b> <b>units,</b> {{while only}} few extend this to permit hierarchies of language-level modules within individual <b>compilation</b> <b>units.</b> But {{when the number}} of such <b>compilation</b> <b>units</b> is large, then it becomes increasingly important that they themselves can be grouped together and that explicit export interfaces can be used to control namespaces. We explain how the group model implemented in SML/NJ's compilation manager CM provides the necessary facilities to avoid unwanted interferences between unrelated parts of large programs. We also discuss the problem of automatic dependency analysis as well as its complexity and show ways of avoiding intractability. 1 Introduction Abstraction and modular design are key elements of modern software engineering. When the number of <b>compilation</b> <b>units</b> is large, then it becomes increasingly important that they themselves can be grouped together and that explicit export interfaces can be used to control n [...] ...|$|R
40|$|A user's manual is {{described}} and is provided for ASAP, an automated tool for static source code analysis of programs {{written in the}} Ada programming language. The purpose of the analysis is to collect and store information pertaining to the analyzed Ada <b>compilation</b> <b>unit's</b> size, complexity, usage of Ada language constructs and features, and static interface with other Ada <b>compilation</b> <b>units...</b>|$|R
5000|$|BCPL handles {{bindings}} spanning separate <b>compilation</b> <b>units</b> in {{a unique}} way. There are no user-declarable global variables; instead there is a global vector, {{which is similar to}} [...] "blank common" [...] in Fortran. All data shared between different <b>compilation</b> <b>units</b> comprises scalars and pointers to vectors stored in a pre-arranged place in the global vector. Thus the header files (files included during compilation using the [...] "GET" [...] directive) become the primary means of synchronizing global data between <b>compilation</b> <b>units,</b> containing [...] "GLOBAL" [...] directives that present lists of symbolic names, each paired with a number that associates the name with the corresponding numerically addressed word in the global vector. As well as variables, the global vector also contains bindings for external procedures. This makes dynamic loading of <b>compilation</b> <b>units</b> very simple to achieve. Instead of relying on the link loader of the underlying implementation, effectively BCPL gives the programmer control of the linking process.|$|R
50|$|In {{computer}} programming, a one-pass compiler is a compiler {{that passes}} through the parts of each <b>compilation</b> <b>unit</b> only once, immediately translating each part into its final machine code. This {{is in contrast to}} a multi-pass compiler which converts the program into one or more intermediate representations in steps between source code and machine code, and which reprocesses the entire <b>compilation</b> <b>unit</b> in each sequential pass.|$|E
5000|$|... extern int overShared = 1; /* This one has {{external}} linkage (not * limited to this <b>compilation</b> <b>unit).</b> [...] */ ...|$|E
5000|$|For example, if {{you have}} the source files foo.cpp and bar.cpp, they can be placed in a Single <b>Compilation</b> <b>Unit</b> as follows: ...|$|E
5000|$|Classpath: {{performs}} {{abstract syntax}} tree parsing and type binding of Java and AspectJ <b>compilation</b> <b>units</b> ...|$|R
5000|$|... {{brittleness}} - most {{changes to}} the library will require recompilation of all <b>compilation</b> <b>units</b> using that library ...|$|R
5000|$|RTL/2 was a {{strongly}} typed language with separate <b>compilation.</b> The <b>compilation</b> <b>units</b> contained {{one or more}} items known as [...] "bricks", i.e.: ...|$|R
5000|$|... longer {{compilation}} times - the <b>compilation</b> <b>unit</b> {{must see}} {{the implementation of}} all components in the included files, rather than just their interfaces ...|$|E
50|$|The extern {{storage class}} {{specifier}} {{indicates that the}} storage for an object has been defined elsewhere. When used inside a block, it indicates that the storage has been defined by a declaration outside of that block. When used outside of all blocks, it indicates that the storage has been defined outside of the <b>compilation</b> <b>unit.</b> The extern storage class specifier is redundant when used on a function declaration. It indicates that the declared function has been defined outside of the <b>compilation</b> <b>unit.</b>|$|E
5000|$|... static int shared = 3; /* This is the file-scope {{variable}} (with [...] * internal linkage), visible only in [...] * this <b>compilation</b> <b>unit.</b> [...] */ ...|$|E
50|$|These can be {{done without}} inlining, but require a {{significantly}} more complicated compiler and linker (in case caller and callee are in separate <b>compilation</b> <b>units).</b>|$|R
40|$|Separate {{compilation}} is {{an important}} tool for coping with design complexity in large software projects. When done right {{it can also be}} used to create software libraries, thus promoting code reuse. But separate compilation comes in various flavors and has many facets: namespace management, linking, optimization, dependencies. Many programming languages identify modular units with <b>units</b> of <b>compilation,</b> while only a few extend this to permit hierarchies of language-level modules within individual <b>compilation</b> <b>units.</b> When the number of <b>compilation</b> <b>units</b> is large, then it becomes increasingly important that the mechanism of separate compilation itself can be used to control namespaces. The group model implemented in SML/NJ's compilation manager CM provides the necessary facilities to avoid unwanted interferences between unrelated parts of large programs. <b>Compilation</b> <b>units</b> are arranged into groups, and explicit export interfaces can be used to control namespaces. When there are many groups, t [...] ...|$|R
40|$|Region-based {{compilation}} repartitions {{a program}} into more desirable <b>compilation</b> <b>units</b> for optimization and scheduling, particularly beneficial for ILP architectures. With region-based compilation, the compiler can control problem size and complexity by controlling region size and contents, expose interprocedural scheduling and optimization opportunities without interprocedural analysis or large function bodies, and create <b>compilation</b> <b>units</b> for program analysis that more accurately reflect the dynamic {{behavior of the}} program. This paper presents a region formation algorithm that eliminates the high compile-time memory costs due to an aggressive inlining prepass. Individual subregions are inlined in a demand-driven way during interprocedural region formation. Our experimental results on {{a subset of the}} SPEC benchmarks demonstrate a significant reduction in compile-time memory requirements with comparable runtime performance. 1...|$|R
5000|$|This [...] "scrutinizer" [...] {{does not}} allow cross-module flow analysis, so {{it can only be}} used to {{optimize}} code that's part of one <b>compilation</b> <b>unit</b> (or module).|$|E
50|$|The 6th Photographic Squadron, {{which was}} a {{photographic}} <b>compilation</b> <b>unit</b> located at Jefferson Barracks, and the 16th Photographic Squadron remained in the United States under the wing's control.|$|E
5000|$|Both {{of these}} methods require a method of {{constructing}} unique names. Modern compilers support a [...] preprocessor define that facilitates the construction of unique names, by returning monotonically increasing numbers for each <b>compilation</b> <b>unit.</b>|$|E
3000|$|Our {{design is}} split into <b>compilation</b> <b>units,</b> {{each of which}} can be {{compiled}} separately. Alternatively, it is possible to use several tools for different parts of your design, or even using the partition in order to explore most of the possible parallelism and pipelining for more efficient hardware implementation. Eventually, the main block modules of the design were split into a group of small modules that work in parallel and/or in pipelining. For instance, the module BLOCK 1 contains tree <b>compilation</b> <b>units</b> (modules): a [...] "Decision" [...] Module which contains the first stage's classifiers. This module is used for computation and decision on each sub-window. The second module is [...] "Shift-and-Scale" [...] used for shifting and scaling the window in order to obtain all subsequent locations. Finally, a [...] "Memory-Ctrl" [...] module manages the intermediate memory access.|$|R
40|$|National audienceStrongly-typed {{languages}} rely on link-time {{checks to}} ensure that type safety is not violated at the borders of <b>compilation</b> <b>units.</b> Such checks entail very fine-grained dependencies among <b>compilation</b> <b>units,</b> which {{are at odds with}} the implicit assumption of backward compatibility that is relied upon by common library packaging techniques adopted by FOSS (Free and Open Source Software) package-based distributions. As a consequence, package managers are often unable to prevent users to install a set of libraries which cannot be linked together. We discuss how to guarantee link-time compatibility using inter-package relationships; in doing so, we take into account real-life maintainability problems such as support for automatic package rebuild and manageability of ABI (Application Binary Interface) strings by humans. We present the dh_ocaml implementation of the proposed solution, which is currently in use in the Debian distribution to safely deploy more than 300 OCaml-related packages...|$|R
40|$|This paper {{serves as}} a guide {{how to work with}} the MOCKA system. MOCKA - Modula- 2 Compiler System 5 2 MOCKA Reference Manual 2. 1 The Compiler There are three kinds of <b>compilation</b> <b>units</b> in Modula- 2 : Definition Modules specify {{interfaces}} which may be imported by other modules. Files containing definition modules must end with the suffix ". md"...|$|R
5000|$|... and {{therefore}} {{has no effect}} on the <b>compilation</b> <b>unit,</b> not even evaluating its argument. Therefore expressions passed to [...] must not contain side-effects since they will not happen when debugging is disabled. For instance: ...|$|E
50|$|Note that storage specifiers {{apply only}} to {{functions}} and objects; other things such as type and enum declarations are private to the <b>compilation</b> <b>unit</b> in which they appear. Types, on the other hand, have qualifiers (see below).|$|E
5000|$|The C {{language}} {{does not}} have a [...] keyword. However, variables declared outside a function have [...] "file scope," [...] meaning they are visible within the file. Variables declared with file scope are visible between their declaration {{and the end of the}} <b>compilation</b> <b>unit</b> ( [...] file) (unless shadowed by a like-named object in a nearer scope, such as a local variable); and they implicitly have external linkage and are thus visible to not only the [...] file or <b>compilation</b> <b>unit</b> containing their declarations but also to every other <b>compilation</b> <b>unit</b> that is linked to form the complete program. Note that not specifying [...] is the same as specifying : the default is external linkage. External linkage, however, is not sufficient for such a variable's use in other files: for a <b>compilation</b> <b>unit</b> to correctly access such a global variable, it will need to know its type. This is accomplished by declaring the variable in each file using the [...] keyword. (It will be declared in each file but may be defined in only one.) Such [...] declarations are often placed in a shared header file, since it is common practice for all [...]c files in a project to include at least one [...] file: the standard header file [...] is an example, making the [...] variable accessible to all modules in a project. Where this global access mechanism is judged problematic, it can be disabled using the [...] keyword which restricts a variable to file scope, and will cause attempts to import it with [...] to raise a compilation (or linking) error.|$|E
5000|$|Avoids lock-in: Roo can be rapidly {{removed from}} a user project, which is useful to protect against vendor lock-in. This is {{possible}} {{because there is no}} runtime component to remove, @Roo annotations are [...] "source retention" [...] only (ensuring they are not preserved in compiled *.class files) and Roo's AspectJ inter-type declarations can be [...] "pushed in" [...] to standard *.java <b>compilation</b> <b>units.</b>|$|R
5000|$|For example, {{the line}} [...] {{in a program}} {{included}} the unit called crt; the [...] is the mechanism for using other <b>compilation</b> <b>units.</b> [...] and [...] were the keywords used to specify, within the unit, what was (and what was not) visible outside the unit. This {{is similar to the}} [...] and [...] keywords in other languages such as C++ and Java.|$|R
40|$|This note {{describes}} a simple mechanism for checking structural type equivalence across <b>compilation</b> <b>units.</b> The type of each external object {{is described in}} canonical form. A hash function compresses the description into a one- or two-word code. Type checking is then performed by any standard linker. without modifications. For distributed programs. type checking can be also performed at run rime. with minimal overhead. I. In troduction A type-checking mechanism for separate compilation must strike a difficult balance between correctness and conservatism. On the one hand. it should prevent the use of <b>compilation</b> <b>units</b> that make incompatible assumptions about their interface. On the other hand, it should cause as few unnecessary recompilations as possible. When definitions change, an ideal mechanism would recompile all and only those pieces of a program that would otherwise malfunction. Approaching this ideal has proven surprisingly difficult. enough so that many programming systems provide no checking whatsoever. We believe that a simple and easy-to-use type-checking mechanism for separate compilation i...|$|R
5000|$|Any <b>compilation</b> <b>unit</b> may [...] other interfaces, {{although}} circular imports are forbidden.This may {{be resolved}} by doing the import from the implementation MODULE.The entities within the imported module may be imported, instead of just the module name, using the [...] syntax: ...|$|E
5000|$|In a REPL, {{the user}} enters {{one or more}} {{expressions}} (rather than an entire <b>compilation</b> <b>unit)</b> and the REPL evaluates them and displays the results. The name read-eval-print loop comes from {{the names of the}} Lisp primitive functions which implement this functionality: ...|$|E
5000|$|In the C language, the [...] pre-compile {{directive}} always {{causes a}} file's contents to be {{inserted into the}} source at that point. Objective-C has the [...] directive, equivalent except that each file is included only once per <b>compilation</b> <b>unit,</b> obviating the need for include guards.|$|E
40|$|The Ada Semantic Interface Specification (ASIS) {{provides}} {{the basis for}} implementing portable tools aimed at analysing static properties of Ada source code. The main purpose of the Ada language definition is to specify the legality of <b>compilation</b> <b>units</b> and the behaviour of a program at run-time. While there is obviously a large common part in Ada and ASIS, the different goals also justify some specific terminology and mechanisms in ASIS. The article presents some of them...|$|R
50|$|CDL2, which {{appeared}} in 1976, kept the principles of CDL1 but made the language suitable for large projects. It introduced modules, enforced data-change-only-on-success and extended {{the capabilities of the}} language somewhat. The optimizers in the CDL2 compiler and especially in the CDL2 Laboratory (an IDE for CDL2) were world class and not just for their time. One feature of the CDL2 Laboratory optimizer is almost unique: it can perform optimizations across <b>compilation</b> <b>units,</b> i.e., treating the entire program as a single compilation.|$|R
5000|$|A Fabasoft app.ducx project {{consists}} {{of one or}} more source files, formally known as <b>compilation</b> <b>units,</b> and project files that are specific to the development environment used (Eclipse). The source code for an app.ducx project is typically stored in one or more text files with a file extension of [...]ducx-om, [...]ducx-rs, [...]ducx-uc, [...]ducx-ui, [...]ducx-os, [...]ducx-bp or [...]ducx-cu.Each source file must contain exactly one type of model. A model {{consists of}} a block that can contain import declarations and element definitions.|$|R
