3|10000|Public
50|$|In {{computer}} science, {{a composite}} data type or <b>compound</b> <b>data</b> <b>type</b> is any data type {{which can be}} constructed in a program using the programming language's primitive data types and other composite types. It is sometimes called a structure or aggregate data type, although the latter term may also refer to arrays, lists, etc. The act of constructing a composite type is known as composition.|$|E
5000|$|The basic {{types in}} Fril {{are similar to}} those in Prolog, with one {{important}} exception: Prolog's <b>compound</b> <b>data</b> <b>type</b> is the term, with lists defined as nested terms using the [...] functor; in Fril, the compound type is the list itself, which forms the basis for most constructs. Variables are distinguished by identifiers containing only uppercase letters and underscores (whereas Prolog only requires the first character to be uppercase). As in Prolog, the name [...] is reserved to mean [...] "any value", with multiple occurrences of [...] replaced by distinct variables.|$|E
40|$|The {{problem of}} {{choosing}} the programming language for training is {{considered in the}} paper. Requirements to the language are determined, and a new programming language for training is offered. Language structures have С-like syntax, but more consecutive and regular. The language supports two programming paradigms: procedural and object-oriented. One of the main features of the language is the existence of singular <b>compound</b> <b>data</b> <b>type</b> – the generalized container. Some interesting properties of IDE are described besides the language definition...|$|E
5000|$|Tuples: Tuples are {{containers}} for a fixed number of Erlang <b>data</b> <b>types.</b> The syntax [...] denotes a tuple whose arguments are [...] The arguments can be primitive <b>data</b> <b>types</b> or <b>compound</b> <b>data</b> <b>types.</b> Any {{element of a}} tuple can be accessed in constant time.|$|R
5000|$|Sawzall {{supports}} the <b>compound</b> <b>data</b> <b>types</b> lists, maps, and structs. However, {{there are no}} references or pointers. All assignments and function arguments create copies. This means that recursive data structures and cycles are impossible.|$|R
2500|$|Tuples: Tuples are {{containers}} for a fixed number of Erlang <b>data</b> <b>types.</b> The syntax {D1,D2,...,Dn} denotes a tuple whose arguments are D1, D2, ... Dn. The arguments can be primitive <b>data</b> <b>types</b> or <b>compound</b> <b>data</b> <b>types.</b> Any {{element of a}} tuple can be accessed in constant time.|$|R
50|$|In {{computer}} science, type conversion, type casting, {{and type}} coercion are {{different ways of}} changing an entity of one <b>data</b> <b>type</b> into another. An example would be the conversion of an integer value into a floating point value or its textual representation as a string, and vice versa. Type conversions {{can take advantage of}} certain features of <b>type</b> hierarchies or <b>data</b> representations. Two important aspects of a type conversion is whether it happens implicitly or explicitly, and whether the underlying data representation is converted from one representation into another, or a given representation is merely reinterpreted as the representation of another <b>data</b> <b>type.</b> In general, both primitive and <b>compound</b> <b>data</b> <b>types</b> can be converted.|$|R
40|$|Part 4 : Engineering of Enterprise Software ProductsInternational audienceHierarchical Data Format (HDF 5) is {{a popular}} binary storage {{solution}} in high performance computing (HPC) and other scientific fields. It has bindings for many popular programming languages, including C++, which is widely used in the HPC field. Its C++ API requires mapping of the native C++ <b>data</b> <b>types</b> to types native to the HDF 5 API. This task can be error prone, especially when working with complex data structures, which are usually stored using HDF 5 <b>compound</b> <b>data</b> <b>types.</b> Due {{to the lack of}} a comprehensive reflection mechanism in C++, the mapping code for data manipulation has to be hand-written for each compound type separately. This approach is vulnerable to bugs and mistakes, which can be eliminated by using an automated code generation phase. In this paper we present an approach implemented in the LARA language and supported by the tool Clava, which allows us to automate the generation of the HDF 5 data access code for complex data structures in C++...|$|R
40|$|Object-oriented re-architecting (OORA) {{concerns}} {{identification of}} objects in procedural code with the goal to transform a procedural into an object-oriented program. We have developed a method {{to address the problem}} of object identification from two different directions: 1) building an object model of the application based on system documentation to ensure the creation of application-semantic classes; and 2) analyzing the source code to identify potential class candidates on the basis of <b>compound</b> <b>data</b> <b>types</b> and <b>data</b> flow analysis. Object model classes are bound to class candidates to prepare a forward biased and thus semantically meaningful program transformation at the source code level. In this paper, we define a similarity measure for classes to enables the binding process. We also describe the constraints and benefits of human intervention in this process. We have applied this method to a real-world embedded software system to identify potential classes; results from the case study are given in the paper. 1...|$|R
50|$|Tables are <b>compound</b> <b>data</b> {{structures}} that may contain {{any of the}} regular <b>data</b> <b>types.</b>|$|R
5000|$|In an {{associative}} array (or map, dictionary, lookup table), {{like in a}} dictionary, a lookup on a key (like a word) {{provides a}} value (like a definition). The value might be {{a reference to a}} <b>compound</b> <b>data</b> structure. A hash table is usually an efficient implementation, and thus this <b>data</b> <b>type</b> is often known as a [...] "hash".|$|R
5000|$|In {{computer}} science, {{a record}} (also called struct or <b>compound</b> <b>data)</b> {{is a basic}} data structure. A record {{is a collection of}} fields, possibly of different <b>data</b> <b>types,</b> typically in fixed number and sequence [...] The fields of a record may also be called members, particularly in object-oriented programming. Fields may also be called elements, though these risk confusion with the elements of a collection. A tuple {{may or may not be}} considered a record, and vice versa, depending on conventions and the specific programming language.|$|R
40|$|Visualization {{of large}} data sets, {{especially}} on small machines, requires advanced techniques in image processing and image generation. Our hybrid raytracer {{is capable of}} rendering volumetric and geometric data simultaneously, without loss of accuracy due to <b>data</b> conversion. <b>Compound</b> <b>data</b> sets, consisting of several <b>types</b> of <b>data,</b> are called "hybrid data sets". There is only one rendering pipeline to obtain loss-less and efficient visualization of hybrid data. Algorithms apply to both <b>types</b> of <b>data.</b> Optical material properties are stored in the same data base for both volumetric and geometric objects, and anti-aliasing methods appeal to both <b>data</b> <b>types.</b> Stereoscopic display routines {{have been added to}} obtain true three-dimensional visualization on various media, and animation features allow generation of recordable 3 -D sequences...|$|R
40|$|LFC is a {{functional}} language based on recursive functions defined on context-free languages. In LFC context-free language (CFL) {{is used as}} <b>data</b> <b>type</b> to represent <b>compound</b> <b>data</b> structures. This makes LFC a dynamically typed language. To improve efficiency, we present a practical type checking method, which consists of both static and dynamic type checking. Although the inclusion relation of CFLs is not decidable, a special subset of the relation is decidable, i. e. the sentential pattern relation, which can be statically checked. Moreover, most of the expressions in actual LFC programs appear to satisfy this relation according to the statistic data of our experiments. So, despite the static type checking is not complete, it undertakes most of the type checking task. Consequently the run time efficiency is greatly improved...|$|R
50|$|A new <b>data</b> <b>type</b> can be added, {{possibly}} with default <b>data</b> <b>type</b> ID, {{as long as}} {{the default}} <b>data</b> <b>type</b> ID doesn’t conflict with one of the existing <b>data</b> <b>types.</b>|$|R
5000|$|ActionScript {{primarily}} {{consists of}} [...] "fundamental" [...] or [...] "simple" [...] <b>data</b> <b>types</b> {{which are used}} to create other <b>data</b> <b>types.</b> These <b>data</b> <b>types</b> {{are very similar to}} Java <b>data</b> <b>types.</b> Since ActionScript 3 was a complete rewrite of ActionScript 2, the <b>data</b> <b>types</b> and their inheritances have changed.|$|R
50|$|Data Type: The <b>Data</b> <b>Type</b> {{specifies}} how the payload of {{the message}} shall be interpreted with respect to its <b>data</b> <b>type</b> (i.e. floating-point <b>data</b> or number of bytes in case of integer data). The corresponding <b>data</b> <b>type</b> code is taken from the CANaerospace <b>data</b> <b>type</b> list which allows also user-defined <b>data</b> <b>type</b> definitions.|$|R
50|$|Two pins in OpenWire {{can connect}} and {{exchange}} data {{only if they}} support compatible <b>data</b> <b>types.</b> Each pin can support one or more <b>data</b> <b>types.</b> The <b>data</b> <b>types</b> are distinguished by GUID unique for each <b>data</b> <b>type.</b>|$|R
5000|$|Many {{implementations}} of YAML {{can support}} user-defined <b>data</b> <b>types</b> for object serialization. Local <b>data</b> <b>types</b> are not universal <b>data</b> <b>types</b> but are {{defined in the}} application using the YAML parser library. Local <b>data</b> <b>types</b> use a single exclamation mark (...) [...]|$|R
50|$|In some {{programming}} environments {{the term}} complex <b>data</b> <b>type</b> (in contrast to primitive <b>data</b> <b>types)</b> is {{a synonym for}} the composite <b>data</b> <b>type.</b>|$|R
5000|$|Care has to {{be taken}} for select <b>data</b> <b>types</b> based on defined <b>data</b> <b>types.</b> Here the name of the defined <b>data</b> <b>type</b> gets mapped too.|$|R
40|$|<b>Data</b> <b>types</b> are {{the core}} of many applications, and {{libraries}} offering implementations of <b>data</b> <b>types</b> should better be solid and well tested. Testing purely functional <b>data</b> <b>types</b> with QuickCheck provides a complete test method for <b>data</b> <b>types,</b> but establishing a complete test method for <b>data</b> <b>types</b> with side-effects is still an open issue. In this paper we show how we can use a stateful QuickCheck model to establish a complete test method for any <b>data</b> <b>type.</b> Considering side effects allows us {{to move from the}} purely functional world to the imperative world, as needed to face the testing of <b>data</b> <b>types</b> implementations in languages such as C. We therefore applied our method to some of the <b>data</b> <b>types</b> provided by the well-known GNOME Glib library...|$|R
50|$|The main way of {{defining}} <b>data</b> <b>types</b> in Agda is via inductive <b>data</b> <b>types</b> which {{are similar to}} algebraic <b>data</b> <b>types</b> in non-dependently typed programming languages.|$|R
40|$|Abstract: Various fuzzy {{data models}} such as fuzzy {{relational}} databases, fuzzy object-oriented databases, fuzzy objectrelational databases and fuzzy XML {{have been proposed}} in the literature in order to represent and process fuzzy information in databases and XML. But little {{work has been done}} in modeling fuzzy <b>data</b> <b>types.</b> Actually in the fuzzy data models, each fuzzy value is associated with a fuzzy <b>data</b> <b>type.</b> Explicit representations of fuzzy <b>data</b> <b>types</b> are the foundation of fuzzy data processing. To fill this gap, in this paper, we propose several fuzzy <b>data</b> <b>types,</b> including fuzzy simple <b>data</b> <b>types,</b> fuzzy collection <b>data</b> <b>types</b> and fuzzy defined <b>data</b> <b>types.</b> We further investigate how to declare the fuzzy <b>data</b> <b>types</b> in the fuzzy object-oriented database model and fuzzy XML Schema. The proposed fuzzy <b>data</b> <b>types</b> can meet the requirement of modeling fuzzy data in the fuzzy databases and fuzzy XML...|$|R
40|$|We {{discuss the}} {{application}} of the Haskell/Gofer type classes and constructor classes to the implementation and teaching of the manipulation techniques in the domain of formal mathematical expressions. We show also how the lazy evaluation paradigms simplify the construction and the presentation of several algorithms dealing with iterative <b>data</b> <b>types,</b> such as power series or formal Pad'e expansion. We show {{the application of}} higher order functions to algebra and geometry, and specifically [...] - to the construction of parametric surfaces. 1 Introduction Formal manipulation of algebraic and geometric objects seems `a priori to be a wonderful training ground for mathematically oriented students who want to learn the design and the implementation of complex algorithms and heterogeneous data structures. It is not very often exploited, though. While it is standard at quite elementary level, to teach formal differentiation of algebraic tree structures, or the arithmetic of <b>compound</b> <b>data</b> struct [...] ...|$|R
50|$|Although Excel {{nominally}} {{works with}} 8-byte numbers by default, VBA has {{a variety of}} <b>data</b> <b>types.</b> The Double <b>data</b> <b>type</b> is 8 bytes, the Integer <b>data</b> <b>type</b> is 2 bytes, and the general purpose 16 byte Variant <b>data</b> <b>type</b> can be converted to a 12 byte Decimal <b>data</b> <b>type</b> using the VBA conversion function CDec. Choice of variable types in a VBA calculation involves consideration of storage requirements, accuracy and speed.|$|R
50|$|In {{computer}} programming languages, a recursive <b>data</b> <b>type</b> (also {{known as a}} recursively-defined, inductively-defined or inductive <b>data</b> <b>type)</b> is a <b>data</b> <b>type</b> for values that may contain other values of the same <b>type.</b> <b>Data</b> of recursive <b>types</b> are usually viewed as directed graphs.|$|R
40|$|A program {{derivation}} {{is said to}} be polytypic if some of its {{parameters are}} <b>data</b> <b>types.</b> Polytypic program derivations necessitate a general, non-inductive definition of `data type'. Here we propose such a definition: a <b>data</b> <b>type</b> is a relator that has membership. It is shown how this definition implies various other properties that are shared by all <b>data</b> <b>types.</b> In particular, all <b>data</b> <b>types</b> have a unique strength, and all natural transformations between <b>data</b> <b>types</b> are strong. 1 Introduction What is a <b>data</b> <b>type?</b> It is easy to list a number of examples: pairs, lists, bags, finite sets, possibly infinite sets, function spaces... but such a list of examples hardly makes a definition. The obvious formalisation is a definition that builds up the class of <b>data</b> <b>types</b> inductively; such an inductive definition, however, leads to cumbersome proofs if we want to prove a property of all <b>data</b> <b>types.</b> Here we aim to give a non-inductive characterisation, defining a <b>data</b> <b>type</b> as a mathematical object [...] ...|$|R
50|$|Cg also {{features}} vector and matrix <b>data</b> <b>types</b> {{that are based}} on the basic <b>data</b> <b>types,</b> such as float3 and float4x4. Such <b>data</b> <b>types</b> are quite common when dealing with 3D graphics programming. Cg also has struct and array <b>data</b> <b>types,</b> which work in a similar way to their C equivalents.|$|R
30|$|Elements of the {{specific}} vector have the same <b>data</b> <b>types,</b> meaning that conversion of different <b>data</b> <b>types</b> to one <b>data</b> <b>type</b> for vectors should be done before employing the vector model.|$|R
50|$|Once {{declared}} deprecated, the <b>data</b> <b>type</b> will {{be maintained}} {{for at least}} two more years. After this period its default <b>data</b> <b>type</b> ID may be reused for an incompatible <b>data</b> <b>type.</b>|$|R
40|$|Data {{interoperability}} is {{an ongoing}} challenge for global open data initiatives. The machine-readable specification of <b>data</b> <b>types</b> for datasets will help address interoperability issues. <b>Data</b> <b>types</b> have typically been at the syntactical level such as integer, float and string, etc. in programming languages. The work {{presented in this paper}} is a model design for the semantic specification of <b>data</b> <b>types,</b> such as a topographic map. The work was conducted {{in the context of the}} Semantic Web. The model differentiates the semantic <b>data</b> <b>type</b> from the basic <b>data</b> <b>type.</b> The former are instances (e. g., topographic map) of a specific <b>data</b> <b>type</b> class that is defined in the developed model. The latter are classes (e. g., Image) of resource types in existing ontologies. A data resource is an instance of a basic <b>data</b> <b>type</b> and is tagged with one or more specific <b>data</b> <b>types.</b> The implementation of the model is given within an existing production data portal that enables one to register specific <b>data</b> <b>types</b> and use them to annotate data resources. Data users can obtain explicating assumptions or information inherent in a dataset through the specific <b>data</b> <b>types</b> of that dataset. The machine-readable information of specific <b>data</b> <b>types</b> also paves the way for further studies, such as dataset recommendation...|$|R
5000|$|There are {{additional}} [...] "complex" [...] <b>data</b> <b>types.</b> These are more processor and memory intensive and consist of many [...] "simple" [...] <b>data</b> <b>types.</b> For AS2, {{some of these}} <b>data</b> <b>types</b> are: ...|$|R
5000|$|A {{wide range}} of {{computational}} <b>data</b> <b>types,</b> program control <b>data</b> <b>types,</b> and forms of <b>data</b> structure (strong <b>typing).</b>|$|R
30|$|Another notable {{issue in}} {{exploring}} the AoaS layout {{is the use}} of build-in <b>data</b> <b>types.</b> CUDA has provided various build-in <b>data</b> <b>types.</b> The size requirement for alignment is automatically fulfilled. Compared to those user-defined <b>data</b> <b>types</b> in AoaS formant (see Fig.  3), we have found the counterparts of the build-in <b>data</b> <b>types</b> provided by CUDA do not achieve notable advantages. In addition, the user-defined AoaS <b>data</b> <b>types</b> are suggested to be used for the convenience in programming.|$|R
40|$|A program {{derivation}} {{is said to}} be polytypic if some of its {{parameters are}} <b>data</b> <b>types.</b> Polytypic program derivations necessitate a general non inductive definition of ‘data type’. Here we propose such a definition: a <b>data</b> <b>type</b> is a relator that has membership. It is shown how this definition implies various other properties that are shared by all <b>data</b> <b>types.</b> In particular, all <b>data</b> <b>types</b> have a unique strength, and all natural transformations between <b>data</b> <b>types</b> are strong...|$|R
