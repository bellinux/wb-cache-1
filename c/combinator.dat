959|740|Public
25|$|A more {{interesting}} <b>combinator</b> is the fixed point <b>combinator</b> or Y <b>combinator,</b> {{which can be}} used to implement recursion.|$|E
25|$|In March 2015, it was {{announced}} that Thiel joined Y <b>Combinator</b> as one of 10 part-time partners.|$|E
25|$|Bracket {{abstraction}} induces {{a translation}} from lambda terms to <b>combinator</b> expressions, by interpreting lambda-abstractions using the bracket abstraction algorithm.|$|E
50|$|The {{simplest}} {{example of}} an undecidable word problem occurs in combinatory logic: when are two strings of <b>combinators</b> equivalent? Because <b>combinators</b> encode all possible Turing machines, and the equivalence of two Turing machines is undecidable, {{it follows that the}} equivalence of two strings of <b>combinators</b> is undecidable.|$|R
40|$|There {{are many}} combinatorially {{complete}} sets of <b>combinators,</b> or `instruction sets' {{to which the}} -calculus can be compiled. The most famous are perhaps fS; K g and fB;C;K;W g. Several authors have observed {{that there is a}} set of `arithmetical' <b>combinators</b> fA; M;E;N g arising from the Church numerals, which is also combinatorially complete. However their sets of <b>combinators</b> are not absolutely perfect. The perfect set of <b>combinators</b> (f(+); (); (^); 0 g in section-notation) is defined herein. There i...|$|R
50|$|IsaPlanner's library {{supplies}} <b>combinators</b> for branching and iteration, amongst other tasks, {{and powerful}} reasoning techniques {{can be created}} by combining simpler reasoning techniques with these <b>combinators.</b>|$|R
25|$|As a consequence, <b>combinator</b> K is {{not present}} in the λI {{calculus}} nor in the CLI calculus. The constants of CLI are: I, B, C and S, which form a basis from which all CLI terms can be composed (modulo equality). Every λI term can be converted into an equal CLI <b>combinator</b> according to rules similar to those presented above for the conversion of λK terms into CLK combinators. See chapter 9 in Barendregt (1984).|$|E
25|$|Several {{of these}} have direct {{applications}} in the elimination of lambda-abstraction that turns lambda terms into <b>combinator</b> calculus terms.|$|E
25|$|A central {{property}} of the lambda calculus is, that recursive definitions are non-elemental, but can instead be expressed by a fixed point <b>combinator.</b>|$|E
40|$|We {{describe}} a scheme for constructing parsers for precedence grammars {{based on the}} <b>combinators</b> described in [4]. The new <b>combinators</b> provide a robust method for building parsers and help avoid {{the possibility of a}} non-terminating parser. Efficiency is improved via an optimisation to the grammar. A number of approaches to the problem are described [...] the most elegant and efficient method is based on continuation passing. A parser for the expression part of the C programming language is presented. 1 Introduction In this paper, we use the parsing <b>combinators</b> described in [4] to construct a set of higher-level <b>combinators</b> designed specifically to handle precedence grammars. This set is open ended [...] we have chosen to implement functions to handle the most common expressions syntaxes; specifically, there are <b>combinators</b> for infix binary operators, prefix and postfix unary operators, subexpressions and atoms. In Section 5 we develop some specialised <b>combinators</b> to handle some of the more un [...] ...|$|R
50|$|The {{first two}} rules are also simple: Variables convert to themselves,and applications, which are allowed in combinatory terms, areconverted to <b>combinators</b> simply by {{converting}} the applicand and theargument to <b>combinators.</b>|$|R
40|$|One of {{the most}} {{appealing}} features of constraint programming is its rich constraint language for expressing combinatorial optimization problems. This paper demonstrates that traditional <b>combinators</b> from constraint programming have natural counterparts for local search, although their underlying computational model is radically different. In particular, the paper shows that constraint <b>combinators,</b> such as logical and cardinality operators, reification, and first-class expressions can all be viewed as differentiable objects. These <b>combinators</b> naturally support elegant and efficient modelings, generic search procedures, and partial constraint satisfaction techniques for local search. Experimental results {{on a variety of}} applications demonstrate the expressiveness and the practicability of the <b>combinators...</b>|$|R
25|$|Since {K, S} is a basis, {{it follows}} that {X} is a basis too. The Iota {{programming}} language uses X as its sole <b>combinator.</b>|$|E
25|$|Combinatory logic can {{be viewed}} as a variant of the lambda calculus, in which lambda {{expressions}} (representing functional abstraction) are replaced by a limited set of combinators, primitive functions from which bound variables are absent. It is easy to transform lambda expressions into <b>combinator</b> expressions, and <b>combinator</b> reduction is much simpler than lambda reduction. Hence combinatory logic has been used to model some non-strict functional programming languages and hardware. The purest form of this view is the programming language Unlambda, whose sole primitives are the S and K combinators augmented with character input/output. Although not a practical programming language, Unlambda is of some theoretical interest.|$|E
25|$|It {{is related}} to the process of bracket abstraction, which takes an {{expression}} E built from variables and application and produces a <b>combinator</b> expression E in which the variable x is not free, such that E x = E holds.|$|E
50|$|The simple {{implementations}} of parser <b>combinators</b> {{have some}} shortcomings, which {{are common in}} top-down parsing. Naïve combinatory parsing requires exponential time and space when parsing an ambiguous context-free grammar. In 1996, Frost and Szydlowski demonstrated how memoization {{can be used with}} parser <b>combinators</b> to reduce the time complexity to polynomial. Later Frost used monads to construct the <b>combinators</b> for systematic and correct threading of memo-table throughout the computation.|$|R
50|$|In untyped lambda {{calculus}} fixed-point <b>combinators</b> are not especially rare. In fact there are infinitely many of them. In 2005 Mayer Goldberg {{showed that the}} set of fixed-point <b>combinators</b> of untyped {{lambda calculus}} is recursively enumerable.|$|R
40|$|Program {{understanding}} tools manipulate program representations, such as {{abstract syntax}} trees, controlflow graphs, or data-flow graphs. This paper {{deals with the}} use of visitor <b>combinators</b> to conduct such manipulations. Visitor <b>combinators</b> are an extension of the well-known visitor design pattern. They are small, reusable classes that carry out specific visiting steps. They can be composed in different constellations to build more complex visitors. We evaluate the expressiveness, reusability, ease of development, and applicability of visitor <b>combinators</b> to the construction of program understanding tools. To that end, we conduct a case study in the use of visitor <b>combinators</b> for control-flow analysis and visualization as used in a commercial Cobol program understanding tool...|$|R
25|$|Through July 2011, {{the company}} had raised US$119.8 million in venture funding from Y <b>Combinator,</b> Greylock Partners, Sequoia Capital, Andreessen Horowitz, Digital Sky Technologies, General Catalyst Partners and {{undisclosed}} amounts from Youniversity Ventures partners Jawed Karim, Keith Rabois, and Kevin Hartz, and from A Grade Investments partners Ashton Kutcher and Guy Oseary.|$|E
25|$|In the {{business}} sector, Quartz reported in August 2014 that, among 150 companies checked in three major categories in the United States (Fortune 50 largest companies, mid-size tech and media companies, and startup companies {{from the last}} Y <b>Combinator</b> incubator class), only one Fortune 50 company used Gmail - Google itself - while 60% of mid-sized companies and 92% of startup companies were using Gmail.|$|E
25|$|Given a lambda {{term with}} first {{argument}} representing recursive call (e.g. G here), the fixed-point <b>combinator</b> FIX will return a self-replicating lambda expression representing the recursive function (here, F). The function {{does not need}} to be explicitly passed to itself at any point, for the self-replication is arranged in advance, when it is created, to be done each time it is called. Thus the original lambda expression (FIX G) is re-created inside itself, at call-point, achieving self-reference.|$|E
40|$|A {{possible}} analogue {{of theory}} of <b>combinators</b> {{in the setting}} of concurrent processes is formulated. The new <b>combinators</b> are derived from the analysis of the operation called asynchronous name passing, just as the analysis of logical substitution gave rise to the sequential <b>combinators.</b> A system with seven atoms and fixed interaction rules, but with no notion of prefixing, is introduced, and is shown to be capable of representing input and output prefixes over arbitrary terms in a behaviourally correct way, just as SK-combinators are closed under functional abstraction without having it as a proper syntactic construct. The basic equational correspondence between concurrent <b>combinators</b> and a system of asynchronous mobile processes, as well as the embedding of the finite part of ß-calculus in concurrent <b>combinators,</b> is proved. These results will hopefully serve as a cornerstone for further investigation of the theoretical as well as pragmatic possibilities of the presented construction. 1 [...] ...|$|R
40|$|When bracket {{abstraction}} {{is being}} used to implement a functional programming language, it is desirable, according to Turner, that the algorithm used produces short abstracts, uses only a finite number of <b>combinators,</b> is uni-variate and also well-behaved under self-composition. In this paper I show {{that it is impossible to}} devise an algorithm using a finite number of <b>combinators</b> that is always wellbehaved under self-composition. It is better to retain the property of being wellbehaved under self-composition, but then we need to choose our infinite set of <b>combinators</b> carefully. By using an iconic representation for <b>combinators</b> an easily implementable set can be devised. The resulting algorithm, namely (yn), produces abstracts that are never longer than those produced by Turner’s algorithm and it is always well-behaved. By further exploiting the iconic notation an even better algorithm, namely (yin), can be devised, but this is no longer so well-behaved. 1 2 Rerepresenting <b>Combinators...</b>|$|R
50|$|In {{programming}} languages {{that support}} anonymous functions, fixed-point <b>combinators</b> allow the definition {{and use of}} anonymous recursive functions, i.e. without having to bind such functions to identifiers. In this setting, the use of fixed-point <b>combinators</b> is sometimes called anonymous recursion.|$|R
25|$|In either case, {{a term of}} {{the form}} T(x,N) P can reduce by having the initial <b>combinator</b> I, K, or S grab the {{argument}} P, just like β-reduction of (λx.N) P would do. I returns that argument. K throws the argument away, just like (λx.N) would do if x has no free occurrence in N. S passes the argument on to both subterms of the application, and then applies {{the result of the}} first to the result of the second.|$|E
25|$|Consider all {{languages}} of finite structures with a fixed signature including a linear order relation. Then, all such languages in P {{can be expressed}} in first-order logic {{with the addition of}} a suitable least fixed-point <b>combinator.</b> Effectively, this, in combination with the order, allows the definition of recursive functions. As long as the signature contains at least one predicate or function in addition to the distinguished order relation, so that the amount of space taken to store such finite structures is actually polynomial in the number of elements in the structure, this precisely characterizes P.|$|E
25|$|Sigma Eta Pi and Bruin Entrepreneurs {{organize}} LA Hacks, {{an annual}} hackathon where students {{from around the}} United States come to build technology products. LA Hacks established itself as the largest hackathon in the United States when over 1500 students participated in April 11–13, 2014. LA Hacks also holds {{the record for the}} most funds raised via corporate sponsorships with $250,000 raised. Some of the tech world's most prominent people have given talks and judged projects at LA Hacks, including Evan Spiegel (Founder and CEO of Snapchat), Alexis Ohanian (Co-Founder of Reddit), Sam Altman (President of Y <b>Combinator)</b> and Chris De Wolfe (Founder of Myspace).|$|E
40|$|Abstract We {{advocate}} the Mendler style of coding terminating recursion schemes as <b>combinators</b> by showing on {{the example of}} two simple and much used schemes (course-of-value iteration and simultaneous iteration) that choosing the Mendler style can sometimes lead to handier constructions than following the construction style of cata and para like <b>combinators.</b> 1 Introduction This paper is intended as an advert for something we call the Mendler style. This is a not too widely known style of coding terminating recursion schemes by <b>combinators</b> that di ers from the construction style of the famous cata and para <b>combinators</b> (for iteration and primitive-recursion, respectively) [Mal 90,Mee 92], here called the conventional style. The paper ar [...] ...|$|R
40|$|Parser <b>combinators</b> {{enable the}} {{construction}} of recursive descent parsers in a very clear and simple way. Unfortunately, the resulting parsers have a polynomial complexity and are far too slow for realistic inputs. We show how the speed of these parsers can be improved by one order of magnitude using continuations. These continuations prevents the creation of intermediate data structures. Furthermore, by using an exclusive or-combinator instead of the ordinary or-combinator the complexity for deterministic parsers can be reduced from polynomial to linear. The combination of both improvements turn parser <b>combinators</b> from a beautiful toy to a practically applicable tool {{which can be used}} for real world applications. The improved parser <b>combinators</b> remain very easy to use and are still able to handle ambiguous grammars. 1 Introduction Parser <b>combinators</b> [3, 6, 5, 8] are a beautiful illustration of the use of higher order functions and currying. By using a small set of parser <b>combinators</b> [...] ...|$|R
40|$|In [15, 16], we {{presented}} {{a theory of}} concurrent <b>combinators</b> for the asynchronous monadic ß-calculus without match or summation operator [13, 6]. The system of concurrent <b>combinators</b> {{is based on a}} finite number of atoms and fixed interaction rules, but is as expressive as the original calculus, so that it can represent diverse interaction structures, including polyadic name passing [19] and input guarded summations [22]. The present paper shows that each of five basic <b>combinators</b> introduced in [15] is indispensable to represent the whole computation, i. e. if one of the <b>combinators</b> is missing, we can no longer express the original calculus up to weak bisimilarity. Expressive power of several interesting subsystems of ß-calculus is also measured by using appropriate subsets of the <b>combinators</b> and their variants. Finally as an application of the main result, we show there is no semantically sound encoding of the calculus into its proper subsystem under a certain condition. 1. Introduct [...] ...|$|R
25|$|After {{the sale}} of PayPal, he founded Clarium Capital, a global macro hedge fund. He {{launched}} Palantir Technologies, an analytical software company, in 2004 and continues to serve as its chairman as of 2017. His Founders Fund, a venture capital firm, was launched in 2005 along with PayPal partners Ken Howery and Luke Nosek. Earlier, Thiel became Facebook's first outside investor when he acquired a 10.2% stake for $500,000 in August 2004. He sold {{the majority of his}} shares in Facebook for over $1 billion in 2012, but remains on the board of directors. He also co-founded Valar Ventures in 2010 and operates as its chairman, co-founded Mithril Capital, of which he is investment committee chair, in 2012, and has served as a partner at Y <b>Combinator</b> since 2015.|$|E
25|$|Following Y <b>Combinator,</b> many {{accelerator}}s {{with similar}} models have emerged around the world. The accelerator model have since become very common and widely spread {{and they are}} key organizations of any Startup ecosystem. Title II of the Jumpstart Our Business Startups Act (JOBS Act), first implemented on September 23, 2013, granted startups in and startup co-founders or promoters in US. the right to generally solicit and advertise publicly using any method of communication {{on the condition that}} only accredited investors are allowed to purchase the securities. However the regulations affecting equity crowdfunding in different countries vary a lot with different levels and models of freedom and restrictions. In many countries there are no limitations restricting general public from investing to startups, while there can still be other types of restrictions in place, like limiting the amount that companies can seek from investors. Due to positive development and growth of crowdfunding, many countries are actively updating their regulation in regards to crowdfunding.|$|E
2500|$|It is rules 5 and 6 {{that are}} of interest. [...] Rule 5 simply says that to convert a complex {{abstraction}} to a <b>combinator,</b> we must first convert its body to a <b>combinator,</b> and then eliminate the abstraction. [...] Rule 6 actually eliminates the abstraction.|$|E
40|$|We {{describe}} a scheme for constructing parsers for precedence gram mars {{based on the}} <b>combinators</b> described in The new <b>combinators</b> provide a robust method for building parsers and help avoid the possi bility of a nonterminating parser Eciency is improved via an opti misation to the grammar A number of approaches to the problem are described the most elegant and ecient method is based on continu ation passing A parser for the expression part of the C programming language is presented In this paper we use the parsing <b>combinators</b> described in to construct a set of higherlevel <b>combinators</b> designed specically to handle precedence grammars This set is open ended 	 we have chosen to implement func tions to handle the most common expressions syntaxe...|$|R
50|$|Parsers built using <b>combinators</b> are {{straightforward}} to construct, readable, modular, well-structured, {{and easily}} maintainable. They {{have been used}} extensively in the prototyping of compilers and processors for domain-specific languages such as natural-language interfaces to databases, where complex and varied semantic actions are closely integrated with syntactic processing. In 1989, Richard Frost and John Launchbury demonstrated use of parser <b>combinators</b> to construct natural-language interpreters. Graham Hutton also used higher-order functions for basic parsing in 1992. S.D. Swierstra also exhibited the practical aspects of parser <b>combinators</b> in 2001. In 2008, Frost, Hafiz and Callaghan described a set of parser <b>combinators</b> in Haskell that solve the long-standing problem of accommodating left recursion, and work as a complete top-down parsing tool in polynomial time and space.|$|R
5000|$|According to Milner, [...] "There {{is nothing}} {{canonical}} about {{the choice of}} the basic <b>combinators,</b> even though they were chosen with great attention to economy. What characterises our calculus is not the exact choice of <b>combinators,</b> but rather the choice of interpretation and of mathematical framework".|$|R
