448|83|Public
5|$|Such {{identification}} enables {{interaction with}} {{representations of the}} resource over a network, typically the World Wide Web, using specific protocols. Schemes specifying a <b>concrete</b> <b>syntax</b> and associated protocols define each URI. The {{most common form of}} URI is the Uniform Resource Locator (URL), frequently referred to informally as a web address. More rarely seen in usage is the Uniform Resource Name (URN), which was designed to complement URLs by providing a mechanism for the identification of resources in particular namespaces.|$|E
2500|$|Other {{sources of}} {{technology}} for XML were the TEI (Text Encoding Initiative), which defined {{a profile of}} SGML {{for use as a}} [...] "transfer syntax"; and HTML, in which elements were synchronous with their resource, document character sets were separate from resource encoding, the xml:lang attribute was invented, and (like HTTP) metadata accompanied the resource rather than being needed at the declaration of a link. The ERCS(Extended Reference <b>Concrete</b> <b>Syntax)</b> project of the SPREAD (Standardization Project Regarding East Asian Documents) project of the ISO-related China/Japan/Korea Document Processing expert group was the basis of XML 1.0's naming rules; SPREAD also introduced hexadecimal numeric character references and the concept of references to make available all Unicode characters. To support ERCS, XML and HTML better, the SGML standard IS 8879 was revised in 1996 and 1998 with WebSGML Adaptations. The XML header followed that of ISO HyTime.|$|E
50|$|It is {{straightforward}} {{to provide such}} an RDF <b>concrete</b> <b>syntax</b> for rules, but the presence of variables in rules goes beyond the RDF Semantics. Translation from the XML <b>Concrete</b> <b>Syntax</b> to RDF/XML could be easily accomplished by extending the XSLT transformation for the OWL XML Presentation syntax.|$|E
5000|$|A single {{abstract}} syntax may {{be applied to}} many <b>concrete</b> <b>syntaxes,</b> in our case one for each new natural language we wish to add. The same system of trees can be given: ...|$|R
40|$|Abstract. Textual <b>concrete</b> <b>syntaxes</b> for {{models are}} {{beneficial}} for many reasons. They foster usability and productivity {{because of their}} fast editing style, their us-age of error markers, autocompletion and quick fixes. Furthermore, they can eas-ily be integrated into existing tools such as diff/merge or information interchange through e-mail, wikis or blogs. Several frameworks and tools from different com-munities for creating <b>concrete</b> textual <b>syntaxes</b> for models emerged during recent years. However, these approaches failed to provide a solution in general. Open issues are incremental parsing and model updating as well as partial and fed-erated views. To determine the capabilities of existing approaches, we provide a classification schema, apply it to these approaches, and identify their deficiencies. ...|$|R
40|$|We {{describe}} how multimodal grammars for dialogue {{systems can be}} written using the Grammatical Framework (GF) formalism. A proof-of-concept dialogue system constructed using these techniques is also presented. The software engineering problem of keeping grammars for different languages, modalities and systems (such as speech recognizers and parsers) in sync is reduced by the formal relationship between the abstract and <b>concrete</b> <b>syntaxes,</b> and by generating equivalent grammars from GF grammars. ...|$|R
5000|$|... a <b>concrete</b> <b>syntax</b> {{that fits}} well to model and {{metamodel}} writing.|$|E
5000|$|<b>Concrete</b> <b>syntax</b> is {{identified}} with phonology, broadly construed to include word order.|$|E
5000|$|... (and [...] "&#RE;&#RS;" [...] is a short-reference {{delimiter}} in the <b>concrete</b> <b>syntax),</b> then: ...|$|E
40|$|The {{increased}} use of modelling techniques that motivates the Model Driven Architec-ture requires effective support for model transformation techniques. These are being addressed by the MOF QVT activity with an abstract <b>syntax</b> and/or a <b>concrete</b> textual <b>syntax</b> for transformations. We feel {{that it should be}} possible for model driven tech-niques to be modelled graphically. We therefore present a <b>concrete</b> graphical <b>syntax</b> for a transformation language based on UML and demonstrate the syntax using the working example for MOF QVT submitters. ...|$|R
40|$|UML {{class-based}} {{models and}} OWL ontologies constitute modeling approaches with different strength and weaknesses {{that make them}} appropriate for specifying different aspects of software systems. We propose an integrated use of both modeling approaches in a coherent framework – TwoUse. We present a framework involving different <b>concrete</b> <b>syntaxes</b> for developing integrated models and use an OCL-like approach for writing query operations. We illustrate TwoUse’s applicability with a case study and conclude that TwoUse achieves enhancements of nonfunctional software requirements like maintainability, reusability and extensibility. Key words: CASE tools + UML, Ontologies, languages 1...|$|R
40|$|Abstract Domain-specific {{languages}} (DSLs) provide abstractions and notations {{for better}} understanding and easier modeling of applications {{in a special}} domain. Current shortcomings of DSLs include learning curve and formal semantics. This paper reports on a framework that allows the use of ontology technologies to describe and reason on DSLs. The formal semantics of OWL together with reasoning services allows for addressing constraint definition, progressive evaluation, suggestions, and debugging. The approach integrates existing metamodels and <b>concrete</b> <b>syntaxes</b> in a new technical space. A scenario in which domain models for network devices are created illustrates the framework. ...|$|R
50|$|SPARQL Syntax Expressions (alternatively, SPARQL S-Expressions) is a <b>concrete</b> <b>syntax</b> for {{representing}} SPARQL Algebra expressions.|$|E
5000|$|HOG {{maintains}} Haskell Curry's {{distinction between}} tectogrammatical structure (abstract syntax) and phenogrammatical structure (<b>concrete</b> <b>syntax).</b>|$|E
5000|$|The usual (default) SGML <b>{{concrete}}</b> <b>syntax</b> resembles this example, {{which is}} the default HTML concrete syntax: ...|$|E
40|$|Grammatical Framework, GF, is a grammar {{formalism}} {{designed to}} support multilingual grammars. A multilingual grammar has an abstract syntax, which {{is shared by}} a set of languages. Each of these languages has a con-crete syntax, which defines a relation between trees in the abstract syntax and strings in the language. For example, here is an abstract syntax tree representing predication with the verb love, subject I, and object you: With appropriate <b>concrete</b> <b>syntaxes</b> for Chinese, English, Finnish, and French, we obtain the following strings, together with word alignments determined by the tree structure:...|$|R
40|$|Multimodal {{dialogue}} {{systems are}} interactive systems which support several modes {{of communication with}} the user, for example speech, mouse clicks and drawings. We present a method for writing multimodal grammars in the Grammatical Framework (GF) and for using such grammars in dialogue systems. Parallel multimodality, where the same information is represented in multiple modalities, is achieved by using multiple <b>concrete</b> <b>syntaxes</b> for the same abstract syntax. Integrated multimodality, where the different modalities are used together to represent some information, is done by using record types. We will also present an example multimodal dialogue system implemented using these techniques. This work {{is part of the}} TALK projec...|$|R
40|$|International audienceThe TPTP World is a {{well-established}} infrastructure for automatic theorem provers. It defines several <b>concrete</b> <b>syntaxes,</b> notably an untyped first-order form (FOF) and a typed first-order form (TFF 0), {{that have become}} de facto standards. This paper introduces the TFF 1 format, an extension of TFF 0 with rank- 1 polymorphism. The format {{is designed to be}} easy to process by existing reasoning tools that support ML-style polymorphism. It opens the door to useful middleware, such as monomorphizers and other translation tools that encode polymorphism in FOF or TFF 0. Ultimately, the hope is that TFF 1 will be implemented in popular automatic theorem provers...|$|R
50|$|Tefkat has an SQL-like <b>concrete</b> <b>syntax</b> {{designed}} to concisely convey {{the intent of}} each rule, pattern or template.|$|E
50|$|SGML has an {{abstract}} syntax implemented by many possible concrete syntaxes, however, {{this is not}} the same usage as in {{an abstract}} syntax tree and as in a <b>concrete</b> <b>syntax</b> tree. In the SGML usage, a <b>concrete</b> <b>syntax</b> is a set of specific delimiters, while the abstract syntax is the set of names for the delimiters. The XML Infoset corresponds more to the programming language notion of abstract syntax introduced by John McCarthy.|$|E
50|$|In the <b>concrete</b> <b>syntax</b> below, the prefixes bind {{more tightly}} than the {{parallel}} composition (|), and parentheses {{are used to}} disambiguate.|$|E
40|$|We develop many-valued logic, {{including}} a generic abstract model theory, over a fully abstract syntax. We show that important many-valued logic model theories, such as traditional first-order many-valued logic and fuzzy multi-algebras, may be conservatively embedded into our abstract framework. Our development is technically {{based upon the}} so-called theory of institutions of Goguen and Burstall and {{may serve as a}} template for defining at hand many-valued logic model theories over various <b>concrete</b> <b>syntaxes</b> or, from another perspective, to combine many-valued logic with other logical systems. We also show that our generic many-valued logic abstract model theory enjoys a couple of important institutional model theory properties that support the development of deep model theory methods. Key words: institutions, many-valued logic 1...|$|R
40|$|International audienceThis paper {{deals with}} the problem, coming from an {{industrial}} context, of ontology transformations. EADS, as a major aircraft manufacturer faces the problem of integrating works of experts from different domains using different notations. Addressing this Domain-Specific Language (DSL) problem, we previously developed a solution based on OWL 2 ontologies for the integration of multiple domains at the abstract syntax level. Our next step is then the production of visual <b>concrete</b> <b>syntaxes</b> from this abstract syntax, for each domain. Considering this problem as a transformation issue, we raise the challenge of ontology transformations. We provide an OWL 2 -based rule language {{for the expression of}} such transformations. Validating this approach, our rule language has been implemented in a rule and transformation engine and tested on applications coming from the industry...|$|R
40|$|Abstract. Domain {{specific}} languages (DSLs) play {{a cornerstone}} role in Model-Driven Software Development for representing models and metamodels. DSLs are usually defined {{only in terms}} of their abstract and <b>concrete</b> <b>syntaxes,</b> although this hampers the development of formal analysis and simulation tools. In this paper we advocate the use of in-place model transformations to complement metamodels (the structural aspects of a DSL) with timed behavioral specifications. In particular, we propose an extension for in-place transformation rules to state action properties (not only model element properties), and to model time-dependent behavior. This approach avoids making unnatural changes to the DSL metamodels to represent behavioral and time aspects, and allows the resulting specifications to be translated into different semantic domains, such as Real-Time Maude, making them amenable to simulation and other kinds of formal analysis. ...|$|R
50|$|The <b>Concrete</b> <b>Syntax</b> Development project {{contains}} the Graphical Modeling Framework, an Eclipse-based framework {{dedicated to the}} graphical representation of EMF based models.|$|E
50|$|Jimple is an {{intermediate}} {{representation of a}} Java program designed to be easier to optimize than Java bytecode. It is typed, has a <b>concrete</b> <b>syntax</b> {{and is based on}} three-address code.|$|E
5000|$|Quasi-quotation, {{which allows}} the user to define new <b>concrete</b> <b>syntax</b> for {{expressions}} and patterns. Quasi-quotation is useful when a metaprogram written in Haskell manipulates code written in a language other than Haskell.|$|E
40|$|Abstract. The TPTP World is a {{well-established}} infrastructure for automatic theorem provers. It defines several <b>concrete</b> <b>syntaxes,</b> notably an untyped firstorder form (FOF) and a typed first-order form (TFF 0), {{that have become}} de facto standards in the automated reasoning community. This paper introduces the TFF 1 format, an extension of TFF 0 with rank- 1 polymorphism. It presents its syntax, typing rules, and semantics, {{as well as a}} sound and complete translation to TFF 0. The format is designed to be easy to process by existing reasoning tools that support ML-style polymorphism. It opens the door to useful middleware, such as monomorphizers and other translation tools that encode polymorphism in FOF or TFF 0. Ultimately, the hope is that TFF 1 will be implemented in popular automatic theorem provers. ...|$|R
40|$|In this paper, we {{show how}} the OMG's metamodelling {{approach}} to domain-specific language definition can be exploited to infer human-usable textual notations (<b>concrete</b> <b>syntaxes)</b> from the conceptualization provided by metamodels (abstract syntaxes). We give general rules to derive a context-free EBNF (Extended Backus-Naur Form) grammar from a MOF-compliant metamodel, and we show how to instruct a parser generator by these rules for generating a compiler which is able to parse the grammar and to transfer information about models into a MOF-based instance repository. The approach is exemplified for the Abstract State Machines Metamodel (AsmM), a metamodel for the Abstract State Machine (ASM) formal method, by illustrating the derivation of a textual notation to write ASM specifications conforming to the AsmM, and the process to input ASM models into a MOF repository...|$|R
40|$|The TPTP World is a {{well-established}} infrastructure for automatic theorem provers. It defines several <b>concrete</b> <b>syntaxes,</b> notably an untyped firstorder form (FOF) and a typed first-order form (TFF 0), {{that have become}} de facto standards in the automated reasoning community. This paper introduces the TFF 1 format, an extension of TFF 0 with rank- 1 polymorphism. It presents its syntax, typing rules, and semantics, {{as well as a}} sound and complete translation to TFF 0. The format is designed to be easy to process by existing reasoning tools that support ML-style polymorphism. It opens the door to useful middleware, such as monomorphizers and other translation tools that encode polymorphism in FOF or TFF 0. Ultimately, the hope is that TFF 1 will be implemented in popular automatic theorem provers...|$|R
5000|$|The XML <b>Concrete</b> <b>Syntax</b> is a {{combination}} of the OWL Web Ontology Language XML Presentation Syntax with the RuleML XML syntax. [...] x1 [...] x2 [...] x2 [...] x3 [...] x1 [...] x3 ...|$|E
50|$|CCSL {{provides}} a <b>concrete</b> <b>syntax</b> to handle logical clocks. The term logical clock refers to Leslie Lamport's logical clocks and its usage in CCSL is directly inspired from Synchronous programming languages (like Esterel or Signal).|$|E
50|$|In {{computer}} science, {{the abstract}} syntax of data is its structure {{described as a}} data type (possibly, but not necessarily, an abstract data type), independent of any particular representation or encoding. This is particularly used in the representation of text in computer languages, which are generally stored in a tree structure as an abstract syntax tree. Abstract syntax, which only consists {{of the structure of}} data, is contrasted with <b>concrete</b> <b>syntax,</b> which also includes information about the representation. For example, <b>concrete</b> <b>syntax</b> includes features like parentheses (for grouping) or commas (for lists) which are not included in the abstract syntax, as they are implicit in the structure.|$|E
40|$|Syntax. The current <b>syntax</b> allows {{multiple}} <b>concrete</b> syntactic {{representations of}} the same graph structure. Investigate an abstract syntax (canonical form) for ER Graphs. The mapping from the (various) <b>concrete</b> <b>syntaxes</b> to the abstract shall be defined.. Formalization. The current specification of ER Graphs representations, and its key concepts are not formalized. Formalize the definitions of these concepts using logical or other mathematical tools, such as those used in the AI/KR community.. Subgraph Relations. The current structure does not allow specification of subgraphs, or relationships between graphs, between graphs and subgraphs, or intersection and union of graphs. The only method of nesting graph definitions is currently reification.. Relation Properties. What properties are needed for defining relationships in a relationship graphs? Examples include total orders, symmetry, and other mathematical properties of relations. If such properties are needed, the rules need to b [...] ...|$|R
40|$|Workflow {{management}} {{deals with}} {{different types of}} dependencies among tasks, in particular data- and policy-driven. The ability to reason on dependencies of different type allows workflow designers to consider different alternatives, or to define customized flows, reducing non-determinism. We propose a resource-centered view, in which both data-dependency between tasks and plan-dependent ordering of tasks are expressed as production and consumption of resources. This view is translated into a rule-based formalism, {{expressed in terms of}} multi-set rewriting for workflow enactment. In turn, rules are themselves seen as resources, so that they are prone to the same rewriting process, in order to redefine process schemas. We show how workflows expressed as activity diagrams can be translated to the proposed formalism, exploiting enforced generative patterns applied to triple graph grammars, and how redefinition of workflow processes can occur through typical patterns of adaptation. We also discuss possible <b>concrete</b> <b>syntaxes</b> for the obtained rules...|$|R
40|$|Over {{the last}} years, Model Driven Engineering {{platforms}} evolved from fixed metamodel tools to systems with variable metamodels. This enables {{dealing with a}} variety of Domain Specific Languages (DSLs). These generic platforms are increasingly adopted to solve problems like code generation. However, these environments are often limited to syntax definitions. The AMMA platform conceives DSLs as collections of coordinated models defined using a set of core DSLs. For broadening the approach to semantics definition, AMMA should thus be extended. The paper presents an extension of the core DSLs of AMMA to specify the dynamic semantics of a range of DSLs by means of Abstract State Machines. Thus, DSLs can be defined not only according to their abstract and <b>concrete</b> <b>syntaxes</b> but also to their semantics in a uniform and systematic way. The approach is validated by means of the semantic bootstrap of the ATL transformation language...|$|R
