4|4|Public
50|$|The name {{subprogram}} {{suggests a}} subroutine behaves {{in much the}} same way as a computer program that is used as one step in a larger program or another subprogram. A subroutine is often coded so that it can be started (called) several times and from several places during one execution of the program, including from other subroutines, and then branch back (return) to the next instruction after the call, once the subroutine's task is done. Maurice Wilkes, David Wheeler, and Stanley Gill are credited with the invention of this concept, which they termed a <b>closed</b> <b>subroutine,</b> contrasted with an open subroutine or macro.|$|E
50|$|Whether LR, LALR or SLR, {{the basic}} state machine is the same; only {{the tables are}} different, and these tables are almost always {{mechanically}} generated. Additionally, these tables are usually implemented such that a REDUCE results in a CALL to a <b>closed</b> <b>subroutine</b> which is external to the state machine and which performs a function which is implied by the semantics of the grammar rule which is being REDUCEd. Therefore, the parser is partitioned into an invariant state machine part, and a variant semantics part. This fundamental distinction encourages the development of high-quality parsers which are exceptionally reliable.|$|E
5000|$|Wheeler married Joyce Blackler in August 1957, who herself used EDSAC {{for her own}} {{mathematical}} investigations as {{a research}} student from 1955. He became a Fellow of Darwin College, Cambridge in 1964 and formally retired in 1994, although he continued to be {{an active member of}} the University of Cambridge Computer Laboratory until his death. In 1994 he was inducted as a Fellow of the Association for Computing Machinery. In 2003, he was named a Computer History Museum Fellow Award recipient [...] "for his invention of the <b>closed</b> <b>subroutine,</b> and for his architectural contributions to ILLIAC, the Cambridge Ring, and computer testing." [...] The Computer Laboratory at the University of Cambridge annually holds the [...] "Wheeler Lecture", a series of distinguished lectures named after him.|$|E
50|$|In IBM {{mainframe}} {{operating systems}} from the OS/360 and successors line, a Unit Control Block (UCB) is a memory structure, or a control block, that describes any single input/output peripheral device (unit), or an exposure (alias), {{to the operating}} system. Certain data within the UCB also instructs the Input/Output Supervisor (IOS) to use certain <b>closed</b> <b>subroutines</b> in addition to normal IOS processing for additional physical device control.|$|R
5000|$|A {{comprehensive}} list of [...] "exits" [...] (called appendages) allows authorized {{programs to}} override or augment {{many of the}} system security and data integrity checks. Most of these exits (really, <b>closed</b> <b>subroutines)</b> are supported for compatibility with earlier instances of the OS, but the functions of several have been modified or extended for MVS. The exits are specified in the DCB as the last two characters of the module name IGG019xx. where xx = WA to Z9 inclusive. These module names are reserved for user-written appendages. Any other name of the form IGG019xx is reserved for use by IBM access methods. Appendages must reside in SYS1.SVCLIB (SYS1.LPALIB in SVS or later instances of the OS).|$|R
40|$|An On-Line Modeling System (OLMS) {{which should}} be {{particularly}} useful to the biomedical community is described which utilizes a process called "overlaying " to simplify loading and executing programs. OLMS has been constructed and implemented as an interpreter; that is, a program that translates and then executes each source statement in sequence where these two operations follow each other in close time proximity. It has been written {{so that it can}} be run under the IBM S/ 360 and the PDP- 10 operating systems, but has been implemented only on the PDP- 10. OLMS operates from a command language that is executed interpretively through a set of <b>closed</b> <b>subroutines.</b> The user may run a job, save data, get data, and display data. While his program is running, he can access the whole memory. This report consists of a description of OLMS and programmer's reference manuals for both the OLMS graphical system and OLMS. (JY...|$|R
50|$|Wheeler's {{contributions}} to the field included work on the Electronic delay storage automatic calculator (EDSAC) and the Burrows-Wheeler transform. Along with Maurice Wilkes and Stanley Gill he is credited with {{the invention of the}} subroutine (which they referred to as the <b>closed</b> <b>subroutine),</b> and gave the first explanation of how to design software libraries; as a result, the jump to subroutine instruction was often called a Wheeler Jump. He was responsible for the implementation of the CAP computer, the first to be based on security capabilities. In cryptography, he was the designer of WAKE and the co-designer of the TEA and XTEA encryption algorithms together with Roger Needham. In 1950, along with Maurice Wilkes, he used EDSAC to solve a differential equation relating to gene frequencies in a paper by Ronald Fisher. This represents the first use of a computer for a problem in the field of biology.|$|E
40|$|This paper {{describes}} an algorithm which takes the BNF {{definition of the}} grammar of a language and constructs a set of productions for recognizing sentences of the language. These productions, as introduced by Floyd [4] and modified by Evans [3], constitute a language in which may be written a one-pass, one-push-down- 8 tack recognizer, which involves no <b>closed</b> <b>subroutines.</b> Thus it goes directly from the basic definition of the grammar of a programming language to an efficient parser for the language which could easily be incorporated into a compiler. Production Language*. The production language consists {{of a set of}} produc-tions of the form LO a b c I- * G I *G 1 Let us assume we are parsing a sentence by productions. Each time we scan a character, it is placed {{at the top of a}} push down stack known as the syntax stack. Then we sequence through the productions, comparing the top few characters in the syntax stack to each production. The first bar in the production represents th...|$|R

