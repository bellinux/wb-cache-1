1|13|Public
40|$|Patient {{records and}} their disease and {{treatment}} history can be scattered among healthcare providers. Sharing the knowledge effectively and, {{at the same}} time, respecting patient privacy is crucial in providing safe and accurate clinical decision support systems (CDSSs). In this paper we reflect upon our experience in the HealthAgents project wherein a prototype system was developed and a novel approach employed that supports data transfer and decision making in human brain tumour diagnosis. Here we examine the capability of the lightweight coordination calculus (LCC), a process <b>calculus-based</b> <b>language,</b> in combining together distributed healthcare services and meeting security challenges in pervasive settings. The result is that various clinical specialisms, being captured in representational abstractions and making contribution to patient diagnosis and management, retain their autonomy. However, at the same time, the behaviour of specialists in sharing clinical knowledge about their patients and providing clinical support is constrained by policies and rules in respect of their own clinical duties and responsibilities. Being introduced into the programme of the HRB Centre for Primary Care Research, this novel approach {{has the potential to}} help the provision of optimal solutions in data linkage and sharing across the primary and cecondary care interface. As added value, its application also advances the process of integrating clinical prediction rules and implementing CDSSs in practice and, ultimately, the improvement of quality of car...|$|E
50|$|Lambda <b>calculus-based</b> <b>languages</b> (such as Lisp, ISWIM, and Scheme) are {{in actual}} {{practice}} value-level languages, {{although they are}} not thus restricted by design.|$|R
40|$|Abstract. Are higher-order {{extensions}} to {{logic programming}} needed? We {{answer this question}} in the negative by showing that higher-order features are already available in pure logic programming. It is demonstrated that higher-order lambda <b>calculus-based</b> <b>languages</b> can be compositionally embedded in logic programming languages preserving their semantics and abstraction facilities. Further, we show that such higherorder techniques correspond to programming techniques often practiced in logic programming. Keywords: Higher-order features, functional programming, lambda calculus, logic variables, concurrent logic programming, types, semantics. ...|$|R
40|$|We {{make two}} {{contributions}} to the theory and implementation of dynamical systems. First, we extend the ontology and foundational axioms of the sequential situation calculus to include time. Secondly, based upon this axiomatization, we extend the semantics and interpreter for the situation <b>calculus-based</b> programming <b>language</b> GOLOG to the temporal domain, and illustrate the resulting increased functionality of the language via a GOLOG program describing the temporal behaviour of a coffee delivery robot. 1 Introduction The situation calculus [McCarthy, 1963] {{has long been the}} formalism of choice in artificial intelligence for theoretical investigations of properties of actions, but until recently, it has not been taken seriously as a specification or implementation language for practical problems in dynamic world modeling. An exception to this is the situation <b>calculus-based</b> programming <b>language</b> GOLOG [Levesque et al., 1996], and some of its applications to robotics [Lesp [...] ...|$|R
40|$|This work {{tries to}} employ the monoid {{comprehension}} calculus [...] -which {{has proven to be}} an adequate framework to capture the semantics of modern object query languages featuring a family of collection types like sets, bags, and lists [...] -in a twofold manner: First, serving as a target language for the translation of ODMG OQL queries. We review work done in this field and give comprehension calculus equivalents for the recently introduced OQL 1. 2 concepts. This also presents a novel chance to understand the OQL semantics completely. Our second concern is the fact that <b>calculus-based</b> <b>languages</b> are often said to be not efficiently implementable in the database context, having its reason in the fact that database query engines rather tend to realize algebraic interfaces to access bulk data, e. g. different join types. The main problem coming up here is the "nested-loop nature" of the calculus expressions. While these loop-based semantics for evaluating comprehensions at least provide [...] ...|$|R
40|$|Projet VERSO/[URL] expressiveness and {{complexity}} of several <b>calculus-based</b> query <b>languages</b> for complex objects is considered. Unlike previous investigations, we {{are concerned with the}} complexity of queries on databases of complex objects, rather than flat databases. This raises new issues specific to complex objects. For instance, it is shown that the way the database makes use of its higher-order types has direct impact on query complexity. The use of fixpoint operators is shown to yield languages...|$|R
40|$|We {{extend the}} {{ontology}} and foundational axioms of the sequential situation calculus to include time. When {{combined with a}} view of actions with durations as processes that are initiated and terminated by instantaneous actions, this explicit representation of time yields a very rich account of interleaving concurrency in the situation calculus. Based upon this axiomatization, we extend the semantics and interpreter for the situation <b>calculus-based</b> programming <b>language</b> GOLOG to the temporal domain, and illustrate the resulting increased functionality of the language via a GOLOG program describing the temporal behaviour of a coffee delivery robot...|$|R
40|$|AbstractThe expressiveness and {{complexity}} of several <b>calculus-based</b> query <b>languages</b> for complex objects are considered. Unlike previous investigations, we {{are concerned with the}} complexity of queries on databases of complex objects, rather than flat databases. This raises new issues specific to complex objects. For instance, it is shown that the way the database makes use of its higher-order types has direct impact on query complexity. The use of fixpoint operators is shown to yield languages well-behaved with respect to complexity and expressiveness. In particular, an extension of the fixpoint queries to complex objects is shown to express precisely the PTIME queries, under the assumption that the database makes "full" use of all its types. Similar results involve range-restricted queries...|$|R
40|$|Golog is a {{situation}} <b>calculus-based</b> logic programming <b>language</b> for high-level robotic control. This paper explores Hoareâ€™s axiomatic approach to program verification in the Golog context. We present a novel Hoarestyle proof system for partial correctness of Golog programs. We prove total soundness of the proof system, and relative completeness of a subsystem of it for procedureless Golog programs. Examples are given to illustrate {{the use of the}} proof system...|$|R
40|$|We {{describe}} a forward reasoning planner for open worlds that uses domain specific information for pruning its search space, {{as suggested by}} (Bacchus & Kabanza 1996; 2000). The planner is written in the situation <b>calculus-based</b> programming <b>language</b> GOLOG, and it uses a situation calculus axiomatization of the application domain. Given a sentence oe to prove, the planner regresses it to an equivalent sentence oe 0 about the initial situation, then invokes a theorem prover {{to determine whether the}} initial database entails oe 0 and hence oe. We describe two approaches to this theorem proving task, one based on compiling the initial database to prime implicate form, the other based on Relsat, a Davis/Putnam-based procedure. Finally, we report on our experiments with open world planning based on both these approaches to the theorem proving task...|$|R
40|$|The expressiveness and {{complexity}} of several <b>calculus-based</b> query <b>languages</b> for complex objects is considered. Unlike previous investigations, we {{are concerned with the}} complexity of queries on databases of complex objects, rather than flat databases. This raises new issues specific to complex objects. For instance, it is shown that the way the database makes use of its higher-order types has direct impact on query complexity. The use of fixpoint operators is shown to yield languages well-behaved with respect to complexity and expressiveness. In particular, an extension of the fixpoint queries to complex objects is shown to express precisely the PTIME queries, under the assumption that the database makes "full" use of all its types. Similar results involve range-restricted queries. 1 Introduction Complex objects are increasingly part of advanced database systems. They provide the structural core of object-oriented databases. Several query languages for complex objects have been propo [...] ...|$|R
40|$|We {{establish}} an exact correspondence between temporal logic and {{a subset of}} TSQL 2, a consensus temporal extension of SQL [...] 92. The translation from temporal logic to TSQL 2 developed here enables a user to write high-level queries which can be evaluated against a spaceefficient representation of the database. The reverse translation, also provided, {{makes it possible to}} characterize the expressive power of TSQL 2. We demonstrate that temporal logic is equal in expressive power to a syntactically defined subset of TSQL 2. 1 Introduction In this paper, we bring together two research directions in temporal databases. The first direction is concerned with temporal extensions to <b>calculus-based</b> query <b>languages</b> such as SQL (e. g., [GN 93, NA 93, Sar 93]). The issues addressed include space-efficient storage, effective implementation techniques, and handling large amounts of data. This approach includes the consensus temporal query language TSQL 2 [Sno 95], whose practical implementations should be fo [...] ...|$|R
40|$|We {{illustrate}} {{the utility of}} the situation calculus for representing complex scheduling tasks by axiomatizing a deadline driven scheduler in the language. The actions arising in such a scheduler are examples of natural actions, as investigated in the concurrent situation calculus by Pinto [10], and later by Reiter [13]. Because the deadline driven scheduler is sequential, we must first suitably modify Reiter's approach to natural actions so it applies to the sequential case. Having done this, we then show how the situation calculus axiomatization of this scheduler yields a very simple simulator in GOLOG, a situation <b>calculus-based</b> logic programming <b>language</b> for dynamic domains...|$|R
40|$|Abstract. Various {{temporal}} extensions to {{the relational}} model have been proposed. All of these, however, deviate {{significantly from the}} original relational model. This paper presents a temporal extension of the relational algebra that is {{not significantly different from}} the original relational model, yet is at least as expressive as any of the previous approaches. This algebra employs multidimensional tuple time-stamping to capture the complete temporal behavior of data. The basic relational operations are redefined as consistent extensions of the existing operations in a manner that preserves the basic algebraic equivalences of the snapshot (i. e., conventional static) algebra. A new operation, namely temporal projection, is introduced. The complete update semantics are formally specified and aggregate functions are defined. The algebra is closed, and reduces to the snapshot algebra. It is also shown to be at least as expressive as the <b>calculus-based</b> temporal query <b>language</b> TQuel. In order to assess the algebra, it is evaluated using a set of twenty-six criteria proposed in the literature, and compared to existing temporal relational algebras. The proposed algebra appears to satisfy more criteria than any other existing algebra...|$|R

