129|206|Public
5000|$|Latch {{the count}} {{for a given}} timer. The next read will, rather than {{returning}} the <b>counter</b> <b>value</b> {{at the moment of}} the read, return the <b>counter</b> <b>value</b> at the moment of the latch command. After the read completes, later reads will return the current counter. When the latch command is used, the mode and BCD status are not changed.|$|E
5000|$|When {{a process}} sends a message, it {{includes}} its <b>counter</b> <b>value</b> with the message; ...|$|E
5000|$|Automatically winding {{the tape}} to a tape <b>counter</b> <b>value</b> input on the keypad ("go to").|$|E
30|$|By {{reducing}} the address {{space of the}} summary while keeping the number of entries n constant, <b>counter</b> <b>values</b> and the load of buckets are expected to increase. There exists a trade-off between reducing on-chip memory requirements and the resulting <b>counter</b> <b>values</b> and bucket loads.|$|R
50|$|While using {{powers of}} 2 as <b>counter</b> <b>values</b> is memory efficient, {{arbitrary}} values tend {{to create a}} dynamic error range, and the smaller values will have a greater error ratio than bigger values. Other methods of selecting <b>counter</b> <b>values</b> consider parameters such as memory availability, desired error ratio, or counting range to provide an optimal set of values.|$|R
5000|$|... {{the first}} process adds {{one to the}} <b>value,</b> the <b>counter's</b> <b>value</b> should be 1 ...|$|R
5000|$|... (defclass <b>counter</b> (...) ((<b>value</b> :initarg :value :accessor value-of)))(defmethod functor-call ((c counter)) (incf (value-of c)))(defun make-counter (initial-value) (make-instance 'counter :value initial-value));;; use the counter:(defvar *c* (make-counter 10))(functor-call *c*) --> 11(functor-call *c*) --> 12 ...|$|E
50|$|Continuing the {{previous}} example, consider two processes, A and B, running the same program. Suppose SimpleDB services requests for data, {{as described in}} step 1, from both A and B. A and B see the same value. Let's say that the current value of the counter is 0. Because of steps 2 and 3, A will try to store 1. B will {{try to do the}} same; thus, the final <b>counter</b> <b>value</b> will be 1, even though the expected final <b>counter</b> <b>value</b> is 2, because the system attempted two increment operations, one by A, and another by B.|$|E
50|$|The typical Trojan is condition-based: It is {{triggered}} by sensors, internal logic states, a particular input pattern or an internal <b>counter</b> <b>value.</b> Condition-based Trojans are detectable with power traces {{to some degree}} when inactive. That {{is due to the}} leakage currents generated by the trigger or counter circuit activating the Trojan.|$|E
5000|$|The Performance Monitor {{includes}} several new performance counters and various tools for tuning and monitoring system performance and resources. It shows {{the activities of}} the CPU, disk I/O, network, memory and other resources in the [...] "Resource View". It supports new graph types, the selection of multiple counters, the retrieval of <b>counter</b> <b>values</b> from a point on the graph, the saving of graphed <b>counter</b> <b>values</b> to a log file, and the option to have a line graph continuously scroll in the graph window instead of wrapping-around on itself.|$|R
5000|$|On 29 April 1947, RAND Corporation began {{generating}} random digits with an [...] "electronic roulette wheel", {{consisting of}} a random frequency pulse source of about 100,000 pulses per second gated once per second with a constant frequency pulse and fed into a five-bit binary counter. Douglas Aircraft built the equipment, implementing Cecil Hasting’s suggestion (RAND P-113) for a noise source (most likely the well known behavior of the 6D4 miniature gas thyratron tube, when placed in a magnetic field). Twenty of the 32 possible <b>counter</b> <b>values</b> were mapped onto the 10 decimal digits and the other 12 <b>counter</b> <b>values</b> were discarded.|$|R
50|$|In its {{simplest}} implementation, a TDC {{is simply}} a high-frequency counter that increments every clock cycle. The current contents of the counter represents the current time. When an event occurs, the <b>counter's</b> <b>value</b> is captured in an output register.|$|R
50|$|Perhaps {{the most}} common and {{straight}} forward mechanism to build a MGF is to iteratively apply a hash function together with an incrementing <b>counter</b> <b>value.</b> The counter may be incremented indefinitely to yield new output blocks until a sufficient amount of output is collected. This is the approach used in MGF1 shown below.|$|E
5000|$|... 32 bits are {{encrypted}} (the rolling code) : 4 bits of button information, 2 bits of OVR (used {{to extend}} <b>counter</b> <b>value),</b> 10 bits of DISC (discrimination value; often the low 10 {{bits of the}} serial number), and a 16-bit counter. In a resyncing situation, the encrypted 32 bits are replaced with a 32-bit seed value.|$|E
50|$|The {{incremented}} and periodically {{reset counter}} is the discrete {{version of the}} intersecting method's sawtooth. The analog comparator of the intersecting method becomes a simple integer comparison between the current <b>counter</b> <b>value</b> and the digital (possibly digitized) reference value. The duty cycle can only be varied in discrete steps, {{as a function of}} the counter resolution. However, a high-resolution counter can provide quite satisfactory performance.|$|E
5000|$|In {{the given}} example of R-bits for 6 pages over 5 clock ticks, the {{function}} prints the following output, which lists the R-bits for each clock tick [...] {{and the individual}} <b>counter</b> <b>values</b> [...] for each page in binary representation.|$|R
40|$|Integrated Circuit Metrics {{is mainly}} {{concerned}} with the extraction of measurable properties or features of a given hardware device, capable of uniquely identifying the system's behaviour. This paper presents features that can be extracted from software executing on a device and identify the very software in execution. The main contribution {{of this paper is}} in two folds. The ability to extract features whiles the software is in execution as well as correctly identifying the software to divulge any tampering or malicious exploitation. Our aim is to use program <b>counter</b> <b>values</b> generated during program execution to train a k-means algorithm optimized for vector quantization, and later use the system to associate program <b>counter</b> <b>values</b> with an application. © 2013 IEEE...|$|R
50|$|Alternatively, MRTG can be {{configured}} to run {{a script}} or command, and parse its output for <b>counter</b> <b>values.</b> The MRTG website contains a large library of external scripts to enable monitoring of SQL database statistics, firewall rules, CPU fan RPMs, or virtually any integer-value data.|$|R
50|$|Because {{the short}} set of {{characters}} {{does not change}} until the counter reaches zero, {{it is possible to}} prepare a list of single-use passwords, in order, that can be carried by the user. Alternatively, the user can present the password, characters, and desired <b>counter</b> <b>value</b> to a local calculator to generate the appropriate one-time password that can then be transmitted over the network in the clear. The latter form is more common and practically amounts to challenge-response authentication.|$|E
50|$|Each {{comparator}} {{can generate}} an interrupt when the least significant bits are {{equal to the}} corresponding bits of the 64-bit main <b>counter</b> <b>value.</b> The comparators can be put into one-shot mode or periodic mode, {{with at least one}} comparator supporting periodic mode and all of them supporting one-shot mode. In one-shot mode the comparator fires an interrupt once when the main counter reaches the value stored in the comparator's register, while in the periodic mode the interrupts are generated at specified intervals.|$|E
50|$|Embedded {{debugging}} may {{be performed}} at different levels, {{depending on the}} facilities available. The different metrics that characterize the different forms of embedded debugging are: does it slow down the main application, how close is the debugged system or application to the actual system or application, how expressive are the triggers that I can set for debugging (e.g., I want to inspect the memory when a particular program <b>counter</b> <b>value</b> is reached), and what can I inspect in the debugging process (such as, only memory, or memory and registers, etc.).|$|E
50|$|This linear power model uses five {{performance}} {{events as}} follows: Instruction Executed, Data Dependencies, Instruction Cache Miss, Data TLB Misses, and Instruction TLB Misses. A linear model expression is derived (equation 1) as follows assuming a linear correlation between performance <b>counters</b> <b>values</b> and power consumption.|$|R
5000|$|... (In {{fact the}} data {{values for the}} wrapped-around {{locations}} 0 - 3 must be zero since <b>counter</b> <b>values</b> 8192, 8193 etc. change the B-modified second half of location 1 from a 16 to a 17 instruction, which sets a to n - a instead of clearing it, {{as required by the}} inner loop.) ...|$|R
30|$|Section 4 {{introduced}} a simple word packing scheme for counting Bloom filters where the counters are packed in memory words. Another form of compressed counting Bloom filters {{has been proposed}} by Ficara et al. in 2008. Computing <b>counter</b> <b>values</b> in the ML-CCBF is expensive {{due to the fact}} that all preceding cells must be evaluated and the bitmaps must be accessed using perfect hash functions. These requirements render the ML-CCBF inapplicable as a summary for the EHT, since it needs to return <b>counter</b> multiple <b>values</b> on every lookup to determine the correct bucket of an item.|$|R
50|$|High {{clock rates}} impose {{additional}} design {{constraints on the}} counter: if the clock period is short, {{it is difficult to}} update the count. Binary counters, for example, need a fast carry architecture because they essentially add one to the previous <b>counter</b> <b>value.</b> A solution is using a hybrid counter architecture. A Johnson counter, for example, is a fast non-binary counter. It can be used to count very quickly the low order count; a more conventional binary counter can be used to accumulate the high order count. The fast counter is sometime called a prescaler.|$|E
50|$|Many digital {{circuits}} can generate PWM signals (e.g., many microcontrollers have PWM outputs). They normally use a counter that increments periodically (it is connected {{directly or indirectly}} to the clock of the circuit) and is reset {{at the end of}} every period of the PWM. When the <b>counter</b> <b>value</b> is more than the reference value, the PWM output changes state from high to low (or low to high). This technique is referred to as time proportioning, particularly as time-proportioning control - which proportion of a fixed cycle time is spent in the high state.|$|E
5000|$|... {{introduced}} a new general method based on variable increments that significantly improves the false positive probability of counting Bloom filters and their variants, while still supporting deletions. Unlike counting Bloom filters, at each element insertion, the hashed counters are incremented by a hashed variable increment instead of a unit increment. To query an element, the exact values of the counters are considered and not just their positiveness. If a sum represented by a <b>counter</b> <b>value</b> cannot be composed of the corresponding variable increment for the queried element, a negative answer can {{be returned to the}} query.|$|E
30|$|World Time Mapping. We use the {{internal}} tick counter of the TPM for secure timestamping of images delivered by a camera (see Section 5.3 for details). For that purpose, the tick counter {{has to be}} associated with world time. The trusted lifebeat is used to realize this mapping of tick <b>counter</b> <b>values</b> to world time.|$|R
30|$|Most of {{the data}} are aligned with eleven lines, which are {{predicted}} <b>counter</b> <b>values</b> of the integral multiples (from 1 to 11, shown in the right) of the fundamental pulse interval of 5.882  ms. These values are the remainders of when the total <b>counter</b> <b>values</b> were divided by one counter cycle of 217. For example, the numbers 1 and 2 indicate that two detected pulses have intervals of 5.882 and 11.764  ms, respectively. Numbers in {{the upper part of}} the figure represent the detector gains (2  = low, 8  = high) and the elevation offset angle of the ground telescope. Notably, from 16 : 40 to 16 : 45, when the elevation offset angle of 6  arcsec was introduced to the ground telescope, almost all data are clustered at the line segment “ 1 ”, which indicates that most of the second pulses were detected immediately after detection of the corresponding first pulses.|$|R
40|$|We {{look at a}} {{model of}} a two-way nondeterministic finite {{automaton}} augmented with monotonic counters operating on inputs of the form a 1 ^i 1 [...] . an^in for some fixed n and distinct symbols a 1, [...] .,an, where i 1, [...] .,in are nonnegative integers. Our results concern the following Presburger safety verification problem: Given a machine M, a state q and a Presburger relation E on the <b>counter</b> <b>values,</b> is there (i 1, [...] .,in) such that M, when started in its initial state on the left end of the input a 1 ^i 1 [...] . an^in with all counters initially zero, reaches some configuration where the state is q and the <b>counter</b> <b>values</b> satisfy E? We give positive and negative results for different variations and generalisations of this model. In particular we settle an open problem from stated by Dang, Ibarra and Kemmerer[10]...|$|R
50|$|A {{representative}} {{example is}} a do loop incrementing some counter until it overflows and becomes 0 again.Although the do loop executes the same increment command iteratively, so the program graph executes a cycle, in its state space is not a cycle, but a line.This results from the state being the program location (here cycling) combined with the <b>counter</b> <b>value,</b> which is strictly increasing (until the overflow), so different states are visited in sequence, until the overflow.After the overflow the counter becomes 0 again, so the initial state is revisited in the state space, closing a cycle in the state space (assuming the counter was initialized to 0).|$|E
50|$|Position {{independent}} functions accessing {{global data}} start by determining the absolute {{address of the}} GOT given their own current program <b>counter</b> <b>value.</b> This often {{takes the form of}} a fake function call in order to obtain the return value on stack (x86) or in a special register (PowerPC, SPARC, MIPS, probably at least some other RISC processors, ESA/390), which can then be stored in a predefined standard register. Some processor architectures, such as the Motorola 68000, Motorola 6809, WDC 65C816, Knuth's MMIX, ARM and x86-64 allow referencing data by offset from the program counter. This is specifically targeted at making position-independent code smaller, less register demanding and hence more efficient.|$|E
5000|$|At {{this point}} the client may make another request, reusing the server nonce value (the server only issues a new nonce for each [...] "401" [...] response) but {{providing}} a new client nonce (cnonce). For subsequent requests, the hexadecimal request counter (nc) must be greater than the last value it used - otherwise an attacker could simply [...] "replay" [...] an old request with the same credentials. It {{is up to the}} server to ensure that the counter increases for each of the nonce values that it has issued, rejecting any bad requests appropriately. Obviously changing the method, URI and/or <b>counter</b> <b>value</b> will result in a different response value.|$|E
40|$|Abstract. We {{look at a}} {{model of}} a two-way nondeterministic finite {{automaton}} augmented with monotonic counters operating on inputs of form� �� � � the for some � fixed and distinct � §£ � ���� � � � � symbols, � §� � ���� � � � � where are nonnegative integers. Our results concern the following Presburger safety verification problem: Given a � machine, state � a, and a Presburger � relation over <b>counter</b> <b>values,</b> is �� � §� � ���� � � � �� � there such � that, when started in its initial state on the left end of the � � � input with all counters initially zero, reaches some configuration where the state � is and the <b>counter</b> <b>values</b> � satisfy? We give positive and negative results for different variations and generalizations of the model (e. g., augmenting the model with reversal-bounded counters, discrete clocks, etc.). In particular, we settle an open problem in [10]. ...|$|R
40|$|In delay {{tolerant}} network (DTN), an end-to-end path is {{not guaranteed}} and packets are delivered {{from a source}} node to a destination node via store-carry-forward based routing. In DTN, a source node or an intermediate node stores packets in buffer and carries them while it moves around. These packets are forwarded to other nodes based on predefined criteria and finally are delivered to a destination node via multiple hops. In this paper, we improve the dissemination speed of PRoPHET (probability routing protocol using history of encounters and transitivity) protocol by employing epidemic protocol for disseminating message m, if forwarding counter and hop <b>counter</b> <b>values</b> are smaller {{than or equal to}} the threshold values. The performance of the proposed protocol was analyzed from the aspect of delivery probability, average delay, and overhead ratio. Numerical results show that the proposed protocol can improve the delivery probability, average delay, and overhead ratio of PRoPHET protocol by appropriately selecting the threshold forwarding counter and threshold hop <b>counter</b> <b>values...</b>|$|R
3000|$|... h {{depends on}} the {{sequence}} of <b>counter</b> <b>values,</b> it is upper bound to the longest code sequence it can compress in one word. Assume no compression is used, then every counter will occupy three bits, which equals {{the length of the}} Huffman code for c= 2. Thus, if during compression a long sequence of counters ≥ 2 is found, the compression rate γ [...]...|$|R
