0|6733|Public
40|$|Scheduling a <b>casting</b> <b>sequence</b> {{involving}} a <b>number</b> of orders with dierent casting weights and satisfying due dates of production {{is an important}} optimization problem often encountered in foundries. In this paper, we attempt to solve this complex, multi-variable, and multiconstraint optimization problem using different implementations of genetic algorithms (GAs). I...|$|R
40|$|This paper {{presents}} a simplified procedure {{to account for}} shrinkage and <b>casting</b> <b>sequence</b> effects in the time-dependent analysis of steel-concrete composite continuous decks. Main features related to modelling of early-age concrete behaviour and tensile creep are discussed. The proposed simplified method is applied to evaluate the service response of a realistic three-span composite bridge deck by considering different slab <b>casting</b> <b>sequences.</b> The comparison between the obtained results and those given by the step-by-step procedures shows {{the accuracy of the}} simplified method, which can be considered a useful tool for practical applications. The numerical simulations highlight how the various <b>casting</b> <b>sequences</b> affect the development of tensile stresses in the slab...|$|R
40|$|The paper {{analyzes}} {{the influence of}} the slab cracking in the fatigue assessment of continuous composite decks by considering the effects of slab <b>casting</b> <b>sequences</b> and the shrinkage components (thermal, endogenous and drying). A numerical procedure for the stress calculation accounting for the tension stiffening of the slab longitudinal rebars is presented. The long term effects of <b>casting</b> <b>sequences</b> and concrete shrinkage are analysed with a simplified procedure based on the application of the modular ratio method. With reference to a realistic continuous twin girder composite deck the fatigue verification of the longitudinal girders is carried out by considering three different casting modalities. The obtained results show the important role of the slab <b>casting</b> <b>sequences</b> in the stress range calculation and the remarkable influence of the slab cracking in the fatigue assessment...|$|R
40|$|This paper {{analyses}} {{the problem}} of slab cracking in composite steel-concrete girders during the constructive phases due to early age concrete shrinkage and to <b>casting</b> <b>sequence</b> effects. The analysis is performed {{by means of a}} theoretical model, which includes connection deformability and creep effects. The numerical solution is obtained by means the finite element method and the step-by-step procedures. The proposed model is then applied to a real composite deck showing the advantages obtained by an optimised <b>casting</b> <b>sequence</b> in comparison to the continuous casting of the slab...|$|R
5000|$|<b>Sequence</b> <b>Number</b> (32 bits) : A {{monotonic}} strictly increasing <b>sequence</b> <b>number</b> (incremented by 1 {{for every}} packet sent) to prevent replay attacks. When replay detection is enabled, <b>sequence</b> <b>numbers</b> are never reused, because a new security association must be renegotiated before {{an attempt to}} increment the <b>sequence</b> <b>number</b> beyond its maximum value.|$|R
50|$|To {{avoid these}} problems, {{the most common}} {{solution}} is to define a 1 bit <b>sequence</b> <b>number</b> in the header of the frame. This <b>sequence</b> <b>number</b> alternates (from 0 to 1) in subsequent frames. When the receiver sends an ACK, it includes the <b>sequence</b> <b>number</b> of the next packet it expects. This way, the receiver can detect duplicated frames by checking if the frame <b>sequence</b> <b>numbers</b> alternate. If two subsequent frames have the same <b>sequence</b> <b>number,</b> they are duplicates, and the second frame is discarded. Similarly, if two subsequent ACKs reference the same <b>sequence</b> <b>number,</b> they are acknowledging the same frame.|$|R
5000|$|The {{received}} <b>sequence</b> <b>number</b> is {{the last}} <b>sequence</b> <b>number</b> received by this sender.|$|R
5000|$|S: <b>Sequence</b> <b>number</b> bit. Set to 1 if a <b>sequence</b> <b>number</b> is present.|$|R
50|$|If the SYN flag is set (1), {{then this}} is the initial <b>sequence</b> <b>number.</b> The <b>sequence</b> <b>number</b> of the actual first data byte and the {{acknowledged}} number in the corresponding ACK are then this <b>sequence</b> <b>number</b> plus 1.|$|R
5000|$|<b>Sequence</b> <b>number</b> flag(S): a 1-bit {{value that}} states {{whether there is}} a <b>Sequence</b> <b>Number</b> {{optional}} field.|$|R
30|$|Initially, each server s sends signed <b>sequence</b> <b>numbers</b> 1 through K to each client c, {{and sets}} the next <b>sequence</b> <b>number</b> to emit, N_s^c, to K+ 1. Whenever s accepts to certify a new transaction, s {{increments}} N_s^c and sends N_s^c signed to c. Server s only accepts to certify transactions whose <b>sequence</b> <b>numbers</b> belong to set V_s^c. Initially, this set contains <b>sequence</b> <b>numbers</b> 1 to K. Each time s accepts to certify a transaction with <b>sequence</b> <b>number</b> seq, seq is removed from V_s^c and N_s^c {{is added to the}} set after being incremented.|$|R
5000|$|... #Caption: TCP <b>sequence</b> <b>numbers</b> {{and receive}} windows behave {{very much like}} a clock. The receive window shifts each time the {{receiver}} receives and acknowledges a new segment of data. Once it runs out of <b>sequence</b> <b>numbers,</b> the <b>sequence</b> <b>number</b> loops back to 0.|$|R
50|$|When A sends a message, it resends it continuously, {{with the}} same <b>sequence</b> <b>number,</b> until it {{receives}} an acknowledgment from B that contains the same <b>sequence</b> <b>number.</b> When that happens, A complements (flips) the <b>sequence</b> <b>number</b> and starts transmitting the next message.|$|R
5000|$|Transmission <b>sequence</b> <b>number</b> (TSN) : The <b>sequence</b> <b>number</b> for {{the entire}} DATA stream (used in {{fragmentation}} for reassembly).|$|R
25|$|Numbering {{subsequent}} Application {{records with}} a <b>sequence</b> <b>number</b> and using this <b>sequence</b> <b>number</b> {{in the message}} authentication codes (MACs).|$|R
50|$|Lollipop <b>sequence</b> <b>number</b> {{spaces are}} {{a more recent}} and {{sophisticated}} scheme for dealing with finite-sized <b>sequence</b> <b>numbers</b> in protocols.|$|R
5000|$|S: <b>Sequence</b> <b>number</b> bit. Set to 1 if a <b>sequence</b> <b>number</b> is supplied, {{indicating}} a PPTP GRE data packet.|$|R
5000|$|Numbering {{subsequent}} Application {{records with}} a <b>sequence</b> <b>number</b> and using this <b>sequence</b> <b>number</b> {{in the message}} authentication codes (MACs).|$|R
3000|$|... 1) Using the {{pseudorandom}} <b>sequence</b> <b>number</b> X of {{the confusion}} process as the final set X of pseudorandom <b>sequence</b> <b>numbers.</b>|$|R
50|$|Here {{are some}} {{examples}} (in 16 bits, again), comparing some random <b>sequence</b> <b>numbers,</b> against the <b>sequence</b> <b>number</b> with the value 0.|$|R
50|$|A {{means of}} {{comparing}} two <b>sequence</b> <b>numbers</b> i1 and i2 (the unsigned integer representations of <b>sequence</b> <b>numbers</b> s1 and s2) is presented.|$|R
30|$|A <b>sequence</b> <b>number</b> and a loop flag are {{included}} in the data packet header and are used to detect routing loops. When a node receives a downstream data packet, the node records the <b>sequence</b> <b>number</b> of the data. When a node receives data with the same <b>sequence</b> <b>number,</b> the node judges that a loop has occurred and sets the loop flag to one. Each node records nhist <b>sequence</b> <b>numbers</b> of received packets from the newest received one.|$|R
5000|$|It {{is easy to}} {{see that}} the signed {{interpretation}} of the <b>sequence</b> <b>numbers</b> are in the correct order, so long as we [...] "rotate" [...] the <b>sequence</b> <b>number</b> in question so that its 0 matches up with the <b>sequence</b> <b>number</b> we are comparing it against. It turns out that this is simply done, using an unsigned subtraction, and simply interpreting the result as a signed two's complement number. The result is the signed [...] "distance" [...] between the two <b>sequence</b> <b>numbers.</b> Once again, if i1 and i2 are the unsigned binary representations of the <b>sequence</b> <b>numbers</b> s1 and s2, the distance from s1 to s2 is: ...|$|R
5000|$|So, if {{we simply}} re-cast <b>sequence</b> <b>numbers</b> as 2's {{complement}} integers, and allow {{there to be}} one more <b>sequence</b> <b>number</b> considered [...] "less than" [...] than there are <b>sequence</b> <b>numbers</b> considered [...] "greater than", {{we should be able}} to use simple signed arithmetic comparisons instead of the logically incomplete formula proposed by the RFC.|$|R
5000|$|Many {{communication}} protocols apply serial number arithmetic to packet <b>sequence</b> <b>numbers</b> in their {{implementation of a}} sliding window protocol. Some versions of TCP use [...] protection against wrapped <b>sequence</b> <b>numbers</b> (PAWS). PAWS applies the same serial number arithmetic to packet timestamps, using the timestamp {{as an extension of}} the high-order bits of the <b>sequence</b> <b>number.</b>|$|R
50|$|The {{protocol}} may be initialized {{by sending}} bogus messages and acks with <b>sequence</b> <b>number</b> 1. The first message with <b>sequence</b> <b>number</b> 0 {{is a real}} message.|$|R
50|$|We create log {{records of}} the form (<b>Sequence</b> <b>Number,</b> Transaction ID, Page ID, Redo, Undo, Previous <b>Sequence</b> <b>Number).</b> The Redo and Undo fields keep {{information}} about the changes this log record saves and how to undo them. The Previous <b>Sequence</b> <b>Number</b> is {{a reference to the}} previous log record that was created for this transaction. In the case of an aborted transaction, it's possible to traverse the log file in reverse order using the Previous <b>Sequence</b> <b>Numbers,</b> undoing all actions taken within the specific transaction.|$|R
40|$|This paper {{presents}} {{a study on}} the effectiveness of different <b>casting</b> <b>sequences</b> to control the cracking tendency in a long continuous steel-concrete composite viaduct. The main features of the early-age behaviour of concretes are addressed and the relative modelling options are discussed. Then, the application on a real viaduct with 12 spans of different length is presented considering a continuous and two fractionated <b>sequences</b> of <b>casting.</b> The importance in the selection of the <b>casting</b> <b>sequence</b> and of the segment length is discussed. The thermal shrinkage and the weight of new segments confirmed to be the main cause of the slab premature cracking. The enhanced tensile creep may reduce stresses which remain below the concrete tensile strength even in the long term...|$|R
50|$|It is a ten-digit {{number with}} the format DDMMYY-SSSS, where DDMMYY is {{the date of}} birth and SSSS is a <b>sequence</b> <b>number.</b> The first digit of the <b>sequence</b> <b>number</b> encodes the century of birth (so that centenarians are {{distinguished}} from infants), and the last digit of the <b>sequence</b> <b>number</b> is odd for males and even for females.|$|R
50|$|It is a reader-writer {{consistent}} mechanism which {{avoids the}} problem of writer starvation. A seqlock consists of storage for saving a <b>sequence</b> <b>number</b> {{in addition to a}} lock. The lock is to support synchronization between two writers and the counter is for indicating consistency in readers. In addition to updating the shared data, the writer increments the <b>sequence</b> <b>number,</b> both after acquiring the lock and before releasing the lock. Readers read the <b>sequence</b> <b>number</b> before and after reading the shared data. If the <b>sequence</b> <b>number</b> is odd on either occasion, a writer had taken the lock while the data was being read and it may have changed. If the <b>sequence</b> <b>numbers</b> are different, a writer has changed the data while it was being read. In either case readers simply retry (using a loop) until they read the same even <b>sequence</b> <b>number</b> before and after.|$|R
5000|$|Stream <b>sequence</b> <b>number</b> : Identifier of the <b>sequence</b> <b>number</b> for {{the message}} in this stream. If a message is {{fragmented}} then this value is maintained for all fragments.|$|R
30|$|Calculate all the {{elements}} of the pseudorandom <b>sequence</b> <b>number</b> in (xi[*]×[*] 256)[*]mod[*] 256, and then convert the calculated result into binary, thereby obtaining a binary M[*]×[*]N long <b>sequence</b> <b>number.</b>|$|R
50|$|Lollipop <b>sequence</b> <b>numbering</b> was {{originally}} believed {{to resolve the}} ambiguity problem in cyclic <b>sequence</b> <b>numbering</b> schemes, and was used in OSPF version 1 for this reason. Later work showed {{that this was not}} the case, and OSPF version 2 replaced it with a linear numbering space, with special rules for what happens when the <b>sequence</b> <b>numbers</b> reach the end of the numbering space.|$|R
5000|$|All <b>sequence</b> <b>number</b> {{arithmetic}} {{must deal}} with [...] "wrapping" [...] of <b>sequence</b> numbers; the <b>number</b> 2N−1 is equidistant in both directions, in [...] <b>sequence</b> <b>number</b> terms. In our math, they are both considered to be [...] "less than" [...] each other: ...|$|R
5000|$|Cumulative TSN ACK : Acknowledges all <b>sequence</b> <b>numbers</b> {{received}} in <b>sequence</b> {{so is the}} <b>sequence</b> <b>number</b> of the last received byte. The immediate value after this one has not been received yet.|$|R
5000|$|<b>Sequence</b> <b>Number</b> (32 bits) : A monotonically {{increasing}} <b>sequence</b> <b>number</b> (incremented by 1 {{for every}} packet sent) {{to protect against}} replay attacks. There is a separate counter kept for every security association.|$|R
