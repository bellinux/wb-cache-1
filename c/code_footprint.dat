33|19|Public
50|$|The MQ Telemetry Transport (MQTT) is an ISO {{standard}} (ISO/IEC PRF 20922) {{supported by}} the OASIS organization. It provides a lightweight publish/subscribe reliable messaging transport protocol on top of TCP/IP suitable for communication in M2M/IoT contexts where a small <b>code</b> <b>footprint</b> is required and/or network bandwidth is at a premium.|$|E
50|$|The {{simplest}} core, e200z0 {{features an}} in order, four stage pipeline. It has no MMU, no cache, and no FPU. It uses the variable bit length (VLE) {{part of the}} Power ISA, which uses 16-bit versions of the otherwise standard 32-bit PowerPC Book E ISA, thus reducing <b>code</b> <b>footprint</b> by up to 30%. It has a single 32-bit AMBA 2.0v6 bus interface. The load/store unit is pipelined, has a 1-cycle load latency and supports throughput of one load or store operation per cycle.|$|E
50|$|Leaflet is {{directly}} comparable with OpenLayers, as both are open source, client-side only JavaScript libraries. The library {{as a whole}} is much smaller, around 7,000 lines of code compared to 230,000 as of 2015. It has a smaller <b>code</b> <b>footprint</b> than OpenLayers (around 123 KB vs 423 KB) due partly to its modular structure. The code base is newer, and takes advantage of recent features of JavaScript, plus HTML5 and CSS3. However, Leaflet lacks features OpenLayers supports, such as Web Feature Service (WFS) and native support for projections other than Google Web Mercator (EPSG 3857).|$|E
40|$|We {{will report}} on new dc-free runlength-limited codes (DCRLL) {{intended}} {{for the next generation}} of digital versatile disc (DVD). The efficiency of the newly developed DCRLL schemes is extremely close to the theoretical maximum, and as a result, significant density gains can be obtained with respect to prior art coding schemes. Preferred embodiments of the <b>codes</b> (<b>footprints)</b> and respective hardware realization will be considered...|$|R
40|$|In {{this paper}} we survey the current {{literature}} on code obfuscation and review current practices {{as well as}} applications. We analyze the different obfuscation techniques in relation to protection of intellectual property and the hiding of malicious code. Surprisingly, the same techniques used to thwart reverse engineers are used to hide malicious code from virus scanners. Additionally, obfuscation {{can be used to}} protect against malicious code injection and attacks. Though obfuscation transformations can protect code, they have limitations in the form of larger <b>code</b> <b>footprints</b> and reduced performance...|$|R
40|$|We {{demonstrate}} four visualizations {{of indirect}} branch instructions corresponding to switch statements and virtual function calls in object-oriented programs. Spatial and Temporal hot spot visualizations highlight <b>code</b> locality. <b>Footprints</b> show dynamic program size while prediction profiles visualize the regularity {{of a program}} phase...|$|R
50|$|The x87 {{floating}} point architecture {{is an example}} of a set of registers organised as a stack where direct access to individual registers (relative the current top) is also possible. As with stack-based machines in general, having the top-of-stack as an implicit argument allows for a small machine <b>code</b> <b>footprint</b> with a good usage of bus bandwidth and code caches, but it also prevents some types of optimizations possible on processors permitting random access to the register file for all (two or three) operands. A stack structure also makes superscalar implementations with register renaming (for speculative execution) somewhat more complex to implement, although it is still feasible, as exemplified by modern x87 implementations.|$|E
5000|$|DMALGOL is used {{to provide}} {{tailored}} access routines for DMSII databases. After a database is defined using the Data Access and Structure Definition Language (DASDL), the schema is translated by the preprocessor into tailored DMALGOL access routines and then compiled.This means that, unlike in other DBMS implementations, there is often no need for database-specific if/then/else code at run-time. In the 1970s, this [...] "tailoring" [...] was used very extensively to reduce the <b>code</b> <b>footprint</b> and execution time. It became much less used in later years, partly because low-level fine tuning for memory and speed became less critical, and partly because eliminating the preprocessing made coding simpler and thus enabled more important optimizations. DMALGOL included verbs like [...] "find", [...] "lock", [...] "store". Also the verbs [...] "begintransaction" [...] and [...] "endtransaction" [...] were included, solving the deadlock situation when multiple processes accessed and updated the same structures.|$|E
40|$|Due {{to their}} large <b>code</b> <b>footprint,</b> OLTP workloads suffer from {{significant}} I-cache miss rates on contemporary microprocessors. This paper analyzes the I-stream behavior of an OLTP workload, called the Oracle Database Benchmark (ODB), on Chip-Multiprocessors (CMP). Our results show that, although, the overall <b>code</b> <b>footprint</b> of ODB is large, multiple ODB threads running concurrently on multiple processors tend to access common code segments frequently, thus exhibiting significant constructive sharing. In fact, in a CMP system, an I-cache shared between multiple processors incurs similar miss rate as a dedicated I-cache per processor where the per processor I-cache {{has the same}} capacity as the shared I-cache. Based on these observations, this paper makes {{the case for a}} shared I-cache organization in a CMP, instead of the traditional approach of using a dedicated I-cache per processor. Furthermore, this paper shows that OLTP code stream exhibits good spatial locality. Adding a simple dedicated Line Buffer per processor can exploit this spatial locality effectively, to reduce latency and bandwidth requirements on the shared cache. The proposed shared I-cache organization results in an improvement of at least 5 X in miss rate over a dedicated cache organization, for the same total capacity. 1...|$|E
40|$|Grayware encyclopedias collect known {{species to}} provide {{information}} for incident analysis, however, the lack of categorization and generalization capability renders them ineffective {{in the development of}} defense strategies against clustered strains. A grayware categorization framework is therefore proposed here to not only classify grayware according to diverse taxonomic features but also facilitate evaluations on grayware risk to cyberspace. Armed with Support Vector Machines, the framework builds learning models based on training data extracted automatically from grayware encyclopedias and visualizes categorization results with Self-Organizing Maps. The features used in learning models are selected with information gain and the high dimensionality of feature space is reduced by word stemming and stopword removal process. The grayware categorizations on diversified features reveal that grayware typically attempts to improve its penetration rate by resorting to multiple installation mechanisms and reduced <b>code</b> <b>footprints.</b> The framework also shows that grayware evades detection by attacking victims' security applications and resists being removed by enhancing its clotting capability with infected hosts. Our analysis further points out that species in categories Spyware and Adware continue to dominate the grayware landscape and impose extremely critical threats to the Internet ecosystem...|$|R
40|$|CPU core complex (e 200 z 0 h) – Compatible with classic PowerPC {{instruction}} set – Includes variable length encoding (VLE) {{instruction set}} for smaller code size footprint; with the encoding of mixed 16 -bit and 32 -bit instructions, {{it is possible}} to achieve significant <b>code</b> size <b>footprint</b> reduction over conventional Book E compliant code • On-chip ECC flash memory with flash controller – Up to 1 MB primary flash—two 512 KB modules with prefetch buffer and 128 -bit data access port – 64 KB data flash—separate 4 16 KB flash block for EEPROM emulation with prefetch buffer and 128 -bit data access port • Up to 48 KB on-chip ECC SRAM with SRAM controller • Up to 160 KB on-chip non-ECC graphics SRAM wit...|$|R
2500|$|Due to its simple design, TFTP can {{be easily}} {{implemented}} by small <b>footprint</b> <b>code.</b> It is therefore the protocol of choice for {{the initial stages of}} any network booting strategy like BOOTP, PXE, BSDP, etc., [...] when targeting from highly resourced computers to very low resourced Single-board computers (SBC) and System on a Chip (SoC). It is also used to transfer firmware images and configuration files to network appliances like routers, firewalls, IP phones, etc. Today, TFTP is virtually unused for Internet transfers.|$|R
40|$|With the “Vehicle State Estimator VSE module”, TNO {{offers a}} {{solution}} for integrated active safety. Relevant driving conditions and critical situations for active (safety) control systems are monitored and detected. The VSE {{is a first step}} towards brand independent tuning. Its generic design can be used easily across vehicles in a product line, reducing development effort and cost. The very small <b>code</b> <b>footprint</b> of the VSE and the limited number of application parameters offer {{a solution for}} very little additional costs...|$|E
40|$|Fully {{decentralized}} systems avoid bottlenecks {{and single}} points of failure. Thus, {{they can provide}} excellent scalability and very robust operation. The DecentVM is a fully decentralized, distributed virtual machine. Its simplified instruction set allows for a small VM <b>code</b> <b>footprint.</b> Its partitioned global address space (PGAS) memory model helps to easily create a single system image (SSI) across many processors and processor cores. Originally, the VM was designed for networks of embedded 8 -bit processors. Meanwhile, it also aims at clusters of many core processors. This paper gives {{a brief overview of}} the DecentVM architecture...|$|E
40|$|An overall sensornet {{architecture}} {{would help}} tame the increasingly complex structure of wireless sensornet software and help foster greater interoperability between different codebases. A previous {{step in this}} direction is the Sensornet Protocol (SP), a unifying link-abstraction layer. This paper takes the natural next step by proposing a modular network-layer for sensornets that sits atop SP. This modularity eases implementation of new protocols by increasing code reuse, and enables co-existing protocols to share and reduce code and resources consumed at run-time. We demonstrate how current protocols can be decomposed into this modular structure and show that the costs, in performance and <b>code</b> <b>footprint,</b> are minimal relative to their monolithic counterparts. ...|$|E
40|$|Abstract. There is {{a growing}} trend to use {{general-purpose}} operating systems like Linux in embedded systems. Previous research focused on using compaction and specialization techniques to adapt a general-purpose OS to the memory-constrained environment presented by most embedded systems. However, there is still room for improvement: {{it has been shown}} that even after application of the aforementioned techniques more than 50 % of the kernel code remains unexecuted under normal system operation. We introduce a new technique that reduces the Linux kernel <b>code</b> memory <b>footprint</b> through on-demand <b>code</b> loading of infrequently executed code, for systems that support virtual memory. In this paper, we describe our general approach, and we study code placement algorithms to minimize the performance impact of the code loading. A code size reduction of 68 % is achieved, with a 2. 2 % execution speedup of the system-mode execution time, for a case study based on the MediaBench II benchmark suite. ...|$|R
40|$|By {{analyzing}} the spacing of genes on chromosomes, {{we find that}} transcriptional and RNA-processing regulatory sequences outside <b>coding</b> regions leave <b>footprints</b> {{on the distribution of}} intergenic distances. Using analogies between genes on chromosomes and one-dimensional gases, we constructed a statistical null model. We have used this to estimate typical upstream and downstream regulatory sequence sizes in various species. Deviations from this model reveal bi-directional transcriptional regulatory regions in S. cerevisiae and bi-directional terminators in E. coli. Comment: Main text plus supplementary text; 26 pages, 7 figures in total. To appear in TRENDS in Genetics (May 2008...|$|R
50|$|MPEG {{evaluated}} the state-of-art technologies {{in the field}} of composition coding. Seeing that none were satisfactory for constraint devices like mobiles phones, MPEG decided to create the LASeR standard. The LASeR requirements included compression efficiency, <b>code</b> and memory <b>footprint.</b> The LASeR standard fulfills these requirements by building upon the existing Scalable Vector Graphics (SVG) format defined by the World Wide Web Consortium and particularly on its Tiny profile already adopted in the mobile industry. LASeR complements SVG by defining a small set of compatible key extensions tuned according to the requirements. These key extensions permit among others: the frame-accurate synchronization of the scene with the audio-visual elements, the streaming and efficient compression of SVG content. The workflow of LASeR content from creation based on SVG to consumption is depicted in Figure 1.|$|R
40|$|Tor, {{the popular}} {{anonymous}} relay tool, incurs significant latency costs—partly due to extra network hops, but also due to TCP’s strict in-order delivery. We examine {{the problem of}} TCP’s head-of-line blocking in Tor, although this problem affects any application multiplexing streams atop TCP. Using uTCP and uTLS, techniques for enabling unordered delivery in TCP and TLS, respectively, we eliminate head-of-line blocking between Tor circuits sharing a TCP connection, without sacrificing Tor’s security. The small <b>code</b> <b>footprint</b> of uTCP and uTLS, and the minimal changes required to Tor, suggest the feasability of our approach. A micro-benchmark indicates that the integration of uTCP and uTLS can noticeably lower application-perceived latency. ...|$|E
40|$|We {{introduce}} a novel optimization engine for META 4, a new object oriented language currently under development. It uses Static Single Assignment (henceforth SSA) form coupled with certain reasonable, albeit very uncommon language features not usually found in existing systems. This reduces the <b>code</b> <b>footprint</b> {{and increased the}} optimizer's "reuse" factor. This engine performs the following optimizations; Dead Code Elimination (DCE), Common Subexpression Elimination (CSE) and Constant Propagation (CP) at both runtime and compile time with linear complexity time requirement. CP is essentially free, whether the values are really source-code constants or specific values generated at runtime. CP runs along side with the other optimization passes, thus allowing the efficient runtime specialization of the code during any point of the program's lifetime...|$|E
40|$|With {{increasing}} number of transistors available on a single die, chip multiprocessors are rapidly gaining favor among processor architects; these chip multiprocessors (CMP) are characterized by relatively simple processor cores that emphasize thread-level parallelism (TLP) over instruction-level-parallelism (ILP). Important commercial applications, such as on-line transaction processing (OLTP), have notoriously meager ILP and are instead heavily bottlenecked by memory stalls. These applications, however, exhibit abundant TLP and are eminently suitable for execution on a CMP. This paper analyzes the behavior of an OLTP workload, called the Oracle Database Benchmark (ODB), on CMPs. In particular, it focuses on an important, although less studied, facet of OLTP workloads: the instruction stream. Our results show that due to the large <b>code</b> <b>footprint,</b> OLTP suffers from high I-cache miss rates when using typical first level I-cache sizes seen on contemporary microprocessors. Although, the overall <b>code</b> <b>footprint</b> of ODB is large, multiple ODB threads running concurrently on multiple processors tend to access common code segments frequently, thus exhibiting significant constructive sharing. In fact, in a CMP system, a shared cache of a given size performs almost {{as well as a}} dedicated cache of the same capacity. Based on these observations, this paper makes a case for a shared I-cache organization in a CMP, instead of the traditional approach of using a dedicated I-cache per processor. Furthermore, this paper shows that OLTP code stream exhibits good spatial locality. Adding a simple dedicated Line Buffer per processor can exploit this spatial locality effectively, to reduce latency and bandwidth requirements on the shared cache. The proposed shared I-cache organization results in an improvement of at least 5 X in miss rate over a dedicated cache organization for the same total capacity. ...|$|E
40|$|JPEG <b>coding</b> leaves {{characteristic}} <b>footprints</b> {{that can}} be leveraged to reveal doctored images, e. g. providing the evidence for local tam-pering, copy-move forgery, etc. Recently, {{it has been shown}} that a knowledgeable attacker might attempt to remove such footprints by adding a suitable anti-forensic dithering signal to the image in the DCT domain. Such noise-like signal restores the distribution of the DCT coefficients of the original picture, at the cost of affecting image quality. In this paper we show that it is possible to detect this kind of attack by measuring the noisiness of images obtained by re-compressing the forged image at different quality factors. When tested on a large set of images, our method was able to correctly detect forged images in 97 % of the cases. In addition, the original quality factor could be accurately estimated. Index Terms — digital image forensics; anti-forensics; JPEG compression 1...|$|R
40|$|The {{usage of}} {{cellular}} phones, PDAs, and other mobile de-vices {{has increased dramatically}} {{over the past ten}} years. Java is targeted {{to be one of the}} most popular execution environments on such systems. However, since mobile de-vices are inherently limited in terms of local storage capac-ity and Java requires large amounts of library code to be present on each client device, it is crucial to reduce the <b>code</b> and memory <b>footprint</b> to ensure Java’s success on such sys-tems. SlimVM’s approach eliminates all unnecessary code and meta information on mobile devices. We present a solution for the next generation of mobile computing environments for persistent connected embedded systems where all code resides on a network server and is requested at run time by the Java virtual machine on the client. All application and library code is analyzed on the server prior to execution on the mobile device, and only code essential for execution is sent to the client on demand. Java bytecode is manipulated and transferred to the client in the form of pre-linked basic blocks. Measurements show a reduction of the memory footprint of up to 70 %...|$|R
40|$|Distributed {{real-time}} simulations {{provide important}} timing validation and hardware in the- loop {{results for the}} spacecraft flight software development cycle. Occasionally, the need for higher fidelity modeling and more comprehensive debugging capabilities - combined with {{a limited amount of}} computational resources - calls for a non real-time simulation environment that mimics the real-time environment. By creating a non real-time environment that accommodates simulations and flight software designed for a multi-CPU real-time system, we can save development time, cut mission costs, and reduce the likelihood of errors. This paper presents such a solution: Virtual Equivalent Real-time Simulation Environment (VERSE). VERSE turns the real-time operating system RTAI (Real-time Application Interface) into an event driven simulator that runs in virtual real time. Designed to keep the original RTAI architecture as intact as possible, and therefore inheriting RTAI's many capabilities, VERSE was implemented with remarkably little change to the RTAI source <b>code.</b> This small <b>footprint</b> together with use of the same API allows users to easily run the same application in both real-time and virtual time environments. VERSE has been used to build a workstation testbed for NASA's Space Interferometry Mission (SIM PlanetQuest) instrument flight software. With its flexible simulation controls and inexpensive setup and replication costs, VERSE will become an invaluable tool in future mission development...|$|R
40|$|This thesis {{describes}} {{the design and}} development of both the hardware and software of an embedded, distributed control system using a LAN infrastructure for communication between nodes. The primary application of this system is for power monitoring and control at Rhodes University. Both the hardware and software {{have been developed to}} provide a modular and scalable system capable of growing and adapting to meet the changing demands placed on it. The software includes a custom written Internet Protocol stack for use in the embedded environment, with a small <b>code</b> <b>footprint</b> and low processing overheads. There is also Linux-based control software, which includes a web-based device management interface and graphical output. Problems specific to the application are discussed as well as their solutions, with particular attention to the constraints of an embedded system...|$|E
40|$|This paper {{describes}} gnatDb, {{which is}} an embedded database system that provides protection against both accidental and malicious corruption of data. GnatDb is designed to run {{on a wide range}} of appliances, some of which have very limited resources. Therefore, its design is heavily driven by the need to reduce resource consumption. GnatDb employs atomic and durable updates to protect the data against accidental corruption. It prevents malicious corruption of the data using standard cryptographic techniques that leverage the underlying log-structured storage model. We show that the total memory consumption of gnatDb, which includes the <b>code</b> <b>footprint,</b> the stack and the heap, does not exceed 11 KB, while its performance on a typical appliance platform remains at an acceptable level (less than 0. 6 s) for database utilization below 50 %...|$|E
40|$|Security is an {{increasingly}} fundamental requirement in Software-Defined Networking (SDN). However, {{the pace of}} adoption of secure mechanisms has been slow, which we estimate to be {{a consequence of the}} performance overhead of traditional solutions and of the complexity of their support infrastructure. To address these challenges we propose KISS, a secure SDN control plane communications architecture that includes innovative solutions in the context of key distribution and secure channel support. Core to our contribution is the integrated device verification value (iDVV), a deterministic but indistinguishablefrom-random secret code generation protocol that allows local but synchronized generation/verification of keys {{at both ends of the}} control channel, even on a per-message basis. We show that our solution, while offering the same security properties, outperforms reference alternatives, with performance improvements up to 30 % over OpenSSL, and improvement in robustness based on a <b>code</b> <b>footprint</b> one order of magnitude smaller...|$|E
40|$|In this {{research}} report, we propose an enhancement of the compilation of synchronous programs {{with a combined}} numerical-Boolean abstraction. While our approach applies to synchronous dataflow languages in general, here, we consider the Signal language for illustration. In the new abstraction, every signal in a program {{is associated with a}} pair of the form (clock, value), where clock is a Boolean function and value is a Boolean or numeric function. Given the performance level reached by recent progress in Satisfiability Modulo Theory (SMT), we use an SMT solver reason on this abstraction. Through sample examples, we show how our solution is used to determine absence of reaction captured by empty clocks; mutual exclusion captured by two or more clocks whose associated signals never occur at the same time; or hierarchical control of component activations via clock inclusion. We also show this analysis improves the quality of the code generated automatically by a compiler, e. g., a <b>code</b> with smaller <b>footprint,</b> or a <b>code</b> executed more efficiently thanks to optimizations enabled by the new abstraction. The implementation of the whole approach includes a translator of synchronous programs towards the standard input format of SMT solvers, and an ad hoc SMT solver that integrates advanced functionalities to cope with the issues of interest in this work...|$|R
40|$|Last version = author {{version of}} our CSI Journal of Computer Paper (same title and same content) In this {{research}} report, we propose an enhancement of the compilation of synchronous programs {{with a combined}} numerical-Boolean abstraction. While our approach applies to synchronous dataflow languages in general, here, we consider the *signal* language for illustration. In the new abstraction, every signal in a program {{is associated with a}} pair of the form (clock, value), where clock is a Boolean function and value is a Boolean or numeric function. Given the performance level reached by recent progress in Satisfiability Modulo Theory (SMT), we use an SMT solver reason on this abstraction. Through sample examples, we show how our solution is used to determine absence of reaction captured by empty clocks; mutual exclusion captured by two or more clocks whose associated signals never occur at the same time; or hierarchical control of component activations via clock inclusion. We also show this analysis improves the quality of the code generated automatically by a compiler, e. g., a <b>code</b> with smaller <b>footprint,</b> or a <b>code</b> executed more efficiently thanks to optimizations enabled by the new abstraction. The implementation of the whole approach includes a translator of synchronous programs towards the standard input format of SMT solvers, and an *ad hoc* SMT solver that integrates advanced functionalities to cope with the issues of interest in this work...|$|R
40|$|RR version = [URL] audienceIn this paper, {{we propose}} an {{enhancement}} of the compilation of synchronous programs {{with a combined}} numerical-Boolean abstraction. While our approach applies to synchronous dataflow languages in general, here, we consider the SIGNAL language for illustration. In the new abstraction, every signal in a program {{is associated with a}} pair of the form (clock, value), where clock is a Boolean function and value is a Boolean or numeric function. Given the performance level reached by recent progress in Satisfiability Modulo Theory (SMT), we use an SMT solver to reason on this abstraction. Through sample examples, we show how our solution is used to determine absence of reaction captured by empty clocks; mutual exclusion captured by two or more clocks whose associated signals never occur at the same time; or hierarchical control of component activations via clock inclusion. We also show that the analysis improves the quality of the code generated automatically by a compiler, e. g., a <b>code</b> with smaller <b>footprint,</b> or a <b>code</b> executed more efficiently thanks to optimizations enabled by the new abstraction. The implementation of the whole approach includes a translator of synchronous programs towards the standard input format of SMT solvers, and an ad hoc SMT solver that integrates advanced functionalities to cope with the issues of interest in this wor...|$|R
40|$|Abstract — NAND Flash is {{preferred}} for code and data storage in embedded devices {{due to high}} density and low cost. However, NAND Flash requires code to be copied (shadowed) into a device’s main memory for execution. In inexpensive devices without hardware memory management, full shadowing of an application binary is commonly used to load the program. This approach {{can lead to a}} high initial application start-up latency and poor amortization of copy overhead. To overcome these problems, we describe a software-only demand-paging approach that incrementally copies code to memory with a dynamic binary translator (DBT). This approach does not require hardware or operating system support. With careful management, a savings can be achieved in total <b>code</b> <b>footprint,</b> which can offset the size of data structures used by DBT. For applications that cannot amortize full shadowing cost, our approach can reduce start-up latency by 50 % or more, and improve performance by 11 % on average. I...|$|E
40|$|The {{most serious}} {{impediment}} to writing substantial {{programs in the}} Java TM programming language {{is the lack of}} a genericity mechanism for abstracting classes and methods with respect to type. During the past two years, several research groups have developed Java extensions that support various forms of genericity, but none has succeeded in accommodating general type parameterization (akin to Java arrays) while retaining compatibility with the existing Java Virtual Machine. In this paper, we explain how to support general type parameterization [...] -including both non-variant and covariant subtyping [...] -on top of the existing Java Virtual Machine at the cost of a larger <b>code</b> <b>footprint</b> and the forwarding of some method calls involving parameterized classes and methods. Our language extension is forward and backward compatible with the Java 1. 2 language and run-time environment: programs in the extended language will run on existing Java 1. 2 virtual machines (relying only on the unparameteri [...] ...|$|E
40|$|Refactorings are—as {{defined by}} Fowler—behavior {{preserving}} source code transformations. Their main {{purpose is to}} improve maintainability or comprehensibility, or also reduce the <b>code</b> <b>footprint</b> if needed. In principle, refactorings are defined as simple operations so that are “unlikely to go wrong” and introduce faults. In practice, refactoring activities could have their risks, as other changes. This paper reports an empirical {{study carried out on}} three Java software systems, namely Apache Ant, Xerces, and ArgoUML, aimed at investigating to what extent refactoring activities induce faults. Specifically, we automatically detect (and then manually validate) 15, 008 refactoring operations (of 52 different kinds) using an existing tool (Ref-Finder). Then, we use the SZZ algorithm to determine whether it is likely that refactorings induced a fault. Results indicate that, while some kinds of refactorings are unlikely to be harmful, others, such as refactorings involving hierarchies (e. g., pull up method), tend to induce faults very frequently. This suggests more accurate code inspection or testing activities when such specific refactorings are performed...|$|E
40|$|By {{analyzing}} the spacing of genes on chromosomes, {{we find that}} transcriptional and RNA-processing regulatory sequences outside <b>coding</b> regions leave <b>footprints</b> {{on the distribution of}} intergenic distances. Using analogies between genes on chromosomes and one-dimensional gases, we constructed a statistical null model. We have used this to estimate typical upstream and downstream regulatory sequence sizes in various species. Deviations from this model reveal bi-directional transcriptional regulatory regions in S. cerevisiae and bi-directional terminators in E. coli. 1 Probability distributions of intergenic distances The probability distributions of intergenic distances are shaped by stochastic processes, such as insertions, deletions, inversions and duplications, and by natural selection. Although the former tends to randomize the distribution, the latter introduces biases if there are functional reasons for genes to be spaced in a particular way [1]. Here we compare data of both Escherichia coli and different fungal species to a statistical mechanics model to study which features can be explained by random processes only, and which require an explanation in terms of functionality. 2 The Constant-Force model The Constant-Force (CF) model is based on two observations (see Fig. 1). First, open reading frames (ORFs) usually do not overlap, even if their density is high. For example, if the genes of Saccharomyces cervisiae (budding yeast) were randomly distributed, 78 % of the ORFs would overlap with another ORF, whereas in reality, only 9 % do. Second, ORFs are rarely very close together (e. g. see Fig. 2 a for S. cerevisiae). We hypothesize that this is caused by functional sequences directly upstream and downstrea...|$|R
40|$|The RAG 1 and RAG 2 {{proteins}} initiate V(D) J recombination {{by introducing}} double-strand breaks {{at the border}} between a recombination signal sequence (RSS) and a coding segment. To understand the distinct functions of RAG 1 and RAG 2 in signal recognition, we have compared the DNA binding activities of RAG 1 alone and RAG 1 plus RAG 2 by gel retardation and footprinting analyses. RAG 1 exhibits only a three- to fivefold preference for binding DNA containing an RSS over random sequence DNA. Although direct binding of RAG 2 by itself was not detected, the presence of both RAG 1 and RAG 2 results {{in the formation of}} a RAG 1 -RAG 2 -DNA complex which is more stable and more specific than the RAG 1 -DNA complex and is active in V(D) J cleavage. These results suggest that biologically effective discrimination between an RSS and nonspecific sequences requires both RAG 1 and RAG 2. Unlike the binding of RAG 1 plus RAG 2, RAG 1 can bind to DNA {{in the absence of a}} divalent metal ion and does not require the presence of <b>coding</b> flank sequence. <b>Footprinting</b> of the RAG 1 -RAG 2 complex with 1, 10 -phenanthroline-copper and dimethyl sulfate protection reveal that both the heptamer and the nonamer are involved. The nonamer is protected, with extensive protein contacts within the minor groove. Conversely, the heptamer is rendered more accessible to chemical attack, suggesting that binding of RAG 1 plus RAG 2 distorts the DNA near the coding/signal border...|$|R
40|$|Part 4 : Secure Storage in the CloudInternational audienceSoftware-based {{approaches}} for search over encrypted data are still either challenged {{by lack of}} proper, low-leakage encryption or slow performance. Existing hardware-based approaches do not scale well due to hardware limitations and software designs that are not specifically tailored to the hardware architecture, and are rarely well analyzed for their security (e. g., the impact of side channels). Additionally, existing hardware-based solutions often have a large <b>code</b> <b>footprint</b> in the trusted environment susceptible to software compromises. In this paper we present HardIDX: a hardware-based approach, leveraging Intel’s SGX, for search over encrypted data. It implements only the security critical core, i. e., the search functionality, in the trusted environment and resorts to untrusted software for the remainder. HardIDX is deployable as a highly performant encrypted database index: it is logarithmic {{in the size of}} the index and searches are performed within a few milliseconds. We formally model and prove the security of our scheme showing that its leakage is equivalent to the best known searchable encryption schemes...|$|E
