5254|0|Public
5|$|The chief {{device of}} ancient Hebrew Biblical poetry, {{including}} {{many of the}} psalms, was parallelism, a rhetorical structure in which successive lines reflected each other in grammatical structure, sound structure, notional content, or all three. Parallelism lent itself to antiphonal or call-and-response performance, which could also be reinforced by intonation. Thus, Biblical poetry relies much less on metrical feet to create rhythm, but instead creates rhythm based on much larger sound units of lines, phrases and sentences. Some classical poetry forms, such as Venpa of the Tamil language, had rigid grammars (to {{the point that they}} could be expressed as a <b>context-free</b> grammar) which ensured a rhythm. In Chinese poetry, tones as well as stresses create rhythm. Classical Chinese poetics identifies four tones: the level tone, rising tone, departing tone, and entering tone.|$|E
25|$|Languages {{generated}} by <b>context-free</b> grammars {{are known as}} <b>context-free</b> languages (CFL). Different <b>context-free</b> grammars can generate the same <b>context-free</b> language. It is important to distinguish {{the properties of the}} language (intrinsic properties) from the properties of a particular grammar (extrinsic properties). The language equality question (do two given <b>context-free</b> grammars generate the same language?) is undecidable.|$|E
25|$|Every regular grammar is <b>context-free,</b> {{but not all}} <b>context-free</b> grammars are regular. The {{following}} <b>context-free</b> grammar, however, is also regular.|$|E
25|$|The {{efficiency}} of <b>context-free</b> grammar parsing {{is determined by}} the automaton that accepts it. Deterministic <b>context-free</b> grammars are accepted by deterministic pushdown automata and can be parsed in linear time, for example by the LR parser. This is a subset of the <b>context-free</b> grammars which are accepted by the pushdown automaton and can be parsed in polynomial time, for example by the CYK algorithm. Unambiguous <b>context-free</b> grammars can be nondeterministic.|$|E
25|$|An {{extended}} <b>context-free</b> grammar (or regular right part grammar) is one {{in which}} the right-hand side of the production rules is allowed to be a regular expression over the grammar's terminals and nonterminals. Extended <b>context-free</b> grammars describe exactly the <b>context-free</b> languages.|$|E
25|$|An L-system is <b>context-free</b> if each {{production}} rule refers only {{to an individual}} symbol and not to its neighbours. <b>Context-free</b> L-systems are thus specified by a <b>context-free</b> grammar. If a rule depends not only on a single symbol but also on its neighbours, it is termed a context-sensitive L-system.|$|E
25|$|Deterministic pushdown automata can {{recognize}} all deterministic <b>context-free</b> languages while nondeterministic ones {{can recognize}} all <b>context-free</b> languages, {{with the former}} often used in parser design.|$|E
25|$|LR(k) grammars (also {{known as}} {{deterministic}} <b>context-free</b> grammars) allow parsing (string recognition) with deterministic pushdown automata (PDA), {{but they can}} only describe deterministic <b>context-free</b> languages.|$|E
25|$|In automata theory, a {{deterministic}} pushdown automaton (DPDA or DPA) is {{a variation}} of the pushdown automaton. The class of deterministic pushdown automata accepts the deterministic <b>context-free</b> languages, a proper subset of <b>context-free</b> languages.|$|E
25|$|In linguistics, {{some authors}} {{use the term}} phrase {{structure}} grammar to refer to <b>context-free</b> grammars, whereby phrase-structure grammars are distinct from dependency grammars. In computer science, a popular notation for <b>context-free</b> grammars is Backus–Naur form, or BNF.|$|E
25|$|Some {{questions}} that are undecidable for wider classes of grammars become decidable for <b>context-free</b> grammars; e.g. the emptiness problem (whether the grammar generates any terminal strings at all), is undecidable for context-sensitive grammars, but decidable for <b>context-free</b> grammars.|$|E
25|$|Deterministic <b>context-free</b> {{languages}} can {{be recognized}} by a deterministic Turing machine in polynomial time and O(log2 n) space; as a corollary, DCFL is {{a subset of the}} complexity class SC. The set of deterministic <b>context-free</b> languages is not closed under union but is closed under complement.|$|E
25|$|In {{computer}} science, {{an ambiguous}} grammar is a <b>context-free</b> grammar {{for which there}} exists a string that can {{have more than one}} leftmost derivation or parse tree, while an unambiguous grammar is a <b>context-free</b> grammar for which every valid string has a unique leftmost derivation or parse tree. Many languages admit both ambiguous and unambiguous grammars, while some languages admit only ambiguous grammars. Any non-empty language admits an ambiguous grammar by taking an unambiguous grammar and introducing a duplicate rule or synonym (the only language without ambiguous grammars is the empty language). A language that only admits ambiguous grammars is called an inherently ambiguous language, and there are inherently ambiguous <b>context-free</b> languages. Deterministic <b>context-free</b> grammars are always unambiguous, and are an important subclass of unambiguous grammars; there are non-deterministic unambiguous grammars, however.|$|E
25|$|The {{language}} is <b>context-free,</b> however, {{it can be}} proved {{that it is not}} regular.|$|E
25|$|Chomsky {{initially}} {{hoped to}} overcome the limitations of <b>context-free</b> grammars by adding transformation rules.|$|E
25|$|<b>Context-free</b> grammars {{are simple}} {{enough to allow}} the {{construction}} of efficient parsing algorithms that, for a given string, determine whether {{and how it can}} be generated from the grammar. An Earley parser is an example of such an algorithm, while the widely used LR and LL parsers are simpler algorithms that deal only with more restrictive subsets of <b>context-free</b> grammars.|$|E
25|$|Closure {{properties}} of deterministic <b>context-free</b> languages (accepted by deterministic PDA by final state) are drastically {{different from the}} <b>context-free</b> languages. As an example they are (effectively) closed under complementation, but not closed under union. To prove that the complement of a language accepted by a deterministic PDA is also accepted by a deterministic PDA is tricky. In principle one has to avoid infinite computations.|$|E
25|$|There are {{algorithms}} {{to decide}} whether a <b>context-free</b> language is empty and whether it is finite.|$|E
25|$|PCFGs models extend <b>context-free</b> grammars {{the same}} way as hidden Markov models extend regular grammars.|$|E
25|$|In this case, (1) is the <b>context-free</b> {{interpretation}} of choice, but (2) is {{possible with the}} proper context.|$|E
25|$|The {{formalism}} of <b>context-free</b> grammars {{was developed}} in the mid-1950s by Noam Chomsky, and also their classification as a special type of formal grammar (which he called phrase-structure grammars). What Chomsky called a phrase structure grammar is also known now as a constituency grammar, whereby constituency grammars stand in contrast to dependency grammars. In Chomsky's generative grammar framework, the syntax of natural language was described by <b>context-free</b> rules combined with transformation rules.|$|E
25|$|The {{languages}} of this class have great practical importance {{in computer science}} {{as they can be}} parsed much more efficiently than nondeterministic <b>context-free</b> languages. The complexity of the program and execution time of a deterministic pushdown automaton is vastly less than that of a nondeterministic one. In the naive implementation, the latter must make copies of the stack every time a nondeterministic step occurs. The best known algorithm to test membership in any <b>context-free</b> language is Valiant's algorithm, taking O(n2.378) time, where n is the length of the string. On the other hand, deterministic <b>context-free</b> languages can be accepted in O(n) time by an LR(k) parser. This is very important for computer language translation because many computer languages belong to this class of languages.|$|E
25|$|Technically, given a <b>context-free</b> grammar, the PDA has {{a single}} state, 1, and its {{transition}} relation is constructed as follows.|$|E
25|$|The usual {{acceptance}} criterion is final state, {{and it is}} this {{acceptance criterion}} which is used to define the deterministic <b>context-free</b> languages.|$|E
25|$|For a <b>context-free</b> grammar in Greibach normal form, {{defining}} (1,γ) ∈ δ(1,a,A) {{for each}} grammar rule A → aγ also yields an equivalent nondeterministic pushdown automaton.|$|E
25|$|Aizikowitz and Kaminski {{introduced}} synchronized alternating pushdown automata (SAPDA) {{that are}} equivalent to conjunctive grammars {{in the same}} way as nondeterministic PDA are equivalent to <b>context-free</b> grammars.|$|E
25|$|Every <b>context-free</b> grammar can be {{effectively}} {{transformed into a}} weakly equivalent one without unreachable symbols, a weakly equivalent one without unproductive symbols, and a weakly equivalent one without cycles.|$|E
25|$|Every <b>context-free</b> grammar not {{producing}} ε can {{be effectively}} {{transformed into a}} weakly equivalent one without ε-productions; altogether, every such grammar can be effectively transformed into a weakly equivalent proper CFG.|$|E
25|$|The {{formation}} {{rules for}} the terms and formulas of formal logic fit the definition of <b>context-free</b> grammar, except that the set of symbols may be infinite {{and there may be}} more than one start symbol.|$|E
25|$|Chomsky's general {{position}} {{regarding the}} non-context-freeness of natural language has held up since then, although his specific examples regarding {{the inadequacy of}} <b>context-free</b> grammars {{in terms of their}} weak generative capacity were later disproved.|$|E
25|$|As a {{consequence}} of the complementation it is decidable whether a deterministic PDA accepts all words over its input alphabet, by testing its complement for emptiness. This is not possible for <b>context-free</b> grammars (hence not for general PDA).|$|E
25|$|Gerald Gazdar and Geoffrey Pullum {{have argued}} that despite a few non-context-free constructions in natural {{language}} (such as cross-serial dependencies in Swiss German and reduplication in Bambara), {{the vast majority of}} forms in natural language are indeed <b>context-free.</b>|$|E
25|$|The {{decision}} problem of whether an arbitrary grammar is ambiguous is undecidable {{because it can}} be shown that it is equivalent to the Post correspondence problem. At least, there are tools implementing some semi-decision procedure for detecting ambiguity of <b>context-free</b> grammars.|$|E
25|$|A common {{example of}} {{ambiguity}} in computer programming languages is the dangling else problem. In many languages, the else in an If–then(–else) statement is optional, {{which results in}} nested conditionals having multiple ways of being recognized {{in terms of the}} <b>context-free</b> grammar.|$|E
25|$|Starting from a {{sequence}} of characters, the lexical analyzer builds {{a sequence}} of language tokens (such as reserved words, literals, and identifiers) from which the parser builds a syntax tree. The lexical analyzer and the parser handle the regular and <b>context-free</b> parts of the programming language's grammar.|$|E
25|$|If {{there is}} exactly one {{production}} for each symbol, then the L-system {{is said to}} be deterministic (a deterministic <b>context-free</b> L-system is popularly called a D0L system). If there are several, and each is chosen with a certain probability during each iteration, then it is a stochastic L-system.|$|E
