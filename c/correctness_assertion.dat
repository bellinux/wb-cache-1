10|61|Public
50|$|A proof {{would have}} to be a {{mathematical}} proof, assuming both the algorithm and specification are given formally. In particular it is not expected to be a <b>correctness</b> <b>assertion</b> for a given program implementing the algorithm on a given machine. That would involve such considerations as limitations on computer memory.|$|E
50|$|A {{distinction}} is made between total correctness, which additionally {{requires that the}} algorithm terminates, and partial correctness, which simply requires that if an answer is returned it will be correct. Since there is no general solution to the halting problem, a total <b>correctness</b> <b>assertion</b> may lie much deeper. A termination proof {{is a type of}} mathematical proof that plays a critical role in formal verification because total correctness of an algorithm depends on termination.|$|E
40|$|AbstractIn {{this paper}} {{processes}} specifiable over a non-uniform language are considered. The language contains constants {{for a set}} of atomic actions and constructs for alternative and sequential composition. Furthermore it provides a mechanism for specifying processes recursively (including nested recursion). We consider processes as having a state: atomic actions are to be specified in terms of observable behaviour (relative to initial states) and state transformations. Any process having some initial state can be associated with a transition system representing all possible courses of execution. This leads to an operational semantics in the style of Plotkin. The partial <b>correctness</b> <b>assertion</b> {α} p{β} expresses that for any transition system associated with the process p and having some initial state satisfying α, its final states representing successful execution satisfy β. A logic in the style of Hoare, containing a proof system for deriving partial correctness assertions, is presented. This proof system is sound and relatively complete, so any partial <b>correctness</b> <b>assertion</b> can be evaluated by investigating its derivability. Included is a short discussion about the extension of the process language with “guarded recursion”. It appears that such an extension violates the completeness of the Hoare logic. This reveals a remarkable property of Scott's induction rule in the context of non-determinism: only regular recursion allows a completeness result...|$|E
40|$|It {{is known}} (Bergstra and Tucker (1982) J. Comput. System Sci. 25, 217) {{that if the}} Hoare rules are {{complete}} for a first-order structure %plane 1 D; 49 C;, then the set of partial <b>correctness</b> <b>assertions</b> true over %plane 1 D; 49 C; is recursive in the first-order theory of %plane 1 D; 49 C;. We show that the converse is not true. Namely, there is a first-order structure %plane 1 D; 49 E; such that the set of partial <b>correctness</b> <b>assertions</b> true over %plane 1 D; 49 E; is recursive {{in the theory of}} %plane 1 D; 49 E;, but the Hoare rules are not complete for %plane 1 D; 49 E;...|$|R
40|$|We {{show that}} propositional Hoare logic is subsumed by the type {{calculus}} of typed Kleene algebra augmented with subtypes and typecasting. Assertions are interpreted as typecast operators. Thus Hoare-style reasoning with partial <b>correctness</b> <b>assertions</b> reduces to typechecking in this system. 1 Introduction In previous work [18, 19], {{we have shown}} that Kleene algebra with tests (KAT) subsumes propositional Hoare logic (PHL). Thus the specialized syntax and deductive apparatus of Hoare logic are inessential and can be replaced by simple equational reasoning. We have also shown that KAT provides a complete deductive system for Hoare-style inference rules involving partial <b>correctness</b> <b>assertions</b> and that PHL is PSPACE-complete. In other recent work [17], we have introduced a simple and natural type system for Kleene algebra (KA) in which objects have types s ! t. The use of types was motivated {{by the desire to}} handle nonsquare matrices, although there are other useful interpretations. In t [...] ...|$|R
40|$|Despite {{their ability}} to help with program <b>correctness,</b> <b>assertions</b> have been {{notoriously}} unpopular [...] -even with professional programmers. End-user programmers seem even less likely to appreciate the value of assertions; yet end-user programs suffer from serious <b>correctness</b> problems that <b>assertions</b> could help detect. This leads to the following question: can end users be enticed to enter assertions? To investigate this question, we have devised a curiosity-centered approach to eliciting assertions from end users, built on a surprise-explain-reward strategy. Our follow-up work with end-user participants shows that the approach is effective in encouraging end users to enter assertions that help them find errors...|$|R
40|$|We {{present a}} {{methodology}} and corresponding implementation that, given a {{program and a}} <b>correctness</b> <b>assertion</b> violated by the program, identifies a set of focus statements that captures in the most succinct manner possible {{the cause of the}} violation. Our method, which is based on program dependency analysis, also automatically identifies feasible counter-examples and presents the user with sets of constraints over program variables necessary for their feasibility. We illustrate the practical utility of our approach via its successful application to the Resolution Advisory module of the Traffic Collision Avoidance system (TCAS) ...|$|E
40|$|AbstractA {{well-known}} {{result of}} Cook asserts the completeness of Hoare's logic for while-programs relative to any expressive structure. In this paper {{we present a}} wide and natural class of structures whose members are either expressive or make Hoare's logic strongly incomplete relative to them, {{in the sense that}} a trivially true partial <b>correctness</b> <b>assertion</b> is not Hoare-derivable from the first order theory of the structure. The definition of this class is related to the so-called unwind property for while-programs, and its behaviour follows from quite general sufficient conditions for strong relative incompleteness. We state also two questions about the connections among inexpressiveness, relative incompleteness and strong relative incompleteness, and point out the seeming difficulty of answering them...|$|E
40|$|Abrtrr?ct: For a wide cless of {{programming}} languages P and expressive interpretatiorrs 1, {{we show that}} there exist sound and relatively complete Hoara-tike Iogica for both partial correctness and termination aasertiona. In fact, under mild assumptions on P and I, we show that the assertions true for P in I are uniformly decidable {{in the theory of}} I (l’h(I)) iff the halting problem for P is decidable for finite interpretations. Moreover termination assertions are uniformly r. e. in T%(I) even if the halting problem for P is not decklable for finite interpretationa. Since totat <b>correctness</b> <b>assertion</b> 9 coincide with termination a. wertiona for deterministic programming lartguege. s. this last result unexpectedly suggests that the class of tanguages with good axiom systems for total correctness may be wider than for partial correctness...|$|E
40|$|We {{claim that}} the {{continuation}} style semantics of a programming language can provide {{a starting point for}} constructing a proof system for that language. The basic idea is to see weakest precondition as a particular instance of continuation style semantics, hence to interpret <b>correctness</b> <b>assertions</b> (e. g. Hoare triples fpg C frg) as inequalities over continuations. This approach also shows a correspondence between labels in a program and annotations...|$|R
40|$|We {{formulate}} a noncommutative sequent calculus for partial correctness that subsumes propositional Hoare Logic. Partial <b>correctness</b> <b>assertions</b> {{are represented by}} intuitionistic linear implication. We prove soundness and completeness over relational and trace models. As a corollary we obtain a complete sequent calculus for inclusion and equivalence of regular expressions. Categories and Subject Descriptors: D. 2. 2 [Software Engineering]: Tools and Techniques— structured programming; D. 2. 4 [Software Engineering]: Program Verification—correctnes...|$|R
40|$|Abstract. Symbolic {{indexing}} is a {{data abstraction}} technique that exploits the partially-ordered state space of symbolic trajectory evaluation (STE). Use {{of this technique}} has been somewhat limited in practice because of its complexity. We present logical machinery and efficient algorithms that provide a much simpler interface to symbolic indexing for the STE user. Our logical machinery also allows <b>correctness</b> <b>assertions</b> proved by symbolic indexing to be composed into larger properties, something previously not possible. ...|$|R
40|$|Abstract. Localizing {{the cause}} of an error in an error trace {{is one of the}} most {{time-consuming}} aspects of debugging. We develop a novel technique to automate this task. For this purpose, we introduce the concept of error invariants. An error invariant for a position in an error trace is a formula over program variables that over-approximates the reachable states at the given position while only capturing states that will still produce the error, if execution of the trace is continued from that position. Error invariants can be used for slicing error traces and for obtaining concise error explanations. We present an algorithm that computes error invariants from Craig interpolants, which we construct from proofs of unsatisfiability of formulas that explain why an error trace violates a particular <b>correctness</b> <b>assertion.</b> We demonstrate the effectiveness of our algorithm by using it to localize faults in real-world programs. ...|$|E
40|$|Computer program {{analysis}} {{is the process}} of automatically analysing the bahavior of computer programs. There are two main approaches in progam analysis: static program analysis and dynamic program analysis. In static analysis the programs are not executed but are analysed by tools to produce useful information. Static analysis techniques range from the most mundane (statistics on the density of comments, for instance) to the more complex, semantics-based analysis techniques. This text will give an overview of the more complex static program analysis techniques. The main applications of program analysis are program optimization and program correctness. As far as correctness is concerned there is made a distinction between total correctness, where it is additionally required that the algorithm terminates, and partial correctness, which simply requires that if an answer is returned it will be correct. Since there is no general solution to the halting problem, a total <b>correctness</b> <b>assertion</b> is no...|$|E
40|$|AbstractWe {{propose a}} new {{approach}} to delineating logics of programs, based directly on inductive definition of program semantics. The ingredients are elementary and well-known, but their fusion yields a simple yet powerful approach, surprisingly overlooked for decades. The denotational semantics of a regular program can be construed as a relation, easily definable by structural induction on programs. Invoking the framework of canonical theories for (iterated) inductive definitions, we consider the first-order theory for program semantic, i. e. with the generative clauses as construction (introduction) rules, and their dual templates as deconstruction (elimination) rules. We prove that Hoare's logic is inductively complete, in the sense that a partial-correctness assertion is Hoare provable iff it is provable in the inductive theory (with deconstruction for formulas in the base vocabulary). Thus first-order automated theorem-proving can be applied directly to program verification. Proceeding to program termination, we show that a total <b>correctness</b> <b>assertion</b> is valid iff it is provable in the inductive theory without any use of deconstruction. This is yet another take on the first-order nature of total correctness...|$|E
40|$|AbstractWe {{introduce}} a Hoare-style logic for probabilistic programs, called VPHL, {{that has been}} formally verified in the Coq proof assistant. VPHL features propositional, rather than additive, assertions and a simple set of rules for reasoning about these assertions using the standard axioms of probability theory. VPHL's <b>assertions</b> are partial <b>correctness</b> <b>assertions,</b> meaning that their conclusions are dependent upon (deterministic) program termination. The underlying simple probabilistic imperative language, PrImp, includes a probabilistic toss operator, probabilistic guards and potentially-non-terminating while loops...|$|R
40|$|AbstractThe {{question}} of whether a semantic model is suitable {{for the construction of a}} modular proof system is studied in detail. The notion of one semantic model being a (full) abstraction of another semantic model with respect to a given class of properties is introduced, and is used in analyzing different semantic models for communicating processes. A trace model for communicating processes is described and shown to be suitable for the construction of a modular proof system in which partial <b>correctness</b> <b>assertions</b> about communicating processes can be expressed...|$|R
40|$|An {{extension}} of the WHILE-language is developed for programming game-theoretic mechanisms involving multiple agents. Examples of such mechanisms include auctions, voting procedures, and negotiation protocols. A structured operational semantics is provided in terms of extensive games of almost perfect information. Hoare-style partial <b>correctness</b> <b>assertions</b> are proposed to reason about the correctness of these mechanisms, where correctness is interpreted as {{the existence of a}} subgame perfect equilibrium. Using an extensional approach to pre- and postconditions, we show that an {{extension of}} Hoare’s original calculus is sound and complete for reasoning about subgame perfect equilibria in game-theoretic mechanisms. ...|$|R
40|$|Many elegant formalisms {{have been}} {{developed}} for specifying and reasoning about concurrent systems. However, these formalisms have not been widely used by developers and programmers of concurrent systems. One reason is that most formal methods involve techniques and tools not familiar to programmers, for example, a specification language very different from C, C++ or Java. SeSF is a framework for design, verification and testing of concurrent systems that attempts to address these concerns by keeping the theory close to the programmer's world. SeSF considers "layered compositionality". Here, a composite system consists of layers of component systems, and "services" define the allowed sequences of interactions between layers. SeSF uses conventional programming languages to define services. Specifically, SeSF is a markup language that can be integrated with any programming language. We have integrated SeSF into Java, resulting in what we call SeSFJava. We developed a testing harness for SeSFJava, called SeSFJava Harness, in which a (distributed) SeSFJava program can be executed, and the execution checked against its service and any other <b>correctness</b> <b>assertion.</b> A key capability of the SeSFJava Harness is that one can test the final implementation of a concurrent system, rather than just an abstract representation of it. We have two major applications of SeSFJava and the Harness. The first is to the TCP transport layer, where service specification is cast in SeSFJava and the system is tested under SeSFJava Harness. The second is to a Gnutella network. We define the intended services of Gnutella [...] which was not done before {{to the best of our}} knowledge [...] and we tested an open-source implementation, namely Furi, against the service...|$|E
40|$|AbstractWe {{show that}} {{termination}} is a first-order notion if approached via Nonstandard Logics of Programs (NLP). We give explicit first-order characterizations of the program-verifying {{power of the}} well-known Manna-Cooper method for proving total <b>correctness</b> <b>assertions</b> (tca's). Similar characterization {{is given to the}} Intermittent Assertions Method (w. r. t. tca's). A comparison of the tca-proving powers of distinguished methods (or logics of programs) is also attempted. We also show that NLP provides new methods which are strictly stronger than the Manna-Cooper method. In the end we turn to partial correctness issues related to {{the main body of the}} paper...|$|R
40|$|In {{this paper}} a {{generalization}} {{of a certain}} theorem of Lipton (“Proc. 18 th IEEE Sympos. Found. of Comput Sci. ” (1977), pp. 1 – 6) is presented. Namely, we show that for a wide class of programming languages the following holds: the set of all partial <b>correctness</b> <b>assertions</b> true in an expressive interpretation I is uniformly dedicable (in I) {{in the theory of}} I iff the halting problem is decidable for finite interpretations. In the effect we show that such limitations as effectiveness or Herbrand-definability of interpretation (they are relevant in the previous proofs) can be removed in the case of partial correctness...|$|R
40|$|AbstractIt {{is known}} that incompleteness of Hoare's logic {{relative}} to certain data type specifications can occur due {{to the ability of}} partial <b>correctness</b> <b>assertions</b> to code unsolvable problems; cf. Andréka, Németi, and Sain (1979, Lecture Notes in Computer Science Vol. 74, pp. 208 – 218, Springer-Verlag, New York/Berlin) and Bergstra and Tucker (1982, Theoret. Comput. Sci. 17, 303 – 315). We improve what we think are the main known theorems of this kind, showing that they depend only on very weak assumptions on the data type specification (ensuring the ability to simulate arbitrarily long finite initial segments of the natural numbers with successor), and pointing out that the recursion theoretic strength of the obtained results can be increased...|$|R
40|$|We enrich Kleene algebra by {{domain and}} codomain operators. These abstractions of {{relational}} notions {{give rise to}} four modal operators. The boxes and diamonds enjoy various symmetries via Galois connections and dualities. Lifting modal statements to modal operator semirings yields a further abstraction and thus a more elegant and concise “statefree” reasoning about modalities. We use this modal Kleene algebra for calculating soundness and completeness proofs for propositional Hoare logic. While our soundness proof is more direct than related ones, our algebraic completeness proof seems entirely novel. It uses a modal symmetry that relates the wlp predicate transformer with partial <b>correctness</b> <b>assertions</b> and that is beyond the expressibility of formalisms like propositional dynamic logic...|$|R
40|$|Abstract. Traditional (classical) Floyd-Hoare {{logic is}} defined for {{a case of}} total pre- and postconditions while {{programs}} can be partial. In the chapter we propose to extend this logic for partial conditions. To do this we first construct and investigate special program algebras of partial predicates, functions, and programs. In such algebras program <b>correctness</b> <b>assertions</b> are presented {{with the help of}} a special composition called Floyd-Hoare composition. This composition is monotone and continuous. Considering the class of constructed algebras as a semantic base we then define an extended logic – Partial Floyd-Hoare Logic – and investigate its properties. This logic has rather complicated soundness constraints for inference rules, therefore simpler sufficient constraints are proposed. The logic constructed can be used for program verification...|$|R
40|$|We present DynAlloy, an {{extension}} to the Alloy specification language to describe dynamic properties of systems using actions. Actions {{allow us to}} appropriately specify dynamic properties, particularly, properties regarding execution traces, {{in the style of}} dynamic logic specifications. We extend Alloy’s syntax with a notation for partial <b>correctness</b> <b>assertions,</b> whose semantics relies on an adaptation of Dijkstra’s weakest liberal precondition. These assertions, defined in terms of actions, allow us to easily express properties regarding executions, favoring the separation of concerns between the static and dynamic aspects of a system specification. We also extend the Alloy tool {{in such a way that}} DynAlloy specifications are also automatically analyzable, as standard Alloy specifications. We present the foundations, two case-studies, and empirical results evidencing that the analysis of DynAlloy specifications can be performed efficiently...|$|R
40|$|We {{consider}} {{the problem of}} implementing multiway synchronization in a distributed environment providing only binary asynchronous communication. Our implementation strategy is formulated as a transformation on transition systems and we give a distributed algorithm for multiway synchronization. <b>Correctness</b> <b>assertions</b> and proofs {{are based on a}} new method: coupled simulations. The coupled simulation equivalence is weaker than observation equivalence and stronger than testing equivalence and combines some of their advantages. Like observation equivalence (and unlike testing) it is established through case analysis over single transitions. Like testing equivalence (and unlike observation) it allows an internal choice to be distributed onto several internal choices. The latter is particularly important when relating our distributed implementations to their specifications. 1 Introduction In this paper we will formally verify a strategy for implementing multiway synchronizations between pro [...] ...|$|R
40|$|The paper {{presents}} (human-oriented) specification and (pen-and-paper) {{verification of}} the square root function. The function implements Newton method and uses a look-up table for initial approximations. Specification is done in terms of total <b>correctness</b> <b>assertions</b> with use of precise arithmetic and the mathematical square root √( [...] .), algorithms are presented in pseudo-code with explicit distinction between precise and machine arithmetic, verification is done in Floyd-Hoare style and adjustment (matching) of runs of algorithms with precise arithmetic and with machine arithmetic. The {{primary purpose of the}} paper is to make explicit properties of the machine arithmetic that are sufficient to make verification presented in the paper. Computer-aided implementation and validation of the proofs (using some proof-assistant) is the topic for further studies. Comment: 25 pages, 7 figures, full version with complete proof...|$|R
40|$|In {{this paper}} generic {{software}} development steps of different complexity are represented and verified using the (higher-order, strongly typed) specification and verification system PVS. The transformations considered {{in this paper}} include "large" powerful steps encoding general algorithmic paradigms as well as "smaller" transformations for the operationalization of a descriptive specification. The application of these transformation patterns is illustrated by means of simple examples. Furthermore, we show how to guide proofs of <b>correctness</b> <b>assertions</b> about development steps. Finally, this work serves as a case-study and test for {{the usefulness of the}} PVS system. 1 Introduction The methodology of stepwise refinement is widely accepted in modern software engineering. The idea is to start from an abstract requirement specification of a given problem and successively apply correctness preserving transformation patterns to finally yield an executable program. These transformati [...] ...|$|R
40|$|We {{investigate}} the completeness of Hoare logic on the propositional level. In particular, the expressiveness requirements of Cook's proof are characterized propositionally. We give a completeness result for propositional Hoare logic (PHL) : all relationally valid rules fb 1 g p 1 fc 1 g; : : :; fbng pn fcng fbg p fcg are derivable in PHL, provided the propositional expressiveness conditions are met. Moreover, if the programs p i {{in the premises}} are atomic, no expressiveness assumptions are needed. 1 Introduction As shown by Cook [7], Hoare logic is relatively complete for partial <b>correctness</b> <b>assertions</b> (PCAs) over while programs whenever the underlying assertion language is sufficiently expressive. The expressiveness conditions in Cook's formulation provide {{for the expression of}} weakest preconditions. These conditions hold for first-order logic over N, for example, because of the coding power of firstorder number theory. Cook's proof essentially shows that in any sufficiently expressive [...] ...|$|R
40|$|Abstract: This paper gives a {{definition}} of ASM refinement suitable for the verification that a protocol implements atomic transactions. We used this definition {{as the basis of}} the formal verification of the refinements of the Mondex case study with the interactive theorem prover KIV. The refinement definition we give differs from the one we gave in earlier work which preserves partial and total <b>correctness</b> <b>assertions</b> of ASM runs. The reason is that the main goal of the refinement of the Mondex protocol is to preserve a security invariant, while total correctness is not preserved. To preserve invariants, the definition of generalized forward simulation is limited to the use of “small ” diagrams, which contain of a single protocol step. We show a technique that allows to use the natural “big ” diagrams that consist of an atomic action being refined by a full protocol run...|$|R
40|$|This paper {{introduces}} the semantics {{of a wide}} spectrum language with a rich compositional structure that is able to represent both temporal specifications and sequential programs. A key feature of the language {{is the ability to}} represent partial correctness annotations expressed in temporal logic. A refinement relation is presented that enables refinement steps to make use of these partial <b>correctness</b> <b>assertions.</b> It is argued by means of an example that the approach presented allows for more flexible reasoning using temporal annotations than previous approaches, and that the added flexibility has significant value for program optimization. Keywords: Refinement calculus, temporal logic, temporal refinement calculi 1 Introduction Work on program refinement can be categorised into two classes. One of the most deeply explored approaches [Mor 90,BvW 98,Mor 87] is state-based, premised on the use of predicate transformers and weakest preconditions as a semantic basis. This is natu [...] ...|$|R
40|$|This paper {{introduces}} the semantics {{of a wide}} spectrum language with a rich compositional structure that is able to represent both temporal specifications and sequential programs. A key feature of the language {{is the ability to}} represent partial correctness annotations expressed in temporal logic. A refinement relation is presented that enables refinement steps to make use of these partial <b>correctness</b> <b>assertions.</b> It is argued by means of an example that the approach presented allows for more flexible reasoning using temporal annotations than previous approaches, and that the added flexibility has significant value for program optimization. Submitted to: FM' 99, ALGORITHMIC LANGUAGES AND CALCULI mini-track. keywords: DESIGN CALCULI mini-track, refinement, temporal logic 1 Introduction The refinement approach to the top-down development of computer programs has received a considerable amount of attention {{in the last couple of}} decades, reaching a level of maturity with the publicatio [...] ...|$|R
60|$|Trackless pointed {{with great}} dignity towards the north east, {{standing}} motionless as a statue the while, as if inviting the closest possible scrutiny into the <b>correctness</b> of his <b>assertion.</b>|$|R
40|$|We {{present a}} proof system for verifying CCS {{processes}} in the modal ¯-calculus. Its novelty lies in the generality of the proof judgements allowing parametric and compositional reasoning in this complex setting. This is achieved, in part, {{by the use of}} explicit fixed point ordinal approximations, and in part by a complete separation, following an approach by Simpson, of rules concerning the logic from the rules encoding the operational semantics of the process language. 1 Introduction In a number of recent papers [1 [...] 4, 9] proof-theoretical frameworks for compositional verification have been put forward based on Gentzen-style sequents of the shape Γ ` Δ, where the components of Γ and Δ are <b>correctness</b> <b>assertions</b> P : OE. Several programming or modelling languages have been considered, including CCS [3], the ß-calculus [2], CHOCS [1], general GSOS-definable languages [9], and even a significant core fragment of a real programming language, Erlang [4]. An important [...] ...|$|R
40|$|An arithmetically {{complete}} axiom {{system for}} full Algol-like higher order procedures with mode depth one is presented. To show soundness, {{a translation of}} the calculus into a variant of Dynamic Logic is defined. The completeness proof is outlined. 1 Introduction The treatment of higher-order procedures (procedures can be passed as parameters) in Hoare-like axiomatic systems {{has been a major}} research topic since the problem of sound and relatively complete calculi for `simple' procedures was solved in a satisfactory way, [Coo 78], [Old 81], [Apt 81]. All known proof systems for higher-order procedures extend the basic formalism introduced by Hoare, [Hoa 69], in a significant way. Olderog, [Old 84], and Damm and Josko, [DJ 83], extend the language for pre- and postconditions while the form of the partial <b>correctness</b> <b>assertions</b> is maintained. In contrast to that German, Clarke and Halpern, [GCH 89], extend the expressiveness of the underlying logic adhering to a first-order language for pr [...] ...|$|R
40|$|AbstractWe {{introduce}} a temporal logic for the polyadicπ-calculus based on fixed point extensions of Hennessy–Milner logic. Features {{are added to}} account for parametrisation, generation, and passing of names, including the use, following Milner, of dependent sum and product to account for (unlocalised) input and output, and explicit parametrisation on names usingλ-abstraction and application. The latter provides a single name binding mechanism supporting all parametrisation needed. A proof system and decision procedure is developed based on Stirling and Walker's approach to model checking the modalμ-calculus using constants. One difficulty, for both conceptual and efficiency-based reasons, is to avoid the explicit use of theω-rule for parametrised processes. A key idea, following Hennessy and Lin's approach to deciding bisimulation for certain types of value-passing processes, is the relativisation of <b>correctness</b> <b>assertions</b> to conditions on names. Based on this idea, a proof system and a decision procedure are obtained for arbitraryπ-calculus processes with finite control,π-calculus correlates of CCS finite-state processes, avoiding the use of parallel composition in recursively defined processes...|$|R
