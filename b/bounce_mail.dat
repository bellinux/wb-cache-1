2|10|Public
5000|$|The {{receiving}} {{mail server}} verifies the sender address, by verifying both {{parts of the}} sender address - the domain name (part after the @ character), and the local part (part before the @ character). The {{first step is to}} establish a successful SMTP connection to the mail exchanger for the sender address. The mail exchanger is found by looking up the MX records in the domain's DNS zone. The second step is to query the exchanger, and make sure that it accepts the address as a valid one. This is done {{in the same way as}} sending an email to the address, however the process is stopped after the mail exchanger accepts or rejects the recipient address. These are the same steps the receiving mail server would take to <b>bounce</b> <b>mail</b> back to the sender, however in this case no mail is sent. The SMTP commands sent out are: ...|$|E
40|$|RedAlert is a {{complete}} application monitoring system which consists of a stateful server daemon and extensible Perl client API. Almost any IP-protocol service {{is a candidate for}} RedAlert monitoring: the clients determine what error condition they have discovered, convert that information into a standard message format, and transmit the Alert to the server. RedAlert therefore will easily plug in to existing script-based monitoring environments, providing greatly increased functionality for a minimal investment in configuration time. This functionality includes volume tracking, interval sampling, threshold-based notifications, and reporting mechanisms which include pager, electronic mail, and SNMP traps. We have chosen to focus on email monitoring, specifically postmaster <b>bounce</b> <b>mail,</b> for the scope of this paper. <b>Bounce</b> <b>mail</b> is both ubiquitous and complicated, making it ideal for RedAlert monitoring. View from 25, 000 Feet RedAlert is an extensible, easy-to-use client/ server framework written in object-oriented Perl. I...|$|E
50|$|Email loops are not {{as common}} today as in the past, due to changes to email software, both on the client side and the server side, that prevent {{automatic}} replies to vacation responses and <b>bounced</b> <b>mail</b> responses.|$|R
5000|$|From this <b>bounce</b> message the <b>mailing</b> list manager can deduce that {{a message}} to [...] must have failed.|$|R
5000|$|Servers that reject all <b>bounce</b> <b>mails</b> (contrary to the RFC 1123, {{a part of}} STD 3). To {{work around}} this problem, postfix, for example, uses either the local {{postmaster}} address or an address of [...] "double-bounce" [...] in the MAIL FROM part of the callout. This workaround, however, has two problems: first, it can cause a verification loop; secondly it will fail if Bounce Address Tag Validation is used to reduce backscatter. So, this work around should not be used. Callback verification can still work if rejecting all bounces happens at the DATA stage instead of the earlier MAIL FROM stage, while rejecting invalid e-mail addresses remains at the RCPT TO stage instead of also being moved to the DATA stage.|$|R
50|$|Critics of C/R {{systems have}} raised several issues {{regarding}} their usefulness as an email defense. A {{number of these}} issues relate to all programs which auto-respond to E-mail, including mailing list managers, vacation programs and <b>bounce</b> messages from <b>mail</b> servers.|$|R
40|$|In early 1998, we {{were asked}} by Corporate Communications to develop a {{facility}} for providing a subscription based internal company mailing list capability that would permit Senior Executive management to send messages on an irregular basis {{from anywhere in the}} world. Shortly thereafter, we were also asked to provide a one-use-only mechanism to send all 175, 000 worldwide employees a (self-qualifying) message of where internally to report perceived spam in order to support corporate efforts to reduce incoming spam through technical means. Much to our surprise, delivering this message was a technical non-event. The success of these efforts led Corporate Communications to request a more general system for permitting multiple mailings to targeted audiences, with a goal of completely eliminating the paper-based communications Management Information Bulletin systems, hopefully at considerable cost savings. Given time and budget constraints, we chose to base our solution on majordomo. This paper describes a scalable method for handling deliveries to multiple majordomo mailing lists with a minimum of administration. Ancillary issues such as sender authentication, message constraints, <b>bounces,</b> <b>mail</b> replies, and mailing list recipient management are also described. This system is in use literally daily in Boeing, and has easily supported lists as large as 150, 000 recipients- drawn from custom SQL queries of the companyâ€™s employee database. Conservative estimates of the savings in moving to a fully electronic communications mechanism exceed $ 1, 000, 000 per year with cycle time that has improved from several days to only a few hours...|$|R
5000|$|Usually, ADMDs {{authorize the}} IP {{addresses}} used {{by their own}} outbound MTAs, including any proxy or smarthost. That way, messages sent by an ADMD's boxes get authenticated if they flow through the normal path. Otherwise, unless the intermediate relay (sometimes called mediator) takes specific measures, SPF authentication does not succeed. [...] Those specific measures consist of altering the <b>bounce</b> address, which <b>mailing</b> lists routinely do while forwarding services in general do not.|$|R
40|$|Some methods against spam {{are based}} on a {{principle}} that a recipient reads only messages from senders who are registered by the recipient (challenge and response). In these schemes, some exceptions are required to show error <b>mail</b> (<b>bounce</b> message) to a sender of an original message. However, spammers can abuse this exception to send spam to users. In this paper, we propose a new method which combines a Bayesian filter and challenge-and-response using Message Authentication Code (MAC) to avoid that spam...|$|R
40|$|This memo defines an Experimental Protocol for the Internet community. This memo {{does not}} specify an Internet {{standard}} of any kind. Discussion {{and suggestions for}} improvement are requested. Distribution of this memo is unlimited. This memo defines a new Simple Mail Transfer Protocol (SMTP) [1] reply code, 521, which one may use to indicate that an Internet host does not accept incoming mail. 1. Motivations Hosts on the Internet have shifted from large, general-purpose hosts to smaller, more specialized hosts. There is {{an increasing number of}} hosts which are dedicated to specific tasks, such as serving NTP or DNS. These dedicated hosts frequently do not provide mail service. Usually, these mailless hosts do not run an SMTP server. Unfortunately, users will occasionally misaddress mail to these hosts. Regular SMTP clients attempting to deliver this misaddressed mail must treat the lack of an SMTP server on the host as a temporary error. They must queue the mail for later delivery, should an SMTP server be started at a later time. This causes the mail to remain queued for days, until it is returned with what is usually a confusing error message. 2. Two complementary solutions Two complementary solutions MAY be implemented to deal with this issue. The first one is to use MX relays to <b>bounce</b> misaddressed <b>mails.</b> The second one is to implement a minimal smtp server on the mailless host to <b>bounce</b> all <b>mails.</b> The choice between the two solutions is site dependent. Durand & Dupont Experimental [Page 1] RFC 1846 SMTP 521 Reply Code September 1995 3. The MX relays solution MX relays may be used to indicate SMTP clients that an Internet host does not accept mail. During the SMTP dialog, these MX relays MAY bounce any message destinated to this particular host with an SMTP 521 reply code. SMTP dialog example: [...] -> 220 relay. imag. fr ready 250 relay. imag. fr Hello client. inria. f...|$|R
5000|$|Sami Farin {{proposed}} an Anti-Bogus Bounce System in 2003 in news.admin.net-abuse.email, which {{used the same}} basic idea of putting a hard to forge hash in a message's bounce address. In late 2004, Goodman et al. proposed a much more complex [...] "Signed Envelope Sender" [...] that included a hash of the message body and was intended to address {{a wide variety of}} forgery threats, including <b>bounces</b> from forged <b>mail.</b> Several months later, Levine and Crocker proposed BATV under its current name and close to its current form.|$|R
50|$|The {{hard part}} of bounce {{handling}} is matching up a bounce message with the undeliverable address {{that caused the}} <b>bounce.</b> If the <b>mailing</b> list software can see that a bounce resulted from an attempt {{to send a message}} to user@example.com then it doesn't need to understand the rest of the information in the bounce. It can simply count how many messages were recently sent to user@example.com, and how many bounces resulted, and if the proportion of bounced messages is too high, the address is removed from the list.|$|R

