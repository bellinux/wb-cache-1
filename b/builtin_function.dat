8|19|Public
50|$|Nullable {{resource}} types {{can also}} be used to implement optional resource arguments for functions. The isnull <b>builtin</b> <b>function</b> can be used to check if a resource is null.|$|E
50|$|This {{optimized}} function runs 200 {{times faster}} than the interpreted original function on a long NumPy array; and it is 30% faster than NumPy's <b>builtin</b> <b>function</b> (version 0.27.0).|$|E
5000|$|... the <b>builtin</b> <b>function</b> updater {{returning}} the updater of the doublet. Of course, updater was itself a doublet {{and could be}} used to change the updater component of a doublet.|$|E
5000|$|Perform <b>builtin</b> <b>functions</b> such as {{comparing}} strings, retrieving resources, all {{using an}} extensible builtins suite.|$|R
50|$|The {{standard}} RIF dialects are Core, BLD and PRD. These dialects {{depend on}} an extensive list of datatypes with <b>builtin</b> <b>functions</b> and predicates on those datatypes.|$|R
50|$|There were {{no special}} {{language}} constructs for creating arrays or record structures {{as they are}} commonly understood: instead, these were created {{with the aid of}} special <b>builtin</b> <b>functions,</b> e.g. newarray (for arrays that could contain any type of item) and newanyarray for creating restricted types of items.|$|R
5000|$|Microsoft Visual C {{compiler}} has <b>builtin</b> <b>function</b> [...] so the cpuid instruction may be embedded {{without using}} inline assembly, which is handy since the x86-64 version of MSVC {{does not allow}} inline assembly at all. The same program for MSVC would be: ...|$|E
5000|$|Some C compilers provide {{intrinsic}} {{functions that}} provide bit counting facilities. For example, GCC (since version 3.4 in April 2004) includes a <b>builtin</b> <b>function</b> [...] that {{will use a}} processor instruction if available or an efficient library implementation otherwise. [...] LLVM-GCC has included this function since version 1.5 in June 2005.|$|E
50|$|In {{compiler}} theory, {{an intrinsic}} function (or <b>builtin</b> <b>function)</b> {{is a function}} available {{for use in a}} given programming language whose implementation is handled specially by the compiler. Typically, it may substitute a sequence of automatically generated instructions for the original function call, similar to an inline function. Unlike an inline function though, the compiler has an intimate knowledge of the intrinsic function and can therefore better integrate it and optimize it for the situation.|$|E
5000|$|TREE-META Like META II also is scanerless having <b>builtin</b> lexer <b>functions.</b>|$|R
50|$|Values are {{computed}} by expressions written using {{a specific}} set of operations and <b>builtin</b> <b>functions,</b> most of which may be applied to aggregates as well as to single values, together with user-defined procedures which, likewise, may operate on and return aggregate as well as single values. The assignment statement assigns values to one or more variables.|$|R
40|$|MATLAB is {{a dynamic}} {{scientific}} language used by scientists, engineers and students worldwide. Although MATLAB is very suitable for rapid prototyping and development, MATLAB users often want to convert their final MATLAB programs to a static language such as FORTRAN, to integrate them into already existing programs of that language, to leverage the performance of powerful static compilers, or to ease the distribution of executables. This thesis presents an extensible object-oriented toolkit to help facilitate the generation of static programs from dynamic MATLAB programs. Our open source toolkit, called the MATLAB Tamer, targets a large subset of MATLAB. Given information about the entry point of the program, the MATLAB Tamer builds a complete callgraph, transforms every function into a reduced intermediate representation, and provides typing information to aid the generation of static code. In order to provide this functionality, we need to handle {{a large number of}} MATLAB <b>builtin</b> <b>functions.</b> Part of the Tamer framework is the builtin framework, an extensible toolkit which provides a principled approach to handle a large number of <b>builtin</b> <b>functions...</b>|$|R
40|$|I wrote a plot {{function}} 'mjplot' for {{the stable}} release of octave (tested on version 2. 0. 14). This function uses gnuplots inline data (implemented in gnuplot 3. 7) {{and do not}} use temporary files. 'mjplot' uses an own gnuplot process (not {{the same as the}} <b>builtin</b> <b>function</b> 'gplot' uses). Commands like 'gset grid' will not work, use 'mjgraw ("set grid") ' instead. I tried to make the function a little bit like the plot function in Matlab. Some switches and arguments don't make sense with gnuplot, but they are included anyway. I don't have access to Matlab so I don't know the exact behavior of their plot function. ...|$|E
40|$|Optical scan (OS) voting systems play an {{increasing}} {{role in the}} United States elections, with over 40 states deploying such systems. The AccuVote optical scanners (AV-OS) manufactured by ES&S account for over 20 % of all OS systems. OS systems typically use removable media (cards) to provide election-specific programming to the scanners and to convey precinct election results for central tabulation. Several reports document occurrences of AV-OS memory card failures, with up to 15 % of all cards failing in some cases. This paper reports on determining the causes of memory card failures that lead to complete loss of data from the card. An initial experimental analysis identified the battery discharge as {{a significant part of}} the problem. This finding led to the question of the dependability of the <b>builtin</b> <b>function</b> of the AccuVote OS system that issues a warning when the memory card contains a low-voltage battery. We identified the components used to implement this function in one type of AccuVote memory card. Using the specifications of the commodity batteries that are used in these cards, we determined the time interval from the instant when a battery warning is issued by the AccuVote to the point when the battery does not have enough voltage to retain data o...|$|E
5000|$|STELLA's {{approach}} to modeling systems shares some similarities with a precursor, the DYNAMO simulation language. DYNAMO explicitly defined [...] "stocks" [...] (reservoirs) and [...] "flows" [...] (inputs and outputs) as key variables in a system, a vocabulary which STELLA shares. Within STELLA, users {{are presented with}} a graphical user interface in which they may create graphical models of a system using four fundamentals: stocks, flows, converters, and connectors. Relationships between converters (which convey transforming variables) and other elements may be drawn with converters. Users are able to input values for stocks, flows, and converters (including {{with a variety of}} <b>builtin</b> <b>functions).</b> STELLA does not differentiate between external and intermediate variables within a system; all of them are represented with converters.|$|R
5000|$|The 'table' {{parameter}} {{requires a}} pseudo-randomly shuffled list of range 0..255. This may easily be generated by using python's <b>builtin</b> range <b>function,</b> and using random.shuffle to mutate it:from random import shuffleexample_table = range(0, 256)shuffle(example_table)def hash8(message, table): hash = len(message) % 256 for i in message: hash = table% 256 return hash ...|$|R
40|$|Abstract. How {{to query}} XML {{documents}} to extract and restructure {{the information is}} an important issue in XML research. Currently, XQuery based on XPath is the most promising standard of W 3 C. In this paper, we introduce a new set of syntax rules called XTree, which is a generalization of XPath. XTree has a tree structure, and a user can bind multiple variables in one XTree expression. It explicitly identifies list-valued variables, and defines some natural <b>builtin</b> <b>functions</b> to manipulate them. XTree expression can also be used in the result construction part of a query, to make it easy to read and comprehend. With these differences, XTree expressions are much more compact, and more convenient to write and understand than XPath expressions. We also give algorithms to convert queries based on XTree expressions to standard XQuery queries. ...|$|R
40|$|The SPARQL query {{language}} for RDF {{is the standard}} recommended by the W 3 C to query the Semantic Web. It enables to query and search RDF data by using query graph patterns and filters restricting the solutions produced by graph pattern matching according to the constraints they express. Constraints are either expressions defined according to the expression language specified in the W 3 C recommendation or function calls to SPARQL <b>builtin</b> <b>functions</b> or to extension functions. The use of extension functions in a SPARQL query, although compliant to the recommendation, limits the interoperability of the query. In this report we propose a lightweight extension of SPARQL to enable the definition of extension functions in the SPARQL filter language. We call it FunSPARQL, standing for Functional SPARQL, as it consists in providing SPARQL with a functional language for expressing constraints...|$|R
50|$|The Yoix {{language}} is not an object oriented language, but makes use of over 165 object types that provide access {{to most of the}} standard Java classes. Because the Yoix interpreter is built entirely using Java technology, it means that Yoix applications are cross-platform, GUI-capable and both network and thread friendly, yet Yoix developers find themselves insulated from the more complex and error-prone parts of coding the same functionality directly in Java. It does not use reflection to access Java functionality and thus adds value by not only simplifying access to that functionality, but also improving application reliability by coding through both Java glitches and complicated Java features one-time, behind-the-scenes. The Yoix language includes safe pointers, addressing, declarations, and global and local variables. In addition to supporting native user functions, users can add their own <b>builtin</b> <b>functions</b> written in Java.|$|R
50|$|InfluxDB has no {{external}} dependencies {{and provides}} an SQL-like language with <b>builtin</b> time-centric <b>functions</b> for querying a data {{structure composed of}} measurements, series, and points. Each point consists of several key-value pairs called the fieldset and a timestamp. When grouped together {{by a set of}} key-value pairs called the tagset, these define a series. Finally, series are grouped together by a string identifier to form a measurement.|$|R
5000|$|Command name {{completion}} is {{the completion}} of the name of a command. In most shells, a command can be a program in the command path (usually [...] ), a <b>builtin</b> command, a <b>function</b> or alias.|$|R
40|$|Python is an interpreted, object-oriented, {{high-level}} {{programming language}} with dynamic semantics. Its high-level built in data structures, combined with dynamic typing and dynamic binding, {{make it very}} attractive for rapid application development, {{as well as for}} use as a scripting or glue language to connect existing components together. Python’s simple, easy to learn syntax emphasizes readability and therefore reduces the cost of program maintenance. Python supports modules and packages, which encourages program modularity and code reuse. The Python interpreter and the extensive standard library are available in source or binary form without charge for all major platforms, and can be freely distributed. This reference manual describes the syntax and “core semantics ” of the language. It is terse, but attempts to be exact and complete. The semantics of non-essential built-in object types and of the <b>builtin</b> <b>functions</b> and modules are described in the Python Library Reference. For an informal introduction to the language, see the Python Tutorial. For C or C++ programmers, two additional manuals exist: Extending and Embedding the Python Interpreter describes the high-level picture of how to write a Python extension module, and the Python/C API Reference Manual describes the interfaces available to C/C+...|$|R
40|$|Abstract: The Python {{programming}} language supports object-oriented programming using {{a simple and}} elegant model that treats member variables, methods, and various metadata as instances of a single kind of ‘attribute’. While this allows a simple imple-mentation of an interpreter that supports advanced metaprogramming features, it can inhibit the performance of certain very common special cases. This paper deals with the optimization of code that loads and then calls object methods. We modify Python’s compiler to emit special bytecode sequences for load/call pairs on object attributes to avoid unnecessary allocation of method objects. This can result in considerable speedups, but may cause slowdowns at call sites that refer to <b>builtin</b> <b>functions</b> or other special attributes rather than methods. We therefore extend this static compile-time approach by a dynamic runtime quickening scheme that falls back to the generic load/call sequence at such call sites. The experimental evaluation of dynamic unboxing shows speedups of up to 8 % and rare slowdowns caused by as yet unresolved excessive instruction cache misses. A comparison with a common manual optimization of method calls in Python programs shows that our automatic method is not as powerful but more widely applicable. ...|$|R
40|$|In this thesis, {{the problem}} of finding an optimal {{training}} sequence for estimating a MIMO flat fading channel with spatially and temporally correlated Gaussian noise is considered. The methods analyzed tailor the training sequence not only according to the known statistical CSI {{but also to the}} specific purpose the channel estimate will fulfill. The task of obtaining the optimal training sequence is formulated in two different ways, either guaranteeing a specific performance or setting a maximum training power budget. Two different applications are considered, the ZF precoder and the MMSE equalizer. The performance of the training sequence obtained by minimizing a metric that is representative for this applications is compared to using the training sequence that minimizes the channel estimate mean square error. Additionally, since some approximations are required to solve the optimization problem when using the application-oriented metrics, the impact of these is analyzed. Two different approximations that allow convexification and lead to SDP formulations are considered for each problem. The two approximations and problem formulations are analyzed in terms of performance, training power and outage probability. The SDP formulations are then compared to the solutions provided by <b>builtin</b> <b>functions</b> in MATLAB that converge to a minimum in order to obtain information about how far from optimal the solutions obtained from the SDP are...|$|R
40|$|MATLAB is {{a dynamic}} {{scientific}} language used by scientists, engineers and students worldwide. Although MATLAB is very suitable for rapid prototyping and development, MAT-LAB users often want to convert their final MATLAB programs to a static language such as FORTRAN. This paper presents an extensible object-oriented toolkit for supporting the generation of static programs from dynamic MAT-LAB programs. Our open source toolkit, called the MATLAB Tamer, identifies a large tame subset of MATLAB, supports the generation of a specialized Tame IR for that subset, provides a principled approach to handling {{the large number of}} <b>builtin</b> MATLAB <b>functions,</b> and supports an extensible interprocedural value analysis for estimating MATLAB types and call graphs...|$|R
40|$|Computer aided {{engineering}} (CAE) {{and electronic}} design automation (EDA) software has become indispensable for engineers designing circuits for products {{operating in the}} RF, microwave and millimeter wave bands and beyond. While the increased dependence on these software packages has been {{and continues to be}} immensely beneficial to the user, some degree of creativity is yielded to the types of solutions provided by the EDA program and the way the program itself is structured. A certain way of approaching a problem is sometimes forced on the user by the program’s work flow model, menu structure, features and available tools. A great degree of flexibility and creative power is given to the user when some kind of user programmability or user defined functions are provided by the software. The LINC 2 Pro circuit simulator from Applied Computational Sciences (ACS), provides user variables and user defined functions for enhancing the flexibility and power of the software. There are two kinds of functions available to the user for customizing the LINC 2 simulator such that it produces the simulations and analyses that are most satisfying to the user. These can be broadly categorized as either input functions or output functions. In the LINC 2 simulator, output <b>functions</b> are generally <b>builtin</b> <b>functions</b> that provide new ways of processing and viewing simulation results. For example, an intrinsic function can be employed to find the loaded Q of a circuit or, more specifically, the exact frequency at which the maximum loaded Q is obtained- a useful feature in designing oscillator circuits for low phase noise. In a July 2008 MPD article on VCO design, this author demonstrated the use of LINC 2 intrinsi...|$|R
40|$|DEMOS is {{a package}} built {{on top of}} SIMULA 67, {{designed}} to provide building blocks that a modeller can tailor to his own personal needs, or {{which can be used}} as predefined units. Also, DEMOS provides <b>builtin</b> probability sampling <b>functions,</b> report generation, and tracing facilities. What in impresses most about DEMOS is the ease with which a modeller can combine the simple blocks into quite complex systems, with relatively few simplifying assumptions...|$|R

