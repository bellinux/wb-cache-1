63|60|Public
5|$|Team member Lucas Davis {{compiled}} {{the development}} tools and documentation for Anachronox and released them in August 2001. Four bug-fixing patches exist for Anachronox. Ion Storm {{created the first}} (1.01), which fixed the Windows 2000 <b>buffer</b> <b>overrun</b> crash and implemented other improvements such as taxi-cabs between distant points and enhanced save game functionality. Ion Storm released the first patch (1.01) on July 2, 2001. Joey Liaw set up a GeoCities website for reporting bugs and technical information after the game's release, and worked on a new patch in his spare time. The second patch (1.02, or build 44) was released in May 2003 and overhauls the save-game system and provides other important stability fixes. The third and fourth patches—1.02 (build 45), released September 2003, and 1.02 (build 46), released April 2004—are fan-made unofficial patches and fix {{most of the remaining}} bugs. Fans have translated the game into German and released a conversion patch. Level designer Rich Carlson released a scrapped secret level for Anachronox in February 2004 after finding it on an old floppy disk.|$|E
25|$|In {{computer}} security and programming, a buffer overflow, or <b>buffer</b> <b>overrun,</b> is an anomaly where a program, while writing data to a buffer, overruns the buffer's boundary and overwrites adjacent memory locations.|$|E
25|$|In addition, Internet Explorer 9 is {{compiled}} {{with the}} new C++ compiler provided with Visual Studio 2010. This compiler includes a feature known as Enhanced GS, also known as Stack <b>Buffer</b> <b>Overrun</b> Detection, which helps prevent stack buffer overruns by detecting stack corruption and avoiding execution if such corruption is encountered.|$|E
40|$|Despite {{previous}} {{efforts in}} auditing software manually and automatically, <b>buffer</b> <b>overruns</b> {{are still being}} discovered in programs in use. A dynamic bounds checker detects <b>buffer</b> <b>overruns</b> in erroneous software before it occurs and thereby prevents attacks from corrupting {{the integrity of the}} system. Dynamic buffe...|$|R
5000|$|Prevention of code-level {{security}} breaches (<b>buffer</b> <b>overruns</b> or array index overflows, for example) ...|$|R
40|$|This article {{describes}} three powerful general-purpose families of exploits for buffer overruns: arc injection, pointer subterfuge, and heap smashing. These new techniques {{go beyond the}} traditional “stack smashing ” attack and invalidate traditional assumptions about <b>buffer</b> <b>overruns.</b> Security vulnerabilities related to <b>buffer</b> <b>overruns</b> account for the largest share of CERT advisories, as well as high-profile worms—from the original Internet Worm in 1987 through Blaster’s appearance in 2003. When malicious crackers discover a vulnerability, they devise exploits that {{take advantage of the}} vulnerability to attack a system. The traditional approach to exploiting <b>buffer</b> <b>overruns</b> is stack smashing: modifying a return address saved on the stack (the region of memory used for parameters...|$|R
25|$|Although any {{programming}} language {{can be used}} on the server to process a form's data, the most commonly used languages are scripting languages, which tend to have stronger string handling functionality than {{programming language}}s such as C, and also have automatic memory management which helps to prevent <b>buffer</b> <b>overrun</b> attacks.|$|E
25|$|After {{a couple}} of preview Windows releases, Apple {{released}} 7.0.2 as the first stable release on September 7, 2005 for Windows 2000 and Windows XP. Version 7.0.4, released on January 10, 2006 was the first universal binary version. But it suffered numerous bugs, including a <b>buffer</b> <b>overrun,</b> which is more problematic to most users.|$|E
25|$|Note {{that the}} above code {{is not free}} from {{problems}} either; while a <b>buffer</b> <b>overrun</b> has been prevented this time, the strncpy library function does not null-terminate the destination buffer if the source string's length is {{greater than or equal}} to the size of the buffer (the third argument passed to the function), therefore A is, in this case, not null-terminated and cannot be treated as a valid C-style string.|$|E
5000|$|... x86-64 also {{introduced}} the NX bit, which offers some protection against security bugs caused by <b>buffer</b> <b>overruns.</b>|$|R
5000|$|Address space layout {{randomization}} (to make {{it harder}} for <b>buffer</b> <b>overruns</b> to execute privileged instructions at known addresses in memory) ...|$|R
40|$|Bounds {{violations}} or <b>buffer</b> <b>overruns</b> {{have historically}} been {{a major source of}} defects in software systems, making bounds checking a key component in practical automatic verification methods. With the advent of the Internet, <b>buffer</b> <b>overruns</b> have been exploited by attackers to break into secure systems as well. Many security violations ranging from the 1988 Internet worm incident to the AnalogX Proxy server vulnerability have been attributed to <b>buffer</b> <b>overruns.</b> Programs written in the C language, which comprise most of the systems software available today, are particularly vulnerable {{because of the lack of}} array bounds checking in the C compiler, presence of pointers that can be used to write anywhere in memory, and the weak type system of the C language. Many methods have been proposed to detect these errors. Runtime methods that detect <b>buffer</b> <b>overruns</b> suffer from significant overhead and incomplete coverage, while compile time methods could suffer from low accuracy and poor scalability. In this thesis, we propose a new technique for bounds checking based on data abstraction that is more accurate, more scalable, and suffers from no runtime overhead. Enhancements have been made to C Wolf, a suite of model generation tools, to handle buffer overflow analysis. Case studies on web 2 c, a publicly available software package, pico server, an open source web server, and on the wu-ftpd server are presented to demonstrate the practicality of the technique...|$|R
25|$|JavaScript {{provides}} an interface {{to a wide}} range of browser capabilities, some of which may have flaws such as buffer overflows. These flaws can allow attackers to write scripts that would run any code they wish on the user's system. This code is not by any means limited to another JavaScript application. For example, a <b>buffer</b> <b>overrun</b> exploit can allow an attacker to gain access to the operating system's API with superuser privileges.|$|E
50|$|Object-code <b>Buffer</b> <b>Overrun</b> Evaluator (OBOE) is a {{security}} or programming tool by R. Banfi, D. Bruschi, and E. Rosti for the automatic detection of <b>buffer</b> <b>overrun</b> vulnerabilities in object code. OBOE {{can be applied}} to operating system components as well as ordinary application programs. It was designed for the system administrator to identify vulnerable programs before they are exploited. Being automatic, OBOE can be run as a background process for the analysis of all potentially insecure programs installed on a Unix system. It runs on HP-UX, Linux, and Solaris.|$|E
50|$|In {{computer}} security and programming, a buffer overflow, or <b>buffer</b> <b>overrun,</b> is an anomaly where a program, while writing data to a buffer, overruns the buffer's boundary and overwrites adjacent memory locations.|$|E
50|$|In {{computer}} security and programming, a buffer over-read is an anomaly where a program, while reading {{data from a}} <b>buffer,</b> <b>overruns</b> the <b>buffer's</b> boundary and reads (or tries to read) adjacent memory. This is a special case of violation of memory safety.|$|R
5000|$|Simple DNS Plus {{is based}} on the Microsoft [...]NET Framework 2.0 and is 100% managed code, {{protecting}} it from common security issues such as <b>buffer</b> <b>overruns,</b> and making it run natively on both 32 bit and 64 bit CPUs and Windows versions, including Windows Vista.|$|R
40|$|A {{great deal}} of {{research}} {{in the last several years}} has focused on securing sever-side software systems, which are a common target to <b>buffer</b> <b>overruns,</b> format string violations, and other similar types of attacks. A variety of techniques to protect server-side software have been suggested, ranging from hardware-leve...|$|R
50|$|When both memory {{tracking}} and API validation are enabled, it becomes possible to detect {{many kinds of}} array and <b>buffer</b> <b>overrun</b> conditions. Compiler instrumentation enhances this ability. This is the feature for which the product was originally named.|$|E
5000|$|Running {{applications}} with {{least privilege}} (for example by running Internet Explorer with the Administrator SID disabled {{in the process}} token) {{in order to reduce}} the ability of <b>buffer</b> <b>overrun</b> exploits to abuse the privileges of an elevated user.|$|E
50|$|The trinoo or trin00 {{is a set}} of {{computer}} programs to conduct a DDoS attack. It is believed that trinoo networks have been set up on thousands of systems on the Internet that have been compromised by remote <b>buffer</b> <b>overrun</b> exploits.|$|E
40|$|Introduction to {{security}} issues arising primarily from computer networks. Topics include node and service authentication, address spoofing, hijacking, SYN floods, smurfing, sniffing, routing tricks, and privacy of data en route. <b>Buffer</b> <b>overruns</b> and other exploitation of software development errors. Hardening of operating systems. Intrusion detection. Firewalls. Ethics. Prerequisites...|$|R
5000|$|... strsafe.h is a {{non-standard}} C header file {{provided with}} the Windows SDK starting with Windows XP Service Pack 2 that provides safer buffer handling than that which {{is provided by the}} standard C string functions, which are widely known to have security issues involving <b>buffer</b> <b>overruns</b> when not used correctly.|$|R
40|$|Advanced static-analysis {{tools for}} finding {{programming}} errors {{have become very}} popular recently. These detect many common generic programming errors such as null pointer dereferences, <b>buffer</b> <b>overruns,</b> and race conditions. Most major static-analysis tools also provide an interface {{that can be used}} to find domain-specific errors. This paper describes how custom domain-specific checkers can be used to improve software quality in complex embedded systems. 1...|$|R
5000|$|Flow control: The rate of data {{transmission}} between two nodes must sometimes be managed {{to prevent a}} fast sender from transmitting more data than can be supported by the receiving data buffer, causing a <b>buffer</b> <b>overrun.</b> This {{can also be used}} to improve efficiency by reducing buffer underrun.|$|E
50|$|Although any {{programming}} language {{can be used}} on the server to process a form's data, the most commonly used languages are scripting languages, which tend to have stronger string handling functionality than {{programming language}}s such as C, and also have automatic memory management which helps to prevent <b>buffer</b> <b>overrun</b> attacks.|$|E
50|$|The VBA {{emulator}} {{is vulnerable}} to arbitrary code execution through a feature that allows importation of cheat codes from files, which isn't protected against <b>buffer</b> <b>overrun.</b> By importing a malicious XPC file (usually containing a list of GameShark cheat codes), VBA and VBA-rr can execute arbitrary code contained within the file.|$|E
40|$|This course {{introduces}} security hardening of {{a single}} system, and how to protect it when connected to a network. It explains how malware can compromise security and privacy from the moment a machine is powered on until shut down. Topics include Privilege Escalation, <b>Buffer</b> <b>Overruns,</b> Network Packet Mangling, Session Hijacking, Firewalls, and ethics. Lab work uses tools such as nmap and Kali (BackTrack) Linux. Prerequisites: CEG 435...|$|R
50|$|PREFast for Drivers (PFD) {{performs}} rather shallow {{analysis of}} driver operations. PFD can check for <b>buffer</b> <b>overruns</b> and other common programming errors likewise {{a number of}} driver specific problems. Because its scope of operation is within a single function, PFD's run time is much shorter than SDV. Therefore, PFD can be used throughout the driver development process. PREFast scans each function as an isolated unit. It does not do inter-procedural analysis.|$|R
40|$|Detecting <b>buffer</b> <b>overruns</b> from {{a source}} code {{is one of the}} most common and yet {{challenging}} tasks in program analysis. Current approaches have mainly relied on rigid rules and handcrafted features devised by a few experts, limiting themselves in terms of flexible applicability and robustness due to diverse bug patterns and characteristics existing in sophisticated real-world software programs. In this paper, we propose a novel, data-driven approach that is completely end-to-end without requiring any hand-crafted features, thus free from any program language-specific structural limitations. In particular, our approach leverages a recently proposed neural network model called memory networks that have shown the state-of-the-art performances mainly in question-answering tasks. Our experimental results using source codes demonstrate that our proposed model is capable of accurately detecting simple <b>buffer</b> <b>overruns.</b> We also present in-depth analyses on how a memory network can learn to understand the semantics in programming languages solely from raw source codes, such as tracing variables of interest, identifying numerical values, and performing their quantitative comparisons. Comment: 6 pages + 1 appendix, 5 figure...|$|R
50|$|In addition, Internet Explorer 9 is {{compiled}} {{with the}} new C++ compiler provided with Visual Studio 2010. This compiler includes a feature known as Enhanced GS, also known as Stack <b>Buffer</b> <b>Overrun</b> Detection, which helps prevent stack buffer overruns by detecting stack corruption and avoiding execution if such corruption is encountered.|$|E
5000|$|Return-oriented {{programming}} is an advanced {{version of a}} stack smashing attack. Generally, these types of attacks arise when an adversary manipulates the call stack {{by taking advantage of}} a bug in the program, often a <b>buffer</b> <b>overrun.</b> In a <b>buffer</b> <b>overrun,</b> a function that does not perform proper bounds checking before storing user-provided data into memory will accept more input data than it can store properly. If the data is being written onto the stack, the excess data may overflow the space allocated to the function's variables (e.g., [...] "locals" [...] in the stack diagram to the right) and overwrite the return address. This address will later be used by the function to redirect control flow back to the caller. If it has been overwritten, control flow will be diverted to the location specified by the new return address.|$|E
50|$|After {{a couple}} of preview Windows releases, Apple {{released}} 7.0.2 as the first stable release on September 7, 2005 for Windows 2000 and Windows XP. Version 7.0.4, released on January 10, 2006 was the first universal binary version. But it suffered numerous bugs, including a <b>buffer</b> <b>overrun,</b> which is more problematic to most users.|$|E
5000|$|As of Android Jelly Bean MR1 (4.2), bionic {{supports}} a growing subset of glibc's , {{which is a}} feature where unsafe string and memory functions (such as [...] and [...] ) include checks for <b>buffer</b> <b>overruns</b> when <b>buffer</b> sizes can be determined at compile time. This feature works better with gcc than with Clang, and—because it relies on runtime support from libc—limits portability to older Android releases. The platform itself is built with [...] enabled.|$|R
5000|$|Since arrays {{are always}} {{accessed}} (in effect) via pointers, array accesses are typically not checked against the underlying array size, although some compilers may provide bounds checking as an option. [...] Array bounds violations are therefore possible and rather common in carelessly written code, {{and can lead}} to various repercussions, including illegal memory accesses, corruption of data, <b>buffer</b> <b>overruns,</b> and run-time exceptions. If bounds checking is desired, it must be done manually.|$|R
50|$|In computing, in {{particular}} compiler construction, value range analysis {{is a type}} of data flow analysis that tracks the range (interval) of values that a numeric variable can take on at each point of a program's execution.The resulting information can be used in optimizations such as redundancy elimination, dead code elimination, instruction selection, etc., but {{can also be used to}} improve the safety of programs, e.g. in the detection of <b>buffer</b> <b>overruns.</b> Techniques for value range analysis typically use symbolic analysis extensively.|$|R
