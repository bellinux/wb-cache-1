65|1317|Public
50|$|One of the {{cornerstone}} Conflict-Driven Clause Learning SAT solver algorithms is the DPLL algorithm. The algorithm works by iteratively assigning free variables, {{and when the}} algorithm encounters a bad assignment, then it backtracks to a previous iteration and chooses a different assignment of variables. It relies on a Branching Heuristic to pick the next free variable assignment; the <b>branching</b> <b>algorithm</b> effectively makes choosing the variable assignment into a decision tree. Different implementations of this heuristic produce markedly different decision trees, and thus have {{significant effect on the}} efficiency of the solver.|$|E
5000|$|Saturation {{arithmetic}} for integers {{has also}} been implemented in software {{for a number of}} programming languages including C, C++, and Eiffel. This helps programmers anticipate and understand the effects of overflow better. On the other hand, saturation is challenging to implement efficiently in software on a machine with only modular arithmetic operations, since simple implementations require branches that create huge pipeline delays. However, it is possible to implement saturating addition and subtraction in software without branches, using only modular arithmetic and bitwise logical operations that are available on all modern CPUs and their predecessors, including all x86 CPUs (back to the original Intel 8086) and some popular 8-bit CPUs (some of which, such as the Zilog Z80, are still in production). (However, on simple 8-bit and 16-bit CPUs, a <b>branching</b> <b>algorithm</b> might actually be faster, since there are no pipelines to stall and each instruction always takes multiple clock cycles.) ...|$|E
3000|$|A: We {{propose a}} <b>branching</b> <b>{{algorithm}}</b> in Algorithm 1. The intuition behind this algorithm is that, if a data packet p [...]...|$|E
40|$|Abstract In {{this paper}} we present <b>branching</b> <b>algorithms</b> for {{infinite}} classes of prob-lems. The novelty {{in the design}} and analysis of our <b>branching</b> <b>algorithms</b> {{lies in the fact that}} the weights are redistributed over the graph by the algorithms. Our partic-ular setting to make this idea work is a combination of a branching approach with a recharging mechanism. We call it Branch & Recharge. To demonstrate this approach we consider a generalized domination problem...|$|R
40|$|Various {{kinds of}} scored {{dependency}} graphs are proposed as packed shared data structures {{in combination with}} optimum dependency tree search algorithms. This paper classifies the scored dependency graphs and discusses the specific features of the “Dependency Forest ” (DF) which is the packed shared data structure adopted in the “Preference Dependency Grammar” (PDG), and proposes the “Graph <b>Branch</b> <b>Algorithm</b> ” for computing the optimum dependency tree from a DF. This paper also reports the experiment showing the computational amount and behavior of the graph <b>branch</b> <b>algorithm.</b> ...|$|R
40|$|AbstractTwo-dimensional (2 D) phase unwrapping {{is a key}} data-processing step of {{interferometric}} {{synthetic aperture}} radar (InSAR). After analyzing the classical <b>branch</b> cut <b>algorithm,</b> the method of first-child, next-sibling is adopted to express the residues connective relationship, and a dendriform <b>branch</b> cut <b>algorithm</b> is proposed which can remove the ‘dead area’ existing in the classical <b>branch</b> cut <b>algorithm.</b> A <b>branch</b> cut regrowing strategy is proposed to improve the simple dendriform <b>branch</b> cut <b>algorithm,</b> which keeps the high efficiency of the original algorithm and solves the discontinuous problem caused by the long branch cuts connection. The experiment result using real InSAR data indicates that the proposed method is effective, and greatly improves the phase unwrapping result...|$|R
40|$|AbstractWe {{deal with}} the problem of testing {{equivalence}} of two LL(k) grammars. The problem had been shown to be decidable for general k by Rosenkrantz and Stearns [2], who solved it by reduction into an equivalence problem for special DPDA's. In a paper by Korenjak and Hopcroft [1] the equivalence problem for LL(1) grammars is solved by a <b>branching</b> <b>algorithm</b> operating directly on the grammars. Our work presents a direct <b>branching</b> <b>algorithm</b> for the general LL(k) grammars equivalence problem...|$|E
40|$|Traditional methods {{model the}} billion-dollar airline crew {{scheduling}} problem as deterministic {{and do not}} explicitly include information on potential disruptions. Instead of modelling the crew scheduling problem as deterministic, we consider a stochastic crew scheduling model and devise a solution method-ology for integrating disruptions {{in the evaluation of}} crew schedules. The goal is to use that information to find robust solutions that better withstand disruptions. Such an approach is important because we can proactively consider the effects of certain scheduling decisions. By identifying more robust schedules, cascading delay effects will be minimized. In this paper we describe our stochastic integer programming model for the airline crew scheduling problem and develop a <b>branching</b> <b>algorithm</b> to identify expensive flight connections and find alternative solutions. The <b>branching</b> <b>algorithm</b> uses the structure of the prob-lem to branch simultaneously on multiple variables without invalidating the optimality of the algorithm. We present computational results demonstrating the effectiveness of our <b>branching</b> <b>algorithm.</b> ...|$|E
40|$|Abstract. Given an {{undirected graph}} G with n nodes, the Maximum Leaf Spanning Tree problem asks {{to find a}} {{spanning}} tree of G with as many leaves as possible. When parameterized {{in the number of}} leaves k, this problem can be solved in timeO(4 kpoly(n)) using a simple <b>branching</b> <b>algorithm</b> introduced by a subset of the authors [13]. Daligault, Gutin, Kim, and Yeo [6] improved this <b>branching</b> <b>algorithm</b> and obtained a running time of O(3. 72 kpoly(n)). In this paper, we study the problem from an exact exponential time point of view, where it is equivalent to the Connected Dominating Set problem. For this problem Fomin, Grandoni, and Kratsch showed how to break the Ω(2 n) barrier and proposed an O(1. 9407 n) time algorithm [10]. Based on some properties of [6] and [13], we establish a <b>branching</b> <b>algorithm</b> whose running time of O(1. 8966 n) has been analyzed using the Measure-and-Conquer tech-nique. Finally we provide a lower bound of Ω(1. 4422 n) for the worst case running time of our algorithm. ...|$|E
40|$|Method of {{computation}} acceleration in data-flow {{systems for}} <b>branching</b> <b>algorithms</b> realization is proposed. It {{is based on}} dynamic parallel instruction flows compilation. There is shown a possibility to identify actor and data words during compilation {{on the base of}} task graph for data-flow systems with several instruction formation units. ????????? ????? ????????? ?????????? ? ????????, ??????????? ??????? ??????, ??? ?????????? ?????????? ? ???????????, ?????????? ?? ???????????? ???????????? ???????????? ??????? ??????. ???????? ??????????? ????????????? ???? ??????? ? ?????? ?? ?????? ????? ?????? ? ???????? ?????????? ??? ????????? ?????? ? ??????????? ??????? ???????????? ??????...|$|R
40|$|In {{this paper}} we discuss an {{alternative}} to the existing <b>branch</b> prediction <b>algorithms,</b> called pre-computed <b>branch</b> prediction. This method does not actually involve prediction, as the branch's outcome is calculated as soon as its last operand is known. We attempted to validate the claim that pre-computed branches give a higher rate of performance than the existing branch prediction methods, by implementing the pre-computed <b>branch</b> <b>algorithm</b> in SimpleScalar. After analyzing our data, we concluded that one does get a higher hit rate and IPC if pre-computed branches are used, which results in increased performance. 1...|$|R
40|$|We {{investigate}} {{the gap between}} theory and practice for exact <b>branching</b> <b>algorithms.</b> In theory, branch-and-reduce algorithms currently have the best time complexity for numerous important problems. On the other hand, in practice, state-of-the-art methods are based on different approaches, and the empirical efficiency of such theoretical algorithms have seldom been investigated probably because they are seemingly inefficient because of the plethora of complex reduction rules. In this paper, we design a branch-and-reduce algorithm for the vertex cover problem using the techniques developed for theoretical algorithms and compare its practical performance with other state-of-the-art empirical methods. The results indicate that branch-and-reduce algorithms are actually quite practical and competitive with other state-of-the-art approaches for several kinds of instances, thus showing the practical impact of theoretical research on <b>branching</b> <b>algorithms.</b> Comment: To appear in ALENEX 201...|$|R
40|$|A new direct {{algorithm}} is presented for checking equivalence of some classes of deterministic pushdown automata (dpda's), after Korenjak and Hopcroft's <b>branching</b> <b>algorithm.</b> It {{is not only}} powerful enough to be applicable to two dpda's accepting by empty stack, {{one of which is}} real-time, but also simple even for dpda's in lower subclasses. This is the first time the <b>branching</b> <b>algorithm</b> has been used to give such a general decision procedure without ever “mixing” the two languages in question. In other words, it deals with only the equivalence equation whose left-hand side consists of a pure reachable configuration of one dpda and whose right-hand side that of the other...|$|E
40|$|AbstractA new direct <b>branching</b> <b>algorithm</b> is {{presented}} for checking the equivalence of deterministic pushdown transducers, one of whose associated deterministic pushdown automata (DPDAs) is real-time strict. It is a straightforward {{extension of the}} corresponding algorithm for DPDAs (Tomita, 1982), and then proves the general applicability of our approach...|$|E
3000|$|A {{solution}} to MKEP through exhaustive search has been proposed, it follows {{the structure of}} a <b>branching</b> <b>algorithm</b> [32]. Their algorithm, as well as the one we propose in our methods section initially obtain the maximum k-core. The following greedy algorithm obtains the maximum k-core in polynomial time [13]: [...]...|$|E
40|$|Abstract We {{present a}} <b>branch</b> and bound <b>algorithm</b> {{for the global}} {{optimization}} of a twice differentiable nonconvex objective function with a Lipschitz continuous Hessian over a com-pact, convex set. The algorithm is based on applying cubic regularisation techniques to the objective function within an overlapping <b>branch</b> and bound <b>algorithm</b> for convex constrained global optimization. Unlike other <b>branch</b> and bound <b>algorithms,</b> lower bounds are obtained via nonconvex underestimators of the function. For a numerical example, we apply the pro-posed <b>branch</b> and bound <b>algorithm</b> to radial basis function approximations...|$|R
40|$|We {{present a}} <b>branch</b> and bound <b>algorithm</b> {{for the global}} {{optimization}} of a twice differentiable nonconvex objective function with a Lipschitz continuous Hessian over a compact, convex set. The algorithm is based on applying cubic regularisation techniques to the objective function within an overlapping <b>branch</b> and bound <b>algorithm</b> for convex constrained global optimization. Unlike other <b>branch</b> and bound <b>algorithms,</b> lower bounds are obtained via nonconvex underestimators of the function. For a numerical example, we apply the proposed <b>branch</b> and bound <b>algorithm</b> to radial basis function approximations. © 2012 Springer Science+Business Media, LLC...|$|R
40|$|We {{provide an}} {{introduction}} to the design and analysis of moder-ately exponential-time <b>branching</b> <b>algorithms</b> via the study of a col-lection of such algorithms among them algorithms for Maximum In-dependent Set, SAT and 3 -SAT. The tools for simple running time analysis are presented. The limits of such an analysis including lower bounds for the worst-case running time of some particular branchin...|$|R
40|$|We {{investigate}} the parameterized complexity of Vertex Cover parameterized by {{the difference between}} the size of the optimal solution and the value of the linear programming (LP) relaxation of the problem. By carefully analyzing the change in the LP value in the branching steps, we argue that combining previously known preprocessing rules with the most straightforward <b>branching</b> <b>algorithm</b> yields an O∗((2. 618) k) algorithm for the problem. Here k is the excess of the vertex cover size over the LP optimum, and we write O∗(f(k)) for a time complexity of the form O(f(k) nO(1)), where f(k) grows exponentially with k. We proceed to show that a more sophisticated <b>branching</b> <b>algorithm</b> achieves a runtime of O∗(2. 3146 k). Following this, using known and new reductions, we give O∗(2. 3146 k) algorithms for the parameterized versions of Above Guarantee Vertex Cover, Odd Cycl...|$|E
40|$|In this paper, the {{behaviour}} of {{an existing}} pronominal anaphora resolution system is modified so that different types of pronoun are treated in different ways. Weights are derived using a genetic algorithm for the outcomes of tests applied by this <b>branching</b> <b>algorithm.</b> Detailed evaluation and error analysis is undertaken. Proposals for future research are put forward. ...|$|E
40|$|Given a graph on n {{vertices}} and {{an integer}} k, the feedback vertex set problem asks for the deletion of at most k vertices {{to make the}} graph acyclic. We show that a greedy <b>branching</b> <b>algorithm,</b> which always branches on an undecided vertex with the largest degree, runs in single-exponential time, i. e., O(c^k· n^ 2) for some constant c...|$|E
40|$|Recent {{experience}} suggests that <b>branching</b> <b>algorithms</b> {{are among the}} most attractive for solving propositional satisfiability problems. A key factor in their success is the rule they use to decide on which variable to branch next. We attempt to explain and improve the performance of branching rules with an empirical model-building approach. One model is based on the rationale given for the Jeroslow-Wang rule, variations of which have performed well in recent work. The model is refuted by carefully designed computational experiments. A second model explains the success of the Jeroslow-Wang rule, makes other predictions confirmed by experiment, and leads to the design of branching rules that are clearly superior to Jeroslow-Wang. Recent computational studies [2, 7, 13, 21] suggest that <b>branching</b> <b>algorithms</b> {{are among the most}} attractive for solving the propositional satisfiability problem. An important factor in their success [...] -perhaps the dominant factor [...] -is the branching rule they use [ [...] ...|$|R
5000|$|Sophisticated <b>branch</b> {{prediction}} <b>algorithm</b> {{that significantly}} increases performance and reduces energy from misprediction and speculation ...|$|R
40|$|Abstract- in {{this paper}} we propose a new {{heuristic}} function, for <b>Branch</b> & Bound <b>algorithm.</b> By this function we can increase the efficiency of <b>Branch</b> & bound <b>algorithm.</b> Divisible loads represent computations which can be arbitrarily divided into parts and performed independently parallel. The scheduling problem consists in distributing the load in a heterogeneous system taking into account communication and computation times, so that the whole processing time is as short as possible. Since our scheduling problem is computationally hard, we propose a <b>Branch</b> & Bound <b>algorithm.</b> By simulating and comparing results, it is observed which this result produces better answers than other methods, it means that, <b>branch</b> & bound <b>algorithm</b> have less total average of relative error percentage in the variety Heuristic functions. Keywords- divisible load scheduling; Heterogeneous System; <b>Branch</b> & bound <b>algorithm.</b> I...|$|R
40|$|In [5] we {{describe}} a branching particle algorithm which produces a particle approximation {{to the solution}} of the Zakai equation and find an upper bound for the rate of convergence of the mean square error. In this paper, the exact rate of convergence of the mean square error is deduced. Also, several variations of <b>branching</b> <b>algorithm</b> with better rates of convergence are introduced...|$|E
40|$|International audienceIn this paper, we are {{interested}} in computing the number of edge colourings and total colourings of a connected graph. We prove that the maximum number of k-edge-colourings of a connected k-regular graph on n vertices is k·((k- 1) !) ^n/ 2. Our proof is constructive and leads to a <b>branching</b> <b>algorithm</b> enumerating all the k-edge-colourings of a connected k-regular graph in time O^*(((k- 1) !) ^n/ 2) and polynomial space. In particular, we obtain a algorithm to enumerate all the 3 -edge-colourings of a connected cubic graph in time O^*(2 ^n/ 2) =O^*(1. 4143 ^n) and polynomial space. This improves the running time of O^*(1. 5423 ^n) of the algorithm due to Golovach et al. GKC 10. We also show that the number of 4 -total-colourings of a connected cubic graph is at most 3 · 2 ^ 3 n/ 2. Again, our proof yields a <b>branching</b> <b>algorithm</b> to enumerate all the 4 -total-colourings of a connected cubic graph...|$|E
40|$|Abstract. Given an {{undirected graph}} with n nodes, the Maximum Leaf Spanning Tree {{problem is to}} find a {{spanning}} tree with as many leaves as possible. When parameterized in the number of leaves k, this problem can be solved in time O(4 kpoly(n)) using a simple <b>branching</b> <b>algorithm</b> introduced by a subset of the authors [12]. Daligault, Gutin, Kim, and Yeo [6] improved the branching and obtained a running time of O(3. 72 kpoly(n)). In this paper, we study the problem from an exponen-tial time viewpoint, where it is equivalent to the Connected Dominat-ing Set problem. Here, Fomin, Grandoni, and Kratsch showed how to break the Ω(2 n) barrier and proposed an O(1. 9407 n) -time algorithm [10]. In light of some useful properties of [12] and [6], we present a <b>branching</b> <b>algorithm</b> whose running time of O(1. 8966 n) has been analyzed using the Measure-and-Conquer technique. Finally we provide a lower bound of Ω(1. 4422 n) for the worst case running time of our algorithm. ...|$|E
40|$|International audienceIn {{this paper}} we present <b>branching</b> <b>algorithms</b> for {{infinite}} classes of problems. The novelty {{in the design}} and analysis of our <b>branching</b> <b>algorithms</b> {{lies in the fact that}} the weights are redistributed over the graph by the algorithms. Our particular setting to make this idea work is a combination of a branching approach with a recharging mechanism. We call it Branch & Recharge. To demonstrate this approach we consider a generalized domination problem. Let σ and ϱ be two nonempty sets of nonnegative integers. A vertex subset S⊆ V of an undirected graph G=(V(G),E(G)) is called a (σ,ϱ) -dominating set of G if |N(v) ∩ S| ∈σ for all v∈ S and |N(v) ∩ S| ∈ϱ for all v∈ V∖ S. This notion generalizes many domination-type graph invariants. We present <b>Branch</b> & Recharge <b>algorithms</b> enumerating all (σ,ϱ) -dominating sets of an input graph G in time O^*(c^n) for some c< 2, if σ is successor-free, i. e., it does not contain two consecutive integers, and either both σ and ϱ are finite, or one of them is finite and σ∩ϱ = ∅. Our algorithm implies a non trivial upper bound of O^*(c^n) on the number of (σ,ϱ) -dominating sets in an n-vertex graph under the above conditions on σ and ϱ...|$|R
40|$|We study {{links between}} approximation, {{exponential}} time computation and fixed parameter tractability. In particular, {{rather than focusing}} on one particular optimization problem, we tackle the question of finding sufficient conditions for a problem to admit "good" approximation algorithms in exponential time. In particular, we focus on the existence of "approximation schemata" (ratios 1 ± ε for arbitrarily small ε) and we exhibit conditions under which a technique of devising approximate <b>branching</b> <b>algorithms</b> reaches interesting results...|$|R
40|$|For most <b>branching</b> <b>algorithms</b> in Boolean logic "branching" means "variable-wise branching". We {{present the}} {{apparently}} novel technique of clause-wise branching, {{which is used}} to solve the ALLSAT problem for arbitrary Boolean functions in CNF format. Specifically, it converts a CNF into an orthogonal DNF, i. e. into an exclusive sum of products. Our method is enhanced by two ingredients: The use of a good SAT-solver and wildcards beyond the common don't-care symbol. Comment: 27 pages, 3 figures, 10 Table...|$|R
40|$|In this paper, we are {{interested}} in computing the number of edge colourings and total colourings of a graph. We prove that the maximum number of k-edge-colourings of a k-regular graph on n vertices is k·(k- 1 !) ^n/ 2. Our proof is constructible and leads to a <b>branching</b> <b>algorithm</b> enumerating all the k-edge-colourings of a k-regular graph using a time O^*((k- 1 !) ^n/ 2) and polynomial space. In particular, we obtain a algorithm on time O^*(2 ^n/ 2) =O^*(1. 4143 ^n) and polynomial space to enumerate all the 3 -edge colourings of a cubic graph, improving the running time of O^*(1. 5423 ^n) of the algorithm due to Golovach et al. GKC 10. We also show that the number of 4 -total-colourings of a connected cubic graph is at most 3. 2 ^ 3 n/ 2. Again, our proof yields a <b>branching</b> <b>algorithm</b> to enumerate all the 4 -total-colourings of a connected cubic graph...|$|E
40|$|Paper {{presented}} at the Proceedings of RRNLP- 2002, Alicante, Spain. In this paper, the behaviour of an existing pronominal anaphora resolution system is modified so that different types of pronoun are treated in different ways. Weights are derived using a genetic algorithm for the outcomes of tests applied by this <b>branching</b> <b>algorithm.</b> Detailed evaluation and error analysis is undertaken. Proposals for future research are put forward...|$|E
40|$|AbstractGiven an {{undirected graph}} with n vertices, the Maximum Leaf Spanning Tree problem {{is to find}} a {{spanning}} tree with as many leaves as possible. When parameterized in the number of leaves k, this problem can be solved in time O(4 kpoly(n)) using a simple <b>branching</b> <b>algorithm</b> introduced by a subset of the authors (Kneis et al. 2008  [16]). Daligault et al. (2010) [6] improved the branching and obtained a running time of O(3. 72 kpoly(n)). In this paper, we study the problem from an exponential time viewpoint, where it is equivalent to the Connected Dominating Set problem. Here, Fomin, Grandoni, and Kratsch showed how to break the Ω(2 n) barrier and proposed an O(1. 9407 n) -time algorithm (Fomin et al. 2008 [11]). Based on some useful properties of Kneis et al. (2008)  [16] and Daligault et al. (2010)  [6], we present a <b>branching</b> <b>algorithm</b> whose running time of O(1. 8966 n) has been analyzed using the Measure-and-Conquer technique. Finally, we provide a lower bound of Ω(1. 4422 n) for the worst case running time of our algorithm...|$|E
40|$|Abstract:- There {{are various}} {{techniques}} available to solve or give partial solution to constraint satisfaction problem. This paper presents {{a modification of}} <b>branch</b> and bound <b>algorithm,</b> {{which is used to}} solve a constraint satisfaction problem in map colouring problem. There are two constraints involved in which only three colours are allowed to use and adjacent regions in the map must not be of the same colour. The modified <b>branch</b> and bound <b>algorithm</b> uses back jumping when it encounters a dead-end in the search. Static variable ordering was also applied to aid the searching process. The modified <b>branch</b> and bound <b>algorithm</b> shows a better result {{in terms of the number}} nodes instantiated and reduced the number of backtracking at dead ends. The result illustrated that the modified <b>branch</b> and bound <b>algorithm</b> with the use of variable ordering technique is better if compared to backjumping. Thus, it is concluded that the modified <b>branch</b> and bound <b>algorithm</b> would improve constraint satisfaction problem...|$|R
40|$|In {{this paper}} {{we present a}} {{classification}} of parallel <b>branch</b> and bound <b>algorithms,</b> and elaborate on the consequences of particular parameter settings. The taxonomy is based upon how the algorithms handle the knowledge about the problem instance to be solved, generated during execution. The starting point of the taxonomy is the generally accepted description of the sequential <b>branch</b> and bound <b>algorithm,</b> as presented in, for example, [Mitten 1970] and [Ibaraki 1976 a, 1976 b, 1977 a, 1977 b]. 1980 Mathematical Subject Classification: 90 C 27, 68 Q 10, 68 R 05. Key Words & Phrases: branch and bound, taxonomy, parallelism, nondeterminism, asynchronicity. 1. THE <b>BRANCH</b> AND BOUND <b>ALGORITHM</b> <b>Branch</b> and bound <b>algorithms</b> solve optimization problems by partitioning the solution space. Throughout this paper, we will assume that all optimization problems are posed as minimization problems, and that solving a problem is tantamount to finding a feasible solution with minimal value. If there are many such s [...] ...|$|R
50|$|Edmonds is {{well known}} for his theorems on max-weight <b>branching</b> <b>algorithms</b> and packing edge-disjoint branchings and his work with Richard Karp on faster flow algorithms. The Edmonds-Gallai {{decomposition}} theorem describes finite graphs {{from the point of view}} of matchings. He introduced polymatroids, submodular flows with Richard Giles, and the terms clutter and blocker in the study of hypergraphs. A recurring theme in his work is to seek algorithms whose time complexity is polynomially bounded by their input size and bit-complexity.|$|R
