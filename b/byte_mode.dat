4|17|Public
50|$|The {{speed of}} CardBus {{interfaces}} in 32-bit burst mode {{depends on the}} transfer type: in <b>byte</b> <b>mode,</b> transfer is 33 MB/s; in word mode it is 66 MB/s; and in dword (double-word) mode 132 MB/s.|$|E
5000|$|Alphanumeric {{encoding}} mode stores {{a message}} more compactly than the <b>byte</b> <b>mode</b> can, but cannot store lower-case letters and {{has only a}} limited selection of punctuation marks, which are sufficient for rudimentary web addresses. Two characters are coded in an 11-bit value by this formula: ...|$|E
5000|$|<b>Byte</b> <b>Mode,</b> {{also known}} as [...] "Bi-Directional" [...] (although all modes except Compatibility Mode are in fact bi-directional), is a {{half-duplex}} mode that allows the device to transmit eight bits at a time using the same data lines that are used for the other direction. This mode is supported on a minority of pre-IEEE-1284 interfaces as well, such as those built into the IBM PS/2 computers; because of this, it is sometimes unofficially called the PS/2 mode.|$|E
50|$|Interface byte TA2, if present, is global, and {{is named}} the {{specific}} <b>mode</b> <b>byte.</b>|$|R
50|$|Historical note: Provision for {{specific}} mode {{did not exist}} in ISO/IEC 7816-3:1989. Back then, the interface character TA2 had no particular name or function, and was specific (to the protocol introduced by TD1). ISO/IEC 7816-3:1997 introduced the specific mode and the specific <b>mode</b> <b>byte,</b> with interim note helping cards with specific <b>mode</b> <b>byte</b> TA2 in their ATR dealing with a reader that did not implement specific mode.|$|R
40|$|A {{data link}} is {{described}} which provides an access path between many computer based stations {{so that the}} facilities of a central large computing system can be used. It is operated as a party line with each sending-receiving station capable of communicating with any other station; subsequent data transfers can be in burst or unit <b>byte</b> <b>modes.</b> The hardware format is a 24 bit parallel data bus with a parity bit per eight bit byte, and five pairs of symmetrical asynchronous control lines used to govern data flow, status retrieval, etc. on the data bus. The link also allows remote peripheral devices to be attached to it and controlled by a particular computer...|$|R
50|$|The {{introduction}} of new devices like scanners and multi-function printers demanded much more performance than either the Bi-Tronics or IBM style backchannels could handle. Two other standards have become more popular for these purposes. The Enhanced Parallel Port (EPP), originally defined by Zenith Electronics, is similar to IBM's <b>byte</b> <b>mode</b> in concept, but changes details of the handshaking to allow up to 2 MByte/s. The Extended Capability Port (ECP) is essentially an entirely new port in the same physical housing that also adds direct memory access based on the ISA and run-length encoding to compress the data, which is especially useful when transferring simple images like faxes or black-and-white scanned images. ECP offers performance up to 2.5 MByte/s in both directions.|$|E
50|$|All {{of these}} {{enhancements}} are collected {{as part of}} the IEEE 1284 standard. The first release in 1994 included original Centronics mode ("compatibility mode"), nibble and <b>byte</b> <b>modes,</b> as well as a change to the handshaking that was already widely used; the original Centronics implementation called for the BUSY lead to toggle with each change on any line of data (busy-by-line), whereas IEEE 1284 calls for BUSY to toggle with each received character (busy-by-character). This reduces the number of BUSY toggles and the resulting interruptions on both sides. A 1997 update standardized the printer status codes. In 2000, the EPP and ECP modes were moved into the standard, as well as several connector and cable styles, and a method for daisy chaining up to eight devices from a single port.|$|R
5000|$|... <b>mode</b> <b>bytes</b> = struct 4 char; op elem = (int index, bytes val) char: valindex; ... bytes b = [...] "abcd"; ... print (2 elem b); ...|$|R
50|$|ALGOL 68RS {{generalised}} these ideas. A struct 4 char variable held exactly 4 chars (the {{size was}} part of the type). On most ALGOL 68RS systems the <b>mode</b> <b>bytes</b> was equivalent to struct 4 char.|$|R
50|$|ALGOL68 already {{included}} {{fixed length}} structures for efficient handling of characters and bit-data on word based machines, the <b>bytes</b> and bits <b>modes.</b> A <b>bytes</b> variable held one machine word of characters, a bits variable held {{the bits of}} one machine word.|$|R
50|$|NBench is {{essentially}} release 2 of BYTE Magazine's BYTEmark benchmark program (previously known as <b>BYTE's</b> Native <b>Mode</b> Benchmarks), published about 1995, {{which was just}} a few years before the magazine ceased publication. NBench is written in C, and was initially focused on PCs running the Microsoft Windows operating system. Independently of BYTE, in 1996 NBench was ported to Linux and other flavors of Unix by Uwe F. Mayer.More recently Ludovic Drolez prepared an NBench App for the Android mobile device operating system.NBench {{should not be confused with}} the similarly named but unrelated AMD N-Bench.|$|R
50|$|SQL Server 7.0 {{was a major}} re-write (C++) of {{the older}} Sybase engine, which was coded in C. Data pages were {{enlarged}} from 2k bytes to 8k bytes. Extents thereby grew from 16k bytes to 64k <b>bytes.</b> User <b>Mode</b> Scheduling (UMS) was introduced to handle SQL Server threads better than Windows pre-emptive multi-threading. SQL Server 7.0 also introduced a multi-dimensional database product called SQL OLAP Services.SQL Server 7.0 {{would be the last}} version to run on the DEC Alpha platform. Although there were pre-release versions of SQL 2000 (as well as Windows 2000) compiled for Alpha, these were canceled and were never commercially released.|$|R
30|$|The SD/SDHC card {{communication}} protocol in SPI mode is entirely a command-dependent protocol and the card responds to every command with a pre-defined response pattern. In {{the way of}} initialization, first the card is initiated with CMD 0 command. Then, the controller validates the voltage range by generating the CMD 8 command. It also identifies the version of the card (version 2 (SDHC) card or some other cards). Subsequently, the controller generates the application-specific commands such as (CMD 55 + ACMD 41) to complete the initialization process. The controller will continuously generate (CMD 55 + ACMD 41) command until the card initializes itself by giving a “ 00000000 ” response. The SDHC card supports two types of addressing mode. They are block addressing <b>mode</b> and <b>byte</b> addressing <b>mode.</b> The CMD 58 command identifies the addressing mode of the version 2 SDHC card. Also, CMD 16 command is issued to fix the data block length to 512 bytes. After initialization process, the card goes to the idle state until the next command is being generated for single/multiblock read/write.|$|R
50|$|The 64-bit {{addressing}} mode ("long mode") is a superset of Physical Address Extensions (PAE); because of this, page sizes may be 4 KB (212 bytes) or 2 MB (221 <b>bytes).</b> Long <b>mode</b> also supports page sizes of 1 GB (230 bytes). Rather than the three-level page table system used by systems in PAE mode, systems running in long mode use four levels of page table: PAE's Page-Directory Pointer Table is extended from 4 entries to 512, {{and an additional}} Page-Map Level 4 (PML4) Table is added, containing 512 entries in 48-bit implementations. In implementations providing larger virtual addresses, this latter table would either grow to accommodate sufficient entries to describe the entire address range, up to a theoretical maximum of 33,554,432 entries for a 64-bit implementation, or be over ranked by a new mapping level, such as a PML5. A full mapping hierarchy of 4 KB pages for the whole 48-bit space would take {{a bit more than}} 512 GB of RAM (about 0.195% of the 256 TB virtual space).|$|R
5000|$|While it is {{possible}} to switch the 65C816/65C802 from native mode to emulation mode within an ISR, such is fraught with peril. [...] In addition to forcing the accumulator and index registers to 8 bits (causing a loss of the most significant byte in the index registers), entering emulation mode will truncate the stack pointer to 8 bits and relocate the stack itself to page 1 RAM. [...] The result is the stack that existed {{at the time of the}} interrupt will be inaccessible unless it was also in page 1 RAM and no larger than 256 <b>bytes.</b> In general, <b>mode</b> switching while servicing an interrupt is not a recommended procedure, but may be necessary in specific operating environments.|$|R
5000|$|Unlike the octal-oriented PDP-11, the VAX-11 was a hexadecimal-oriented machine (4-bit sub-byte). This {{resulted}} in 16 logical addressing modes (0-15), however, addressing modes 0-3 were [...] "short immediate" [...] for immediate data of 6 bits or less (the 2 low-order {{bits of the}} addressing mode being the 2 high-order bits of the immediate data, when prepended to the remaining 4 bits in that data-addressing <b>byte).</b> Since addressing <b>modes</b> 0-3 were identical, this made 13 (electronic) addressing modes, but as in the PDP-11, {{the use of the}} Stack Pointer (R14) and Program Counter (R15) created a total of over 15 conceptual addressing modes (with the assembler program translating the source code into the actual stack-pointer or program-counter based addressing mode needed).|$|R
40|$|Test-bed {{experimental}} {{analysis of}} the client/server applications in embedded systems is presented. The experiments are executed on different embedded platforms and with different packet sizes. The evaluation of client/server application includes measuring the speed of network hardware and protocol stack processing and the OS speed in creating a socket and reading/writing to it. The experiments include UDP and TCP client/server applications. They are made using a software tool for test-bed experiments in experimental network [5]. The paper includes {{a comparison of the}} embedded systems based on the received results. It examines the dependency of the communication latency on packet sizes for small packets (1 - 500 <b>bytes).</b> Using two <b>modes</b> of TCP communication (single transport stream for multiple transfers and new transport stream for every packet) enables distinguishing the socket creation time from socket access time...|$|R
40|$|Memory (EEPROM) with 2 kbits (256 × 8 -bit) {{non-volatile}} storage. By {{using an}} internal redundant storage code, it is fault tolerant to single bit errors. This feature dramatically increases the reliability compared to conventional EEPROMs. Power consumption is low {{due to the}} full CMOS technology used. The programming voltage is generated on-chip, using a voltage multiplier. Data bytes are received and transmitted via the serial I 2 C-bus. Up to eight PCF 85102 C- 2 devices may {{be connected to the}} I 2 C-bus. Chip select is accomplished by three address inputs (A 0, A 1 and A 2). 2. Features ■ Low power CMOS: ◆ 2. 0 mA maximum operating current ◆ maximum standby current 10 µA (at 6. 0 V), typical 4 µA ■ Non-volatile storage of 2 kbits organized as 256 × 8 -bit ■ Single supply with full operation down to 2. 5 V ■ On-chip voltage multiplier ■ Serial input/output I 2 C-bus ■ Write operations: ◆ <b>byte</b> write <b>mode</b> ◆ 8 -byte page write mode (minimizes total write time per byte) ■ Read operations: ◆ sequential read ◆ random read ■ Internal timer for writing (no external components) ■ Internal power-on reset ■ 0 kHz to 100 kHz clock frequency ■ High reliability by using a redundant storage code ■ Endurance: 1, 000, 000 Erase/Write (E/W) cycles at Tamb = 22 °C ■ 10 years non-volatile data retention tim...|$|R
40|$|RC 4 can be {{made more}} secured if an {{additional}} RC 4 -like Post-KSA Random Shuffing (PKRS) process is introduced between KSA and PRGA. It can also be made significantly faster if RC 4 bytes are processed in a FPGA embedded system using multiple coprocessors functioning in parallel. The PKRS process is tuned to form as many S-boxes as required by particular design architectures involving multiple coprocessors, each one undertaking byte-by-byte processing. Following a ecent idea [1] [2] the speed of execution of each processor is also enhanced by another fold if the byte-by-byte processing {{is replaced by a}} scheme of processing two consecutive bytes together. Adopting some new innovative concepts, three hardware design architectures are proposed in a suitable FPGA embedded system involving 1, 2 and 4 coprocessors functioning in parallel and a study is made on accelerating RC 4 by processing <b>bytes</b> in byte-by-byte <b>mode</b> achieving throughputs from 1 -byte-in- 1 -clock to 4 -bytes-in- 1 -clock. The hardware designs are appropriately upgraded to accelerate RC 4 further by processing 2 onsecutive RC 4 bytes together and it has been possible to achieve a maximum throughput of 8 -bytes per clock in Xilinx Virtex- 5 LX 110 t FPGA [3] architecture followed by secured data communication between two FPGA boards. Comment: Manuscrip...|$|R
5000|$|The Dazzler {{supported}} four graphics modes in total, {{selected by}} setting or clearing bits {{in the control}} register (0F) that controlled two orthogonal selections. The first selected {{the size of the}} frame buffer, either 512 bytes or 2 kB. The other selected normal or [...] "X4" [...] mode, the former using 4-bit nybbles packed 2 to a byte in the frame buffer to produce an 8-color image, or the latter which was a higher resolution monochrome mode using 1-bits per pixel, 8 to a <b>byte.</b> Selecting the <b>mode</b> indirectly selected the resolution. In normal mode with a 512 byte buffer there would be 512 bytes × 2 pixels per byte = 1,024 pixels, arranged as a 32 by 32 pixel image. A 2 kB buffer produced a 64 by 64 pixel image, while the highest resolution used a 2 kB buffer in X4 mode to produce a 128 by 128 pixel image. In normal mode the color was selected from a fixed 8-color palette with an additional bit selecting intensity, while in X4 mode the foreground color was selected by setting three bits in the control register to turn on red, green or blue (or combinations) while a separate bit controlled the intensity.|$|R

