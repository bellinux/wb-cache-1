3|65|Public
50|$|In its {{simplest}} form each {{user process}} is assigned a single contiguous segment of main memory. The operating system loads the physical address of this segment into a base register and its size into a <b>bound</b> <b>register.</b> Virtual addresses {{seen by the}} program {{are added to the}} contents of the base register to generate the physical address. The address is checked against the contents of the bounds register to prevent a process from accessing memory beyond its assigned segment.|$|E
40|$|T cell {{activation}} requires {{formation of}} a tri-molecular interaction between a major histocompatibility complex (MHC), peptide, and T cell receptor. In a common model system, the ovalbumin epitope 323 - 339 binds the murine class II MHC, I-A(d), {{in at least three}} distinct registers. The DO 11. 10 T cell recognizes the least stable of these, as determined by peptide-MHC dissociation rates. Using exogenous peptides and peptide insertions into a carrier protein in combination with IL- 2 secretion assays, we show that the alternate registers do not competitively inhibit display of the active register four. In contrast, this weakly binding register is stabilized by the presence of n-terminal flanking residues active in MHC binding. The DO 11. 10 hybridoma is sensitive to the presence of specific wild-type residues extending to at least the P- 3 peptide position. Transfer of the P- 4 to P- 2 flanking residues to a hen egg lysozyme epitope also presented by I-A(d) increases the activity of that epitope substantially. These results illustrate the inherent complexity in delineating the interaction of multiple registers based on traditional thermodynamic measurements and demonstrate the potential of flanking residue modification for increasing the activity of weakly bound epitopes. The latter technique represents an alternative to substitution of anchor residues within a weakly <b>bound</b> <b>register,</b> which we show can significantly decrease the activity of the epitope to a responding T cell...|$|E
40|$|University of Minnesota Ph. D. dissertation. December 2012. Major: Chemical Engineering. Advisor: Jennifer A. Maynard. 1 {{computer}} file (PDF); ix, 123 pages. During an induced immune response, the BALB/c strain of laboratory mouse presents ovalbumin peptides by major histocompatibility complexes that stimulate responding T cells. This work first investigates {{the nature of}} ovalbumin peptide 323 - 339 presentation by the Class II MHC I-Ad in an in vitro setting, then focuses on the engineering of an individual T cell receptor (DO 11) involved in ovalbumin response, and finally, pursues isolation of other responding T cell receptors with modern high throughput sequencing techniques. T cell activation requires formation of a tri-molecular complex between a major histocompatibility complex (MHC), peptide, and T cell receptor. In a common model system, the ovalbumin epitope 323 - 339 binds the murine class II MHC, I-Ad {{in at least three}} distinct registers. The DO 11 T cell recognizes the least stable of these, as determined by peptide-MHC dissociation rates. Using synthesized peptides in combination with IL- 2 secretion assays, we show that the alternate registers do not competitively inhibit display of the active register four. In contrast, this weak register is stabilized by the presence of n-terminal flanking residues active in MHC binding. DO 11 is sensitive to the presence of wild type residues extending to at least the P- 3 peptide position, and the transfer of flanking residues in the P- 4 and P- 2 positions to an I-Ad presented hen egg lysozyme epitope increases the activity of that epitope substantially. Further, we provide evidence that display of the active register is dependent on the stability of an adjacent, overlapping register three. When epitopes were inserted in a maltose binding protein carrier, activity positively correlated with stability of the adjacent register, which was modulated by P 1 anchor residue substitutions. Collectively, these results illustrate the potential of flanking residue modification to increase the activity of weakly bound epitopes. This represents an alternative to substitution of anchor residues within a weakly <b>bound</b> <b>register,</b> which we show can significantly decrease the activity of the epitope to a T cell responder. In order to monitor the presentation of ovalbumin peptides, we have engineered a high affinity, multivalent single chain T cell receptor complex that exhibits specificity towards the OVA 323 - 339 peptide when displayed by I-Ad. DO 11 was expressed as a single chain T cell receptor at levels in excess of 30 mg/L when oriented as beta variable region followed by alpha region separated by a flexible linker and incorporating previously identified solubility-inducing mutations. High affinity variants of DO 11 were obtained from a randomized CDR 3 a; library displayed as pIII fusions by M 13 bacteriophage and panned against the DO 11 -specific, pMHC-mimicking antibody KJ 1 - 26. ScTCR dimers were created by introduction of a hexapeptide EE-epitope tag into the flexible (G 4 S) 4 linker, followed by complexation with a specific monoclonal antibody. Tetramers were formed by further association of dimers with a fluorescently labeled anti-IgG 1, and shown to specifically target peptide-loaded lymphoma cells in flow cytometry. The applicability of scTCR protein expression and phage display techniques is also explored with other TCRs and found to be generally applicable to those containing mouse TRBV 13 - 2, a gene previously noted for its preferential usage in the responding repertoire in mouse autoimmune models. We also show that 172, a TCR isolated from a mouse experimental autoimmune encephalomyelitis model, can be expressed at high levels as a fusion with the short peptide IT 9302, a peptide from the c-terminus of interleukin 10 shown to possess many of the immunosuppressive characteristics of its parent cytokine. We also report on the adaptation of phage display vector pMoPac 24 to display fusion proteins with M 13 major coat protein pVIII along with three previously identified display-optimized variants. We find that the production of phage particles containing these fusions and surface display is specific to the variant being expressed, but we demonstrate more efficient display for pVIII fusions as compared to pIII for DO 11, as measured by inhibition of Interleukin 2 (IL- 2) secretion during a 24 -hour incubation with antigen presenting cells and specific peptide. The use of these vectors may be necessary for directed evolution of T cell receptors exhibiting low affinity interactions with their target peptide/MHC complexes. Finally, we report on the high throughput sequencing of mouse T cell receptor genes using pyrosequencing technologies. Alpha and Beta primer sets were designed to amplify cDNA from isolated mouse total RNA. The set was validated on T Cells isolated from mouse spleens, and used to identify T cell receptor genes from two clones, 3 B 6 and 4 C 4. A high throughput comparison of ovalbumin immunized mice and unimmunized controls is in progress. Identification of and subsequent engineering of T cell receptors involved in the ovalbumin response may provide further tools for future research on this murine system...|$|E
5000|$|Intel MPX (Memory Protection Extensions) {{is a set}} of {{extensions}} to the x86 {{instruction set}} architecture. With compiler, runtime library and operating system support, Intel MPX brings increased security to software by checking pointer references whose normal compile-time intentions are maliciously exploited at runtime due to buffer overflows. Intel MPX introduces new <b>bounds</b> <b>registers,</b> and new instruction set extensions that operate on these registers. Additionally, there is a new set of [...] "bound tables" [...] that store bounds beyond what can fit in the <b>bounds</b> <b>registers.</b>|$|R
50|$|The 6000 {{supported}} multiple processors. Each processor {{had four}} ports for connection to memory or I/O controllers. Memory protection and relocation was accomplished using a base and <b>bounds</b> <b>register,</b> the Base Address Register (BAR).|$|R
50|$|In {{computing}} {{base and}} bounds {{refers to a}} simple form of virtual memory where access to computer memory is controlled by one or {{a small number of}} sets of processor registers called base and <b>bounds</b> <b>registers.</b>|$|R
50|$|This {{technique}} protects memory used by one process against access or modification by another. By itself it {{does not}} protect memory from erroneous access by the owning process. It also allows programs to be easily relocated in memory, since only the base and <b>bounds</b> <b>registers</b> have to be modified when the program is moved.|$|R
40|$|Abstract. We {{present the}} first wait-free and self-stabilizing {{implementation}} of a single-writer/single-reader regular register by single-writer/single-reader safe registers. The construction is in two steps: one implements a regular register using 1 -regular registers, and the other implements a 1 -regular register using saferegisters. In both steps, if the initial <b>register</b> is <b>bounded</b> then the implementation uses only <b>bounded</b> <b>registers.</b> ...|$|R
40|$|We present two {{algorithms}} for the Group Mutual Exclusion (GME) Problem that {{satisfy the}} properties of Mutual Exclusion, Starvation Freedom, Bounded Exit, Concurrent Entry and First Come First Served. Both our algorithms use only simple read and write instructions, have O(N) Shared Space complexity and O(N) Remote Memory Reference (RMR) complexity in the Cache Coherency (CC) model. Our first algorithm is developed by generalizing the well-known Lamport's Bakery Algorithm for the classical mutual exclusion problem, while preserving its simplicity and elegance. However, it uses unbounded shared registers. Our second algorithm uses only <b>bounded</b> <b>registers</b> and is developed by generalizing Taubenfeld's Black and White Bakery Algorithm to solve the classical mutual exclusion problem using only <b>bounded</b> shared <b>registers.</b> We show that contrary to common perception our algorithms {{are the first to}} achieve these properties with these combination of complexities. Comment: A total of 21 pages including 5 figures and 3 appendices. The <b>bounded</b> shared <b>registers</b> algorithm in the old version has a subtle error (that has no easy fix) necessitating replacement. A correct, but fundamentally different, <b>bounded</b> shared <b>registers</b> algorithm, which has the same properties claimed in the old version is presented in this new version. Also, this version has an additional autho...|$|R
5000|$|Partitions may be {{relocatable}} using hardware typed memory, {{like the}} Burroughs Corporation B5500, or base and <b>bounds</b> <b>registers</b> like the PDP-10 or GE-635. Relocatable partitions {{are able to}} be compacted to provide larger chunks of contiguous physical memory. Compaction moves [...] "in-use" [...] areas of memory to eliminate [...] "holes" [...] or unused areas of memory caused by process termination {{in order to create}} larger contiguous free areas.|$|R
50|$|Partitioned {{allocation}} {{usually requires}} some hardware support {{to prevent the}} jobs from interfering with one another or with the operating system. The IBM System/360 used a lock-and-key technique. Other systems used base and <b>bounds</b> <b>registers</b> which contained {{the limits of the}} partition and flagged invalid accesses. The UNIVAC 1108 Storage Limits Register had separate base/bound sets for instructions and data. The system took advantage of memory interleaving to place what were called the i bank and d bank in separate memory modules.|$|R
5000|$|MPX uses {{four new}} 128-bit <b>bounds</b> <b>registers,</b> [...] to , each storing {{a pair of}} 64-bit lower bound (LB) and upper bound (UB) values of a buffer. The upper bound is stored in ones' {{complement}} form, with [...] (create bounds) and [...] (check upper bound) performing the conversion. The architecture includes two configuration registers [...] ( [...] in user space and [...] in kernel mode), and a status register , which provides a memory address and error code {{in case of an}} exception.|$|R
40|$|Many {{important}} protocols in {{distributed computing}} have simple and elegant solutions {{if we allow}} the assumption of unbounded size registers. This assumption can be simulated in practice using sufficiently large but bounded registers; however the resulting protocols are extremely vulnerable to transient faults. In this paper we present a general methodology for the transformation of unbounded register protocols {{so that they can}} work with <b>bounded</b> <b>registers</b> in a self-stabilizing fashion. The applicability of our method is demonstrated with two examples: spanning tree computation and topology update...|$|R
50|$|Several memory {{systems are}} {{supported}} in the specification. Physical-only is {{suited to the}} smallest embedded systems. Hardware address relocation using a single set of base-and-bound registers permits different code to run at the same address. Hardware relocation for two separate sets of base and <b>bound</b> <b>registers</b> permits processes with different RAM to share the same code, or permits a system to run code from read-only memory. These options are suitable for systems that keep all code and data in memory. Applications include intermediate-sized embedded systems, and fast supercomputers that operate from memory. There are also three UNIX-style virtual memory systems for memory cached in mass-storage systems.|$|R
40|$|We {{investigate}} {{the time and}} space complexity of detecting and preventing ABAs in shared memory algorithms for systems with n processes and bounded base objects. To that end, we define ABA-detecting registers, which are similar to normal read/write registers, except that they allow a process q to detect with a read operation, whether some process wrote the register since q's last read. ABA-detecting registers can be implemented trivially from a single unbounded register, but we show {{that they have a}} high complexity if base objects are bounded: An obstruction-free implementation of an ABA-detecting single bit register cannot be implemented from fewer than n- 1 <b>bounded</b> <b>registers.</b> Moreover, <b>bounded</b> CAS objects (or more generally, conditional read-modify-write primitives) offer little help to implement ABA-detecting single bit registers: We prove a linear time-space tradeoff for such implementations. We show that the same time-space tradeoff holds for implementations of single bit LL/SC primitives from bounded writable CAS objects. This proves that the implementations of LL/SC/VL by Anderson and Moir (1995) as well as Jayanti and Petrovic (2003) are optimal. We complement our lower bounds with tight upper bounds: We give an implementation of ABA-detecting registers from n+ 1 <b>bounded</b> <b>registers,</b> which has step complexity O(1). We also show that (bounded) LL/SC/VL can be implemented from a single bounded CAS object and with O(n) step complexity. Both upper bounds are asymptotically optimal with respect to their time-space product. These results give formal evidence that the ABA problem is inherently difficult, that even writable CAS objects do not provide significant benefits over registers for dealing with the ABA problem itself, and that there is no hope of finding a more efficient implementation of LL/SC/VL from bounded CAS objects and registers than the ones mentioned...|$|R
50|$|The KA10 has {{a maximum}} main memory {{capacity}} (both virtual and physical) of 256 kilowords (equivalent to 1152 kilobytes). As supplied by DEC, {{it did not}} include paging hardware; memory management consisted of two sets of protection and relocation registers, called base and <b>bounds</b> <b>registers.</b> This allows each half of a user's address space {{to be limited to}} a set section of main memory, designated by the base physical address and size. This allows the model of separate read-only shareable code segment (normally the high segment) and read-write data/stack segment (normally the low segment) used by TOPS-10 and later adopted by Unix. Some KA10 machines, first at MIT, and later at Bolt, Beranek and Newman (BBN), were modified to add virtual memory and support for demand paging, as well as more physical memory.|$|R
40|$|AbstractFor integer k⩾ 0, let srm(nO(1),k) {{denote the}} {{collection}} of relations computable by a stack register machine with stack <b>registers</b> <b>bounded</b> by a polynomial p(n) in the input n, and work <b>registers</b> <b>bounded</b> by k. Let nsrm(nO(1),k) denote the analogous class accepted by nondeterministic stack register machines. In this paper, nondeterminism is shown to provide no additional power. Specifically, (nO(1), 0) = (nO(1), 0), (nO(1), 1) = srm(nO(1), 1), (nO(1),k) = srm(nO(1),k), for k ⩾ 4, srm(nO(1),k) = alintime, for k ⩾ 4...|$|R
40|$|This paper {{introduces}} a general formulation of atomic snapshot memory, a shared memory partitioned into words written (updated) by individual processes, or instantaneously read (scanned) in its entirety. This paper presents three wait-free implementations of atomic snapshot memory. The first implementation {{in this paper}} uses unbounded (integer) fields in these registers, and is particularly easy to understand. The second implementation uses <b>bounded</b> <b>registers.</b> Its correctness proof follows {{the ideas of the}} unbounded implementation. Both constructions implement a single-writer snapshot memory, in which each word may be updated by only one process, from single-writer, n-reader registers. The third algorithm implements a multi-writer snapshot memory from atomic n-writer, n-reader registers, again echoing key ideas from the earlier constructions. All operations require Θ(n 2) reads and writes to the component shared registers in the worst case. Categories and Subject Discriptors: [...] ...|$|R
40|$|Abstract. Distributed {{protocols}} {{that run}} in dynamic environments {{such as the}} Internet are often not able to use an upper bound {{on the number of}} potentially participating processes. In these settings adaptive and uniform algorithms are desirable where the step complexity of all operations {{is a function of the}} number of concurrently participating processes (adaptive) and the algorithm does not need to know an upper bound on the number of participating processes (uniform). Adaptive algorithms, however, are generally not adaptive with respect to their memory consumption- if no upper bound on the number of participating processes is known in advance- they require unbounded MWMR registers and an unbounded number of such registers (even if only finitely many distinct processes appear), making them impractical for real systems. In this paper we ask whether this must be the case: Can adaptive algorithms where no upper bound on the number of participating processes is known in advance be uniformly implemented with finite memory (if only finitely many distinct processes keep reappearing) ? We will show that in the dynamic setting it is impossible to implement long-lived adaptive splitters, collect and renaming with infinitely many <b>bounded</b> MWMR <b>registers,</b> making such adaptive algorithms impractical in dynamic settings. On the positive side we provide algorithms that implement a long-lived uniform adaptive splitter if unbounded registers are available and that implement a non-uniform adaptive splitter with finitely many <b>bounded</b> <b>registers</b> if an upper bound on the number of participating processes is known in advance. ...|$|R
40|$|For integer k 0, let srm(n O(1); k) {{denote the}} {{collection}} of relations computable by a stack register machine with stack <b>registers</b> <b>bounded</b> by a polynomial p(n) in the input n, and work <b>registers</b> <b>bounded</b> by k. Let nsrm(n O(1); k) denote the analogous class accepted by nondeterministic stack register machines. In this paper, nondeterminism is shown to provide no additional power. Specifically, nsrm(n O(1); 0) = srm(n O(1); 0) nsrm(n O(1); 1) = srm(n O(1); 1) nsrm(n O(1); k) = srm(n O(1); k); for k 4 srm(n O(1); k) = alintime; for k 4...|$|R
40|$|Abstract {{models are}} given which reflect the {{properties}} of most existing mechanisms for enforcing protection or access control, together with some possible implementations. The properties of existing systems are explicated {{in terms of the}} model and implementations. Introduction `Protection' is a general term for all the mechanisms that control the access of a program to other things in the system. There is an immense variety of such mechanisms. Indeed, it is normal for a single system to have a number of different and unrelated ones: for example, a supervisor/user mode, memory relocation and <b>bounds</b> <b>registers,</b> some kind of file numbers for open files, access control by user to file directories, and a password scheme for identification at logon. It therefore seems desirable to take a rather abstract approach to the subject. Matters are somewhat confused by the fact that a system can be complete {{from the point of view}} of a community of friendly and infallible users, without any protectio [...] ...|$|R
40|$|This paper {{shows how}} to {{software}} pipeline a loop for minimal register pressure without sacrificing the loop's minimum execution time. This novel bidirectional slack-scheduling method has been implemented in a FORTRAN compiler and tested on many scientific benchmarks. The empirical results [...] -when measured against an absolute lower bound on execution time, and against a novel schedule-independent absolute lower <b>bound</b> on <b>register</b> pressure [...] -indicate nearoptimal performance...|$|R
50|$|In {{many cases}} of 498a, huge amounts of dowry are claimed without any valid reasoning. A {{rickshaw}} puller's wife can allege that she gave crore's of money as dowry and since it is a cognizable case, police are <b>bound</b> to <b>register</b> the case. And in most cases, {{the capacity of the}} wife or her parents and the source of the funds are never tracked.|$|R
50|$|Transparency positives {{could be}} made from the system's {{panchromatic}} negatives by contact printing; these positives were then <b>bound</b> in <b>register</b> with a colour viewing screen of the same type as used for exposure, to reproduce the image in colour. Multiple copies could be printed from each negative, the resultant positives each being registered with their own colour viewing screens. If, on the other hand, a black-and-white print was required, the negative was used and the colour viewing screen ignored.|$|R
40|$|So far we {{have been}} putting the entire address space of each process in memory. With the base and <b>bounds</b> <b>registers,</b> the OS can easily {{relocate}} processes to different parts of physical memory. However, you might have noticed something interesting about these address spaces of ours: {{there is a big}} chunk of “free ” space right in the middle, between the stack and the heap. As you can imagine from Figure 11. 1, although the space between the stack and heap is not being used by the process, it is is still taking up physical memory when we perform dynamic relocation of the entire address space. Thus, a problem: THE CRUX: SUPPORTING LARGE ADDRESS SPACES How do we support a large address space with (potentially) a lot of free space in between the stack and the heap? Note that in our examples, with tiny (pretend) address spaces, the waste doesn’t seem too bad. Imagine, however, a 32 -bit address space (4 GB in size); a typical program will only use megabytes of memory, but still would demand that the entire address space be resident in memory...|$|R
5000|$|The General Electric M236 {{computer}} {{was developed to}} support MISTRAM and other large military radar projects in the 1960s. (According to Dr. Neelands, certain military {{people involved in the}} project were adamant about not relying on [...] "computers", therefore this [...] "information processor" [...] was developed.) This high speed 36-bit mini{{computer was}} developed by the GE Heavy Military Electronics Department (HMED) in Syracuse, New York, eventually leading to the GE-600 series of mainframe computers. The M236 was designed for real-time processing in a radar-based missile flight measurement system and lacked some general purpose features, such as overlapped instruction processing, the floating point operations needed for Fortran, and operating system support features, such as base and <b>bounds</b> <b>registers.</b> The M-236 computer was developed for the US Air Force Cape Canaveral Missile Range, and installed it at Eleuthera (Bahamas). The 36-bit computer word length was needed for radar tracking computations and for the required exchange of data with an IBM 7094 located at the Cape. The chief architect of the M-236 was John Couleur who will become later a technical leader of the GE large computer systems.|$|R
40|$|Abstract. A mutual {{exclusion}} algorithm is presented that has four desired properties: (1) it satisfies FIFO fairness, (2) it satisfies localspinning, (3) it is adaptive, and (4) it uses finite number of <b>bounded</b> size atomic <b>registers.</b> No previously published algorithm satisfies all these properties. In fact, {{it is the}} first algorithm (using only atomic registers) which satisfies both FIFO and local-spinning, and {{it is the first}} bounded space algorithm which satisfies both FIFO and adaptivity. All the algorithms presented are based on Lamport’s famous Bakery algorithm [27], which satisfies FIFO, but uses unbounded size registers (and does not satisfy local-spinning and is not adaptive). Using only one additional shared bit, we bound the amount of space required by the Bakery algorithm by coloring the tickets taken in the Bakery algorithm. The resulting Black-White Bakery algorithm preserves the simplicity and elegance of the original algorithm, satisfies FIFO and uses finite number of <b>bounded</b> size <b>registers.</b> Then, in a sequence of steps (which preserve simplicity and elegance) we modify the new algorithm so that it is also adaptive to point contention and satisfies local-spinning. ...|$|R
60|$|I SHALL {{never forget}} the one-fourth serious and three-fourths comical astonishment, with which, {{on the morning of}} the third of January eighteen-hundred-and-forty-two, I opened the door of, and put my head into, a 'state-room' on board the Britannia steam- packet, twelve hundred tons burthen per <b>register,</b> <b>bound</b> for Halifax and Boston, and {{carrying}} Her Majesty's mails.|$|R
40|$|In {{the group}} mutual {{exclusion}} problem [6], which general-izes mutual exclusion [2], a process chooses a session when it requests {{entry to the}} Critical Section. A group mutual exclusion algorithm must ensure that the mutual exclusion property holds: If two processes are in the Critical Section at the same time, then they request the same session. In addition to mutual exclusicJn, lockout freedom, bounded exit and concurrent entering are basic properties that are desir-able in any group mutual exclusion algorithm. Hadzilacos in [4] first introduced a fairness condition, called first-come-first-served (FCFS), for group mutual ex-clusion. The only known FCFS group mutual exclusion algo-rithm is due to Hadzilacos [4], and requires e(N 2) <b>bounded</b> shared <b>registers,</b> where N {{is the number of}} processes. We present a FCFS group mutual exclusion algorithm that uses only e(N) <b>bounded</b> shared <b>registers.</b> (The existence of such an algorithm was posed as an open problem by Hadzilacos.) Next, we demonstrate that the FCFS property does not fully capture our intuitive notion of fairness. We therefore propose an additional fairness property, called first-in-first-enabled (FIFE). Finally, we present a reduction that trans-forms any &quot;abortable &quot; FCFS mutual exclusion algorithm. h 4 into a group mutual exclusion algorithm G. Thus, different group mutual exclusion algorithms can be obtained by in-stantiating A 4 with different abortable FCFS mutual exclu-sion algorithms. The group mutual exclusion algorithms so obtained satisfy all of the properties mentioned above: mu-tual exclusion, lockout freedom, bounded exit, concurrent entering, FCFS, and FIFE...|$|R
40|$|Finding aid {{only for}} Manuscripts Collection 66. Original, <b>bound</b> folio hotel <b>registers</b> and <b>bound</b> typescript {{copies of the}} same for the Mammoth Cave Hotel, located near the famed {{subterranean}} tourist attraction in Edmonson County, Kentucky. Entries include the name and hometown of the visitor as well as the date. One wag signed in as Abraham Lincoln on 30 May 1863...|$|R
40|$|International audienceTight Θ(n^ 2) bounds {{are known}} for the total step {{complexity}} of randomized algorithms for n-process consensus from registers [1]. However, {{there is a large}} gap between the best known space lower <b>bound</b> of Ω(sqrt(n)) <b>registers</b> and the Θ(n) space complexity of the best existing algorithms. We prove matching upper and lower bounds of n for the space complexity of nondeterministic solo-terminating consensus in a restricted computational model...|$|R
40|$|For integer k 0, let srm(n O(1); k) {{denote the}} {{collection}} of relations computable by a stack register machine with stack <b>registers</b> <b>bounded</b> by a polynomial p(n) in the input n, and work <b>registers</b> <b>bounded</b> by k. Let nsrm(n O(1); k) denote the analogous class accepted by nondeterministic stack register machines. In this paper, nondeterminism is shown to provide no additional power. Specifically, nsrm(n O(1); 0) = srm(n O(1); 0) nsrm(n O(1); 1) = srm(n O(1); 1) nsrm(n O(1); k) = srm(n O(1); k); for k 4 srm(n O(1); k) = alintime; for k 4 : 1 Introduction In a recently rediscovered letter from K. Godel to J. von Neumann dated March 1956, 1 Godel raised a problem about length of proofs, which has since been seen to be equivalent to the P = NP question. Around the same time, a few other logicians began investigating other problems in what was later defined to be the field of computational complexity. In 1955, Asser [1] asked whether the complement of a spec [...] ...|$|R
40|$|We {{present an}} {{algorithm}} {{to solve the}} GROUP MUTUAL EXCLUSION problem in the cache-coherent (CC) model. For the same prob-lem in the distributed shared memory (DSM) model, Danek and Hadzilacos presented algorithms of O(n) remote memory refer-ences (RMR) and proved a matching lower bound, where n {{is the number of}} processes. We show that in the CC model, using regis-ters and LL/SC variables, our algorithm achievesO(min(logn, k)) RMR, where k is the point contention, which is so far the best. Moreover, given a recent result of Attiya, Hendler and Woelfel showing that exclusion problems have aΩ(logn) RMR lower <b>bound</b> using <b>registers,</b> comparison primitives and LL/SC variables, our al-gorithm thus achieves the best theoretical bound. Categories and Subject Descriptors D [Software]: Programming Techniques—Concurrent Program-min...|$|R
40|$|Aguilera, Gafni and Lamport {{introduced}} the signaling problem in [5]. In this problem, two processes numbered 0 and 1 can call two procedures: update and Fscan. A parameter {{of the problem}} is a two- variable function F(x_ 0,x_ 1). Each process p_i can assign values to variable x_i by calling update(v) with some data value v, and compute the value: F(x_ 0,x_ 1) by executing an Fscan procedure. The problem is interesting when the domain of F is infinite and the range of F is finite. In this case, some "access restrictions" are imposed that limit the size of the registers that the Fscan procedure can access. Aguilera et al. provided a non-blocking solution and asked whether a wait-free solution exists. A positive answer can be found in [7]. The natural generalization of the two-process signaling problem to an arbitrary number of processes turns out to yield an interesting generalization of the fundamental snapshot problem, which we call the F-snapshot problem. In this problem n processes can write values to an n-segment array (each process to its own segment), and can read and obtain the value of an n-variable function F on the array of segments. In case that the range of F is finite, it is required that only <b>bounded</b> <b>registers</b> are accessed when the processes apply the function F to the array, although the data values written to the segments may be taken from an infinite set. We provide here an affirmative {{answer to the question of}} Aguilera et al. for an arbitrary number of processes. Our solution employs only single-writer atomic registers, and its time complexity is O(n n), which is also the time complexity of the fastest snapshot algorithm that uses only single-writer registers...|$|R
6000|$|Back in {{the work}} room she wandered solemnly about, glancing now at the prodigious filing system, at the chart and {{blue-print}} cabinets, at the revolving shelves of reference books, and at the long rows of stoutly <b>bound</b> herd <b>registers.</b> At last she came to his books--a goodly row of pamphlets, bound magazine articles, and an even dozen ambitious tomes. She read the titles painstakingly: [...] "Corn in California," [...] "Silage Practice," [...] "Farm Organization," [...] "Farm Book-keeping," [...] "The Shire in America," [...] "Humus Destruction," [...] "Soilage," [...] "Alfalfa in California," [...] "Cover Crops for California," [...] "The Shorthorn in America"--at this last she smiled affectionately with memory of the great controversy he had waged for the beef cow and the milch cow as against the dual purpose cow.|$|R
30|$|The {{total length}} of the {{accumulative}} lifetime divided by II gives a lower <b>bound</b> on <b>register</b> pressure, denoted AvgLive. Despite {{the fact that a}} minimized AvgLive gives smaller register usage, it does not necessarily provide the lowest. For example, a found schedule with a total lifetime of 110 requires a minimum of 17 registers, while another schedule with a lifetime of 118 required only a minimum of 16 registers. A better <b>register</b> lower <b>bound</b> is computed considering overlapped lifetimes over II cycles, getting an array (called LiveVector) of II elements as described in [33]. The maximum among the LiveVector values was named the MaxLive, which is a precise lower bound measure of the number of needed registers. It was shown in [33] that a schedule requires at most MaxLive[*]+[*] 1 registers.|$|R
