163|347|Public
25|$|Where the {{constant}} representing the <b>boolean</b> <b>value</b> of true is T in most Lisps, in Scheme it is #t.|$|E
25|$|Because {{the golden}} ratio does exist, {{this is a}} true sentence, and belongs to the existential theory of the reals. The answer to the {{decision}} problem for the existential theory of the reals, given this sentence as input, is the <b>Boolean</b> <b>value</b> true.|$|E
25|$|The {{answer to}} the {{decision}} problem for the existential theory of the reals, given this sentence as input, is the <b>Boolean</b> <b>value</b> false: there are no counterexamples. Therefore, this sentence {{does not belong to}} the existential theory of the reals, despite being of the correct grammatical form.|$|E
2500|$|Boolean {{function}}, {{a function}} that determines <b>Boolean</b> <b>values</b> or operators ...|$|R
5000|$|Majority function, the {{majority}} {{of a collection of}} <b>Boolean</b> <b>values</b> ...|$|R
40|$|AbstractFor each {{consistent}} universal {{first order}} theory T a <b>Boolean</b> <b>valued</b> model of T is constructed that satisfies an existential sentence if {{and only if}} it is provable from T. The resolution calculus is extended so that proofs from T yield representations of objects incompletely specified by T in a <b>Boolean</b> <b>valued</b> model...|$|R
25|$|In PHP, {{the triple}} equals sign (===) denotes value and type equality, meaning {{that not only}} do the two {{expressions}} evaluate to equal values, they are also of the same data type. For instance, the expression 0==false is true, but 0===false is not, because the number 0 is an integer value whereas false is a <b>Boolean</b> <b>value.</b>|$|E
2500|$|Boolean {{expression}}, {{an expression}} in {{a programming language}} that produces a <b>Boolean</b> <b>value</b> when evaluated ...|$|E
2500|$|In {{the case}} of Boolean-valued forcing, the {{procedure}} is similar – one has {{to prove that the}} <b>Boolean</b> <b>value</b> of [...] is not [...]|$|E
50|$|The <b>Boolean</b> <b>valued</b> models {{constructed}} by forcing are built using a cumulative hierarchy.|$|R
5000|$|Axiom 1 {{expresses the}} idea that [...] and [...] are the only <b>boolean</b> <b>values.</b>|$|R
40|$|For any {{first order}} theory T we {{construct}} a <b>Boolean</b> <b>valued</b> model M, in which precisely the T [...] provable formulas hold, {{and in which}} every (<b>Boolean</b> <b>valued)</b> subset which is invariant under all automorphisms of M is definable by a first order formula. Our presentation is entirely selfcontained, and only requires familiarity with the most elementary properties of model theory...|$|R
2500|$|A {{predicate}} is {{a function}} that returns a <b>Boolean</b> <b>value.</b> The most fundamental predicate is , which returns [...] if its argument is the Church numeral , and [...] if its argument is any other Church numeral: ...|$|E
2500|$|So, one {{can think}} of removeFile as a {{function}} that, given a FilePath, returns an IO action; this action will ensure that the world, {{in this case the}} underlying file system, won't have a file named by that FilePath when it gets executed. Here, the IO internal value is of type (...) which means that the caller does not care about any other outcomes. On the other hand, in doesFileExist, the function returns an IO action which wraps a <b>boolean</b> <b>value,</b> True or False; this conceptually represents a new state of the world where the caller knows for certain whether that FilePath is present in the file system or not {{at the time of the}} action is performed. The state of the world managed in this way can be passed from action to action, thus defining a series of actions which will be applied in order as steps of state changes. This process is similar to how a temporal logic represents the passage of time using only declarative propositions. The following example clarifies in detail how this chaining of actions occurs in a program, again using Haskell.|$|E
5000|$|Boolean {{expression}}, {{an expression}} in {{a programming language}} that produces a <b>Boolean</b> <b>value</b> when evaluated ...|$|E
5000|$|Simplified Independence Proofs: <b>Boolean</b> <b>Valued</b> Models of Set Theory, by J. Barkley Rosser, Academic Press, 1969 ...|$|R
40|$|The term “Boolean valued {{analysis}} ” appeared {{within the}} realm of mathematical logic. It was Takeuti, a renowned expert in proof theory, who introduced the term. Takeuti defined <b>Boolean</b> <b>valued</b> analysis in [18, p. 1] as “an application of Scott–Solovay’s <b>Boolean</b> <b>valued</b> models of set theory to analysis. ” Vopěnka invented similar models at the same time. That is how the question of the title receive...|$|R
40|$|Recently <b>Boolean</b> <b>valued</b> {{analysis}} (i. e., analysis {{based on}} <b>Boolean</b> <b>valued</b> set theory) {{has been extensively}} studied by G. Takeuti [14 – 16]. The main {{purpose of this paper}} is to show, by using this technique, that any continuous geometry can be viewed as an irreducible continuous geometry in its center valued set theory. This makes the transition from irreducible continuous geometries to reducible ones automatic...|$|R
50|$|Here again B is a <b>boolean</b> <b>value</b> (0 or 1), and S is a {{sequence}} of statements.|$|E
5000|$|Conversion of <b>Boolean</b> <b>value</b> True to Integer {{may yield}} -1 or 1 {{depending}} on the conversion used ...|$|E
50|$|Bit (<b>boolean</b> <b>value),</b> {{bit field}} (group {{of up to}} 32 bits) and bit string (up to 4Gb in length).|$|E
50|$|Kutateladze S.S. What is <b>Boolean</b> <b>valued</b> analysis? Siberian Advances in Mathematics, 2007, Vol. 17, No. 2, 91-111.|$|R
2500|$|By convention, the {{following}} two definitions (known as Church booleans) are used for the <b>boolean</b> <b>values</b> TRUE and FALSE: ...|$|R
5000|$|The {{following}} two definitions for the <b>boolean</b> <b>values</b> [...] and [...] are used, extending {{the definition of}} Church booleans: ...|$|R
5000|$|A boolean flag, truth bit or truth flag in {{computer}} science is a <b>Boolean</b> <b>value</b> represented as one bit ...|$|E
5000|$|Where the {{constant}} representing the <b>boolean</b> <b>value</b> of true is [...] in most Lisps, in Scheme it is [...]|$|E
5000|$|Acknowledging {{the weak}} low order bit, the authors {{go on to}} say:We suggest to use a sign test to extract a random <b>Boolean</b> <b>value</b> ...|$|E
50|$|Kutateladze S.S. Leibnizian, Robinsonian, and <b>Boolean</b> <b>valued</b> monads, Journal of Applied and Industrial Mathematics, 2011, Vol. 5, No. 3, 365-373.|$|R
50|$|Interpretations used {{to study}} non-classical logic include topological models, <b>Boolean</b> <b>valued</b> models, and Kripke models. Modal logic is also studied using Kripke models.|$|R
40|$|In {{this paper}} we {{will present a}} definability theorem for first order logic This theorem {{is very easy to}} state and its proof only uses {{elementary}} tools To explain the theorem let us first observe that if M is a model of a theory T in a language L then clearly any definable subset S M ie a subset S fa j M j ag defined by some formula is invariant under all automorphisms of M The same is of course true for subsets of Mn defined by formulas with n free variables Our theorem states that if one allows <b>Boolean</b> <b>valued</b> models the converse holds More precisely for any theory T we will construct a <b>Boolean</b> <b>valued</b> model M in which precisely the Tprovable formulas hold and in which every <b>Boolean</b> <b>valued</b> subset which is invariant under all automorphisms of M is denable by a formula of L Our presentation is entirely selfcontained and only requires familiarity with the most elementary properties of model theory In particular we have added a first section in which we review the basic definitions concerning <b>Boolean</b> <b>valued</b> models. The <b>Boolean</b> algebra used {{in the construction of the}} model will be presented concretely as the algebra of closed and open subsets of a topological space X naturally associated with the theory T The construction of this space is closely related to the one in In fact one of the results in that paper could be interpreted as a definability theorem for innitary logic using topological rather than <b>Boolean</b> <b>valued</b> model...|$|R
5000|$|In {{the case}} of Boolean-valued forcing, the {{procedure}} is similar - one has {{to prove that the}} <b>Boolean</b> <b>value</b> of [...] is not [...]|$|E
50|$|DER is {{a subset}} of BER {{providing}} for exactly one way to encode an ASN.1 value. DER is intended for situations when a unique encoding is needed, such as in cryptography, and ensures that a data structure {{that needs to be}} digitally signed produces a unique serialized representation. DER can be considered a canonical form of BER. For example, in BER a <b>Boolean</b> <b>value</b> of true can be encoded as any of 255 non-zero byte values, while in DER there is one way to encode a <b>boolean</b> <b>value</b> of true.|$|E
5000|$|Here, when [...] is a <b>Boolean</b> <b>value</b> {{then the}} section tag {{acts like a}}n if conditional, but when [...] is an array then it acts like a foreach loop.|$|E
5000|$|Standard C (since C99) {{provides}} a boolean type, called [...] By {{including the header}} [...] one can use the more intuitive name [...] and the constants [...] and [...] The language guarantees that any two true values will compare equal (which was impossible to achieve before {{the introduction of the}} type). <b>Boolean</b> <b>values</b> still behave as integers, can be stored in integer variables, and used anywhere integers would be valid, including in indexing, arithmetic, parsing, and formatting. This approach (<b>Boolean</b> <b>values</b> are just integers) has been retained in all later versions of C.|$|R
25|$|Church Booleans are the Church {{encoding}} of the <b>Boolean</b> <b>values</b> true and false. Some programming languages {{use these}} as an implementation model for Boolean arithmetic; examples are Smalltalk and Pico.|$|R
30|$|The {{agents in}} the model {{have a variety of}} {{attributes}} that can take on any double precision value as well as individualized lists, <b>Boolean</b> <b>values,</b> etc. As such, they are asymptotically incompressible.|$|R
