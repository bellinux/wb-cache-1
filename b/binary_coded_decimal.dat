75|5308|Public
25|$|Early in 1952, a {{high-speed}} shifter was added, which improved the speed for shifting {{by a factor}} of five. In July 1953, a 100-word expansion core memory was added to the system, using <b>binary</b> <b>coded</b> <b>decimal,</b> excess-3 number representation. To support this expansion memory, ENIAC was equipped with a new Function Table selector, a memory address selector, pulse-shaping circuits, and three new orders were added to the programming mechanism.|$|E
5000|$|... excess-3 <b>binary</b> <b>coded</b> <b>decimal</b> {{with four}} bits per digit, {{allowing}} six-digit signed decimal numbers ...|$|E
50|$|IBM later {{created the}} 8-bit Extended <b>Binary</b> <b>Coded</b> <b>Decimal</b> Interchange Code (EBCDIC) based on BCDIC.|$|E
5000|$|The {{handling}} of the digit 0. The straightforward translation from punched form would place the blank before digits 1 - 9, and encode 0 somewhere else entirely. All codes have some special-case handling which either translates the digit 0 to the all-zero <b>binary</b> <b>code</b> (and moves the blank elsewhere), or gives it <b>binary</b> <b>code</b> 001010 (<b>decimal</b> 10) and uses the 8+2 punch elsewhere.|$|R
40|$|An {{energy meter}} is {{a device that}} able to measure {{electric}} energy at any one time. The energy data {{is very important for}} the study about energy demand especially in residential sector. The meters that {{can be found in the}} market nowadays are expensive because they work on operation principle that requires the use of expensive hardware. Hence, a digital meter that can measure electrical energy consumed by domestic appliances such as kettle, television, toaster, and others has been developed. This meter is robust, user friendly and informative enough for the purpose of simple data gathering. The project involved of hardware designing and microcontroller interfacing. In hardware design, the energy will be determined in digital form. The function of the microcontroller is for the output part. It consists of soft code specially written to calculate energy cost and to convert digital energy signals to <b>binary</b> <b>code</b> <b>decimal.</b> The total energy consumption used by the appliances and the related cost are given as seven segment display after decoding...|$|R
40|$|In {{this paper}} {{we present a}} novel adder/subtracter {{arithmetic}} unit that combines <b>Binary</b> and <b>Binary</b> <b>Code</b> <b>Decimal</b> (BCD) operations. The proposed unit uses effective addition/subtraction operations on unsigned, sign-magnitude, and various complement representations. Our design overcomes the limitations of previously reported approaches that produce some of the results in complement representation when operating on sign-magnitude numbers. The proposal can be implemented in ASIC as a run time configurable unit {{as well as in}} reconfigurable technology in form of a run-time reconfigurable engine. When reconfigurable technology is considered, a preliminary estimation indicates that 40 % of the hardware resources are shared by the different operations. This makes the proposed unit highly suitable for reconfigurable platforms with partial reconfiguration support. The proposed design together with some classical adder organizations were compared after synthesis targeting 4 vfx 60 ff 672 - 12 Xilinx Virtex 4 FPGA. Our design achieves a throughput of 82. 6 MOPS with almost equivalent area-time product when compared to the other proposals. ...|$|R
5000|$|DataFormat: format used {{to encode}} the sampled data - {{examples}} include Offset Binary and <b>Binary</b> <b>Coded</b> <b>Decimal</b> ...|$|E
50|$|IBM's Extended <b>Binary</b> <b>Coded</b> <b>Decimal</b> Interchange Code (usually {{abbreviated}} as EBCDIC) is an eight-bit {{encoding scheme}} developed in 1963.|$|E
5000|$|All {{used the}} Extended <b>Binary</b> <b>Coded</b> <b>Decimal</b> Interchange Code (EBCDIC) of eight bits plus parity for {{internal}} data representation.|$|E
40|$|This paper {{provides}} the details for novel adder/subtractor arithmetic unit that combines <b>Binary,</b> <b>Binary</b> <b>Code</b> <b>Decimal</b> (BCD) and single precision Binary floating point operations {{in a single}} structure. The unit is able to perform effective addition-subtraction operations on unsigned, sign-magnitude, and various complement representations. The design is runtime reconfigurable or can be implemented in ASIC as a runtime configurable unit and maximum utilization of hardware resource are the feature of the architecture. All the subunits {{have been designed to}} work with least delay. The modified unit and base unit were synthesized for 4 vfx 60 ff 672 - 12 Xilinx Virtex 4 FPGA for comparison. The proposed design has 8. 9 ns delay and achievethroughput of 112. 3 MOPS using only 2 % of the available hardware resources of the targeted FPGA. Under the assumption that significant part of the hardware in the proposed structure is shared by the different operation reconfigurable platforms with partial reconfiguration become an interesting target...|$|R
50|$|With advancements in laser technology, digits {{could be}} etched on tags, which caused {{the switch from}} <b>binary</b> to <b>decimal</b> <b>codes.</b> Currently, coded wire tags are marked using a decimal system, which is a row of numbers. The decimal system allows 1 million unique codes for batch tags, and 100,000 unique codes for {{individual}} sequential tags.|$|R
40|$|The {{transcoder}} we {{have set}} out to synthetize and to simulate in this paper is important {{due to the fact}} that it brings into discussion and also presents the family of weighted and unweights <b>binary</b> <b>decimal</b> <b>codes,</b> presented in <b>binary</b> sequences of 4 bits each. Some of these are used even today with great success in the technique of data transmission, especially in recognition and access keys to certain dedicated programs and soft wares. The <b>binary</b> symmetric <b>code</b> is among the first <b>binary</b> <b>decimal</b> weighted <b>codes,</b> which has been the basis for the creation and development of other such codes. Therefore {{we have set}} out to design and simulate such a transcoder...|$|R
50|$|Each digit is {{converted}} to 4 <b>binary</b> <b>coded</b> <b>decimal</b> bits. Then a 1 bit is prepended and two 0 bits are appended.|$|E
50|$|In all octets {{the values}} {{are stored in}} <b>binary</b> <b>coded</b> <b>decimal</b> format with {{switched}} digits (number 35 is stored as 53 hex).|$|E
5000|$|Bits 11 to 29 {{contain the}} data. Bit-field, <b>Binary</b> <b>Coded</b> <b>Decimal</b> (BCD), and Binary Number Representation (BNR) are common ARINC 429 data formats. Data formats {{may also be}} mixed.|$|E
40|$|Abstract: This paper {{presents}} {{an application of}} parallel genetic algorithm to optimal long-range generation expansion planning. The problem is formulated as a combinatorial optimization problem that determines the number of newly introduced generation units of each technology during different time intervals. A new string representation method for the problem is presented. <b>Binary</b> and <b>decimal</b> <b>coding</b> for the string representation method are compared. The method is implemented on transputers, one of the practical multi-processors. The effectiveness of the proposed method is demonstrated on a typical generation expansion problem with four technologies, five intervals, and a various number of generation units. It is compared favorably with dynamic programming and conventional genetic algorithm. The results reveal the speed and effectiveness of the proposed method for solving this problem...|$|R
50|$|Historically, {{bootstrapping}} also {{refers to}} an early technique for computer program development on new hardware. The technique described in this paragraph {{has been replaced by}} the use of a cross compiler executed by a pre-existing computer. Bootstrapping in program development began during the 1950s when each program was constructed on paper in <b>decimal</b> <b>code</b> or in <b>binary</b> <b>code,</b> bit by bit (1s and 0s), because there was no high-level computer language, no compiler, no assembler, and no linker. A tiny assembler program was hand-coded for a new computer (for example the IBM 650) which converted a few instructions into binary or decimal code: A1. This simple assembler program was then rewritten in its just-defined assembly language but with extensions that would enable the use of some additional mnemonics for more complex operation codes. The enhanced assembler's source program was then assembled by its predecessor's executable (A1) into <b>binary</b> or <b>decimal</b> <b>code</b> to give A2, and the cycle repeated (now with those enhancements available), until the entire instruction set was coded, branch addresses were automatically calculated, and other conveniences (such as conditional assembly, macros, optimisations, etc.) established. This was how the early assembly program SOAP (Symbolic Optimal Assembly Program) was developed. Compilers, linkers, loaders, and utilities were then coded in assembly language, further continuing the bootstrapping process of developing complex software systems by using simpler software.|$|R
5000|$|... #Caption: IBM 650 {{front panel}} with bi-quinary <b>coded</b> <b>decimal</b> {{displays}} ...|$|R
50|$|Occasionally {{there are}} {{advantages}} to using a counting sequence {{other than the}} natural binary sequenceâ€”such as the <b>binary</b> <b>coded</b> <b>decimal</b> counter, a linear feedback shift register counter, or a Gray-code counter.|$|E
50|$|The Extended <b>Binary</b> <b>Coded</b> <b>Decimal</b> Interchange Code (EBCDIC) {{character}} set contains 65 control codes, including {{all of the}} ASCII control codes as well as additional codes which are mostly used to control IBM peripherals.|$|E
50|$|A {{special feature}} of ZBasic was BCD (<b>binary</b> <b>coded</b> <b>decimal)</b> math with {{accuracy}} up to 54 digits. Another special feature was INDEX$ array, {{an array of}} variable length strings that could be easily sorted, searched etc.|$|E
50|$|Unicode and HTML <b>code</b> (<b>decimal</b> numeric {{character}} reference) for breve characters.|$|R
50|$|Inverted breve {{characters}} are supported in Unicode and HTML <b>code</b> (<b>decimal</b> numeric character reference).|$|R
25|$|Using an {{otherwise}} valid instruction {{on the wrong}} data type (see packed decimal/binary <b>coded</b> <b>decimal).</b>|$|R
5000|$|In {{the case}} of <b>Binary</b> <b>Coded</b> <b>Decimal</b> (BCD) representation, the SSM may also {{indicate}} the Sign (+/-) of the data or some information analogous to sign, like an orientation (North/South; East/West). When so indicating sign, the SSM is also considered to be indicating Normal Operation.|$|E
50|$|The {{following}} charts {{show the}} numeric values of BCD characters in hexadecimal (base-16) notation, as that most clearly reflects {{the structure of}} 4-bit <b>binary</b> <b>coded</b> <b>decimal,</b> plus two extra bits. For example, the code for 'A", in row 2x and column x1, is hexadecimal 21, or binary '01 0001'.|$|E
50|$|RDM Server {{supports}} the following native data types: signed and unsigned 8-, 16-, 32- and 64-bit integers, UTF-8 and Unicode characters, floating point (32 and 64 bit), BLOBs (binary large objects), BCD (<b>Binary</b> <b>Coded</b> <b>Decimal),</b> date, time and timestamp. In addition it has native support for structs and multi-dimensional arrays {{based on the}} above list of base types.|$|E
5000|$|<b>Binary</b> <b>coding</b> {{systems of}} complex numbers, i. e. systems with the digits , are of {{practical}} interest.Listed below are some coding systems [...] (all are special {{cases of the}} systems above) and resp. <b>codes</b> for the (<b>decimal)</b> numbers [...]The standard binary (which requires a sign) and the [...] "negabinary" [...] systems are also listed for comparison. They {{do not have a}} genuine expansion for [...]|$|R
5000|$|A = 10 (<b>code</b> value: 2 <b>decimal,</b> bits: 2) B = 0 (<b>code</b> value: 0 <b>decimal,</b> bits: 1) C = 110 (<b>code</b> value: 6 <b>decimal,</b> bits: 3) D = 111 (<b>code</b> value: 7 <b>decimal,</b> bits: 3) ...|$|R
50|$|Some of {{the more}} notable uses of constant-weight codes, other than the one-hot and balanced-weight codes already {{mentioned}} above, includeCode 39 uses a 3 of 9 code;bi-quinary <b>coded</b> <b>decimal</b> <b>code</b> uses a 2 of 7 code,the 2 of 5 code,etc.|$|R
5000|$|SMPTE timecodes ( [...] or [...] ) contain <b>binary</b> <b>coded</b> <b>decimal</b> hour:minute:second:frame {{identification}} and 32 bits {{for use by}} users. There are also drop-frame and color framing flags and three extra 'binary group flag' bits used for defining {{the use of the}} user bits. The formats of other varieties of SMPTE time codes are derived from that of the longitudinal timecode.|$|E
50|$|As the S/360 {{was to be}} a {{successor}} to both scientific machines like the 7090 and data processing machines like the 1401, it needed a design that could reasonably support all forms of processing. Hence the instruction set was designed to manipulate simple binary numbers, and text, scientific floating-point (similar to the numbers used in a calculator), and the <b>binary</b> <b>coded</b> <b>decimal</b> arithmetic needed by accounting systems.|$|E
5000|$|Burroughs {{produced}} the B2500 or [...] "medium systems" [...] computers aimed primarily {{at the business}} world. The machines were designed to execute COBOL efficiently. This included a BCD (<b>Binary</b> <b>Coded</b> <b>Decimal)</b> based arithmetic unit, storing and addressing the main memory using base 10 numbering instead of binary. The designation for these systems was Burroughs B2500 through B49xx, followed by Unisys V-Series V340 through V560.|$|E
40|$|AbstractSome nontrivial {{properties}} of perfect <b>binary</b> <b>codes</b> are discussed. We consider some constructions of perfect <b>binary</b> <b>codes</b> {{with the purpose}} to outline bounds {{on the number of}} nonequivalent perfect <b>binary</b> <b>codes</b> and we present the best known lower and upper bounds on the number of different perfect <b>binary</b> <b>codes...</b>|$|R
40|$|The paper {{approaches}} the low-level {{details of the}} code generated by compilers whose format permits outside actions. <b>Binary</b> <b>code</b> modifications are manually done when the internal format is known and understood, or automatically by certain tools developed to process the <b>binary</b> <b>code.</b> The <b>binary</b> <b>code</b> instrumentation goals may be various from security increasing and bug fixing to development of malicious software. The paper highlights the <b>binary</b> <b>code</b> instrumentation techniques by code injection to increase the security and reliability of a software application. Also, the paper offers examples for <b>binary</b> <b>code</b> formats understanding and how the <b>binary</b> <b>code</b> injection may be applied...|$|R
40|$|<b>Binary</b> <b>coding</b> or hashing {{techniques}} are recognized to accomplish efficient near neighbor search, and have thus attracted broad {{interests in the}} recent vision and learning studies. However, such studies have rarely been dedicated to Maximum Inner Product Search (MIPS), which plays {{a critical role in}} various vision applications. In this paper, we investigate learning <b>binary</b> <b>codes</b> to exclusively handle the MIPS problem. Inspired by the latest advance in asymmetric hashing schemes, we propose an asymmetric <b>binary</b> <b>code</b> learning framework based on inner product fitting. Specifically, two sets of coding functions are learned such that the inner products between their generated <b>binary</b> <b>codes</b> can reveal the inner products between original data vectors. We also propose an alternative simpler objective which maximizes the correlations between the inner products of the produced <b>binary</b> <b>codes</b> and raw data vectors. In both objectives, the <b>binary</b> <b>codes</b> and coding functions are simultaneously learned without continuous relaxations, which is the key to achieving high-quality <b>binary</b> <b>codes.</b> We evaluate the proposed method, dubbed Asymmetric Inner-product <b>Binary</b> <b>Coding</b> (AIBC), relying on the two objectives on several large-scale image datasets. Both of them are superior to the state-of-the-art <b>binary</b> <b>coding</b> and hashing methods in performing MIPS tasks...|$|R
