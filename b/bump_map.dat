34|265|Public
5000|$|... #Caption: A sphere without {{bump mapping}} (left). The <b>bump</b> <b>map</b> {{to be applied}} to the sphere (middle). The sphere with the <b>bump</b> <b>map</b> applied (right).|$|E
5000|$|... #Caption: A sphere without {{bump mapping}} (left). A <b>bump</b> <b>map</b> {{to be applied}} to the sphere (middle). The sphere with the <b>bump</b> <b>map</b> applied (right) appears to have a mottled surface {{resembling}} an orange. Bump maps achieve this effect by changing how an illuminated surface reacts to light, without modifying the size or shape of the surface.|$|E
5000|$|... bump lemur_bump.tga # <b>bump</b> <b>map</b> (which {{by default}} uses {{luminance}} channel of the image) disp lemur_disp.tga # displacement map decal lemur_stencil.tga # stencil decal texture (defaults to 'matte' channel of the image) ...|$|E
50|$|<b>Bump</b> <b>mapping</b> {{is another}} form of texture mapping which does not provide pixels with color, but rather with depth. Especially with modern pixel shaders (see below), <b>bump</b> <b>mapping</b> creates the feel of view and lighting-dependent {{roughness}} on a surface to enhance realism greatly.|$|R
5000|$|Environment <b>maps,</b> <b>bump</b> <b>maps,</b> transparency, specularity amongst others ...|$|R
5000|$|... #Caption: Frosted glass using Dielectric and Spekle <b>bump</b> <b>mapping.</b>|$|R
5000|$|Mudbox also {{includes}} stamps and stencils. Stencils work by overlaying a grayscale, or [...] "alpha channel" [...] image, {{such as a}} <b>bump</b> <b>map,</b> over the mesh. The artist can then project part {{or all of the}} image's detail onto the mesh through brush strokes, providing a method to quickly sculpt surface detail.|$|E
50|$|Chris Green of Valve, a {{video game}} maker, says that <b>bump</b> <b>map</b> data is derived from {{geometric}} descriptions of the objects surface significant lighting cues due to lighting occlusion by surface details are not calculated. A common fix is to use an additional texture channel to create an ambient occlusion field. This only provides a darkening effect that is not connected to {{the direction of the}} light source on acting on the surface.|$|E
5000|$|... #Caption: Bump mapping {{is limited}} in {{that it does not}} modify the shape of the {{underlying}} object. On the left, a mathematical function defining a <b>bump</b> <b>map</b> simulates a crumbling surface on a sphere, but the object's outline and shadow remain those of a perfect sphere. On the right, the same function is used to modify the surface of a sphere by generating an isosurface. This models a sphere with a bumpy surface with the result that both its outline and its shadow are rendered realistically.|$|E
5000|$|Line and edge anti-aliasing, <b>bump</b> <b>mapping,</b> 8-bit {{stencil buffer}} ...|$|R
40|$|<b>Bump</b> <b>mapping</b> is a normal-perturbation {{rendering}} {{technique for}} simulating lighting effects caused by patterned irregularities on otherwise locally smooth surfaces. By encoding such surface patterns in texture <b>maps,</b> texture-based <b>bump</b> <b>mapping</b> simulates a surface’s irregular lighting appearance without modeling the patterns as true geometric perturbations to the surface. <b>Bump</b> <b>mapping</b> is advantageous {{because it can}} decouple a texture-based description of small-scale surface irregularities used for per-pixel lighting computations from the vertex-based description of large-scale object shape required for efficient transformation and rasterization. This paper describes a practical and robust bump-mapping technique suited for the capabilities of today’s Graphics Processor Units (GPUs). This paper has six sections including the introduction. The second section presents the theory of <b>bump</b> <b>mapping.</b> The third section reviews several existing hardware bump-mapping techniques. The fourth section describes the cube map texturing and “register combiners ” features of NVIDIA’s GeForce 256 and Quadro GPUs. These features in combination are {{the basis for the}} <b>bump</b> <b>mapping</b> technique presented in the fifth section. This technique achieves real-time performance on current generation NVIDIA GPUs. The technique can model ambient, diffuse, and specular lighting terms, a textured surface decal, and attenuated and spotlight illumination. The technique is notable because of its robustness and relative fidelity to Blinn’s original mathematical formulation of <b>bump</b> <b>mapping.</b> The sixth section concludes. Several appendices provide OpenGL implementation details...|$|R
50|$|There are {{two primary}} methods to perform <b>bump</b> <b>mapping.</b> The first uses a height map for {{simulating}} the surface displacement yielding the modified normal. This is the method invented by Blinn {{and is usually}} what {{is referred to as}} <b>bump</b> <b>mapping</b> unless specified. The steps of this method are summarized as follows.|$|R
50|$|KPT Materializer {{can create}} {{advanced}} surface textures based on bump maps that define troughs and peaks. It can use any external image for {{the basis of}} the <b>bump</b> <b>map</b> or alternatively the user can pick out the hue, saturation, luminance or red, green, or blue channel of the current image. It can then offset, scale and rotate the texture map, control its lighting, and even blend in a reflection map. The filter can be used for anything from providing an oil-painting feel to an entire image, to giving the illusion of depth to a selection.|$|E
50|$|When light {{bounces off}} an object, it {{reflects}} with location-specific brightness {{that depends on}} the shape of the object and the position of the lightning source. This reflection map can be used to create a <b>bump</b> <b>map</b> of a surface, which uses grayscale levels to depict the height of a point on a surface. Knowing the direction and angle of the light source, one can calculate the approximate height that a point has. However, the light direction and angle is usually unknown, which leads to poor quality images, or having to create multiple bump maps, each time trying different settings.|$|E
5000|$|Modo allows {{an artist}} to paint {{directly}} onto 3D models and even paint instances of existing meshes {{onto the surface of}} an object. The paint system allows users to use a combination of tools, brushes and inks to achieve many different paint effects and styles. Examples of the paint tools in Modo are airbrush, clone, smudge, and blur. These tools are paired with your choice of [...] "brush" [...] (such as soft or hard edge, procedural). Lastly, you add an ink, an example of which is image ink, where you paint an existing image onto a 3D model. Pressure-sensitive tablets are supported. The results of painting are stored in a bitmap and that map can be driving anything in Modo's Shader Tree. Thus you can paint into a map that is acting as a <b>bump</b> <b>map</b> and see the bumps in real-time in the viewport.|$|E
40|$|<b>Bump</b> <b>mapping</b> is a {{technique}} that represents the detailed parts of an object surface, such as {{the skin of a}} peanut, using the geometry mapping without complex modeling. However, the hardware implementation for <b>bump</b> <b>mapping</b> is very expensive, because a large amount of per pixel computations, including the normal vector shading, is required. In this paper, we propose an effective <b>bump</b> <b>mapping</b> algorithm that utilizes the reference space with the polar coordinate system and also propose a new hardware architecture associated with the proposed <b>bump</b> <b>mapping</b> algorithm. The proposed architecture reduces the computations to transform the vectors from the object space into the reference space by using a new vector rotation method. It also reduces the computations for the illumination calculation by using the law of cosine. Compared with the previous approaches, the proposed architecture reduces multiplication operations up to 78 %...|$|R
40|$|<b>Bump</b> <b>mapping</b> is a normal-perturbation {{rendering}} {{technique for}} simulating lighting effects caused by patterned irregularities on otherwise locally smooth surfaces. By encoding such surface patterns in texture <b>maps,</b> texture-based <b>bump</b> <b>mapping</b> simulates a surface's irregular lighting appearance without modeling the patterns as true geometric perturbations to the surface. <b>Bump</b> <b>mapping</b> is advantageous {{because it can}} decouple a texture-based description of small-scale surface irregularities used for per-pixel lighting computations from the vertexbased description of large-scale object shape required for efficient transformation and rasterization. This paper describes a practical and robust bump-mapping technique suited for the capabilities of today's Graphics Processor Units (GPUs) ...|$|R
50|$|Rollcage Stage II {{was also}} among the very first titles to feature {{hardware-accelerated}} <b>bump</b> <b>mapping</b> upon its release in March 2000, {{in the form of}} EMBM (Environment <b>Mapped</b> <b>Bump</b> <b>Mapping).</b> RSII was designed to be best experienced at the time on Matrox Millennium G400 graphics cards, released in mid-1999, which had exclusive support for EMBM until the ATI Radeon was released in late 2000. Matrox's <b>bump</b> <b>mapping</b> technology was much hyped by industry press outlets at the time, with Matrox demoing Rollcage Stage II as a cutting-edge showcase for their cards, as well as dedicating a page on their website to the game.|$|R
50|$|Several {{attempts}} have been made to either revive or remake the series. The first attempt evolved into Space: 1999. In the 1990s and early 2000s there were scattered reports of production companies around the world investigating the possibility of producing a new TV series or film, most recently in 2003 when Carlton International Media (current rights holders for the series) announced that an American company was planning to produce a new series, but nothing has yet come of this. Australian company <b>Bump</b> <b>Map,</b> run by Albert Hastings, pitched a revival of UFO to one of Australia's major TV production companies in 1995/6. Also in 1996, Ed Bishop briefly corresponded with independent Australian film maker/UFO fan Adrian Sherlock about an unofficial revival called Damon Dark: Shadofall. Funding for the project fell through, but the script has been made into a fan-made audio production and uploaded to YouTube, and it continues as an independent series.|$|E
40|$|Figure 1 : Bump mapped sphere at {{different}} levels of detail consistently generated and shaded with the normal distribution shown on the left. In this paper we present a method that automatically synthesizes bump maps at arbitrary levels of detail in real-time. The only input data we require is a normal density function; the <b>bump</b> <b>map</b> is generated according to that function. It is also used to shade the generated <b>bump</b> <b>map.</b> The technique allows to infinitely zoom into the surface, because more (consistent) detail can be created on the fly. The shading of such a surface is consistent when displayed {{at different}} distances to the viewer (assuming that the surface structure is self-similar). The <b>bump</b> <b>map</b> generation and the shading algorithm can also be used separately...|$|E
40|$|In {{order to}} texture {{surfaces}} realistically with texture images (e. g. photos), {{it is important}} to consider the underlying relief. Here, a method is proposed to recover a coherent <b>bump</b> <b>map</b> from a single texture image. Different visual zones are first identified using segmentation and classification. Then, by linearly separating the relief into a noise-like small-scale component and a smooth “shape-related ” large-scale component, we can automatically deduce the <b>bump</b> <b>map</b> as well as an “unshaded ” color map of the texture. The major advantage of our approach, compared to sophisticated measurement techniques based on multiple photos or specific devices, is its practical simplicity and broad accessibility, while it allows us to obtain very easily, via basic bump mapping or displacement mapping, rendering results of good quality. Key words: texturing, shape from shading, texture segmentation, bump mapping. ...|$|E
50|$|Normal mapping is {{the most}} common {{variation}} of <b>bump</b> <b>mapping</b> used.|$|R
50|$|<b>Bump</b> <b>mapping</b> is {{achieved}} by perturbing the surface normals of an object and using a grayscale image and the perturbed normal during illumination calculations. The result is an apparently bumpy surface rather than a perfectly smooth surface although {{the surface of the}} underlying object is not actually changed. <b>Bump</b> <b>mapping</b> was introduced by Blinn in 1978.|$|R
50|$|Render {{featured}} raytraced-shadows, raytraced reflections, transparency, texture <b>maps,</b> <b>bump</b> <b>mapping,</b> Lambert and Phong reflections.|$|R
40|$|The bump-mapping {{technique}} {{is often used}} to represent bumps on objects such as bark on trees and craters on the moon. In order to render shadows cast by bumps, the horizon map method was proposed. The horizon map is a table which has, for each of a small collection of azimuthal directions, slopes from each viewpoint on the <b>bump</b> <b>map</b> (height field) to the corresponding horizon point, which is the highest viewable point seen from that viewpoint. In this paper, we propose a more precise method for rendering bumpmap shadows using a both a horizon map and a distance map, to take curvature of surfaces into consideration. The distance map is a table which has, for each azimuthal direction, horizontal projected distances from each point of the <b>bump</b> <b>map</b> to its corresponding horizon point. The proposed method can render shadows efficiently by using programmable graphics hardware...|$|E
40|$|Figure 1 : (a) A low-polygon {{video game}} car drives down a highway. (b) The driver {{slams into the}} guard rail and spins out. (c) The {{collision}} with the rail results in a dent {{along the side of}} the car, which we simulate in the car’s <b>bump</b> <b>map.</b> (d) The car strikes the opposite rail, smashing the front. The damage to the hood of the car is too extensive to represent with a <b>bump</b> <b>map</b> (the <b>bump</b> <b>map</b> in this case became fully saturated at the lowest value) so we instead use a pre-deformed mesh. (e) What the side of the car looks like without bump mapping. (f) Wireframe for the side of the car; unmodified by collision. (g) Wireframe for the front of the car; predeformed. We present a method for efficiently simulating minor deformations that result from collisions. Our method alters only bump maps and leaves mesh geometry unchanged. It is well suited to games because although the results are not physically correct, they are plausible and are computed in real-time. In a real-time simulation the CPU already carries a high load due to game logic, I/O, and physical simulation. To achieve high performance, we move the deformation computation off the CPU. The task of computing surface deformations and collisions for physics is very similar to that of rendering computational solid geometry objects. We exploit this observation by “rendering ” the intersection to an off-screen buffer using graphics hardware and parallel texture map operations. ...|$|E
40|$|Abstract. We {{propose a}} new bump mapping scheme {{that can produce}} parallax, self-occlusion, and self-shadowing for {{arbitrary}} bump maps yet is efficient enough for games when implemented in a pixel shader and uses existing data formats. Related Work Let E and L be unit vectors from the eye and light in a local tangent space. At a pixel, let 2 -vector s be the texture coordinate (i. e. where the eye ray hits the true, flat surface) and t be the coordinate of the texel where the ray would have hit the surface if it were actually displaced by the <b>bump</b> <b>map.</b> Shading is computed by Phong illumination, using the normal to the scalar <b>bump</b> <b>map</b> surface B at t {{and the color of}} the texture map at t. It is common practice to pack a combined map NB with heights in α and normals in rgb. Blinn’s original Bump (a. k. a. Normal) Mapping uses th...|$|E
5000|$|... surface {{patterns}} such as wrinkles, bumps, and ripples, {{for use in}} procedural {{textures and}} <b>bump</b> <b>mapping</b> ...|$|R
5000|$|Graphics {{system with}} {{real-time}} lighting, particle effects, <b>bump</b> <b>mapping,</b> spectacular lighting, stencil shadowing and highly detailed environments ...|$|R
50|$|Millennium Soldier: Expendable {{supports}} Environment-Mapped <b>Bump</b> <b>Mapping,</b> a DirectX 6 feature first {{supported by}} the Matrox Millennium G400.|$|R
40|$|A {{method is}} {{presented}} for representing botanical trees, given three-dimensional points and connections ~ Limbs are modeled as generalized cylinders whose axes are space curves that interpolate the points A free-form sur~ce connects branching limbs. "'Blobby' " techniques {{are used to}} model the tree trunk {{as a series of}} non-circular cross sections. Bark is simulated with a <b>bump</b> <b>map</b> digitized from real world bark; leaves are textures mapped onto simple surface...|$|E
40|$|A {{method for}} {{efficiently}} generating plausible dents and scratches on object surfaces due to collisions. Uses bumps maps instead of mesh deformation. The GPU calculates the deformation to the <b>bump</b> <b>map</b> during a collision. Works in real time. • Uses a rigid body simulator {{based on that}} of Guendelman et al. [2003], with collisions detected by interpenetration using the OPCODE and G 3 D libraries. PARAMETERIZATION AND RENDERING As a pre-process, create a parameterization for each object with a 1 : 1 mapping from points on the object to points on the <b>bump</b> <b>map.</b> Use Sheffer and de Sturler’s parameterization technique [2001] to produce a roughly uniform <b>bump</b> <b>map</b> resolution across the surface. Objects are rendered using parallax bump mapping, a recent hardwarerendering trick described by Welsh [2004] that approximates both selfocclusion and shading for a rough surface (Figure 2). This method works in the following way: 1. For each point p 1 being rendered, the view vector v is formed from the eye to p 1. At p 1, the corresponding point b 1 in the <b>bump</b> <b>map</b> stores a height value. 2. A point b 2 is found by backtracking along the view vector until the height above the surface {{is equal to the}} height stored at b 1. 3. The point b 2 is projected onto the surface of the object at point p 2. 4. The texture and normal values at p 1 are set using the values from p 2. METHOD When objects A and B collide, the location and shape of the deformation is computed by rendering their overlap to an offscreen depth-buffer as follows (all rendering done with no lighting or bump mapping) : 1. Place an orthographic camera a small distance away and facing towards the collision (Fig. 3. 2). 2. Clear the frame buffer. 3. Render the front faces of A, substituting for the color texture an address map, with color (r, g, 0) at texel (r, g) (Fig. 3. 3). 4. Read back the depth buffer D 0 (which now holds the “highest ” points on A) and the color buffer C A. 5. Set the depth test to pass when the new pixel is farther from the camera than the old one (GL_GREATER). 6. Render the back faces of B using the address map, and set the stencil buffer to 1 wherever the depth test passes (i. e. wherever B penetrates A...|$|E
40|$|This work {{details the}} use of {{information}} commonly contained within the 2 D texture map, of a colour 3 D capture, as a driver to add additional geometric detail to the underlying 3 D shape mesh. A novel combination of established 2 D image processing operations and uniform mesh re-sampling facilitates the recovery of additional surface relief detail information which is then added a displacement <b>bump</b> <b>map</b> to the underlying mesh. The technique is demonstrated by enhancing shape from silhouette derived 3 D surface captures. ...|$|E
50|$|<b>Bump</b> <b>mapping</b> is a {{technique}} in computer graphics for simulating bumps and wrinkles {{on the surface of}} an object. This is achieved by perturbing the surface normals of the object and using the perturbed normal during lighting calculations. The result is an apparently bumpy surface rather than a smooth surface although the surface of the underlying object is not changed. <b>Bump</b> <b>mapping</b> was introduced by James Blinn in 1978.|$|R
50|$|In 3D {{computer}} graphics, normal <b>mapping,</b> or Dot3 <b>bump</b> <b>mapping,</b> is {{a technique}} used for faking the lighting of bumps and dents - an implementation of <b>bump</b> <b>mapping.</b> It is used to add details without using more polygons. A common use of this technique is to greatly enhance the appearance and details of a low polygon model by generating a normal map from a high polygon model or height map.|$|R
50|$|Before {{the advent}} of mass-marketed 3D {{acceleration}} hardware, democoders often focused on lighting and shading techniques in software 3D engines, including Gouraud shading, Phong shading, texture <b>mapping,</b> <b>bump</b> <b>mapping,</b> environment mapping, radiosity and even real-time ray tracing.|$|R
