2109|189|Public
5|$|Instead of {{generating}} {{a set of}} woven source code, some AspectJ weavers instead weave the aspects and classes together directly into <b>bytecode,</b> acting both as the aspect weaver and compiler. While {{it is expected that}} the performance of aspect weavers which also perform the compilation process will require more computation time due to the weaving process involved. However, the <b>bytecode</b> weaving process produces more efficient runtime code than would usually be achieved through compiled woven source.|$|E
5|$|Parrot {{a virtual}} machine {{designed}} to run dynamic languages efficiently; Pipp transforms the PHP source code into the Parrot intermediate representation, {{which is then}} translated into the Parrot's <b>bytecode</b> and executed by the virtual machine.|$|E
5|$|Psyco is a {{just-in-time}} specialising compiler that integrates with CPython and transforms <b>bytecode</b> {{to machine}} code at runtime. The emitted code is specialised for certain data types and is faster than standard Python code.|$|E
40|$|Specialized Java <b>bytecodes</b> provide {{functionality}} that {{is easily}} replicated using other Java <b>bytecodes.</b> This study uses profiling {{to explore how}} the set of specialized <b>bytecodes</b> currently implemented by the Java Virtual Machine is utilized by comparing {{it to the other}} specialized <b>bytecodes</b> which could have been implemented. Categories and Subject Descriptors D. 3. 4 [Programming Languages]...|$|R
40|$|Java is {{implemented}} by 201 <b>bytecodes</b> that serve {{the same purpose}} as assembler instructions while providing object-file platform independence. A collection of core <b>bytecodes</b> provide critical and independent functionality while a collection of specialized <b>bytecodes</b> is meant to improve {{on the performance of}} some of the core <b>bytecodes.</b> This study identifies 67 specialized <b>bytecodes</b> and shows the impact of their removal by despecializing them into semantically equivalent core <b>bytecodes.</b> A detailed analysis of the effects of despecialization on execution efficiency and classfile size was performed. The effects on the SPEC JVM 98 Benchmark Suite were analyzed for various subsets of the despecialized <b>bytecodes</b> using three distinct Java virtual machines. When all 67 <b>bytecodes</b> were despecialized, the average slow down across all benchmarks and virtual machines was 2. 1 percent, while the single largest performance loss for any one benchmark was 12. 7 percent. In some cases, a speedup was observed. An analysis of the impact of despecialization on class file size was also conducted. It was found that the average class file size increased by approximately 6 percent when 67 specialized <b>bytecodes</b> were removed. This study shows that many of the specialized <b>bytecodes</b> currently in use offer little benefit to either execution efficiency or class file size. Thus, they can be considered as candidates for Copyright c ○ 2004 Ben Stephenson and Wade Holst. Permission to copy is hereby granted provided the original copyright notice is reproduced in copies made...|$|R
30|$|The major design goal of JOP is the time-predictable {{execution}} of Java <b>bytecodes</b> [59]. All functional units, {{and especially the}} interactions between them, are carefully designed to avoid any timing dependency between <b>bytecodes.</b>|$|R
5|$|The RPython {{language}} can be compiled to C, Java <b>bytecode,</b> or Common Intermediate Language, {{and is used}} to build the PyPy interpreter of Python.|$|E
5|$|HipHop Virtual Machine (HHVM) {{developed}} at Facebook and available as open source, it converts PHP code into a high-level <b>bytecode</b> (commonly {{known as an}} intermediate language), which is then translated into x86-64 machine code dynamically at runtime by a just-in-time (JIT) compiler, resulting in up to 6× performance improvements.|$|E
5|$|Once Perl code is compiled, {{there is}} {{additional}} overhead during the execution phase that typically isn't present for programs written in compiled languages such as C or C++. Examples of such overhead include <b>bytecode</b> interpretation, reference-counting memory management, and dynamic type-checking.|$|E
50|$|Jazelle mode is entered via the BXJ instructions. A {{hardware}} {{implementation of}} Jazelle will only cover {{a subset of}} JVM <b>bytecodes.</b> For unhandled bytecodes—or if overridden by the operating system—the hardware will invoke the software JVM. The system is designed so that the software JVM {{does not need to}} know which <b>bytecodes</b> are implemented in hardware and a software fallback is provided by the software JVM for the full set of <b>bytecodes.</b>|$|R
40|$|Java {{processors}} {{have been}} introduced to offer hardware acceleration for Java applications. They execute Java <b>bytecodes</b> directly in hardware. However, the stack nature of the Java virtual machine instruction set imposes a limitation on the achievable execution performance. If we intend to exploit instruction level parallelism, we must remove the stack completely. This {{can be achieved by}} recursive stack folding algorithms, such as OPEX, which dynamically transform groups of Java <b>bytecodes</b> to RISC like instructions. However, the decoding throughputs that are obtained are limited. In this paper we propose a novel stack folding technique, that uses a predecoded cache to store folded <b>bytecodes,</b> thus enabling reuse. The decoding throughput reaches 4 RISC instructions per cycle. With use of a superscalar backend core, the obtained IPC is approximately 2. 08 instructions per cycle (or 3. 02 Java <b>bytecodes</b> per cycle). Copyright 2006 ACM...|$|R
40|$|Java <b>bytecodes</b> can be {{executed}} {{with the following}} three methods: a Java interpretor running on a particular machine interprets bytecodes; a Just-In-Time (JIT) compiler translates <b>bytecodes</b> to the native primitives of the particular machine and the machine executes the translated codes; and a Java processor executes <b>bytecodes</b> directly. The first two methods require no special hardware support for the execution of Java <b>bytecodes</b> and are widely used currently. The last method requires an embedded Java processor, picoJavaI or picoJavaII for instance. The picoJavaI and pico-JavaII are simple pipelined processors with no ILP (instruction level parallelism) and TLP (thread level parallelism) supports. A so-called MAJC (microprocessor architecture for Java computing) design can exploit ILP and TLP by using a modified VLIW (very long instruction word) architecture and vertical multithreading technique, but {{it has its own}} instruction set and cannot execute Java <b>bytecodes</b> directly. In this paper, we investigate a processor architecture which can directly execute Java <b>bytecodes</b> meanwhile can exploit Java ILP and TLP simultaneously. The proposed processor consists of multiple slots implementing horizontal multithreading and multiple functional units shared by all threads executed in parallel. Our architectural simulation results show that the Java processor could achieve an average 20 IPC (instructions per cycle), or 7. 33 EIPC (effective IPC), with 8 slots and a 4 -instruction scheduling window for each slot. We also check other configurations and give the utilization of functional units as well as the performance improvement with various kinds of working loads. 1...|$|R
5|$|PHP acts {{primarily}} as a filter, taking input from a file or stream containing text and/or PHP instructions and outputting another stream of data. Most commonly the output will be HTML, although it could be JSON, XML or binary data such as image or audio formats. Since PHP 4, the PHP parser compiles input to produce <b>bytecode</b> for processing by the Zend Engine, giving improved performance over its interpreter predecessor.|$|E
5|$|The main Python implementation, named CPython, {{is written}} in C, meeting the C89 standard, with several select C99 features. It compiles Python {{programs}} into intermediate <b>bytecode,</b> which is executed by the virtual machine. CPython is distributed with a large standard library written {{in a mixture of}} C and Python. It is available in versions for many platforms, including Windows and most modern Unix-like systems. CPython was intended from almost its very conception to be cross-platform.|$|E
5|$|To {{accomplish}} just-in-time weaving, {{a change}} to the virtual machine that executes the compiled <b>bytecode</b> is necessary. A proposed solution for AspectJ uses a layered approach which builds upon the existing Java Virtual Machine to add support for join point management and callbacks to a Dynamic Aspect-Oriented Programming Engine. An alternative implementation uses a weaving engine that uses breakpoints to halt execution at the pointcut, select an appropriate method, embed it into the application, and continue. The use of breakpoints in this manner {{has been shown to}} reduce performance due to {{a very large number of}} context switches.|$|E
40|$|AbstractThis paper {{presents}} a verifier for the memory-safe execution of extended Java <b>bytecodes</b> that support region-based memory management and explicit deallocation primitives. The verifier reads in region-annotated <b>bytecodes</b> that augment the standard Java <b>bytecodes</b> with instructions for creating and removing memory regions, allocating objects in regions, and passing regions as parameters. The verification ensures that each region is live when {{objects in the}} region are in use and that the program does not follow dangling references. The verifier requires region-safety certificates to be provided along with the <b>bytecodes.</b> The verification process consists of a load-time verification of method bodies, and a lazy linkage verification of method calls. Our region system supports both regions that are not lexically scoped and dangling pointers; the verifier proposed in this paper can successfully handle both of these features. Our experiments indicate that the sizes of certificates are acceptable in practice, and that region verification incurs little run-time overhead...|$|R
40|$|We discuss an axiomatic {{description}} of a simple abstract machine similar to the Java Virtual Machine (JVM). Our model supports classes, with fields and <b>bytecoded</b> methods, and a representative sampling of JVM <b>bytecodes</b> for basic operations for both data and control. The GETFIELD and PUTFIELD instructions accurately model inheritance, as does the INVOKE-VIRTUAL instruction. Our model supports multiple threads, synchronized methods, and monitors. Our current model is inadequate or inaccurat...|$|R
30|$|The {{proposed}} {{architecture is}} open-source and all design files are available ([URL] The instruction {{timing of the}} <b>bytecodes</b> is documented.|$|R
25|$|The gcj Java {{compiler}} can target {{either a}} native machine language architecture or the Java virtual machine's Java <b>bytecode.</b> When retargeting GCC {{to a new}} platform, bootstrapping is often used.|$|E
25|$|The {{essential}} {{components in}} the platform are the Java language compiler, the libraries, and the runtime environment in which Java intermediate <b>bytecode</b> executes {{according to the rules}} laid out in the virtual machine specification.|$|E
25|$|Longer {{application}} {{start up}} time. Applications must be verified {{when they are}} started to ensure they have been compiled by the correct compiler, or may need recompiling either from source code or from <b>bytecode.</b>|$|E
5000|$|Intermediate language: {{instrumentation}} {{added to}} assembly or decompiled <b>bytecodes</b> giving support for multiple higher-level source languages and avoiding (non-symbolic) binary offset re-writing issues.|$|R
3000|$|We {{compare the}} time-predictable JOP design with picoJava [63, 64], a Java {{processor}} designed for average-case performance. Simple <b>bytecodes</b> are directly {{supported by the}} processor. Most of them execute in a single cycle. More complex <b>bytecodes</b> trap to a software routine. However, the invocation time of the trap depends on the cache state and is between 6 cycles in the best case and 426 cycles in the worst case—a factor {{in the order of}} two magnitudes. Some of the trapped instructions (e.g., [...]...|$|R
40|$|This paper {{describes}} the optimizations introduced in Juice, a J 2 ME virtual machine for embedded systems. These optimizations {{are designed to}} make possible {{the determination of the}} WCET of the JVM <b>bytecodes</b> related to object and array management. The solution proposed, which is based on subdividing the heap in a set of chunks of fixed size, allows to execute those <b>bytecodes</b> either in a constant time or in a linear time with an upper bound that can be determined. ...|$|R
25|$|The Haskell User's Gofer System (Hugs) is a <b>bytecode</b> interpreter. It {{was once}} one of the {{implementations}} used most widely, alongside the GHC compiler, but has now been mostly replaced by GHCi. It also comes with a graphics library.|$|E
25|$|Just in time compilers pre-compile {{computer}} programs just before execution. For example, the Java virtual machine Hotspot contains a Just In Time Compiler which selectively compiles Java <b>bytecode</b> into machine code - but only code which Hotspot predicts {{is likely to}} be used many times.|$|E
25|$|The {{differences}} between the two languages are more prominent than their similarities. Java has static typing, while JavaScript's typing is dynamic. Java is loaded from compiled <b>bytecode,</b> while JavaScript is loaded as human-readable source code. Java's objects are class-based, while JavaScript's are prototype-based. Finally, Java did not support functional programming until Java 8, while JavaScript has done so from the beginning, being influenced by Scheme.|$|E
5000|$|A {{platform}} dependent {{implementation of}} the Java virtual machine that is {{the means by which}} the <b>bytecodes</b> of the Java libraries and third party applications are executed ...|$|R
5000|$|Note, however, {{addresses}} in [...] for , , etc., are {{two or more}} bytes, {{compared to}} one byte, typically, for the decode and dispatch interpreter described above. In general, instructions for a decode and dispatch interpreter may be any size. For example, a decode and dispatch interpreter to simulate an Intel Pentium decodes instructions that range from 1 to 16 bytes. However, <b>bytecoded</b> systems typically choose 1-byte codes for the most-common operations. Thus, the thread often has a higher space cost than <b>bytecodes.</b> In most uses, the reduction in decode cost outweighs the increase in space cost.|$|R
40|$|We discuss an axiomatic {{description}} of a simple abstract machine similar to the Java Virtual Machine (JVM). Our model supports classes, with fields and <b>bytecoded</b> methods, and a representative sampling of JVM <b>bytecodes</b> for basic operations for both data and control. The GETFIELD and PUTFIELD instructions accurately model inheritance, as does the INVOKEVIRTUAL instruction. Our model supports multiple threads, synchronized methods, and monitors. Our current model is inadequate or inaccurate in many respects (e. g., we do not formalize the JVM's finite arithmetic nor do we describe class loading and initialization). But the model is {{a useful tool for}} studying the application of formal reasoning to the JVM and to Java programs. We demonstrate two useful aspects of an operational formal semantics. First, the model is executable: <b>bytecoded</b> methods can be run on the model. Second, the model allows us to prove theorems about those methods or, more generally, about the model. Because the [...] ...|$|R
25|$|In recent years, {{researchers}} have discovered numerous security flaws in some widely used Java implementations, including Oracle's, which allow untrusted code {{to bypass the}} sandboxing mechanism, exposing users to malicious attacks. These flaws affect only Java applications which execute arbitrary untrusted <b>bytecode,</b> such as web browser plug-ins that run Java applets downloaded from public websites. Applications where the user trusts, and has full control over, all code that is being executed are unaffected.|$|E
25|$|The Ericsson Erlang {{implementation}} loads {{virtual machine}} <b>bytecode</b> which {{is converted to}} threaded code at load time. It also includes a native code compiler on most platforms, developed by the High Performance Erlang Project (HiPE) at Uppsala University. Since October 2001 the HiPE system is fully integrated in Ericsson's Open Source Erlang/OTP system. It also supports interpreting, directly from source code via abstract syntax tree, via script as of R11B-5 release of Erlang.|$|E
25|$|Java <b>bytecode</b> {{can either}} be {{interpreted}} at run time by a virtual machine, {{or it can be}} compiled at load time or runtime into native code which runs directly on the computer's hardware. Interpretation is slower than native execution, and compilation at load time or runtime has an initial performance penalty for the compilation. Modern performant JVM implementations all use the compilation approach, so after the initial startup time the performance is equivalent to native code.|$|E
40|$|The {{execution}} {{performance of}} a stack-based Java virtual machine (JVM) {{is limited by the}} true data dependency. To enhance the performance of the JVM, a stack operations folding mechanism for the picoJava-I/II processor was proposed by Sun Microsystems to fold 42. 3 % stack operations. By comparing the continuous <b>bytecodes</b> with pre-defined folding patterns in instruction decoder, the number of push/pop operations in between the operand stack and the local variable could be reduced. In this study, an enhanced POC (EPOC) folding model is proposed to further fold the discontinuous <b>bytecodes</b> that cannot be folded in continuous <b>bytecodes</b> folding mechanisms. By proposing a stack re-order buffer (SROB) to help the folding check processes, the EPOC folding model can fold the stack operations perfectly with a small size of SROB implementation. Statistical data shows that the four-foldable strategy of the EPOC folding model can eliminate 98. 8 % of push/pop operations with an instruction buffer size of 7 bytes and the SROB size of eight entries...|$|R
50|$|Java backporting {{tools are}} {{programs}} (usually written in Java) that convert Java classes <b>bytecodes</b> from {{one version of}} the Java Platform to an older one (for example Java 5.0 backported to 1.4).|$|R
50|$|When compiled, {{a program}} written in POSXML, becomes {{a set of}} <b>bytecodes</b> that are {{interpreted}} by the virtual machine on the POS terminal which results in the implementation on the POS terminal.|$|R
