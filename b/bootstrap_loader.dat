41|11|Public
5|$|The default <b>bootstrap</b> <b>loader</b> is GNU GRUB version 2, {{though the}} package name is simply grub, while version 1 was renamed to grub-legacy. This {{conflicts}} with e.g. Fedora, where grub version 2 is named grub2.|$|E
25|$|While {{many other}} vendors have {{continued}} to utilize a single-sector setup (logical sector 0 only) for the <b>bootstrap</b> <b>loader,</b> Microsoft's boot sector code has grown to span over logical sectors 0 and 2 since the introduction of FAT32, with logical sector 0 depending on sub-routines in logical sector 2. The Backup Boot Sector area consists of three logical sectors 6, 7, and 8 as well. In some cases, Microsoft also uses sector 12 of the reserved sectors area for an extended boot loader.|$|E
25|$|In theory, real-mode {{applications}} {{could be}} directly executed in 16-bit protected mode if certain rules (newly proposed {{with the introduction}} of the 80286) were followed; however, as many DOS programs did not conform to those rules, protected mode was not widely used until the appearance of its successor, the 32-bit Intel 80386, which was designed to go back and forth between modes easily and to provide an emulation of real mode within protected mode. When Intel designed the 286, it was not designed to be able to multitask real-mode applications; real mode was intended to be a simple way for a <b>bootstrap</b> <b>loader</b> to prepare the system and then switch to protected mode; essentially, in protected mode the 80286 was designed to be a new processor with many similarities to its predecessors, while real mode on the 80286 was offered for smaller-scale systems that could benefit from a more advanced version of the 80186 CPU core, with advantages such as higher clock rates, faster instruction execution (measured in clock cycles), and unmultiplexed buses, but not the 24-bit (16 MB) memory space.|$|E
5000|$|Booting. Early {{microcomputers}} {{often used}} self-modifying code in their bootloaders. Since the bootloader was keyed in via the front panel at every power-on, {{it did not}} matter if the bootloader modified itself. However, even today many <b>bootstrap</b> <b>loaders</b> are self-relocating, and a few are even self-modifying.|$|R
5000|$|The CPU had a microprocessor, {{which was}} {{defined in the}} manual as a {{portmanteau}} of [...] "microcode processor" [...] - {{not to be confused}} with the then nascent microprocessor. The CPU additionally contained instructions, operator communication, <b>bootstrap</b> <b>loaders,</b> and hardware test programs, that were implemented in a 1K read-only memory.|$|R
50|$|In general, {{there are}} two types of class loader: <b>bootstrap</b> class <b>loader</b> and user defined class loader.|$|R
2500|$|To load a system, a 24-byte {{data area}} is loaded into main storage {{from the first}} block of the {{selected}} IPL device at location 0 and {{the second and third}} 8 byte data areas, which are Read IPL-type CCWs, are initiated from the [...] "implied" [...] CCW, and this channel program continuation causes the first portion of the system loading software to be loaded elsewhere in main storage. The first 8 byte data area contains a PSW which, when fetched {{at the conclusion of the}} IPL, causes the CPU to branch to the <b>bootstrap</b> <b>loader</b> (called [...] "IPL Text") at the main storage address where it was just loaded. The IPL Text is then executed, and eventually the operating system's nucleus is loaded and is branched to, after which normal OS operations commences.|$|E
2500|$|On {{a typical}} PowerPC-based Macintosh system, the boot process {{includes}} loading a <b>bootstrap</b> <b>loader</b> from ROM, loading the Process Manager {{stored in the}} boot blocks of the startup device, locating a [...] "blessed" [...] System Folder on the startup device, and then loading Finder. However, because the Pippin platform ran only on non-writable CD-ROM, a modification to the boot process had to be made. For developers who were using standard 7.5.2 system software, a [...] "PippinFinder" [...] was installed into the System Folder, allowing the CD-ROM to be bootable on a Pippin-based system. Once development was finalized, PippinFinder {{was removed from the}} System Folder, and the Pippin-specific system software was placed onto the build. In addition, an alias of the main executable was placed into the Startup Items folder, so that upon bootup, the application will launch automatically. Developers are constrained to the base hardware profile of the Pippin platform, using no hard drive cache for downloaded content, and sharing 128 KB of NVRAM with the system.|$|E
5000|$|... 0x0C00-0x0FFF : 1024 bytes of <b>bootstrap</b> <b>loader</b> ROM (flash parts only).|$|E
50|$|Every Java {{virtual machine}} {{implementation}} {{must have a}} <b>bootstrap</b> class <b>loader,</b> capable of loading trusted classes. The Java virtual machine specification doesn't specify how a class loader should locate classes.|$|R
50|$|Minicomputers, {{starting}} with the Digital Equipment Corporation (DEC) PDP-5 and PDP-8 (1965) simplified design by using the CPU to assist input and output operations. This saved cost but made booting more complicated than pressing a single button. Minicomputers typically had some way to toggle in short programs by manipulating an array of switches on the front panel. Since the early minicomputers used magnetic core memory, which did not lose its information when power was off, these <b>bootstrap</b> <b>loaders</b> would remain in place unless they were erased. Erasure sometimes happened accidentally when a program bug caused a loop that overwrote all of memory.|$|R
5000|$|Almost all of JCL {{is stored}} in a single Java archive file called [...] "rt.jar", which is {{provided}} with JRE and JDK distributions. The Java Class Library (rt.jar) {{is located in the}} default bootstrap classpath, and does not have to appear in the classpath declared for the application. The runtime uses the <b>bootstrap</b> class <b>loader</b> to find the JCL.|$|R
50|$|These {{techniques}} could {{generally be}} easily circumvented since the code {{to read the}} bad sectors was usually in the <b>bootstrap</b> <b>loader</b> on the disk itself, so by reverse engineering and rewriting the <b>bootstrap</b> <b>loader,</b> it would not look for the bad sectors, and the comparison for a known bit pattern {{would have to be}} encoded there, too.|$|E
50|$|A RAM {{image is}} a {{sequence}} of machine code instructions and associated data kept permanently in the non-volatile ROM memory of an embedded system, which is copied into volatile RAM by a <b>bootstrap</b> <b>loader.</b> Typically the RAM image is loaded into RAM when the system is switched on, and it contains a second-level <b>bootstrap</b> <b>loader</b> and basic hardware drivers, enabling the unit to function as desired, or else more sophisticated software to be loaded into the system.|$|E
50|$|In {{the case}} of a computer, the POST {{routines}} are part of a device's pre-boot sequence; if they complete successfully, the <b>bootstrap</b> <b>loader</b> code is invoked to load an operating system.|$|E
5000|$|Ascher Opler {{coined the}} term [...] "firmware" [...] in a 1967 Datamation article. Originally, it meant the {{contents}} of a writable control store (a small specialized high speed memory), containing microcode that defined and implemented the computer's instruction set, and that could be reloaded to specialize or modify the instructions that the central processing unit (CPU) could execute. As originally used, firmware contrasted with hardware (the CPU itself) and software (normal instructions executing on a CPU). It was not composed of CPU machine instructions, but of lower-level microcode involved in the implementation of machine instructions. It existed on the boundary between hardware and software; thus the name [...] "firmware". Over time, popular usage extended the word [...] "firmware" [...] to denote any computer program that is tightly linked to hardware, including processor machine instructions for BIOS, <b>bootstrap</b> <b>loaders,</b> or the control systems for simple electronic devices such as a microwave oven, remote control, or computer peripheral.|$|R
50|$|The boot code in the VBR {{can assume}} that the BIOS has set up its data {{structures}} and interrupts and initialized the hardware. The code should not assume more than 32 KB of memory to be present for fail-safe operation; if it needs more memory it should query INT 12h for it, since other pre-boot code (such as f.e. BIOS extension overlays, encryption systems, or remote <b>bootstrap</b> <b>loaders)</b> may be present elsewhere in memory as well (and would typically hide themselves from the boot sector by reducing the reported INT 12h memory accordingly, {{so that they do}} not get overwritten by the MBR's and VBR's actions). The BIOS Boot Specification allows for 64 KB of memory and explicitly recommends 0000h:7C00h to 0000h:FFFFh as a temporary scratchpad. The boot code must not assume better CPUs than the original Intel 8088 or 8086 (used in the original PC) and make no assumptions in regard to the exact state of the hardware, the interrupt system (interrupts can be enabled or disabled) or the location and size of the stack. Although the original IBM BIOS initializes the DS, ES, and SS CPU registers to segment 0000h and maintains the initial stack at SS:SP = 0000h:0400h, this is not a condition to rely on, as not all BIOSes and MBR codes follow this convention. Registers not mentioned below must be treated as not initialized. Direct hardware access is not normally allowed. While the Disk Parameter Table (DPT/FDPB) is typically set up at 0000h:0078h in memory already, the VBR must move (and possibly fix-up) the DPT pointed to by INT 1Eh vector to this location (INT 1Eh not an interrupt, but a far pointer to the DPT).|$|R
40|$|This {{paper will}} {{introduce}} a new aspect-oriented framework for the Java language called AspectWerkz. The AspectWerkz framework is tailored for dynamic aspect-oriented programming. It has been designed for simplicity {{and ease of use}} in real-world applications, both J 2 EE and regular Java based. AspectWerkz utilizes load time bytecode modification to weave classes at load time. It hooks in and weaves classes loaded by any class <b>loader</b> except the <b>bootstrap</b> class <b>loader.</b> It is high-performant and has a rich join point model. Aspects, advices and introductions are written in plain Java and the target classes can be regular Java objects. It is dynamic {{in the sense that it}} is possible to add, remove and restructure advices as well as swapping the implementation of the introductions at runtime. Aspects can be defined using either XML or runtime attributes...|$|R
50|$|The default <b>bootstrap</b> <b>loader</b> is GNU GRUB version 2, {{though the}} package name is simply grub, while version 1 was renamed to grub-legacy. This {{conflicts}} with e.g. Fedora, where grub version 2 is named grub2.|$|E
50|$|The <b>bootstrap</b> <b>loader</b> {{takes the}} {{control over the}} booting process and loads NTLDR.Ntdetect.com is invoked by NTLDR, and returns the {{information}} it gathers to NTLDR when finished, {{so that it can}} then be passed on to ntoskrnl.exe, the Windows NT kernel.|$|E
50|$|The MBR {{is loaded}} at memory {{location}} 0000hex:7C00hex {{and with the}} following CPU registers set up when the prior <b>bootstrap</b> <b>loader</b> (normally the IPL in the BIOS) passes execution to it by jumping to 0000hex:7C00hex in the CPU's real mode.|$|E
5000|$|Among {{the latest}} and independently-developed {{versions}} of DR-DOS were OEM DR-DOS 7.04 (as of 19 August 1999) and 7.05 (as of 30 November 1999), still branded as [...] "Caldera DR-DOS". These were variants of the system consisting only of the kernel and command shell. With a specialized native implementation of FAT32 and large hard disk support they could be found bundled with Ontrack's Easy Recovery 5 in 2000, replacing the dynamically-loadable DRFAT32 redirector driver, which still came with Easy Recovery 4. They were also used for Seagate Technology's SeaTools and the CD imaging software Nero Burning ROM. While still reporting a BDOS 7.3 internally, these were the first versions to report themselves as [...] "PC DOS 7.10" [...] to applications in order to indicate integrated FAT32 support. Designed to be mostly backwards-compatible, the DR-DOS 7.04/7.05 IBMBIO.COM could be combined with the DR-DOS 7.03 IBMDOS.COM {{in order to give}} the desktop-approved DR-DOS 7.03 kernel LBA capabilities and work with drives larger than 8 GB. For specific OEM requirements, DR-DOS 7.06 by Wightman combined the kernel files into a single binary executable, so that, similar to IO.SYS of Windows 98, it could be booted by MS-DOS 7.10 boot sectors (but no longer by DR-DOS boot sectors). DR-DOS 7.07 (with BDOS 7.4/7.7) by Paul introduced new <b>bootstrap</b> <b>loaders</b> and updated disk tools in order to combine support for CHS and LBA disk access, the FAT12, FAT16 and FAT32 file systems, and the differing bootstrapping conventions of DR-DOS, PC DOS, MS-DOS, Windows, REAL/32 and LOADER into a single MBR and boot sector, so that the code would continue to load any version of DR-DOS down to 3.31 (and since DR-DOS 7.04 also with FAT32 support), but could also be used to launch the PC DOS or MS-DOS system files, including those of Windows 9x and PC DOS 7.10. At the same time the kernel could not only be booted by the new sectors, but also by any previously DR-DOS formatted disks, as well as off disks with existing PC DOS or MS-DOS boot sectors {{and a variety of other}} boot-loaders, thereby easing the coexistence and setup of multi-boot scenarios in conjunction with other operating systems.|$|R
40|$|Abstract The indirection {{of object}} accesses {{is a common}} theme for target domains as diverse as {{transparent}} distribution, persistence, and program instrumentation. Virtualizing accesses to fields and methods (by redirecting calls through accessor and indirection methods) allows interposition of arbitrary code, extending the functionality of an application beyond that intended by the original developer. We present class modifications performed by our RuggedJ transparent distribution platform for standard Java virtual machines. RuggedJ abstracts over the location of objects by implementing a single object model for local and remote objects. However the implementation of this model {{is complicated by the}} presence of native and system code; classes loaded by Java’s <b>bootstrap</b> class <b>loader</b> can be rewritten only in a limited manner, and so cannot be modified to conform to RuggedJ’s complex object model. We observe that system code comprises the majority of a given Java application: an average of 78 % in the applications we study. We consider the constraints imposed upon pervasive class transformation within Java, and present a framework for systematically rewriting arbitrary applications. Our system accommodates all system classes, allowing both user and system classes alike to be referenced using a single object model...|$|R
50|$|The VBR {{is loaded}} at memory {{location}} 0000h:7C00h {{and with the}} following CPU registers set up when the prior <b>bootstrap</b> <b>loader</b> (that is, typically the BIOS or MBR, but possibly another boot loader) passes execution to it by jumping to 0000h:7C00h in the CPU's real mode.|$|E
50|$|As {{initially}} {{introduced the}} Level 6 {{consisted of three}} models: the 6/06, the 6/34, and the 6/36. The CPU featured a real-time clock, a ROM <b>bootstrap</b> <b>loader</b> and 64 interrupt levels. The architecture provided a variety of addressing modes and 18 programmer-visible registers. Rack-mount and tabletop versions were available.|$|E
50|$|The small {{program that}} starts this {{sequence}} {{is known as}} a <b>bootstrap</b> <b>loader,</b> bootstrap or boot loader. This small program's only job is to load other data and programs which are then executed from RAM. Often, multiple-stage boot loaders are used, during which several programs of increasing complexity load one after the other in a process of chain loading.|$|E
50|$|There was a {{hierarchy}} of device drivers: those ending in Z were for Fortran, such as DISKZ, while assembler programmers might use DISK0, and DISK1 was even faster at reading multiple disk sectors. But DISKZ started its sector addressing with the first available unused sector, while the others started with sector zero of the disk, making it easy for a Fortran programmer dabbling in assembler to inadvertently overwrite the <b>bootstrap</b> <b>loader.</b>|$|E
5000|$|The DMA {{controller}} {{also provides}} a special [...] "load mode", which allows loading of memory while the CLEAR and WAIT inputs of the processor are active. This allows a program to be loaded {{without the need for}} a ROM-based <b>bootstrap</b> <b>loader.</b> This was used by the COSMAC Elf microcomputer and its successors to load a program from toggle switches or a hexadecimal keypad with no required software and minimal hardware.|$|E
5000|$|A user would {{normally}} use the [...] "(L)oad" [...] command to load a <b>bootstrap</b> <b>loader</b> (i.e., for CP/M) from a floppy or the fixed disk. One could also access a [...] "(T)ypewriter" [...] mode for direct interface with the serial printer port and basic typing on screen. [...] "(H)ost terminal" [...] {{would allow the}} 820-II to interface as a terminal via either of the serial ports, as specified, at up to 19.2 kbit/s.|$|E
5000|$|The <b>bootstrap</b> <b>loader</b> on PC-compatible {{computers}} (MBR or boot sector) {{is located}} at track zero, the first sector on a disk. The ROM BIOS will load this sector into memory at address :, and typically check for a signature [...] "" [...] at offset [...] If the sector is {{not considered to be}} valid, the ROM BIOS will try the next physical disk in the row, otherwise it will jump to the load address with certain registers set up.|$|E
5000|$|As {{time went}} on and BASIC was no longer shipped on all PCs, this {{interrupt}} would simply display an error message indicating that no bootable volume was found (famously, [...] "No ROM BASIC", or more explanatory messages in later BIOS versions); in other BIOS versions it would prompt the user to insert a bootable volume and press a key, and then after the user pressed a key it would loop back to the <b>bootstrap</b> <b>loader</b> (INT 19h) to try booting again.|$|E
5000|$|While {{many other}} vendors have {{continued}} to utilize a single-sector setup (logical sector 0 only) for the <b>bootstrap</b> <b>loader,</b> Microsoft's boot sector code has grown to span over logical sectors 0 and 2 since the introduction of FAT32, with logical sector 0 depending on sub-routines in logical sector 2. The Backup Boot Sector area consists of three logical sectors 6, 7, and 8 as well. In some cases, Microsoft also uses sector 12 of the reserved sectors area for an extended boot loader.|$|E
50|$|The term boot {{comes from}} the idea of lifting oneself by one's own bootstraps: the {{computer}} contains a tiny program (<b>bootstrap</b> <b>loader)</b> which will load and run a program found on a boot device. This program may itself be a small program designed to load a larger and more capable program, i.e., the full operating system. To enable booting without the requirement either for a mass storage device or to write to the boot medium, it is usual for the boot program to use some system RAM as a RAM disk for temporary file storage.|$|E
50|$|The {{operator}} then {{removed the}} bootstrap tape, snapped {{in the tape}} containing the regular loader, carefully arranging it so it wouldn't jam, and pressed a few more buttons to start up the bootstrap program. Once the regular loader was in, the computer was ready to read in a program tape. The regular loader read a more compact format tape than the <b>bootstrap</b> <b>loader.</b> Each block began with a starting address so the tape could be rewound and retried if an error occurred. If any mistakes {{were made in the}} process, or if the program crashed and damaged the loader program, the process had to be restarted from the beginning.|$|E
5000|$|The Windows Registry is {{structured}} into hives. Each hive {{is kept in}} a separate file (in the directory [...] {{of the system and}} boot partition). When a Windows system boots, the <b>bootstrap</b> <b>loader</b> (the same that loads the kernel and other boot files, such as boot drivers, from the boot partition) loads the SYSTEM file into memory. A great deal of crucial information is kept in the SYSTEM hive, including information about what drivers to use with what devices, what software to run initially, and many parameters governing the operation of the system. The conventions for the arrangement of configuration information are poorly defined.|$|E
50|$|A {{very small}} (about 20 instructions) <b>bootstrap</b> <b>loader</b> {{could be held}} at the front of each program tape, but even this {{approach}} was not always used. Tape labels were (with the exception of COBOL and Tape Control managed applications) almost non-existent. A grandfather/father/son cycle of tape rotation protected production tapes from major disasters, but required careful manual controls. Programmers (or for operational suites Production Control staff) gave the operator written instructions on which program tape and data tapes to load, on which devices, and a written summary of how to load and initiate each program. The operator would then load the tapes, and load and initiate each program in turn manually from the console.|$|E
