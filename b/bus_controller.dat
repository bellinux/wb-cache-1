140|110|Public
25|$|Windows NT uses kernel-mode device {{drivers to}} {{enable it to}} {{interact}} with hardware devices. Each of the drivers has well defined system routines and internal routines that it exports {{to the rest of}} the operating system. All devices are seen by user mode code as a file object in the I/O manager, though to the I/O manager itself the devices are seen as device objects, which it defines as either file, device or driver objects. Kernel mode drivers exist in three levels: highest level drivers, intermediate drivers and low level drivers. The highest level drivers, such as file system drivers for FAT and NTFS, rely on intermediate drivers. Intermediate drivers consist of function drivers—or main driver for a device—that are optionally sandwiched between lower and higher level filter drivers. The function driver then relies on a bus driver—or a driver that services a <b>bus</b> <b>controller,</b> adapter, or bridge—which can have an optional bus filter driver that sits between itself and the function driver. Intermediate drivers rely on the lowest level drivers to function. The Windows Driver Model (WDM) exists in the intermediate layer. The lowest level drivers are either legacy Windows NT device drivers that control a device directly or can be a PnP hardware bus. These lower level drivers directly control hardware and do not rely on any other drivers.|$|E
5000|$|Alternatively, a BM {{is used in}} {{conjunction}} with a Backup <b>Bus</b> <b>Controller.</b> This allows the Backup <b>Bus</b> <b>Controller</b> to [...] "hit the ground running", if it is called upon to become the active <b>Bus</b> <b>Controller.</b>|$|E
5000|$|VIBRA16S, {{the first}} revision, with an {{external}} YMF262/YMF289 OPL-3 or CT1978 CQM synthesis chip. The CT2501, CT2502 and CT2504 chips are ViBRA16S parts. The smaller CT2504 does not incorporate a <b>bus</b> <b>controller,</b> and {{may depend on}} external jumpers or a Plug and Play-compatible CT1705 chip for its logical configuration. The larger CT2501 and CT2502 integrate the <b>bus</b> <b>controller.</b>|$|E
50|$|More recently, the AT89 {{series has}} been {{augmented}} with 8051-cored special function microcontrollers, {{specifically in the}} areas of USB, I²C (two wire interface), SPI and CAN <b>bus</b> <b>controllers,</b> MP3 decoders and hardware PWM.|$|R
50|$|The zEC12 chip has {{on board}} {{multi-channel}} DDR3 RAM memory controller supporting a RAID like configuration {{to recover from}} memory faults. The zEC12 also includes two GX <b>bus</b> <b>controllers</b> for accessing host channel adapters and peripherals.|$|R
50|$|LSI Logic started {{developing}} its CoreWare technology in 1992. In 1993, Sony Computer Entertainment chose LSI Logic as their ASIC partner, charged with fitting the PlayStation CPU {{on a single}} chip. LSI’s CoreWare could do it, while other offers made to Sony needed two chips. Sony also worked with LSI’s engineers develop the graphics engine, DMA <b>controller,</b> I/O and <b>bus</b> <b>controllers.</b>|$|R
5000|$|In April 2012, NXP {{announced}} the LPC11C00 series with a CAN <b>bus</b> <b>controller.</b>|$|E
50|$|There is {{only one}} <b>Bus</b> <b>Controller</b> at a time on any MIL-STD-1553 bus. It initiates all message {{communication}} over the bus.|$|E
5000|$|Six {{types of}} {{transactions}} are allowed between the BC and a specific RT or between the <b>Bus</b> <b>Controller</b> {{and a pair of}} RTs: ...|$|E
50|$|Removal {{of serial}} <b>bus</b> <b>controllers</b> from the Intel uncore further enables {{increased}} performance {{by allowing the}} uncore clock (UCLK) to run at a base of 2.66 GHz, with upwards overclocking limits in excess of 3.44 GHz. This increased clock rate allows the core to access critical functions (such as the iMC) with significantly less latency, typically reducing core access to DRAM by 10 ns or more.|$|R
40|$|Abstract An {{important}} {{function of the}} bus voltage con-troller of voltage-source inverters (VSI) for distributed generation (DG) applications is to control the balance be-tween ac and dc power. Nevertheless is the <b>bus</b> voltage <b>controller</b> not the critical part of {{the control of the}} VSI. Therefore it is justified that little attention is paid to the design of this <b>bus</b> voltage <b>controller</b> what can be seen in literature. However, this controller can (negatively) influ-ence the behaviour of the VSI. In three-phase systems a ripple can exist in the bus voltage due to unbalance or har-monics present in the grid voltage or current. This rip-ple can interact with the <b>bus</b> voltage <b>controller</b> which can have negative consequences on the injected current. Also the timing of updating the output of the bus voltage con-troller can have consequences on the waveform distortion which can result in oscillations. In this paper {{the focus is on the}} timing of updating. An overview of three possible <b>bus</b> voltage <b>controllers</b> is given. The response of the differ-ent implementations of dc-bus voltage controllers during a transient is simulated. Keywords model, digital control, three phase voltage-source inverter (VSI), distributed generation, neutral-point-clamped VSI 1...|$|R
50|$|By {{encoding}} {{control signals}} serially {{they could be}} AC-coupled (with a transformer)to prevent ground loop problems and EMI issues between the controller and the drives, which could be connected by long cables, even to different floors in a building. The same serial interconnect was used for tape and solid state storage devices to the storage subsystem controllers. Large VAX systems primarily used the Hierarchical Storage Controller (HSC) series but Unibus and BI <b>Bus</b> <b>controllers</b> to SDI were built as well. The UDA50 for the Unibus was the first controller shipped with the SDI interface.|$|R
50|$|The Intel 82288 is a <b>bus</b> <b>controller</b> {{designed}} for Intel 80286. The chip is supplied in 20-pin DIP package. It replaces 8288 used with earlier processors.|$|E
50|$|Buster is the {{expansion}} <b>BUS</b> <b>conTrollER</b> {{and was used}} in the Amiga 2000(B), integrating discrete logic from the original A2000(A). Buster controls bus arbitration and DMA for the Zorro II expansion subsystem.|$|E
5000|$|RT to Controller Transfer. The <b>Bus</b> <b>Controller</b> sends one {{transmit}} command word to a Remote Terminal. The Remote Terminal then sends {{a single}} Status word, immediately followed by 1 to 32 words.|$|E
5000|$|... "Uncore" [...] is a {{term used}} by Intel to {{describe}} the functions of a microprocessor {{that are not in}} the core, but which must be closely connected to the core to achieve high performance. It has been called [...] "system agent" [...] since the release of the Sandy Bridge Intel microarchitecture. [...] The core contains the components of the processor involved in executing instructions, including the ALU, FPU, L1 and L2 cache. Uncore functions include QPI controllers, L3 cache, snoop agent pipeline, on-die memory controller, and Thunderbolt <b>controller.</b> [...] Other <b>bus</b> <b>controllers</b> such as SPI and LPC are part of the chipset.|$|R
50|$|Serial ATA (SATA, {{abbreviated}} from Serial AT Attachment) is {{a computer}} bus interface that connects host bus adapters to mass storage devices such as hard disk drives, optical drives, and solid-state drives. Serial ATA succeeded the older Parallel ATA (PATA) standard, offering several advantages over the older interface: reduced cable size and cost (seven conductors instead of 40 or 80), native hot swapping, faster data transfer through higher signaling rates, and more efficient transfer through an (optional) I/O queuing protocol. Although, a number of hot plug PATA offering were first invented and marketed by Core International {{beginning in the late}} 1980s for the Micro Channel architecture <b>bus</b> <b>controllers.</b>|$|R
50|$|Although the {{previous}} SOC projects had had only limited success (the M212 {{was in fact}} sold for a time), many designers still firmly believed in the concept and in 1987, a new project, the T100 was started which combined an 8-bit version of the transputer CPU with configurable logic based on state machines. The transputer instruction set is based on 8-bit instructions and can easily be used with any word size which is a multiple of 8 bits. The target market for the T100 was to be <b>bus</b> <b>controllers</b> such as Futurebus, {{as well as an}} upgrade for the standard link adapters (C011 etc.). The project was stopped when the T840 (later to become the basis of the T9000) was started.|$|R
5000|$|Controller to RT Transfer. The <b>Bus</b> <b>Controller</b> sends one 16-bit receive command word, {{immediately}} {{followed by}} 1 to 32 16-bit data words. The selected Remote Terminal then sends a single 16-bit Status word.|$|E
5000|$|Mode Command Without Data Word. The <b>Bus</b> <b>Controller</b> sends one command {{word with}} a Sub-address of 0 or 31 {{signifying}} a Mode Code type command. The Remote Terminal responds with a Status word.|$|E
50|$|However, the {{standard}} does not specify any particular timing for any particular transfer — that's {{up to the}} system designers. Generally (the way it is done on most military aircraft), the <b>Bus</b> <b>Controller</b> has a schedule of transfers that covers the majority of transfers, often organized into a major frame or major cycle, which is often subdivided into minor cycles. In such a cyclic executive schedule structure, transfers that occur in every minor cycle (rate group 1) happen at the highest rate, typically 50 Hz, transfers that occur in every other minor cycle, {{of which there are}} two groups (rate group 2.1 and 2.2) happen at the next highest rate, e.g. 25 Hz. Similarly, there are four groups (3.1, 3.2, 3.3, and 3.4) at, e.g., 12.5 Hz and so on. Hence, where this scheduling structure is used, the transfers are all at harmonically related frequencies, e.g. 50, 25, 12.5, 6.25, 3.125, and 1.5625 Hz (for a major frame comprising 32 minor cycles at 50 Hz).Whilst RTs cannot start a transfer directly on their own, {{the standard}} does include a method for when an RT needs to transmit data that is not automatically scheduled by the <b>Bus</b> <b>Controller.</b> These transfers are often called acyclic transfers as they are outside the structure used by the cyclic executive. In this sequence, an RT requests transmission through a bit in the status word, the Service Request bit. Generally, this causes the <b>Bus</b> <b>Controller</b> to transmit a Transmit Vector Word Mode Code command. However, where an RT only has one possible acyclic transfer, the <b>Bus</b> <b>Controller</b> can skip this part. The vector word is transmitted by the RT as a single 16-bit data word. The format of this vector word is not defined in the standard, so the system designers must specify what values from what RTs mean what action the <b>Bus</b> <b>Controller</b> is to take. This may be to schedule an acyclic transfer either immediately or {{at the end of the}} current minor cycle. This means that the <b>Bus</b> <b>Controller</b> has to poll all the Remote Terminals connected to the data bus, generally at least once in a major cycle. RTs with higher-priority functions (for example, those operating the aircraft control surfaces) are polled more frequently. Lower-priority functions are polled less frequently.|$|E
40|$|PA-RISC is Hewlett-Packard’s (HP) reduced {{instruction}} set computer (RISC) architecture {{that is used}} in its high-performance computer sys-tems (Mahon et al. 1986). Implementations of this architecture have produced some of the most complex processor boards that HP makes (Robinson et al. 1987; Gassman et al. 1987) : They can contain as many as 8 very large scale integrated (VLSI) chips—most of them custom, from central processing units to <b>bus</b> <b>controllers</b> to floating-point pro-cessors—several high-speed random-access memory arrays, one or more high-speed buses with over 100 lines, and many other compo-nents. In large part because of this complexity, the testing of PA-RISC processor boards became a bottleneck, resulting in an undesirable backlog of undiagnosed boards, growing at a rate of 10 percent each month...|$|R
5000|$|The term [...] "Hot Plug" [...] was a {{registered}} trademark {{issued by the}} USPTO and other countries in 1992 under [...] "Computer & Software Products & Electrical & Scientific Products Trademarks". [...] It was invented for computer components including PATA in the late 1980s by Hal Prewitt, founder of Core International. First patent details were disclosed in 1987 in USA [...] and Europe [...] related to development of the technology to connect host bus adapters to mass storage device however the filings were not completed. Core created and in 1990 marketed the world's first disk controller, host adapter, disk drives, disk arrays and power supplies that were hot pluggable or swappable. Initial implementations were on the IBM PS/2 series and Micro Channel architecture <b>bus</b> <b>controllers.</b>|$|R
40|$|Automotive {{architectures}} {{consist of}} multiple {{electronic control units}} (ECUs) which run distributed control applications. Such ECUs are connected to sensors and actuators and communicate via shared buses. Resource arbitration at the ECUs {{and also in the}} communication medium, coupled with variabilities in execution requirements of tasks results in jitter in the signal/data streams existing in the system. As a result, buffers are required at the ECUs and <b>bus</b> <b>controllers.</b> However, these buffers often implement different semantics – FIFO queuing, which is the most straightforward buffering scheme, and data refreshing, where stale data is overwritten by freshly sampled data. Traditional timing and schedulability analysis that are used to compute, e. g., end-to-end delays, in such automotive architectures can only model FIFO buffering. As a result, they return pessimistic delay and resource estimates because in realit...|$|R
5000|$|VIBRA16C, {{the next}} revision, which {{integrates}} Creative's CQM synthesis and a Plug-and-Play compatible <b>bus</b> <b>controller</b> into the CT2505 chip. The CT2505 is also featured as an on-board sound chip on some motherboards and on Asus Media Bus cards.|$|E
50|$|This {{means that}} during a transfer, all {{communication}} is {{started by the}} <b>Bus</b> <b>Controller,</b> and a terminal device cannot start a data transfer on its own. In {{the case of an}} RT to RT transfer the sequence is as follows: An application or function in the subsystem behind the RT interface (e.g. RT1) writes the data that is to be transmitted into a specific (transmit) sub-address (data buffer). The time at which this data is written to the sub-address is not necessarily linked to the time of the transaction, though the interfaces ensure that partially updated data is not transmitted. The <b>Bus</b> <b>controller</b> commands the RT that is the destination of the data (e.g. RT2) to receive the data at a specified (receive) data sub-address and then commands RT1 to transmit from the transmit sub-address specified in the command. RT1 transmits a Status word, indicating its current status, and the data. The <b>Bus</b> <b>Controller</b> receives RT1's status word, and sees that the transmit command has been received and actioned without a problem. RT2 receives the data on the shared data bus and writes it into the designated receive sub-address and transmits its Status word. An application or function on the subsystem behind the receiving RT interface may then access the data. Again the timing of this read is not necessarily linked to that of the transfer. The <b>Bus</b> <b>Controller</b> receives RT2's status word and sees that the receive command and data have been received and actioned without a problem.|$|E
50|$|DIGIBUS (or Digibus) is the French {{equivalent}} of MIL-STD-1553 {{and it is}} similar to MIL-STD-1553 in the same notion of <b>Bus</b> <b>Controller,</b> Remote Terminal, monitor, same transmission speed, but {{the difference is that}} DIGIBUS uses separate links for data and commands.|$|E
40|$|A decentralized, {{hierarchical}} cache-consistency {{scheme is}} presented. This scheme is targeted for shared-memory multiprocessors consisting of processor and memory modules interconnected by {{a hierarchy of}} ring-connected buses. It is shown that this scheme enforces sequential consistency {{without the need for}} complex hardware or complicated protocols. The proposed scheme relies on snooping and the inherent broadcast nature of the rings and station buses. Because responsibility for maintaining consistency lies with the cache and <b>bus</b> <b>controllers,</b> the scheme is scalable. In the development of the consistency scheme, several assumptions are made about the interconnect structure and the processing modules. By examining these assumptions {{in the context of the}} Hector multiprocessor, it is shown that the scheme can be used to enforce sequential consistency in a real multiprocessor. Finally, using address-trace-driven simulations, it is shown that the performance of Hector would not be adversely a [...] ...|$|R
5000|$|The {{essential}} part of the system relies on GPS satellite data that roughly determine the location of a bus down to 100 metres. Data collected from GPS is passed into a Kalman filter, and other data including velocity and temperature is calculated on the bus and transmitted every 30 seconds via GPRS. With the bus network map, this helps the Central System to make a [...] "best guess" [...] of the bus position and depicts the overall image derived from the data provided by all buses, even in areas with poor GPS reception. The Central System can update the countdown signs as before that now has a more accurate prediction derived from all this data. Knowing the location of the <b>bus,</b> <b>controllers</b> have the means to regulate the service more efficiently, and priority can be given to a bus at traffic lights.|$|R
30|$|This project {{uses the}} VisualSim (VS) Architect tool, {{to carry out}} all the {{simulations}} and run the benchmarks on the modeled architectures. The work presented here utilizes the hardware architecture library of VS that includes the processor cores, which can be configured as per our requirements, as well as <b>bus</b> ports, <b>controllers,</b> and memory blocks.|$|R
50|$|The main {{features}} of the MSC 96 family include a large on-chip memory, Register-to-register architecture, three operand instructions, <b>bus</b> <b>controller</b> to allow 8 or 16 bit bus widths, and direct flat addressability of large blocks (256 or more) of registers.|$|E
5000|$|Mode Command With Data Word (Receive). The <b>Bus</b> <b>Controller</b> sends one command {{word with}} a Sub-address of 0 or 31 {{signifying}} a Mode Code type command immediately {{followed by a}} single data word. The Remote Terminal responds with a Status word.|$|E
50|$|A PCI {{architecture}} has {{no central}} DMA controller, unlike ISA. Instead, any PCI component can request {{control of the}} bus ("become the bus master") and request to read from and write to system memory. More precisely, a PCI component requests bus ownership from the PCI <b>bus</b> <b>controller</b> (usually the southbridge in a modern PC design), which will arbitrate if several devices request bus ownership simultaneously, since there can only be one bus master at one time. When the component is granted ownership, it will issue normal read and write commands on the PCI bus, which will be claimed by the <b>bus</b> <b>controller</b> and will be forwarded to the memory controller using a scheme which is specific to every chipset.|$|E
40|$|Most {{battery monitor}} ICs from TI, {{such as the}} bq 2019 and bq 26500, include a single-wire serial data {{interface}} (HDQ <b>bus).</b> Host <b>controllers</b> can use this interface to access various on-chip registers to read-out battery capacity, voltage, and other parameters. The purpose of this application note is to present a solution for interfacing HDQ-enabled battery gas gauge device...|$|R
40|$|Performance of Multicore Shared <b>bus</b> Embedded <b>Controller</b> {{depends on}} how {{effectively}} the sharing resources can be utilized. Common bus in System on Chip {{is one of the}} sharing resources, shared by the multiple master cores and also acting as a channel between master core and slave core (peripherals) or Memories. Arbiter is an authority to use the share...|$|R
40|$|We {{describe}} an approach for incorporating cores into a system-level specification. The {{goal is to}} allow a designer to specify both custom behavior and pre-designed cores at the earliest design stages, and to refine both into implementations in a unified manner. The approach is based on experience with an actual application of a GPSbased navigation system. We use an object-oriented language for specification, representing each core as an object. We define three specification levels, and we evaluate the appropriateness of existing inter-object communication methods for cores. The approach forms the specification basis for the Dalton project. 1 Introduction Increasing chip capacities has led to entire systems being implemented on a single chip. Pre-designed system components like <b>bus</b> <b>controllers</b> and data encoders, which previously {{took the form of}} integrated circuits (IC's), are now becoming available instead as intellectual property cores so that they may be incorporated onto a single [...] ...|$|R
