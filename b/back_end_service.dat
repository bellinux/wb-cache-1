1|9556|Public
40|$|Maple TA is {{a system}} for authoring, administering, and auto-grading web-based student {{assignments}} that has the Maple technical computation system as a <b>back</b> <b>end</b> <b>service.</b> Its strength {{is its ability to}} facilitate authoring, presenting, and automatically grading technical questions with symbolic or numeric answers. We have used it to develop questions for a course introducing problem-solving through technical computation and programming to over 1000 freshmen engineers per year at Drexel University. We have found that additional Maple programming can extend the flexibility of question generation and answer checking. We explain how to use Maple modules to generate questions, answers, and answering checking algorithms in Maple TA. We discuss how this this has changed our software engineering practices in question development and maintenance. ...|$|E
30|$|The current PHP {{implementation}} {{works well}} {{and has been}} stress tested, {{but it may not}} be as scalable as some cloud applications require, and certainly some of the existing <b>back</b> <b>end</b> <b>services</b> that it uses, such as LDAP, the PERMIS delegation service, the PDP, and MySQL database may not be as elastic as many cloud applications require. To make the security APIs and their supporting services horizontally and massively scalable is a huge research and development task in itself and should not be underestimated.|$|R
40|$|In this {{contribution}} {{we consider}} a light weight approach to support software architecture design over the web. We outline the architecture description language we use {{for this purpose}} {{which is based on}} the concept of a self con-tained software component. Based on this con-cept a loosely coupled approach to combine remote repositories is supported. A number of analysis tools are sketched which are available as <b>back</b> <b>end</b> <b>services</b> within this approach. These tools not only allow to check syntactic and semantic properties but also allow to assess a given architecture wrt. quantitative proper-ties like performance...|$|R
40|$|We {{review the}} growing power and {{capability}} of commod-ity computing and communication technologies largely driven by commercial distributed information systems. These systems are built from CORBA, Microsoft's COM, JavaBeans, and rapidly advancing Web ap-proaches. One can abstract these to a three-tier model with largely independent clients {{connected to a}} dis-tributed network of servers. The latter host various services including object and relational databases and of course parallel and sequential computing. High per-formance {{can be obtained by}} combining concurrency at the middle server tier with optimized parallel <b>back</b> <b>end</b> <b>services.</b> The resultant system combines the needed per-formance for large-scale HPCC applications with th...|$|R
50|$|Hoodie is used commercially by the Appback hosting site {{which uses}} hoodie {{to provide a}} <b>Back</b> <b>end</b> as a <b>Service</b> (BaaS), minutes.io web {{application}} and Neighbourhoodie development house.|$|R
40|$|We {{review the}} growing power and {{capability}} of commodity computing and communication technologies largely driven by commercial distributed information systems. These systems are built from CORBA, Microsoft's COM, JavaBeans, and rapidly advancing Web approaches. One can abstract these to a three-tier model with largely independent clients {{connected to a}} distributed network of servers. The latter host various services including object and relational databases and of course parallel and sequential computing. High performance can be obtained bycombining concurrency at the middle server tier with optimized parallel <b>back</b> <b>end</b> <b>services.</b> The resultant system combines the needed performance for large-scale HPCC applications with the rich functionality of commodity systems. Further the architecture with distinct interface, server and specialized service implementation layers, naturally allows advances in each area tobeeasily incorporated. We illustrate how performance can be obtained within a commodity architecture andwepropose a middleware integration approach based on JWORB (Java Web Object Broker) multi-protocol server technology. Examples are given from collaborative systems, support of multidisciplinary interactions, proposed visual HPCC ComponentWare, quantum Monte Carlo and distributed interactive simulations...|$|R
5000|$|Neustar offers {{internal}} and external managed DNS services that {{play a role in}} directing and managing traffic on the Internet, cloud-based DDoS attack protection and website performance management tools. Neustar manages the authoritative directories for the [...]us and [...]biz Internet domains, and acts as the worldwide [...] "registry gateway" [...] for China's [...]cn and Taiwan's [...]tw Internet domains outside of these two countries. Neustar also provides <b>back</b> <b>end</b> registry <b>services</b> for [...]co Top Level Domain. Neustar manages a collection of these directories that maintain addresses to direct, prioritize and manage Internet traffic, and find and resolve Internet queries and top-level domains on behalf of its enterprise customers. Neustar serves as the provider of registry services and manages directories of similar resources, or addresses, that its customers use for access and connectivity.|$|R
40|$|Computational {{web portals}} provide uniform access to remote {{computational}} resources [...] hardware, software, and data [...] by hiding {{the complexity of}} the heterogeneous, distributed, high performance computing <b>back</b> <b>end.</b> These portal <b>services</b> may be implemented in a programming-language and platform independent way using a Web services approach. However, security in Web services for distributed computing systems is an open issue involving multiple security mechanisms and competing standards. In this paper we present an implementation of a flexible, message-based security system that can be bound to multiple mechanism and multiple message formats...|$|R
40|$|A portal is a Web-based {{application}} {{that acts as}} an entry point to distributed resources. Individual portlets in a portal {{can be used to}} integrate information from a variety of back-end Web services. However, when Web services are deployed, they are available to unintended clients not related to the portal so a general solution for authorizing access to them is needed that is integrated with the portal’s own authentication and authorization mechanisms. This paper investigates the feasibility of an implementation of a general purpose solution for authorization between portlets and their <b>back</b> <b>end</b> Web <b>services</b> based on Privilege and Role Management Infrastructure Standards (PERMIS) which uses Web services security standards such as WS-Security and SAML. This solution is also appropriate for authorization across organizational boundaries supporting the inclusion of service resources to a portal which are contributed by many different organizations. A motivating example of instrument sharing based on the CIMA remote instrument access protocol is presented...|$|R
50|$|The Regional Rail SEPTA {{inherited}} from Conrail and its predecessor railroads was almost entirely run with electric-powered multiple unit cars and locomotives. However, Conrail (the Reading before 1976) operated four SEPTA-branded routes under contract throughout the 1970s, {{all of which}} originated from Reading Terminal. The Allentown via Bethlehem, Quakertown, and Lansdale service was gradually cut <b>back.</b> Alentown-Bethlehem <b>service</b> <b>ended</b> in 1979, Bethlehem-Quakertown <b>service</b> <b>ended</b> July 1, 1981, and Quakertown-Lansdale <b>service</b> <b>ended</b> July 27, 1981. Service to Pottsville via Reading and Norristown, also ended July 27, 1981. West Trenton service previously ran to Newark Penn Station; this was cut back to West Trenton on July 1, 1981, with and replacement New Jersey Transit connecting service continuing until December 1982. The final service, Fox Chase-Newtown <b>service,</b> initially <b>ended</b> on July 1, 1981. It was re-established on October 5, 1981 as the Fox Chase Rapid Transit Line, which then ended on January 14, 1983.|$|R
40|$|Smart mobile devices, such as {{smartphones}} and tablets, {{have become}} an integral part of our daily personal and professional lives. These devices are connected to a wide variety of Internet services and host a vast amount of applications, which access, store and process security- and privacy-sensitive data. A rich set of sensors, ranging from microphones and cameras to location and acceleration sensors, allows these applications and their <b>back</b> <b>end</b> <b>services</b> to reason about user behavior. Further, enterprise administrators integrate smart mobile devices into their IT infrastructures to enable comfortable work on the go. Unsurprisingly, this abundance of available high-quality information has made smart mobile devices an interesting target for attackers, and the number of malicious and privacy-intrusive applications has steadily been rising. Detection and mitigation of such malicious behavior are in focus of mobile security research today. In particular, the Android operating system has received special attention by both academia and industry due to its popularity and open-source character. Related work has scrutinized its security architecture, analyzed attack vectors and vulnerabilities and proposed a wide variety of security extensions. While these extensions have diverse goals, many of them constitute modifications of the Android operating system and extend its default permission-based access control model. However, they are not generic and only address specific security and privacy concerns. The goal of this dissertation is to provide generic and extensible system-centric access control architectures, which can serve as a solid foundation for the instantiation of use-case specific security extensions. In doing so, we enable security researchers, enterprise administrators and end users to design, deploy and distribute security extensions without further modification of the underlying operating system. To achieve this goal, we first analyze the mobile device ecosystem and discuss how Android's security architecture aims to address its inherent threats. We proceed to survey related work on Android security, focusing on system-centric security extensions, and derive a set of generic requirements for extensible access control architectures targeting smart mobile devices. We then present two extensible access control architectures, which address these requirements by providing policy-based and programmable interfaces for the instantiation of use-case specific security solutions. By implementing a set of practical use-cases, ranging from context-aware access control, dynamic application behavior analysis to isolation of security domains we demonstrate the advantages of system-centric access control architectures over application-layer approaches. Finally, we conclude this dissertation by discussing an alternative approach, which is based on application-layer deputies and can be deployed whenever practical limitations prohibit the deployment of system-centric solutions...|$|R
50|$|The {{final phase}} is the {{generation}} of the high level code in the <b>back</b> <b>end</b> of the decompiler. Just as a compiler may have several <b>back</b> <b>ends</b> for generating machine code for different architectures, a decompiler may have several <b>back</b> <b>ends</b> for generating high level code in different high level languages.|$|R
40|$|Devices for {{generating}} streamwise vorticity in a boundary includes {{various forms of}} vortex generators. One form of a split-ramp vortex generator includes a first ramp element and a second ramp element with front <b>ends</b> and <b>back</b> <b>ends,</b> ramp surfaces extending between the front <b>ends</b> and the <b>back</b> <b>ends,</b> and vertical surfaces extending between the front <b>ends</b> and the <b>back</b> <b>ends</b> adjacent the ramp surfaces. A flow channel is between the first ramp element and the second ramp element. The <b>back</b> <b>ends</b> of the ramp elements have a height greater than a height of the front ends, and the front ends of the ramp elements have a width greater than a width of the <b>back</b> <b>ends...</b>|$|R
40|$|When {{designing}} for citizens, municipalities often {{focus on}} the <b>back</b> <b>end</b> infrastructure of <b>services</b> while ignoring the user experience. This {{can lead to a}} lack of engagement by citizens and improperly used services. Contemporary issues facing cities today such as waste reduction, and other challenges associated with living in a dense urban core, reinforce the need for a drastic change in the way that people live, work and co-organize as supported by their local government. A two year design research partnership with a local governing body explored the role of participatory design {{in the creation of a}} service touch-point aimed at decreasing contamination in the streams of waste that are recycled in public city spaces. It considers how principles of behavior change can be utilized in this inquiry for designing services that are used by the general public in an urban context. During the course of the project, participatory methodologies are used to facilitate conversations between municipal waste coordinators and designers. Through user observations, ethnographic research, co-creation and user testing this thesis argues for the need for participatory design to create effective services for cities. Through explorations of form, iconography, and systems this inquiry has culminated in the design of a streetscape recycling station and a human centered framework for municipalities called ‘citizen centered services’. SustainabilityBehaviour changeService designGovernment servicesIndustrial designDesign researc...|$|R
40|$|Fr ank Doodeman A <b>back</b> <b>end</b> {{table is}} part of the Amsterdam Compiler Kit (ACK). It is used to produce the actual <b>back</b> <b>end,</b> a program that {{translates}} the intermediate lan-guage family EM to assembly language for some target machine. The table dis-cussed here can be used for two <b>back</b> <b>ends,</b> suitable for in total three machines: the MC 68000 and MC 68010 (the difference between these two is so small that one <b>back</b> <b>end</b> table can be used for either one), or for the MC 68020...|$|R
5000|$|In compilers, {{the front}} end {{translates}} a computer programming source code into an intermediate representation, and the <b>back</b> <b>end</b> works with the intermediate representation to produce code in a computer output language. The <b>back</b> <b>end</b> usually optimizes to produce code that runs faster. The front-end/back-end distinction can separate the parser section that deals with source code and the <b>back</b> <b>end</b> that generates code and optimizes. Some designs, such as GCC, offer choices between multiple front ends (parsing different source languages) or <b>back</b> <b>ends</b> (generating code for different target processors).|$|R
5000|$|The <b>back</b> <b>end</b> {{takes the}} {{optimized}} IR {{from the middle}} end. It may perform more analysis, transformations and optimizations that specific for the target CPU architecture. The <b>back</b> <b>end</b> generates the target-dependent assembly code, performing register allocation in the process. The <b>back</b> <b>end</b> performs instruction scheduling, which re-orders instructions to keep parallel execution units busy by filling delay slots. Although most algorithms for optimization are NP-hard, heuristic techniques are well-developed and currently implemented in production-quality compilers. Typically the output of a <b>back</b> <b>end</b> is machine code specialized for a particular processor and operating system.|$|R
40|$|Includes bibliographical references. This thesis {{discusses}} the University of Cape Town {{implementation of a}} table driven <b>back</b> <b>end</b> processor. The <b>back</b> <b>end</b> processor takes as input an intermediate tree representation of a high level programming language. It produces as output an object text ready for assembly. The specifications of the input tree and the output object are supplied to the <b>back</b> <b>end</b> processor via two tables. The initial motivation for this project was {{the need to provide}} a <b>back</b> <b>end</b> processor capable of taking the DIANA tree output of the University of Cape Town front end processor and producing a corresponding P-code object. The University of Cape Town <b>back</b> <b>end</b> processor is implemented using Pascal and C in a Unix V environment...|$|R
40|$|The <b>back</b> <b>end</b> of a {{compiler}} performs machine-dependent {{tasks and}} lowlevel optimisations that are laborious to implement and di#cult to debug. In addition, in languages that require run-time {{services such as}} garbage collection, the <b>back</b> <b>end</b> must interface with the run-time system to provide those services. The net result is that building a compiler <b>back</b> <b>end</b> entails a high implementation cost...|$|R
50|$|The <b>back</b> <b>end</b> {{which is}} used to detect {{security}} issues in mobile apps is named Sherlock. The front end is known as Irene, and uses Ember as its framework. The front end development team works independent of the <b>back</b> <b>end</b> team and doesn’t need the server to be online during development. The front <b>end</b> and <b>back</b> <b>end</b> deployment processes are also different from each other.|$|R
40|$|This study {{investigates the}} value {{relevance}} of nuclear decommissioning costs and <b>back</b> <b>end</b> costs (nuclear recycle costs), which are accruals related to {{nuclear power plants}} in electric utilities. We analyze the association between those accruals and stock price levels {{at the end of}} fiscal year, based on earnings capitalization model. The findings of this paper are as follows. (1) Recognizing of decommissioning costs and <b>back</b> <b>end</b> costs contribute to increase the quality of earnings of electric companies. Off-balancing regulation, which compels not to recognize some portion of <b>back</b> <b>end</b> costs, distorts the quality of earnings. (2) Decommissioning costs and <b>back</b> <b>end</b> costs, which are measured by estimating of future payments, are value relevant. However, the contents of information differ each other. The result of OLS regression shows that decommissioning costs (<b>back</b> <b>end</b> costs) are positively (negatively) associated with stock price levels. (3) Though both discretionary decommissioning costs and discretionary <b>back</b> <b>end</b> costs are value relevant, two accruals have different information contents. Moreover, the value relevance of income-increasing (negative signed) discretionary accruals is different form that of income-decreasing (positive signed) discretionary accruals. (4) We cannot observe the signaling effect of discretionary accruals reported in some prior studies. (5) As to the <b>back</b> <b>end</b> costs, although in limited case, we find the conservative behavior of estimating the future payments. In Appendix, we detect the income smoothing strategy of electric companies by discretionary estimation of decommissioning costs and <b>back</b> <b>end</b> costs. ...|$|R
50|$|In {{software}} engineering, {{the terms}} front <b>end</b> and <b>back</b> <b>end</b> {{refers to the}} separation of concerns between the presentation layer (front end), and the data access layer (<b>back</b> <b>end)</b> {{of a piece of}} software, or the physical infrastructure or hardware. In the client-server model, the client is usually considered the front end and the server is usually considered the <b>back</b> <b>end,</b> even when some presentation work is actually done on the server.|$|R
40|$|Although I {{have proven}} {{that the general}} problem is undecidable, I show how, for {{machines}} of practical interest, to generate the <b>back</b> <b>end</b> of a compiler. Unlike previous work on generating <b>back</b> <b>ends,</b> I generate the machinedependent components of the <b>back</b> <b>end</b> using only information that is independent of the compiler’s internal data structures and intermediate form. My techniques substantially reduce the burden of retargeting the compiler: although it is still necessary to master the target machine’s instruction set, {{it is not necessary}} to master the data structures and algorithms in the compiler’s <b>back</b> <b>end.</b> Instead, the machine-dependent knowledge is isolated in the declarative machine descriptions. The largest machine-dependent component in a <b>back</b> <b>end</b> is the instruction selector. Previous work has shown that it is difficult to generate a highquality instruction selector. But by adopting the compiler architecture developed by Davidson and Fraser (1984), I can generate a naïve instructio...|$|R
50|$|EMMS has {{multiple}} <b>back</b> <b>ends</b> {{to connect to}} external players so EMMS can support many different audio and video formats, while remaining clean and small itself. EMMS {{is divided into three}} parts, the player <b>back</b> <b>ends,</b> media sources (which can be a local file system or a network stream), and the core player. One of the player <b>back</b> <b>ends</b> connects to MPD. Other backends are available for mplayer and gstreamer. Additional players can be easily defined.|$|R
40|$|This paper {{presents}} a general discriminative training method {{for both the}} front end feature extractor and <b>back</b> <b>end</b> acoustic model of an automatic speech recognition system. The front <b>end</b> and <b>back</b> <b>end</b> parameters are jointly trained using the Rprop algorithm against a maximum mutual information (MMI) objective function. Results are presented on the Aurora 2 noisy English digit recognition task. It is shown that discriminative training of the front <b>end</b> or <b>back</b> <b>end</b> alone can improve accuracy, but joint training is considerably better. 1...|$|R
50|$|Fortunately, {{for this}} and several reasons {{outlined}} later, DNS servers that use such sophisticated database <b>back</b> <b>ends</b> in general rarely use zone transfer as their database replication mechanism in the first place, and usually instead employ the vastly superior distributed database replication mechanisms that the <b>back</b> <b>ends</b> themselves provide.|$|R
40|$|International audienceThis paper {{presents}} architecture {{design and}} performance {{evaluation of a}} <b>back</b> <b>end</b> system used to store, index, manage and visualize water quality measurements collected by sensor networks deployed in rivers, lakes and coastal regions. The embedded communications systems in each sensor node enable ad hoc network operation to relay the measurements to the <b>back</b> <b>end</b> system in charge of managing, processing and providing data to end users and large communities through web interfaces. The {{focus is on the}} <b>back</b> <b>end</b> system architecture description and on the evaluation of its performance...|$|R
50|$|Toasters - The {{dangerous}} <b>back</b> <b>end</b> of a jet.|$|R
5000|$|Demo Storage - An in-memory <b>back</b> <b>end</b> for the {{persistent}} store.|$|R
5000|$|<b>Back</b> <b>end</b> flespi for the {{integration}} of telematics data into business apps ...|$|R
5000|$|... #Caption: In Sri Lanka {{red lights}} of DMUs shows the <b>back</b> <b>end.</b>|$|R
5000|$|... 2012: Science on the <b>Back</b> <b>End,</b> Hauser and Wirth, New York, NY ...|$|R
40|$|A <b>back</b> <b>end</b> {{generator}} {{generates the}} <b>back</b> <b>end</b> of a compiler automatically from a compact {{description of the}} target machine instruction. In traditional approach, machine descriptions used for <b>back</b> <b>end</b> generation, are a set of patterns modeling some selected machine instructions. This makes the machine description speci c to the compiler. On the other hand there are machine description formalisms like nML, VHDL, EDIF etc., which are used to model machines without any dependency on the tools which can make use of those descriptions. Among these machine description languages, nML supports a higher abstraction level by modeling a machine at the instruction level. We use the machine description language nML to generate compiler <b>back</b> <b>ends.</b> We translate nML machine description to input description of a well known compiler system LCC. We have implemented a tool for automatic conversion from nML to LCC description. Contents...|$|R
40|$|Abstract. In this paper, {{we design}} and {{implement}} workflows in Office Automation (OA) systems by using MVC pattern for enterprise routine business processes. Based on the layered design {{theory of the}} MVC design pattern, our implementation is separated in the Model, View and Controller components. Four major functions in our system are the workflow creation, collaboration, automatic document delivery and work flow search. The system consists of a front <b>end</b> and a <b>back</b> <b>end.</b> The front end is developed as a View layer; while the <b>back</b> <b>end</b> is comprised of a Model layer and a Controller layer. SQL Server 2005 is selected as the backend database management system. The database connections and operations are established and performed by the <b>back</b> <b>end.</b> Every module in our system accesses data by using dedicated interfaces, which create data channels from databases {{to the front and}} <b>back</b> <b>ends</b> and keep data consistency in the system...|$|R
50|$|TCAD has {{traditionally}} focused {{mainly on the}} transistor fabrication {{part of the process}} flow ending with the formation of source and drain contacts—also known as front end of line manufacturing. <b>Back</b> <b>end</b> of line manufacturing, e.g. interconnect and dielectric layers are not considered. One reason for delineation is the availability of powerful analysis tools such as electron microscopy techniques, scanning electron microscopy (SEM) and transmission electron microscopy (TEM), which allow for accurate measurement of device geometry. There are no similar tools available for accurate high resolution measurement of dopant or stress profiles.Nevertheless, there is growing interest to investigate the interaction between front <b>end</b> and <b>back</b> <b>end</b> manufacturing steps. For example, <b>back</b> <b>end</b> manufacturing may cause stress in the transistor region changing device performance. These interactions will stimulate the need for better interfaces to <b>back</b> <b>end</b> simulation tools or lead to integration of some of those capabilities into TCAD tools.|$|R
5000|$|... #Subtitle level 3: Clean Air Act Settlement and {{installation}} of <b>Back</b> <b>End</b> Technology ...|$|R
