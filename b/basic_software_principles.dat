0|1484|Public
40|$|This {{research}} project {{was focused on}} developing an electrical cardiac single cell simulator, which employs the FitzHugh-Nagumo model. An object-oriented design, with attributes such as data encapsulation, inheritance, and polymorphism, is implemented. Since ordinary differential equations (ODEs) constitute {{the main part of}} the mathematical model for ionic currents, this project thus demonstrates how an existing software library (Diffpack) can be used to efficiently put into operation Euler and Runge-Kutta numerical methods. The primary goal of this project was to demonstrate <b>basic</b> <b>software</b> engineering <b>principles</b> that extend to the development of advanced and large-scale codes such as real-life electrocardiac simulators. ...|$|R
40|$|ABSTRACT. Current {{e-learning}} {{systems are}} increasing their importance in higher education. However, {{the state of}} the art of e-learning applications, besides {{the state of the}} practice, does not achieve the level of interactivity that current learning theories advocate. In this article, the possibility of enhancing e-learning systems to achieve deep learning has been studied by replicating an experiment in which students had to learn <b>basic</b> <b>software</b> engineering <b>principles.</b> One group learned these principles using a static approach, while the other group learned the same principles using a system-dynamics-based approach which provided interactivity and feedback. The results show that, quantitatively, the latter group achieved a better understanding of the principles; furthermore, qualitatively, they enjoyed the learning experience...|$|R
40|$|Abstract—Current {{e-learning}} {{systems are}} increasing their importance in higher education. However, {{the state of}} the art of e-learning applications, besides {{the state of the}} practice, does not achieve the level of interactivity that current learning theories advocate. In this paper, the possibility of enhancing e-learning systems to achieve deep learning has been studied by replicating an experiment in which students had to learn <b>basic</b> <b>software</b> engineering <b>principles.</b> One group learned these principles using a static approach, while the other group learned the same prin-ciples using a system-dynamics-based approach, which provided interactivity and feedback. The results show that, quantitatively, the latter group achieved a better understanding of the principles; furthermore, qualitatively, they enjoyed the learning experience. Index Terms—Management education, simulation software, software engineering education, student experiments, system dynamics...|$|R
30|$|Agile {{software}} methods (typically {{referred to}} as ‘agile methods’ or ‘Agile’) have been utilized (‘agile transformation’) {{for a long time}} in many software development organizations. Essentially, they realize in software development what agile enterprises in general aim towards. Modern large-scale agile methods and frameworks expand the <b>basic</b> agile <b>software</b> development <b>principles</b> to the enterprise level. Consequently, it is prospective to assess how these methods and frameworks would support future companies when they strive to become software-intensive.|$|R
40|$|Abstract: The {{heterogeneous}} {{and dynamic}} nature of components {{making up a}} web application, the lack of effective programming mechanisms for implementing <b>basic</b> <b>software</b> engineering <b>principles</b> in it, and undisciplined development processes induced by the high pressure of a very short time-to-market, make web application maintenance a challenging problem. A relevant issue consists of reusing the methodological and technological experience in the sector of traditional software maintenance, and exploring the opportunity of using reverse engineering to support effective web application maintenance. This paper presents reverse engineering approach that help to understand existing undocumented web applications to be maintained or evolved, through the extraction from domain ontology of conceptual schema describing a web application. The advantage of using ontology for conceptual data modelling is the reusability of domain knowledge. As a result of it the conceptual data model will be made faster, easier and with fewer errors than creating conceptual data model in usual way. We demonstrate {{the value of the}} approach by providing an implementation that exhibits appropriate characteristics...|$|R
40|$|Abstract—In {{the past}} [17][18], we have {{proposed}} a scheme for incorporating computer vision tasks and algorithms into undergraduate data structures courses to enrich the experience and enhance the learning process. We have found that introductory computer vision can be easily integrated without detracting from the original goal of teaching data structures. Some of the image-related tasks, such as connected component labeling and binary image manipulation, offer a natural way to introduce basic data structures such as arrays, queues, stacks, trees, and hash tables. The particular advantage of this integrated strategy is that it exposes the students to image related manipulations {{at an early stage}} of the curriculum, furthermore, it facilitates the understanding of data structure concepts by providing a visual context. We have experimented with such an integration strategy using a set of programming assignments. These assignments can be incorporated in existing data structures courses with low time and software overheads. In this paper, we present quantitative analysis of the effectiveness of these assignments using pre- and postassignment tests. We also consider student performance and their evaluations of the assignments. Our analysis suggests that the assignments significantly improved the understanding of standard data structures and <b>basic</b> <b>software</b> design <b>principles.</b> Index Terms—Computer vision, image computations, data structures, undergraduate computer science education...|$|R
40|$|A {{variety of}} {{experiences}} in software development processes between a public sector organisation and several software vendors over a decade-long period are described and interpreted. Three information systems histories {{are presented as}} case examples and their analysis is based on detailed insider observations. A social process model is {{used to describe the}} relationships between key actors within the client organisation while a transaction cost framework is used to explain the joint forms of the relationships between the client and the vendors. The resulting model depicts in a concise way how the relationships have evolved and stabilised over time. In this model, major encounters between the actors are those which have at least the potential to change the relationship state between the parties. The relatively stable passages between consecutive encounters are labelled episodes. By perceiving systems development as a series of encounters and episodes, it is possible to identify the critical turning points of development work and to display the dynamics of a software development trajectory. While our findings support the well-known <b>basic</b> <b>software</b> procurement <b>principle,</b> this is only after the trajectories have stabilised. Two of the three trajectories exhibit major changes in software procurement strategies before reaching a steady state. The paper ends with a discussion of the findings and some implications for researchers and practitioners. © 2000 Elsevier Science Ltd...|$|R
40|$|Many {{schools do}} {{not begin to}} {{introduce}} college students to software engineering until they {{have had at least}} one semester of programming. Since software engineering is a large, complex, and abstract subject it is difficult to construct active learning exercises that build on the students’ elementary knowledge of programming and still teach <b>basic</b> <b>software</b> engineering <b>principles.</b> It is also the case that beginning students typically know how to construct small programs, but they have little experience with the techniques necessary to produce reliable and long-term maintainable modules. I have addressed these two concerns by defining a local standard (Montana Tech Method (MTM) Software Development Standard for Small Modules Template) that step-by-step directs students toward the construction of highly reliable small modules using well known, best-practices software engineering techniques. “Small module” is here defined as a coherent development task that can be unit tested, and can be car ried out by a single (or a pair of) software engineer(s) in at most a few weeks. The standard describes the process to be used and also provides a template for the top-level documentation. The instructional module’s sequence of mini-lectures and exercises {{associated with the use of}} this (and other) local standards are used throughout the course, which perforce covers more abstract software engineering material using traditional reading and writing assignments. The sequence of mini-lectures and hands-on assignments (many of which are done in small groups) constitutes an instructional module that can be used in any similar software engineering course...|$|R
40|$|This paper {{presents}} a tool-supported methodological paradigm for object-oriented software develop-ment, called monitoring-oriented programming and abbreviated MOP, in which runtime monitoring is a <b>basic</b> <b>software</b> design <b>principle.</b> The general idea underlying MOP is that software developers insert speci cations in their code via annotations. Actual monitoring code is automatically synthesized from these annotations before compilation and integrated at appropriate {{places in the}} program, according to user-dened conguration attributes. This way, the specication is checked at runtime against the implementation. Moreover, violations and/or validations of specications can trigger user-dened code at any points in the program, in particular recovery code, outputting or sending messages, or raising exceptions. The MOP paradigm does not promote or enforce any specic formalism to specify requirements: it allows the users to plug-in their favorite or domain-specic specication formalisms via logic plug-in modules. There are two major technical challenges that MOP supporting tools unavoidably face: monitor synthesis and monitor integration. The former is heavily dependent on the specication formalism and comes {{as part of the}} corresponding logic plug-in, while the latter is uniform for all specication formalisms and depends only on the target programming language. An experimental prototype tool, called Java-MOP, is also discussed, which currently supports most but not all of the desired MOP features. MOP aims at reducing the gap between formal specication and implementation, by integrating the two and allowing them together to form a system. 1...|$|R
40|$|The rapid, {{progressive}} {{diffusion of}} Web applications in several productive contexts of our modern society is {{laying the foundations}} of a renewed scenario of software development, {{where one of the}} emerging problems is that of defining and validating cost-effective approaches for maintaining and evolving these software systems. Due to several factors, the solution to this problem is not straightforward. The heterogeneous and dynamic nature of components making up a Web application, the lack of effective programming mechanisms for implementing <b>basic</b> <b>software</b> engineering <b>principles</b> in it, and undisciplined development processes induced by the high pressure of a very short time-to-market, make Web application maintenance a challenging problem. A relevant issue consists of reusing the methodological and technological experience in the sector of traditional software maintenance, and exploring the opportunity of using reverse engineering to support effective Web application maintenance. This paper presents an approach for defining reverse engineering processes involving Web applications. The approach has been used to implement a process, including reverse engineering methods and a supporting software tool, that helps to understand existing undocumented Web applications to be maintained or evolved, through the reconstruction of UML diagrams. The proposed reverse engineering process has been submitted to a validation experiment, the results of which showed the usability of the process for reverse engineering Web applications with different characteristics, and highlighted possible areas for improvement of its effectiveness. The experiment and the lessons learned from it are presented in the pape...|$|R
5000|$|Software {{design is}} both a process and a model. The design process is a {{sequence}} of steps that enables the designer to describe {{all aspects of the}} software for building. Creative skill, past experience, a sense of what makes [...] "good" [...] software, and an overall commitment to quality are examples of critical success factors for a competent design. It is important to note, however, that the design process is not always a straightforward procedure; the design model can be compared to an architect’s plans for a house. It begins by representing the totality of the thing that is to be built (e.g., a three-dimensional rendering of the house); slowly, the thing is reﬁned to provide guidance for constructing each detail (e.g., the plumbing layout). Similarly, the design model that is created for software provides a variety of different views of the computer <b>software.</b> <b>Basic</b> design <b>principles</b> enable the <b>software</b> engineer to navigate the design process. Davis DAV95 suggests a set of <b>principles</b> for <b>software</b> design, which have been adapted and extended in the following list: ...|$|R
5000|$|ECU Configuration Description: {{contains}} all <b>basic</b> <b>software</b> configuration {{information that is}} local to a specific ECU. The executable software can be built from this information, the code of the <b>basic</b> <b>software</b> modules and the code of the software components.|$|R
5000|$|The <b>basic</b> <b>software</b> {{application}} {{contains the}} following features: ...|$|R
40|$|Abstract: This paper {{presents}} AUTOSAR-ready light {{software architecture}} (AUTOSAR-Lite), {{which is a}} light weighted version of the AUTOSAR, for automotive embedded control systems. The proposed AUTOSAR-Lite reduces overhead problems caused by the excessive standard specifications of AUTOSAR. Concurrently, AUTOSAR-Lite keeps advantages of AUTOSAR such as a scalability, re-usability, reliability, and transferability. The fundamental design of AUTOSAR-Lite is originated from the AUTOSAR standard. AUTOSAR-Lite is composed of three layers such as an application software, runtime environment, and <b>basic</b> <b>software</b> layer. The application software layer adopts component-based design methodology as AUTOSAR. The runtime environment layer integrates interfaces between application and <b>basic</b> <b>software</b> layers. In case of the <b>basic</b> <b>software</b> layer, restrictions of the module configurations and interfaces of <b>basic</b> <b>software</b> are minimized. In order to validate the feasibility of AUTOSAR-Lite, a software desig...|$|R
50|$|Pocket PC - the HD2's <b>basic</b> <b>software</b> and {{hardware}} platform.|$|R
5000|$|The <b>basic</b> <b>software</b> {{design to}} {{accommodate}} Tamil characters and their processing are simplified.|$|R
5000|$|To {{effectively}} communicate quality <b>software</b> <b>principles,</b> {{concepts and}} technologies to {{all levels of}} the software development community.|$|R
5000|$|Leo Kornfeld, Deputy Commissioner of Education (Carter and Clinton administrations), and President of True <b>Basic</b> <b>Software</b> Company ...|$|R
50|$|After {{the dot-com}} bubble, {{inspired}} by the Agile Manifesto, internet and software companies began operating under agile software development practices such as Extreme programming. Along with the agile software movement, companies (especially startups) applied both lean enterprise and agile <b>software</b> <b>principles</b> together {{in order to develop}} new products or even new companies more efficiently and based on validated customer demand. Very early practices of lean enterprise and agile <b>software</b> <b>principles</b> was commonly referred to as lean startup.|$|R
5000|$|Another {{essential}} element of COQOS is the AUTOSAR environment. This allows the seamless integration of AUTOSAR <b>software</b> components and <b>basic</b> <b>software</b> modules.|$|R
50|$|The company {{additionally}} provides payroll functionality {{as a part}} of its <b>basic</b> <b>software</b> {{application to}} allow for payroll generation, overtime, and reporting.|$|R
2500|$|Debian, a {{non-commercial}} {{distribution and}} one of the earliest, maintained by a volunteer developer community with a strong commitment to free <b>software</b> <b>principles</b> and democratic project management ...|$|R
5000|$|... #Caption: [...] The 500+ page Osborne 1 {{user manual}} {{contained}} {{instructions on the}} hardware, WordStar, Supercalc, <b>BASIC</b> <b>software</b> and the CP/M operating system and utilities ...|$|R
5000|$|USRP B100: The B100, {{introduced}} in October 2011, replaces the USRP as the <b>basic</b> <b>Software</b> Defined Radio offering from Ettus Research. The {{features of the}} B100 are: ...|$|R
5000|$|Runtime environment: Middleware which abstracts {{from the}} network {{topology}} for the inter- and intra-ECU information exchange between the application software components {{and between the}} <b>Basic</b> <b>Software</b> and the applications.|$|R
5000|$|Part 3 of IEC 61131 {{deals with}} <b>basic</b> <b>software</b> {{architecture}} and programming languages {{of the control}} program within PLC. It defines two graphical and two textual programming language standards: ...|$|R
50|$|The National Informatics Centre (NIC) has {{developed}} <b>basic</b> <b>software</b> {{to create and}} file shipping bills (Customs documents) on the Indian Customs website. The software is free to download with IceGate (Indian Customs) registration.|$|R
50|$|IUS {{released}} a separate application, EasyWriter II. Completely rewritten by <b>Basic</b> <b>Software</b> Group, IUS emphasized that II—developed with C instead of Forth—"is not {{an updated version}} of the original IBM selection or its upgrade".|$|R
50|$|The Atlas Computer Laboratory made {{important}} contributions to systems software including operating systems, compilers, computer graphics, and networking. <b>Basic</b> <b>software</b> {{in the areas}} of statistics, mathematics, linguistics, chemistry and many other areas was also developed.|$|R
5000|$|According to a {{press release}} from Toyota dated August 28, 2002 [...] "Navigational maps and the {{on-board}} terminal's <b>basic</b> <b>software</b> are stored in a Secure Digital (SD) card. The card can be inserted into [...] "E-TOWER" [...] terminals at convenience stores and other locations to download local or new maps or to upgrade the on-board terminal's <b>basic</b> <b>software.</b> Music and games can also be downloaded, and the SD card is compatible with commercially available audio players, digital cameras and PDAs that use SD cards, {{making it possible to}} share content such as music files, images and games." [...] E-Tower locations can be found at numerous locations, including Circle K of Japan.|$|R
50|$|All staff (teaching {{and support}} staff) use <b>basic</b> <b>software</b> {{applications}} {{with the aim}} of having teaching staff engaged with Web 2.0 Interactive Technologies. Staff are engaging in MOODLE editing to provide lesson material for students on the internet.|$|R
40|$|The Globus Project is a {{community}} effort, led by Argonne National Laboratory and the University of Southern California's Information Sciences Institute. Globus is developing the <b>basic</b> <b>software</b> infrastructure for computations that integrate geographically distributed computational and information resources...|$|R
50|$|The Zen of Python is a {{collection}} of 20 <b>software</b> <b>principles</b> that influences the design of Python Programming Language, — only 19 of which were written down — around June 1999 by Tim Peters. The principal text is released into public domain.|$|R
50|$|Released in 2004, {{this remote}} control uses radio {{frequency}} {{to operate a}} Windows-based computer via its Beyond Media <b>Basic</b> <b>software</b> (or a Windows XP Media Center Edition PC via Microsoft's Media Center Edition operating system) and can control other applications.|$|R
40|$|Many group-theoretic {{properties}} {{from elementary}} abstract algebra {{lend themselves to}} simple, easily automated algorithms for small finite groups. A <b>basic</b> <b>software</b> system which implements such algorithms is presented. As well, we attempt to tantalize the reader into further explorations into the Python language...|$|R
5000|$|... 3270 PC/GX - Extended APA {{graphics}} support (1024x1024) {{provided by}} the IBM 5378 Display Attachment Unit; shipped with a 19-inch color or monochrome monitor (IBM 5379). Price at launch was $18,490, although adding the <b>basic</b> <b>software</b> and cables ran close to $20,000.|$|R
