333|740|Public
500|$|This {{objection}} {{seems to}} rest on a misunderstanding of Kant's views since Kant argued that morality is dependent upon {{the concept of a}} rational will (and the related concept of a categorical imperative: an imperative which any rational being must necessarily will for itself). [...] It is not based on contingent features of any being's will, nor upon human wills in particular, so there is no sense in which Kant makes ethics [...] "dependent" [...] upon anything which has not always existed. [...] Furthermore, the sense in which our wills are subject to the law is precisely that if our wills are rational, we must will in a lawlike fashion; that is, we must will according to moral judgments we apply to all rational beings, including ourselves. This is more easily understood <b>by</b> <b>parsing</b> the term [...] "autonomy" [...] into its Greek roots: auto (self) + nomos (rule or law). That is, an autonomous will, according to Kant, is not merely one which follows its own will, but whose will is lawful-that is, conforming to the principle of universalizability, which Kant also identifies with reason. Ironically, in another passage, willing according to immutable reason is precisely the kind of capacity Elshtain ascribes to God as the basis of his moral authority, and she commands this over an inferior voluntarist version of divine command theory, which would make both morality and God's will contingent. Kant's theory is a version of the first rather than the second view of autonomy, so neither God nor any human authority, including contingent human institutions, play any unique authoritative role in his moral theory. Kant and Elshtain, that is, both agree God {{has no choice but to}} conform his will to the immutable facts of reason, including moral truths; humans do have such a choice, but otherwise their relationship to morality is the same as that of God's: they can recognize moral facts, but do not determine their content through contingent acts of will.|$|E
2500|$|The opening verse {{includes}} [...] as a {{name for}} Ganesha. [...] The simple meaning of this name, which would have seemed obvious to his readers, would be [...] "Protector of the Ganas", parsing the name in a straightforward way as [...] (group) + nātha (protector). [...] But Bhaskararaya demonstrates his skill in nirukta <b>by</b> <b>parsing</b> it in an unexpected way as the Bahuvrīhi compound [...] + atha meaning [...] "the one the enumeration (...) of whose qualities brings about auspiciousness. The word atha is associated with auspiciousness (...) [...]" [...] This rhetorical flourish {{at the opening of}} the sahasranama demonstrates Bhaskaraya's skills in nirukta at the very beginning of his commentary on a thousand such names, including a clever twist appropriate to the context of a sahasranama.|$|E
50|$|Finally, the red {{numerator}} numerators {{implied by}} the 2/n table were directly discussed in RMP 36. Ahmes converted, 2/53, 3/53, 5/53, 15/53, 28/53 and 30/53 by two rules. The first rule scaled 2/53*(30/30) = 60/1590, 3/53(20/20) = 60/1060, 5/53*(12/12) = 60/636, 15/53*(4/4) = 60/212, 28/53*(2/2) = 56/106. The second rule converted 30/53 <b>by</b> <b>parsing</b> 30/53 into 2/53 + 28/53. as Ahmes has converted 28/97 <b>by</b> <b>parsing</b> 29/97 into 2/97 + 26/97.|$|E
5000|$|TSimpleJSONProtocol - A write-only {{protocol}} that {{cannot be}} <b>parsed</b> <b>by</b> Thrift because it drops metadata using JSON. Suitable for <b>parsing</b> <b>by</b> scripting languages.|$|R
5000|$|... and a geo microformat {{for that}} location, Belvide Reservoir, {{which will be}} detected, on this page, <b>by</b> microformat <b>parsing</b> tools.|$|R
50|$|The {{generated}} parser can parse inputs very efficiently <b>by</b> packrat <b>parsing.</b> The packrat parsing is the recursive descent parsing algorithm that is accelerated using memoization. <b>By</b> using packrat <b>parsing,</b> any input can be parsed in linear time. Without it, {{however, the}} resulting parser could exhibit exponential time {{performance in the}} worst case due to the unlimited look-ahead capability.|$|R
5000|$|The {{query string}} is {{composed}} {{of a series of}} arguments <b>by</b> <b>parsing</b> the text into words at the spaces.|$|E
50|$|Swagger-Codegen {{contains}} a template-driven engine to generate documentation, API clients and server stubs {{in different languages}} <b>by</b> <b>parsing</b> the OpenAPI definition.|$|E
50|$|VSCPworks is the PC (Linux & Windows)-based tool to {{configure}} {{and manage the}} nodes. VSCPWorks allows reading/setting registers presenting those registers in a human-readable format <b>by</b> <b>parsing</b> the MDF file automatically. VSCPWorks also provides wizards to set the decision matrix.|$|E
50|$|It {{is an open}} {{problem to}} give a {{concrete}} example of a context-free language which cannot be recognized <b>by</b> a <b>parsing</b> expression grammar.|$|R
5000|$|The [...] {{function}} is preferably used to specify, validate, transform and interpret dialects. It does so <b>by</b> matching <b>parse</b> expressions at run time.|$|R
40|$|AbstractScattered context {{generators}} {{derive their}} sentences followed <b>by</b> the corresponding <b>parses.</b> This paper discusses their two canonical versions, which make this derivation {{either in a}} leftmost or rightmost way. It demonstrates that for every recursively enumerable language, L, there exists a canonical scattered context generator whose language consists of L’s sentences followed <b>by</b> their <b>parses.</b> In fact, this result is established based on the generators containing {{no more than six}} nonterminals...|$|R
50|$|It {{does this}} <b>by</b> <b>parsing</b> text, {{determining}} sentence structure, identifies mood and tones of sentences. Also identifies primary imagery and themes. Poetry Analyzer's website states that a unique analysis of text {{is accomplished by}} studying that which is most overlooked, and considered not relevant.|$|E
5000|$|... solves {{this problem}} <b>by</b> <b>parsing</b> {{the code of}} C source files to {{generate}} a list of dependencies (those header files included directly and indirectly). It is able to understand conditional compilation constructs so as to not generate excessive dependencies. It then appends rules expressing the dependencies to the Makefile.|$|E
5000|$|NDoc uses {{two sources}} to {{generate}} documentation. The first is an assembly file produced by compiling the source code. The {{other is a}} pre-generated XML documentation file, usually produced <b>by</b> <b>parsing</b> the source code for special comments (C# compilers from [...]NET Framework and Mono support this using the [...] "/doc" [...] command-line argument).|$|E
30|$|We report {{experimental}} results, in {{a manner}} similar to the results on bpo-graph patterns, on our evolutionary learning of characteristic TTSP graph patterns, using the context-aware fitness function proposed in Sect.  3 and a previous fitness function balanced_accuracy(p) ignoring context which is used in [23]. Using the matching algorithm [21] for TTSP graph patterns and TTSP graphs, we calculate the fitness of TTSP graph patterns represented <b>by</b> <b>parse</b> trees as individuals. We implemented our GP-based learning method for acquiring characteristic TTSP graph patterns from positive and negative TTSP graph data, using a CWC-ranking method in Sect.  3.|$|R
40|$|Abstract: Previously we have {{proposed}} a theoretical framework, called BayesOWL, to model uncertainty in semantic web ontologies based on Bayesian networks. In particular, we have developed {{a set of rules}} and algorithms to translate an OWL taxonomy into a BN. In this paper, we describe our implementation of BayesOWL framework together with examples of its use. values. This is done <b>by</b> Taxonomy <b>Parser</b> (T-Parser for short) and BN structure constructor. The second stage is to incorporate user provided probabilistic information of concepts and inter-concept relations into the BN CPTs. This is done <b>by</b> Probability <b>Parser</b> (P-Parser for short) and CPT Constructor...|$|R
40|$|This paper {{describes}} the incremental generation of parse tables for the LR-type parsing of Tree Adjoining Languages (TALs). The algorithm presented handles {{modifications to the}} input grammar by updating the parser generated so far. In this paper, a lazy generation of LR-type parsers for TALs is defined in which parse tables are created <b>by</b> need while <b>parsing.</b> We then describe an incremental parser generator for TALs which responds to modification of the input grammar <b>by</b> updating <b>parse</b> tables built so far. ...|$|R
5000|$|It is {{also used}} by {{websites}} as a spamdexing technique to fill a page with keywords that a search engine will recognize but are not visible to a visitor. However, Google has taken steps to prevent this <b>by</b> <b>parsing</b> the color of text as it indexes it and {{checking to see if}} it is transparent, giving those pages much lower rankings.|$|E
5000|$|Twitch Plays Pokémon (TPP) is a [...] "social experiment" [...] {{and channel}} {{on the video}} game live {{streaming}} website Twitch, consisting of a crowdsourced attempt to play Game Freaks and Nintendos Pokémon video games <b>by</b> <b>parsing</b> commands sent by users through the channels chat room. It holds the Guinness World Record for having [...] "the most participants on a single-player online videogame" [...] with 1,165,140.|$|E
50|$|IPE {{allows the}} user to insert text objects {{containing}} LaTeX code. This is converted to vector graphics <b>by</b> <b>parsing</b> the output of pdfTeX. This is useful for creating figures {{to be included in}} scientific documents which often contain equations. It also results in the same font being used for both the text and figures of the document. This is often not the case if other drawing programs are used.|$|E
5000|$|Cross-tier (web, database, storage, etc.) {{transaction}} metrics <b>parsed</b> <b>by</b> unique session IDs {{or other}} GUID ...|$|R
40|$|This paper {{describes}} the incremental generation of parse tables for the LR-type parsing of Tree Adjoining Languages (TALs). The algorithm presented handles {{modifications to the}} input grammar by updating the parser generated so far. In this paper, a lazy generation of LR-type parsers for TALs is defined in which parse tables are created <b>by</b> need while <b>parsing.</b> We then describe an incremental parser generator for TALs which responds to modification of the input grammar <b>by</b> updating <b>parse</b> tables built so far. Comment: 12 pages, 12 Postscript figures, uses fullname. st...|$|R
5000|$|CDATASection {{represents}} a CDATA section in a document (text that will NOT be <b>parsed</b> <b>by</b> a parser) ...|$|R
50|$|This {{acquisition}} function {{may include}} {{the transfer of}} discrete lead data via technologies like name-value pairs, XML, RSS, HTTP POST, and FTP. These technologies {{can be used in}} conjunction with an organization's own website or third party lead provider. Often lead providers will deliver leads via a standard email. These leads can be electronically captured <b>by</b> <b>parsing</b> the email and then submitting the lead using one of the methods described above.|$|E
5000|$|Extensible Markup Language (XML) {{encoding}} - This {{format is}} human- and machine-readable {{and it can}} be easily rendered in navigation devices <b>by</b> <b>parsing</b> the XML structure. It is further backwards compatible in a way that new XML tags can be included in a given application, which would be simply skipped by older device populations that do not recognize these tags. New device populations can however benefit from the new features.|$|E
5000|$|The International Aging Research Portfolio (IARP) {{includes}} historic grant {{data from}} the [...] National Institutes of Health(NIH), [...] European Commission(EC), NSF, Canadian and Australian research councils and many other sources. It also contains MEDLINE article abstracts under a license from the National Library of Medicine.The IARP volunteer development team works directly with the publication offices and regularly updates the database either automatically or <b>by</b> <b>parsing</b> the data mailed on physical medium.|$|E
50|$|The {{popularity}} of tree shaking in JavaScript {{is based on}} the fact that in distinction from CommonJS modules, ECMAScript 6 module loading is static and thus whole dependency tree can be deduced <b>by</b> statically <b>parsing</b> the syntax tree. Thus tree shaking becomes an easy problem.|$|R
5000|$|A grammar {{that can}} be <b>parsed</b> <b>by</b> an SLR parser but not by an LR(0) parser is the following: ...|$|R
40|$|The inside-outside probabilities are {{typically}} used for reestimating Probabilistic Context Free Grammars (PCFGs), {{just as the}} forward-backward probabilities {{are typically}} used for reestimating HMMs. I show several novel uses, including improving parser accuracy <b>by</b> matching <b>parsing</b> algorithms to evaluation criteria; speeding up DOP <b>parsing</b> <b>by</b> 500 times; and 30 times faster PCFG thresholding at a given accuracy level. I also give an elegant, state-of-the-art grammar formalism, {{which can be used}} to compute inside-outside probabilities; and a parser description formalism, which makes it easy to derive inside-outside formulas and many others. Comment: Ph. D. Thesis, 257 pages, 40 postscript figure...|$|R
5000|$|MANTRA is a {{recipient}} of the Computerworld Smithsonian Award {{and a part of}} the '1999 Innovation Collection' in the National Museum for American History. In MANTRA-Rajbhasha, the English document is initially sent for pre processing followed <b>by</b> <b>parsing</b> and generation during which the English Lexicon, Hindi Lexicon and Transfer Lexicon are used. The generator generates the Hindi output that undergoes post processing (if required) and leading to the translated Hindi document.|$|E
50|$|Ahmes did {{not mention}} 'single false position' in algebra problems, a valid point made by Robins-Shute in 1987. The {{inaccurate}} 1920s supposition has been replaced <b>by</b> <b>parsing</b> large vulgar fractions by stripping away the unit fraction notation. For example, 28/97, in RMP 31, and RMP 23 expose Ahmes' LCM multiplication method. In RMP 23 where a 45 multiplier was introduced to solve most of the problem. Yet, to read the complete problem LCM 360 was needed as other RMP algebra problems were solved.|$|E
50|$|When {{a program}} is linked with Purify, {{corrected}} verification code is automatically {{inserted into the}} executable <b>by</b> <b>parsing</b> and adding to the object code, including libraries. That way, if a memory error occurs, the program will print out {{the exact location of}} the error, the memory address involved, and other relevant information. Purify also detects memory leaks. By default, a leak report is generated at program exit but can also be generated by calling the Purify leak-detection API from within an instrumented application.|$|E
25|$|Note: Spaces are not ordinarily used in Japanese, {{but they}} are {{supplemented}} here to facilitate <b>parsing</b> <b>by</b> non-speakers of the language.|$|R
25|$|LL(k) and LL(*) grammars allow <b>parsing</b> <b>by</b> direct {{construction}} of a leftmost derivation as described above, and describe even fewer languages.|$|R
50|$|Note: Spaces are not ordinarily used in Japanese, {{but they}} are {{supplemented}} here to facilitate <b>parsing</b> <b>by</b> non-speakers of the language.|$|R
