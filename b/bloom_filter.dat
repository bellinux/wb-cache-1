764|541|Public
5000|$|... #Caption: <b>Bloom</b> <b>filter</b> used {{to speed}} up answers in a {{key-value}} storage system. Values are stored on a disk which has slow access times. <b>Bloom</b> <b>filter</b> decisions are much faster. However some unnecessary disk accesses are made when the filter reports a positive (in order to weed out the false positives). Overall answer speed is better with the <b>Bloom</b> <b>filter</b> than without the <b>Bloom</b> <b>filter.</b> Use of a <b>Bloom</b> <b>filter</b> for this purpose, however, does increase memory usage.|$|E
50|$|A layered <b>Bloom</b> <b>filter</b> {{consists}} of multiple <b>Bloom</b> <b>filter</b> layers. Layered Bloom filters allow {{keeping track of}} how many times an item {{was added to the}} <b>Bloom</b> <b>filter</b> by checking how many layers contain the item. With a layered <b>Bloom</b> <b>filter</b> a check operation will normally return the deepest layer number the item was found in.|$|E
5000|$|The Google Chrome {{web browser}} {{used to use}} a <b>Bloom</b> <b>filter</b> to {{identify}} malicious URLs. Any URL was first checked against a local <b>Bloom</b> <b>filter,</b> and only if the <b>Bloom</b> <b>filter</b> returned a positive result was a full check of the URL performed (and the user warned, if that too returned a positive result).|$|E
3000|$|The Baseline <b>Bloom</b> <b>Filters</b> lookup {{algorithm}} {{we developed}} {{is built on}} top of the Naïve version and includes optimizations to (i) reduce the amount of memory used in each <b>Bloom</b> <b>filters</b> structure and to (ii) decrease the number of <b>Bloom</b> <b>filters</b> employed. The first optimization is implemented with the use of asymmetric <b>Bloom</b> <b>filters</b> [17], which implies that len(f [...]...|$|R
40|$|Abstract: This paper {{surveys the}} {{mathematics}} behind <b>Bloom</b> <b>filters,</b> some important variations and network-related applications of <b>Bloom</b> <b>filters.</b> The current researches show that although <b>Bloom</b> <b>filters</b> start drawing significant {{attention from the}} academic community {{and there has been}} considerable progress, there are still man...|$|R
40|$|In many {{networking}} systems, <b>Bloom</b> <b>filters</b> {{are used}} for high-speed set membership tests. They permit {{a small fraction of}} false positive answers with very good space efficiency. However, they do not permit deletion of items from the set, and previous attempts to extend “standard ” <b>Bloom</b> <b>filters</b> to support deletion all degrade either space or performance. We propose a new data structure called the cuckoo filter that can replace <b>Bloom</b> <b>filters</b> for approximate set member-ship tests. Cuckoo filters support adding and removing items dynamically while achieving even higher performance than <b>Bloom</b> <b>filters.</b> For applications that store many items and target moderately low false positive rates, cuckoo filters have lower space overhead than space-optimized <b>Bloom</b> <b>filters.</b> Our experimental results also show that cuckoo filters out-perform previous data structures that extend <b>Bloom</b> <b>filters</b> to support deletions substantially in both time and space...|$|R
5000|$|Union and {{intersection}} of Bloom filters {{with the same}} size and set of hash functions can be implemented with bitwise OR and AND operations respectively. The union operation on Bloom filters is lossless {{in the sense that the}} resulting <b>Bloom</b> <b>filter</b> is the same as the <b>Bloom</b> <b>filter</b> created from scratch using the union of the two sets. The intersect operation satisfies a weaker property: the false positive probability in the resulting <b>Bloom</b> <b>filter</b> is at most the false-positive probability in one of the constituent Bloom filters, but may be larger than the false positive probability in the <b>Bloom</b> <b>filter</b> created from scratch using the {{intersection of}} the two sets.|$|E
50|$|A <b>Bloom</b> <b>filter</b> can be {{considered}} a kind of superimposed code.|$|E
5000|$|... #Subtitle level 2: Approximating {{the number}} of items in a <b>Bloom</b> <b>filter</b> ...|$|E
30|$|Experimental {{evaluation}} {{illustrates the}} high accuracy and matching achieved {{even in the}} case of false positives in <b>bloom</b> <b>filters.</b> Tolerance to false positives provides large data space savings. Accuracy is maintained even if the size of <b>bloom</b> <b>filters</b> decreases significantly, resulting in a high number of detected false positives. A future extension is the dynamic and automated allocation of larger space in the <b>bloom</b> <b>filters</b> based on accuracy requirements under false positives. Alternative approaches to <b>bloom</b> <b>filters</b> are also considered in future work, e.g., hash compaction (Dillinger and Manolios 2004).|$|R
500|$|For {{approximate}} results, <b>Bloom</b> <b>filters,</b> another probabilistic {{data structure}} based on hashing, store {{a set of}} keys by encoding the keys using a bit array and multiple hash functions. <b>Bloom</b> <b>filters</b> are much more space-efficient than bit arrays in most cases and not much slower: with [...] hash functions, membership queries require only [...] time. However, <b>Bloom</b> <b>filters</b> suffer from false positives.|$|R
5000|$|<b>Bloom</b> <b>filters</b> {{are a way}} of compactly {{representing}} a set of items. It is common to try to compute {{the size of the}} intersection or union between two sets. <b>Bloom</b> <b>filters</b> can be used to approximate the size of the intersection and union of two sets. [...] showed that for two <b>Bloom</b> <b>filters</b> of length , their counts, respectively can be estimated as ...|$|R
5000|$|... #Caption: Attenuated <b>Bloom</b> <b>Filter</b> Example: Search for pattern 11010, {{starting}} from node n1.|$|E
50|$|Design and {{implementation}} of new approach for searching in encrypted data using <b>Bloom</b> <b>Filter.</b>|$|E
5000|$|... {{showed that}} the number of items in a <b>Bloom</b> <b>filter</b> can be {{approximated}} with the following formula, ...|$|E
5000|$|For {{approximate}} results, <b>Bloom</b> <b>filters,</b> another probabilistic {{data structure}} based on hashing, store {{a set of}} keys by encoding the keys using a bit array and multiple hash functions. <b>Bloom</b> <b>filters</b> are much more space-efficient than bitarrays in most cases and not much slower: with [...] hash functions, membership queries require only [...] time. However, <b>Bloom</b> <b>filters</b> suffer from false positives.|$|R
5000|$|<b>Bloom</b> <b>filters</b> can be {{used for}} {{approximate}} data synchronization as in [...] Counting <b>Bloom</b> <b>filters</b> {{can be used}} to approximate the number of differences between two sets and this approach is described in [...]|$|R
30|$|A {{practical}} {{protocol was}} first proposed by Eppstein et al. in 2011 [23]. It {{is based on}} invertible <b>Bloom</b> <b>filters</b> (IBFs), a probabilistic data structure that is related to <b>Bloom</b> <b>filters</b> [11], and stratas for difference estimation.|$|R
5000|$|<b>Bloom</b> <b>filter,</b> memory {{efficient}} data-structure {{designed for}} constant-time approximate lookups; uses hash function(s) {{and can be}} seen as an approximate hash table.|$|E
50|$|A {{quotient}} filter requires 10-25% {{more space}} than a comparable <b>Bloom</b> <b>filter</b> but is faster because each access requires evaluating {{only a single}} hash function.|$|E
50|$|An {{attenuated}} <b>Bloom</b> <b>filter</b> {{of depth}} D {{can be viewed}} as an array of D normal Bloom filters. In the context of service discovery in a network, each node stores regular and attenuated Bloom filters locally. The regular or local <b>Bloom</b> <b>filter</b> indicates which services are offered by the node itself. The attenuated filter of level i indicates which services can be found on nodes that are i-hops away from the current node. The i-th value is constructed by taking a union of local Bloom filters for nodes i-hops away from the node.|$|E
40|$|In this paper, {{we present}} two novel {{hash-based}} indexing structures, based on <b>Bloom</b> <b>filters,</b> called Breadth and Depth <b>Bloom</b> <b>filters,</b> which {{in contrast to}} traditional hash-based indexes, are able to summarize hierarchical data and support regular path expression queries. We describe how these structures can be used for resource discovery in peer-to-peer networks. We have implemented both structures and our experiments show that they both outperform simple <b>Bloom</b> <b>filters</b> in discovering the appropriate resources. 1...|$|R
30|$|<b>Bloom</b> <b>filters</b> {{have since}} gained {{a lot of}} {{attention}} especially in network applications (Broder and Mitzenmacher 2002). Today, <b>Bloom</b> <b>filters</b> can be used as histograms (Cohen and Matias 2003) and represent arbitrary functions (Chazelle et al. 2004). In 2005 Song et al. 2005 suggested using <b>Bloom</b> <b>filters</b> as a hash table summary. This idea was later refined in (Kirsch and Mitzenmacher 2005). Bloom filter-based summaries are also used for minimal perfect hashing (Lu et al. 2006).|$|R
40|$|Abstract. In this paper, {{we present}} two novel {{hash-based}} indexing structures, based on <b>Bloom</b> <b>filters,</b> called {{breadth and depth}} <b>Bloom</b> <b>filters,</b> {{which in contrast to}} traditional hash based indexes, are able to represent hierarchical data and support path expression queries. We describe how these structures can be used for resource discovery in peer-to-peer networks. We have implemented both structures and our experiments show that they both outperform the traditional <b>Bloom</b> <b>filters</b> in discovering the appropriate resources. ...|$|R
5000|$|... {{describe}} a probabilistic structure based on hash tables, hash compaction, which [...] identify as significantly {{more accurate than}} a <b>Bloom</b> <b>filter</b> when each is configured optimally. Dillinger and Manolios, however, {{point out that the}} reasonable accuracy of any given <b>Bloom</b> <b>filter</b> over a wide range of numbers of additions makes it attractive for probabilistic enumeration of state spaces of unknown size. Hash compaction is, therefore, attractive when the number of additions can be predicted accurately; however, despite being very fast in software, hash compaction is poorly suited for hardware because of worst-case linear access time.|$|E
50|$|Hash {{functions}} are an essential ingredient of the <b>Bloom</b> <b>filter,</b> a space-efficient probabilistic data structure {{that is used}} to test whether an element is a member of a set.|$|E
5000|$|The space {{efficient}} variant {{relies on}} using a single hash function that generates for each key a {{value in the}} range [...] where [...] is the requested false positive rate. The sequence of values is then sorted and compressed using Golomb coding (or some other compression technique) to occupy a space close to [...] bits. To query the <b>Bloom</b> <b>filter</b> for a given key, it will suffice to check if its corresponding value is stored in the <b>Bloom</b> <b>filter.</b> Decompressing the whole <b>Bloom</b> <b>filter</b> for each query would make this variant totally unusable. To overcome this problem the sequence of values is divided into small blocks of equal size that are compressed separately. At query time only half a block {{will need to be}} decompressed on average. Because of decompression overhead, this variant may be slower than classic Bloom filters but this may be compensated by the fact that a single hash function need to be computed.|$|E
30|$|Aggregation {{memberships}} {{are realized}} in the <b>bloom</b> <b>filters</b> of the XSienaBloomFilter library (Jerzak and Fetzer 2008). Double hashing (Dillinger and Manolios 2004) is used for collision resolution in the hashed elements of <b>bloom</b> <b>filters.</b> The size 2 m of the <b>bloom</b> <b>filters</b> {{and the number of}} hash functions k are selected empirically using the testing tools of XSienaBloomFilter. The expected number of hashed elements during the performed experiments is equal to the network size n. This selection is performed manually during system parameterization or in an automated fashion. In the latter case, DIAS is initialized with a default size of <b>bloom</b> <b>filters</b> and computes the system size using the COUNT aggregation function.|$|R
40|$|<b>Bloom</b> <b>filters</b> are {{not able}} to handle deletes and inserts on multisets over time. This is {{important}} in many situations when streamed data evolve rapidly and change patterns frequently. Counting <b>Bloom</b> <b>Filters</b> (CBF) have been proposed to overcome this limitation and allow for the dynamic evolution of <b>Bloom</b> <b>filters.</b> The only dynamic approach to a compact and efficient representation of CBF are the Spectral <b>Bloom</b> <b>Filters</b> (SBF). In this paper we propose the Dynamic Count Filters (DCF) as a new dynamic and space-time efficient representation of CBF. Although DCF does not make a compact use of memory, it shows to be faster and more space efficient than any previous proposal. Results show that the proposed data structure is more efficient independently of the incoming data characteristics. 1...|$|R
5000|$|... {{have studied}} some {{variants}} of <b>Bloom</b> <b>filters</b> {{that are either}} faster or use less space than classic <b>Bloom</b> <b>filters.</b> The basic idea of the fast variant is to locate the k hash values associated with each key into one or two blocks having {{the same size as}} processor's memory cache blocks (usually 64 bytes). This will presumably improve performance by reducing the number of potential memory cache misses. The proposed variants have however the drawback of using about 32% more space than classic <b>Bloom</b> <b>filters.</b>|$|R
50|$|By using {{attenuated}} Bloom filters {{consisting of}} multiple layers, services {{at more than}} one hop distance can be discovered while avoiding saturation of the <b>Bloom</b> <b>filter</b> by attenuating (shifting out) bits set by sources further away.|$|E
5000|$|Goel and Gupta, however, give a {{rigorous}} upper bound {{that makes no}} approximations and requires no assumptions. They show that the false positive probability for a finite <b>Bloom</b> <b>filter</b> with m bits (...) , n elements, and k hash functions is at most ...|$|E
50|$|This {{means that}} for a given false {{positive}} probability p, {{the length of a}} <b>Bloom</b> <b>filter</b> m is proportionate to the number of elements being filtered n and the required number of hash functions only depends on the target false positive probability p.|$|E
40|$|Abstract. ± <b>Bloom</b> <b>filters</b> are {{not able}} to handle deletes and inserts on multisets over time. This is {{important}} in many situations when streamed data evolve rapidly and change patterns frequently. Counting <b>Bloom</b> <b>Filters</b> �CBF) have been proposed to overcome this limitation and allow for the dynamic evolution of <b>Bloom</b> <b>filters.</b> The only dynamic approach to a compact and efficient representation of CBF are the Spectral <b>Bloom</b> <b>Filters</b> �SBF). In this paper we propose the Dynamic Count Filters �DCF) as a new dynamic and space-time efficient representation of CBF. Although DCF does not make a compact use of memory, it shows to be faster and more space efficient than any previous proposal. Results show that the proposed data structure is more efficient independently of the incoming data characteristics. 1...|$|R
40|$|<b>Bloom</b> <b>filters</b> {{have been}} very {{interesting}} in networking because they enable the high speed, low cost implementation of various hardware algorithms. The paper introduces the idea of variable-length signatures, {{as opposed to the}} current practice of using fixed-length signatures. This idea naturally enables <b>Bloom</b> <b>filters</b> to perform flow deletions, a well-known problem with standard <b>Bloom</b> <b>filters.</b> Other uses of this idea are also presented and explored. A second contribution of the paper is the use of a bank of <b>Bloom</b> <b>filters</b> to identify the action that must be applied to the packets of a flow, or to dynamically record the state a flow is in. Our work shows that this approach is a promising alternative to expensive CAM or hash table lookups, and suggests a method of building cheap “fuzzy ” flow memories. ...|$|R
40|$|In this paper, {{we present}} an {{algorithm}} that joins relational database tables efficiently in a distributed environment using <b>Bloom</b> <b>filters</b> of an optimal size. We propose {{not to use}} fixed-size <b>bloom</b> <b>filters</b> as in previous research, but to find an optimal size for the <b>bloom</b> <b>filters,</b> by creating a mathematical model of the join algorithm, and then finding the optimal parameters using traditional mathematical optimization. This algorithm with optimal parameters beats both previous approaches using <b>bloom</b> <b>filters</b> and the default SparkSQL engine not only on star-joins, but also on traditional database schema. The experiments were conducted on a standard TPC-H database stored as parquet files on a distributed file system. Comment: The article is in Russian, but {{an analysis of the}} data used in it is available in english at the following address: [URL]...|$|R
