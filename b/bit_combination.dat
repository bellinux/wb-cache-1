10|67|Public
50|$|For example, the <b>bit</b> <b>combination</b> {{corresponding}} to the graphic character “space” is 010 0000 as a 7-bit number, and 0010 0000 as an 8-bit number. According to those column/line numbers, this is represented as 2/0.|$|E
50|$|Values and {{variables}} of an enumerated type are usually implemented as fixed-length bit strings, {{often in a}} format and size compatible with some integer type. Some languages, especially system programming languages, allow the user to specify the <b>bit</b> <b>combination</b> {{to be used for}} each enumerator. In type theory, enumerated types are often regarded as tagged unions of unit types. Since such types are of the form , they may also be written as natural numbers.|$|E
50|$|In {{order to}} {{represent}} the <b>bit</b> <b>combination</b> (bitto kumiawase) of a one-byte code, two decimal numbers - a column number and a line number - are used. Three high-order bits out of seven or four high-order bits out of eight, counting from zero to seven or from zero to fifteen respectively, form the column number. Four low-order bits counting from zero to fifteen form the line number. Each number corresponds to one hexadecimal digit, but is conventionally written in decimal.|$|E
50|$|Unused <b>bit</b> <b>combinations</b> of OPR {{were defined}} as a third Group of microprogrammed actions mostly {{affecting}} the MQ (Multiplier/Quotient) register.|$|R
3000|$|..., 0 < j ≤ l {{having a}} maximum weight q {{with all the}} {{possible}} <b>bit</b> <b>combinations</b> in the least reliable positions, [...]...|$|R
5000|$|The four-of-eight {{code was}} a 64 {{character}} set plus six control characters, encoded in eight bits. Exactly four bits of each character were one bits [...] - [...] there are 70 such possible <b>bit</b> <b>combinations.</b>|$|R
50|$|Every {{possible}} <b>bit</b> <b>combination</b> {{is either}} a NaN or a number with a unique value in the affinely extended real number system with its associated order, except for the two bit combinations negative zero and positive zero, which sometimes require special attention (see below). The binary representation has the special property that, excluding NaNs, any two numbers can be compared as sign and magnitude integers (endianness issues apply). When comparing as 2's-complement integers: If the sign bits differ, the negative number precedes the positive number, so 2's complement gives the correct result (except that negative zero and positive zero should be considered equal). If both values are positive, the 2's complement comparison again gives the correct result. Otherwise (two negative numbers), the correct FP ordering {{is the opposite of}} the 2's complement ordering.|$|E
40|$|A {{lathe tool}} and holder {{combination}} for machining resin impregnated fiberglass cloth laminates is described. The tool holder and tool <b>bit</b> <b>combination</b> {{is designed to}} accommodate a conventional carbide-tipped, round shank router bit as the cutting medium, and provides {{an infinite number of}} cutting angles in order to produce a true and smooth surface in the fiberglass material workpiece with every pass of the tool bit. The technique utilizes damaged router bits which ordinarily would be discarded...|$|E
3000|$|... ms prompt {{correlator}} outputs {{starting from}} a bit boundary (so {{as to avoid}} integrating over a boundary) and locally generated bit combinations. If trying to decode N bits at a time, the number of possible bit combinations is equal to 2 N - 1, and the correct <b>bit</b> <b>combination</b> {{is supposed to have}} the maximum energy. It is noted that the energy based ML bit decoding method detects the bit transition instead of the actual bit values (i.e., there is a sign ambiguity), but this is sufficient for data wipe-off for extending integration time.|$|E
5000|$|... 3GPP {{developed}} TBCD, {{an expansion}} to BCD where the remaining (unused) <b>bit</b> <b>combinations</b> {{are used to}} add specific telephony characters, with digits {{similar to those found}} in telephone keypads original design. It is backward compatible with BCD.|$|R
50|$|This in turn means: A station noting a {{collision}} has occurred {{is sending a}} 4 to 6 byte long pattern composed of 16 1-0 <b>bit</b> <b>combinations.</b> Note: The size of this jam signal is clearly beyond the minimum allowed frame-size of 64 bytes.|$|R
50|$|Another {{advantage}} is that the codes associated with all bits cleared (0000) or set (1111) are not normally (or necessarily) used; these <b>bit</b> <b>combinations</b> are often more prone to errors induced by the hardware or transmission line, f.e. {{it is more difficult}} to write the zero pattern to magneting media.|$|R
40|$|Covert channel {{techniques}} {{are used by}} attackers to transfer data in a way prohibited by the security policy. There are two main categories of covert channels: timing channels and storage channels. This paper introduces a new storage channel technique called a protocol channel. A protocol channel switches one {{of at least two}} protocols to send a <b>bit</b> <b>combination</b> to a destination. The main goal of a protocol channel is that packets containing covert information look equal to all other packets within a network, what makes a protocol channel hard to detect. Comment: 2 page...|$|E
40|$|ABSTRACT: Steganography {{hides the}} {{existence}} of the data inside any cover file. There are different file formats used in steganography like text, image, audio and video. Out of these file formats image steganography is followed in this paper. One of the major objective of hiding data using image steganography is to hide the data in an image, so that the changes in the intensity of the colors of image must not be visible to, human eye. The focus of this paper is on spatial domain technique i. e. LSB technique of image steganography. Method used in the paper hides the data in combination of LSBs instead of hiding the data only in least significant one <b>bit.</b> <b>Combination</b> of bits used are LSB (1, 2) bits and (2, 3) bits. Results are compared qualitatively and quantitatively using parameters PSNR, MSE, BER, Entropy, Standard deviation. data from unauthorized users there is a need of hiding the data. There are various techniques of steganography of which image steganography technique is most useful. 2. Image Steganography An image is an array of M*N matrix. Each and every pixel has a numerical value which represents the color and light intensity of the pixel [4]. Images are more popular cover files for transmission over the internet due to harmlessness and attraction. In image steganography, data is to be inserted into the cover image that gives the resultant stego-image [5, 6]...|$|E
40|$|Sequential {{sampling}} oscilloscopes normally display eye diagrams as {{a series}} of disconnected points on the screen. While these points accurately represent all the combinations of digitized bit patterns, each point is obtained from a separate trigger event, so {{there is no way to}} determine exact characteristics of any specific <b>bit</b> <b>combination</b> (Fig. 1 a). (a) (b) Fig. 1. Sequential sampling oscilloscopes show eye diagrams {{as a series}} of disconnected dots (a). Using the HP Eyeline display mode (b), the individual bit patterns can be distinguished. When sampling live data there is no alternative, but when sampling repetitive waveforms such as pseudorandom binary sequence (PRBS) patterns it is often possible to show the individual bit sequences. This is done by synchronizing the oscilloscope trigger with the pattern repetition rate. In this case, the oscilloscope repeatedly triggers at the same point in the pattern, so the display is a sampled representation of that segment of the pattern. This display mode, called pattern triggering, is commonly used in situations where the device under test can be stimulated with a digital pattern generator from a bit error rate tester (BERT). Pattern generators typically include a trigger output that can be set to produce a trigger pulse at the start of each pattern. The problem has been that until recently, it has not been possible to accurately display portions of the pattern far from the trigger point. While it is theoretically possible to show different parts of the pattern by increasing th...|$|E
30|$|In error concealment, {{the clean}} speech {{estimator}} (29) is a sum due to quantization and the respective finite number of transmittable <b>bit</b> <b>combinations.</b> This estimator is computationally complex but manageable in practice {{due to the}} one-dimensional pdfs (cf. discrete terms (28), (31)). Thus, the sum (29) can explicitly be computed at runtime [26]. Interestingly, a closed-form solution of the sum cannot be achieved due to the likelihood which cannot be approximated by a common pdf, as outlined in Section 1.|$|R
40|$|Described {{is a smart}} {{pressure}} sensor that can be calibrated and compensated for temperature effects by its digitally programmable on-chip electronics, {{without the need for}} additional external components or laser trimming of on-chip thin film resistors. Programming is done via a dual-line connection and a serial port by means of a PC. A program developed for this purpose determines from a simple test the optimum <b>bit</b> <b>combinations</b> for the six programmable parameters that are stored in a 30 -bit static on-chip shift register...|$|R
50|$|The main {{principle}} behind CELP {{is called}} Analysis-by-Synthesis (AbS) and {{means that the}} encoding (analysis) is performed by perceptually optimizing the decoded (synthesis) signal in a closed loop. In theory, the best CELP stream would be produced by trying all possible <b>bit</b> <b>combinations</b> and selecting the one that produces the best-sounding decoded signal. This is obviously not possible in practice for two reasons: the required complexity is beyond any currently available hardware and the “best sounding” selection criterion implies a human listener.|$|R
40|$|The {{subject of}} this thesis is the {{investigation}} of a digital absolute posi- tion-detection system, {{which is based on}} a position-information carrier (i. e. a magnetic tape) with one single code track on the one hand, and an array of magnetoresistive sensors for the detection of the information on the other. The sensor array consists of a permalloy (Ni 0. 81 Fe 0. 19) strip which is electrically sub-divided into adjacent sensor elements by means of cross- contact leads (Mo-Al). The sensor response on a magnetic field in the plane of the strip {{is a result of the}} anisotropic magnetoresistance effect in thin ferromagnetic films. The permalloy strip has a thickness of about 50 nm and a width in the range of 10 to 30 um. The central positions of the sensor elements are located at mutual distances of 50 to 200 um, which is dependent on the bit period in the magnetic tape. The plane of the sensor strip is positioned perpendicular to the magnetic-tape plane. The strip axis and direction of movement of the permalloy strip are lengthways along the magnetic tape. This tape is recorded with a so-called pseudo-random bit pattern, having the property that each arbitrary selected set of n adjacent bits is unique. Depending on the actual position of the sensor head, a special <b>bit</b> <b>combination</b> is detected by a sensor array con- sisting of n elements. This digital word can be decoded to a position coordi- nate. The thesis reports on the feasibility of the position-detection system on the basis of experiments with specially developed measurement heads. In introduc- tory observations the backgrounds, the theory and the design choices come up for discussion. Attention is paid to the modelling of the magnetization distribution in the permalloy strip, which is excited by homogeneous or inhomogeneous magnetic fields. Next the conversion of the magnetization distribution into magnetoresistance and so-called planar-Hall voltages is treated, resulting in a clear choice for the application of the former in a position-detector array. The potentialities of a silicon Hall-sensor array as an alternative for permalloy sensors is considered. Next the basic set-up of a complete position-detection system is discussed, including the generation of the applied position code, as well as methods to cope with problems like the sensor arrays being non-ideally positioned with respect to the bit centres and the potentialities of the application of interpolation schemes. For practical reasons commercially available, longitudinally magnetized tapes are used as a position-data carrier in an experimental system. In view of the computations of the sensor behaviour in the stray field of such a tape, the foundations of a computer simulation model are discussed, resulting in both a practical "simple" model and a more-difficult sophisticated model. Next the details of the realized sensor-chip design are outlined. The realization of the sensor head has been a very demanding activity of this research project; two subjects are discussed in detail. First the realization of the required low interface-resistivity value between permalloy and conduc- tor film is discussed. Second the positioning of the sensor strip at the very edge of the substrate (distance in the order of micrometers) is described. The measurements chapter describes the applied measurement equipment, the various properties and dimensions of the prototype sensor structures and the set-up of the actually performed measurements, i. e. the registration of the sensor-element responses in the stray fields of magnetic tapes. The results are evaluated for sensor elements and tapes with various properties, in the light of the so-called detection distances which are determined with the help of "eye patterns" composed on the basis of worst-case responses. The lower limit of the bit period is found to be in the order of a few hundred micro- meters. Conclusions are first addressed to the performance of the computer model. It is found that the simple simulation model results in reasonably accurate approximations of the sensor responses and detection distances, if the computations are carried out for relatively small values (t ~ 10 um) of the separation between the sensor strip and the magnetic-tape surface. A careful extension of the range of the experimental parameters in the computer model does not result in essentially better computed figures for the minimum bit period (i. e. resolution) of the position-detection system: Prospects of improved performances could possibly arise by the introduction of an all- embracing second design round. It is noted that the final resolution of the position-detection system, being in the order of magnitude of 100 um, can be improved by a factor of 10 to 100 with the application of interpolation techniques. In this case the increase of the accuracy which, in the first instance, is in the order of magnitude of the bit period, will be dependent on the actual quality of these techniques. Finally, the performance of a position detection system based on the alternative silicon-Hall technology is estimated to be of the same order as the permalloy-based version. In an appendix attention is paid to measurement techniques which, based on magnetoresistance sensors, at the time were applied for analysis of the form and magnitude of the compact head field of recording write heads. The utilization of the discussed absolute position-detection system should be based on the possibilities to economically realize a (mass) product with relatively good performance with respect to the established (mostly optical) systems. Having this aim in view, a special-purpose signal-processing chip should be developed, among other things, and integrated with the thin-film sensor structure. However, extensive and multidisciplinar activities of this kind are found to form a certain barrier for the utilization of the design...|$|E
30|$|The {{rationale}} {{beyond the}} use of gray code representation is the following. In the gray code space, just a subset of all possible <b>bit</b> <b>combinations</b> {{is related to the}} eyes patches. We wish to select those bits that usually differ in terms of binary value between eye and non-eye patches. Moreover, by using gray code representation rather than classic bit planes decomposition, we reduce the impact of small changes in intensity of patches that could produce significant variations in the corresponding binary code [17].|$|R
2500|$|In two's {{complement}} notation, a non-negative {{number is}} represented by its ordinary binary representation; in this case, the most significant bit is 0. Though, the range of numbers represented {{is not the same}} as with unsigned binary numbers. [...] For example, an 8-bit unsigned number can represent the values 0 to 255 (11111111). [...] However a two's complement 8-bit number can only represent positive integers from 0 to 127 (01111111), because the rest of the <b>bit</b> <b>combinations</b> with the most significant bit as '1' represent the negative integers −1 to −128.|$|R
40|$|A THz time-domain spectroscopy-based vector network {{analyzer}} for S 21 -parameter measurements is presented providing THz waveforms as input signal for waveguide-coupled devices under test. We integrate an optical pulse shaper into the emitter arm and fiber-couple the photoconductive antennas to allow for flexible usage. The pulse-shaping capabilities are demonstrated by realizing all 5 <b>bit</b> <b>combinations</b> of a 0. 5 THz signal. Furthermore, we can set the center wavelength of the resulting THz spectrum. Finally, we apply the shaped THz waveforms to test the response of a low-noise amplifier...|$|R
50|$|In two's {{complement}} notation, a non-negative {{number is}} represented by its ordinary binary representation; in this case, the most significant bit is 0. Though, the range of numbers represented {{is not the same}} as with unsigned binary numbers. For example, an 8-bit unsigned number can represent the values 0 to 255 (11111111). However a two's complement 8-bit number can only represent positive integers from 0 to 127 (01111111), because the rest of the <b>bit</b> <b>combinations</b> with the most significant bit as '1' represent the negative integers −1 to −128.|$|R
5000|$|DQPSK is the four-level {{version of}} DPSK. DQPSK transmits two bits for every symbol (<b>bit</b> <b>combinations</b> being 00, 01, 11 and 10) {{and has an}} {{additional}} advantage over conventional binary DPSK. DQPSK has a narrower optical spectrum, which tolerates more dispersion (both chromatic and polarization-mode), allows for stronger optical filtering, and enables closer channel spacing. As a result, DQPSK allows processing of 40 Gbit/s data-rate in a 50 GHz channel spacing system. A demodulator for optical DQPSK signals can be constructed using two matched DPSK demodulators with phase off-set at [...]|$|R
3000|$|In {{order to}} be able to employ a bit-level model for the {{acoustic}} channel, we assume that the real part of the speech and the noisy speech DFT coefficients are quantized by M bit. Therefore, those quantities can bijectively be mapped into the <b>bit</b> <b>combinations</b> S_ℓ^re(k) = [...] [S_ 0,ℓ^re(k), S_ 1,ℓ^re(k), [...]..., S_m,ℓ^re(k), [...]..., S_M - 1,ℓ^re(k)] and Y_ℓ^re(k) = [...] [Y_ 0,ℓ^re(k), Y_ 1,ℓ^re(k), [...]..., Y_m,ℓ^re(k), [...]..., Y_M - 1,ℓ^re(k)], respectively. Due to the fact that speech is distorted by acoustic noise while passing through the acoustic channel, the observed <b>bit</b> <b>combinations</b> at the acoustic channel output Y_ℓ^re(k) may differ from those at the channel input S_ℓ^re(k). Accordingly, a bit error at bit position m∈ 0, 1,…,M − 1 occurs if the received bit Y_m,ℓ^re(k) is not equal to the transmitted one S_m,ℓ^re(k). The bit error rate BER_m^re(k) can be measured within a training process by comparing S_m,ℓ^re(k) to Y_m,ℓ^re(k) for all bit positions m, individually for each frequency bin k. Please note that the bit errors also depend on the local SNR in the current time-frequency unit (ℓ,k), therefore, the SNR has to be taken into account during the training process. Accordingly, the training steps can be summarized as follows: Using speech and car noise data we generated noisy speech signals at different signal SNR levels. Then, we calculated the short-time spectra of the clean speech, the noise, and the noisy speech signals resulting in S [...]...|$|R
50|$|Most {{computer}} languages {{support the}} setting {{and testing of}} single or multiple <b>bits</b> in <b>combination</b> for use as truth indicators and usually up to 256 different combinations of conditions can be tested for with just a single instruction on one byte.|$|R
40|$|We utilize {{a formal}} model of {{division}} for determining a testbench of p-bit (dividend, divisor) pairs whose output 2 p-bit quotients have properties characterizing these in-stances {{as the most}} challenging for verifying any division algorithm design and implementation. Specifically, our test suites yield 2 p-bit quotients where the leading p-bits traverse all or a pseudo-random sample of leading <b>bit</b> <b>combinations,</b> and the next p-bits comprise a round bit followed by (p- 1) identical bits. These values are pro ven to be closest to the p-bit quotient rounding boundaries and shown to possess other desirable coverage properties. We introduce an efficient method of generating these test-benches. We also describe applications of these testbench-es at the design simulation stage and the product evalua-tion stage. 1...|$|R
40|$|Recent {{dissemination}} of personal data {{has created an}} important optimization problem: what is the minimal transformation of a dataset {{that is needed to}} guarantee the anonymity of the underlying individuals? One natural representation for this problem is a bit-string, which makes a genetic algorithm a logical choice for optimization. Unfortunately, under certain realistic conditions, not all <b>bit</b> <b>combinations</b> will represent valid solutions. This means that in many instances, useful solutions are sparse in the search space. We implement a new crossover operator that preserves valid solutions under this representation. Our results show that this reproductive strategy is more efficient, effective, and robust than previous work. We also investigate how the population size and uniqueness can affect the performance of genetic search on this application...|$|R
5000|$|The Motorola 6800 {{microprocessor}} was {{the first}} for which an undocumented assembly mnemonic HCF became widely known. The operation codes (opcodes)—the portions of the machine language instructions that specify an operation to be performed—referred to by the mnemonic HCF are $9D and $DD and were reported in an article written by Gerry Wheeler in the December 1977 issue of BYTE magazine on undocumented opcodes. Wheeler noted that Motorola reported 197 valid operation codes for the M6800 processor, and so inferred that with 256 possible 8 <b>bit</b> <b>combinations,</b> there must be 59 [...] "invalid instructions." [...] He goes on to describe the HCF as a [...] "big surprise," [...] and saying of the Catch Fire portion of the moniker, [...] "Well, almost.": ...|$|R
5000|$|The {{following}} {{table lists}} allowed register addressing <b>combinations</b> (<b>bit</b> 4 is always zero when encoding the 16 general purpose registers): ...|$|R
50|$|Some RISC {{machines}} have {{a special}} Load Upper Literal instruction which places a 16- or 20-bit constant in {{the top half of}} a register. That can then be used as the base register in a base-plus-offset addressing mode which supplies the low-order 16 or 12 <b>bits.</b> The <b>combination</b> allows a full 32-bit address.|$|R
3000|$|... (k), respectively. Using the {{resulting}} DFT coefficients, we calculated the true speech power σ _S,ℓ^ 2 (k) = E { |S_ℓ(k)|^ 2 } {{and the true}} noise power σ _D,ℓ^ 2 (k) = E { |D_ℓ(k)|^ 2 }. Using those two power spectra, we obtained the true a priori SNR as ξ _ℓ(k) = σ _S,ℓ^ 2 (k) / σ _D,ℓ^ 2 (k). Then, we quantized the real part of the clean speech and noisy speech DFT coefficients by 16 bit resulting in the <b>bit</b> <b>combinations</b> S_ℓ^re(k) and Y_ℓ^re(k), respectively. By this means, the whole training data was processed and S_m,ℓ^re(k) ∈S_ℓ^re(k) and Y_m,ℓ^re(k) ∈Y_ℓ^re(k) were compared to each other. Bit errors S_m,ℓ^re(k) ≠ Y_m,ℓ^re(k) were counted at bit position m, frequency bin k, and in dependence of the a priori SNR. For the latter, the ideal a priori SNR ξ [...]...|$|R
3000|$|Suppose [...] f [...] has an anti-symmetric {{variable}} pair [...] (x_i,x_j [...]) [...]. If {{this were}} an ordinary symmetric variable pair, the symmetry group of [...] f [...] would contain the group {I,(x_i,x_j [...])}. To test for this subgroup one would check the orbits 01 x…x,  10 x…x, where “x…x” ranges through all <b>bit</b> <b>combinations.</b> However, {{because this is}} an anti-symmetric variable pair, [...] f_ 10 and [...] f_ 01 must produce the opposite value for each input. If 01 x…x produces a one value then 10 x…x must produce a zero value, and vice versa. Thus, no orbit may imply either [...] f [...] or [...] f^'. This is a necessary and sufficient condition for the anti-symmetric variable pair to exist. Thus, it is possible test for anti-symmetric variable pairs using the same library used to detect normal symmetric variable pairs. When testing the orbits, it is necessary to test for non-implication rather than implication. This is a simple change, enabling the algorithm to detect anti-symmetric pairs just as easily as normal symmetric pairs. This principle extends to anti-symmetric pairs of all six types.|$|R
40|$|The {{adoption}} of ECMA- 6 (ISO/IEC 646) as the agreed international 7 -bit code for information interchange {{had led to}} the development of many national, international and application-oriented versions of this code. These versions had a number of limitations generally inherent to the size of the code: they did not provide all graphic characters which were needed; for some characters, specially for accented letters, it was necessary to resort to BACKSPACE sequences, which created problems when processing data containing such composite characters; − interchange among different versions was practically limited to the 82 common graphic characters. With the advent of 8 -bit coding it was possible to increase the number of graphic characters. ISO/IEC 6937, for example, provided a character set covering the requirements of most languages based on the Latin alphabet. This character set, although well suited for text communication, was difficult to use for processing as some graphic characters were represented by one and others by two <b>bit</b> <b>combinations.</b> Thus the need was recognized for coded graphic character sets, each of which: is the same for all users of a given area, provides single-byte coding of all graphic characters, thus permitting easy processing, − takes into account character sets used in the industry...|$|R
40|$|The {{adoption}} of Standard ECMA- 6 (ISO 646) in 1965 as the agreed international 7 -bit code for information interchange {{has led to}} the development of many national, international and application-oriented versions of this code which have been in wide use for quite some time. These versions had a number of limitations generally inherent to the size of the code: − they did not provide all graphic characters which may be needed, − for some characters, specially for accented letters, it was necessary to resort to BACKSPACE sequences, which created problems when processing data containing such composite characters, − interchange among different versions was practically limited to the 82 common graphic characters. With the advent of 8 -bit coding it was possible to increase the number of graphic characters. ISO 6937 / 2, for example, provided a character set covering the requirements of most languages based on the Latin alphabet. This character set, although well suited for text communication, was difficult to use for processing as some graphic characters were represented by one and others by two <b>bit</b> <b>combinations.</b> Thus, the need was recognized for coded graphic character sets, each of which: − is the same for all users of a given area, − provides single-byte coding of all graphic characters thus permitting easy processing...|$|R
50|$|Combination reamers can be {{made out}} of cobalt, carbide, or high speed steel tooling. When using {{combination}} reamers to ream large internal diameters made out of material with lower surface feet per minute, carbide tips can be brazed onto a configured drill blank to build the reamer. Carbide requires additional care because it is very brittle and will chip if chatter occurs. It is common to use a drill <b>bit</b> or <b>combination</b> drill to remove the bulk of material to reduce wear, or {{the risk of the}} part pulling off on the combination reamer.|$|R
