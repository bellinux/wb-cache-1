194|318|Public
25|$|Church Booleans are the Church {{encoding}} of the <b>Boolean</b> <b>values</b> true and false. Some programming languages {{use these}} as an implementation model for Boolean arithmetic; examples are Smalltalk and Pico.|$|E
25|$|SAT is in NP {{because any}} {{assignment}} of <b>Boolean</b> <b>values</b> to Boolean variables that is claimed {{to satisfy the}} given expression can be verified in polynomial time by a deterministic Turing machine. (The statements verifiable in polynomial time by a deterministic Turing machine and solvable in polynomial time by a non-deterministic Turing machine are totally equivalent, and {{the proof can be}} found in many textbooks, for example Sipser's Introduction to the Theory of Computation, section 7.3.).|$|E
2500|$|Boolean {{function}}, {{a function}} that determines <b>Boolean</b> <b>values</b> or operators ...|$|E
40|$|Making use of <b>Boolean</b> <b>valued</b> {{representation}} it is {{proved that}} Kaplansky–Hilbert lattices and injective Banach lattices may be produced {{from each other}} {{by means of the}} convexification procedure. The relationship between the Kantorovich’s heuristic principle and the <b>Boolean</b> <b>value</b> transfer principle is also discussed...|$|R
40|$|AbstractFor each {{consistent}} universal {{first order}} theory T a <b>Boolean</b> <b>valued</b> model of T is constructed that satisfies an existential sentence if {{and only if}} it is provable from T. The resolution calculus is extended so that proofs from T yield representations of objects incompletely specified by T in a <b>Boolean</b> <b>valued</b> model...|$|R
50|$|The <b>Boolean</b> <b>valued</b> models {{constructed}} by forcing are built using a cumulative hierarchy.|$|R
2500|$|By convention, the {{following}} two definitions (known as Church booleans) are used for the <b>boolean</b> <b>values</b> TRUE and FALSE: ...|$|E
2500|$|However, the {{definition}} above is valid for any measurable space [...] of values. [...] Thus one can consider random elements of other sets , such as random <b>boolean</b> <b>values,</b> categorical values, complex numbers, vectors, matrices, sequences, trees, sets, shapes, manifolds, and functions. [...] One may then specifically {{refer to a}} random variable of type , or an -valued random variable.|$|E
2500|$|Another {{disadvantage}} of linked lists is the extra storage needed for references, which often makes them impractical for lists of small data {{items such as}} characters or <b>boolean</b> <b>values,</b> because the storage overhead for the links may exceed {{by a factor of}} two or more the size of the data. In contrast, a dynamic array requires only the space for the data itself (and a very small amount of control data)., where [...] is a per-array constant, [...] is a per-dimension constant, and [...] is the number of dimensions. [...] and [...] are typically on the order of 10 bytes. [...] It can also be slow, and with a naïve allocator, wasteful, to allocate memory separately for each new element, a problem generally solved using memory pools.|$|E
40|$|For any {{first order}} theory T we {{construct}} a <b>Boolean</b> <b>valued</b> model M, in which precisely the T [...] provable formulas hold, {{and in which}} every (<b>Boolean</b> <b>valued)</b> subset which is invariant under all automorphisms of M is definable by a first order formula. Our presentation is entirely selfcontained, and only requires familiarity with the most elementary properties of model theory...|$|R
2500|$|Boolean {{expression}}, {{an expression}} in {{a programming language}} that produces a <b>Boolean</b> <b>value</b> when evaluated ...|$|R
5000|$|Simplified Independence Proofs: <b>Boolean</b> <b>Valued</b> Models of Set Theory, by J. Barkley Rosser, Academic Press, 1969 ...|$|R
2500|$|Computers use two-value Boolean {{circuits}} for {{the above}} reasons. The most common computer architectures use ordered sequences of <b>Boolean</b> <b>values,</b> called bits, of 32 or 64 values, e.g. 01101000110101100101010101001011. When programming in machine code, assembly language, and certain other programming languages, programmers {{work with the}} low-level digital structure of the data registers. These registers operate on voltages, where zero volts represents Boolean 0, and a reference voltage (often +5V, +3.3V, +1.8V) represents Boolean 1. Such languages support both numeric operations and logical operations. In this context, [...] "numeric" [...] means that the computer treats sequences of bits as binary numbers (base two numbers) and executes arithmetic operations like add, subtract, multiply, or divide. [...] "Logical" [...] refers to the Boolean logical operations of disjunction, conjunction, and negation between two sequences of bits, in which each bit in one sequence is simply compared to its counterpart in the other sequence. Programmers therefore {{have the option of}} working in and applying the rules of either numeric algebra or Boolean algebra as needed. A core differentiating feature between these families of operations is the existence of the carry operation in the first but not the second.|$|E
5000|$|Boolean {{function}}, {{a function}} that determines <b>Boolean</b> <b>values</b> or operators ...|$|E
5000|$|Majority function, the {{majority}} {{of a collection of}} <b>Boolean</b> <b>values</b> ...|$|E
40|$|The term “Boolean valued {{analysis}} ” appeared {{within the}} realm of mathematical logic. It was Takeuti, a renowned expert in proof theory, who introduced the term. Takeuti defined <b>Boolean</b> <b>valued</b> analysis in [18, p. 1] as “an application of Scott–Solovay’s <b>Boolean</b> <b>valued</b> models of set theory to analysis. ” Vopěnka invented similar models at the same time. That is how the question of the title receive...|$|R
40|$|Recently <b>Boolean</b> <b>valued</b> {{analysis}} (i. e., analysis {{based on}} <b>Boolean</b> <b>valued</b> set theory) {{has been extensively}} studied by G. Takeuti [14 – 16]. The main {{purpose of this paper}} is to show, by using this technique, that any continuous geometry can be viewed as an irreducible continuous geometry in its center valued set theory. This makes the transition from irreducible continuous geometries to reducible ones automatic...|$|R
50|$|Here again B is a <b>boolean</b> <b>value</b> (0 or 1), and S is a {{sequence}} of statements.|$|R
5000|$|Axiom 1 {{expresses the}} idea that [...] and [...] are the only <b>boolean</b> <b>values.</b>|$|E
5000|$|By convention, the {{following}} two definitions (known as Church booleans) are used for the <b>boolean</b> <b>values</b> TRUE and FALSE: ...|$|E
5000|$|The {{following}} two definitions for the <b>boolean</b> <b>values</b> [...] and [...] are used, extending {{the definition of}} Church booleans: ...|$|E
50|$|Kutateladze S.S. What is <b>Boolean</b> <b>valued</b> analysis? Siberian Advances in Mathematics, 2007, Vol. 17, No. 2, 91-111.|$|R
5000|$|Conversion of <b>Boolean</b> <b>value</b> True to Integer {{may yield}} -1 or 1 {{depending}} on the conversion used ...|$|R
25|$|Where the {{constant}} representing the <b>boolean</b> <b>value</b> of true is T in most Lisps, in Scheme it is #t.|$|R
5000|$|Standard C (since C99) {{provides}} a boolean type, called [...] By {{including the header}} [...] one can use the more intuitive name [...] and the constants [...] and [...] The language guarantees that any two true values will compare equal (which was impossible to achieve before {{the introduction of the}} type). <b>Boolean</b> <b>values</b> still behave as integers, can be stored in integer variables, and used anywhere integers would be valid, including in indexing, arithmetic, parsing, and formatting. This approach (<b>Boolean</b> <b>values</b> are just integers) has been retained in all later versions of C.|$|E
50|$|Church Booleans are the Church {{encoding}} of the <b>Boolean</b> <b>values</b> true and false. Some programming languages {{use these}} as an implementation model for Boolean arithmetic; examples are Smalltalk and Pico.|$|E
5000|$|The [...]NET Framework {{supplies}} a [...] collection class. It stores <b>boolean</b> <b>values,</b> supports {{random access}} and bitwise operators, can be iterated over, and its [...] property {{can be changed}} to grow or truncate it.|$|E
50|$|Bit (<b>boolean</b> <b>value),</b> {{bit field}} (group {{of up to}} 32 bits) and bit string (up to 4Gb in length).|$|R
5000|$|A boolean flag, truth bit or truth flag in {{computer}} science is a <b>Boolean</b> <b>value</b> represented as one bit ...|$|R
5000|$|Where the {{constant}} representing the <b>boolean</b> <b>value</b> of true is [...] in most Lisps, in Scheme it is [...]|$|R
50|$|The {{recursive}} expression then {{represents a}} value {{that does not}} exist. The laws of logic are only valid for <b>Boolean</b> <b>values</b> in {true, false}, so any deduction made from the expression may be in error.|$|E
50|$|The limited-entry {{decision}} table is the simplest to describe. The condition alternatives are simple <b>Boolean</b> <b>values,</b> {{and the action}} entries are check-marks, representing which of the actions in a given column are to be performed.|$|E
5000|$|For the {{language}} of all finite lists of <b>boolean</b> <b>values</b> from the above example, all terms beyond the height limit k=2 can be pumped, since they need to contain an occurrence of [...] For example, ...|$|E
50|$|Kutateladze S.S. Leibnizian, Robinsonian, and <b>Boolean</b> <b>valued</b> monads, Journal of Applied and Industrial Mathematics, 2011, Vol. 5, No. 3, 365-373.|$|R
50|$|Interpretations used {{to study}} non-classical logic include topological models, <b>Boolean</b> <b>valued</b> models, and Kripke models. Modal logic is also studied using Kripke models.|$|R
2500|$|In {{the case}} of Boolean-valued forcing, the {{procedure}} is similar – one has {{to prove that the}} <b>Boolean</b> <b>value</b> of [...] is not [...]|$|R
