57|171|Public
500|$|The {{advantages}} in speed {{offered by the}} fast inverse square root kludge came from treating the longword reduces the portability of this code on modern systems. For the code to execute properly, sizeof(long) must be 4 bytes, otherwise negative outputs may result. Under many modern 64-bit systems, sizeof(long) is 8 bytes. containing the floating point number as an integer then subtracting it from a specific constant, 0x5F3759DF. [...] The purpose of the constant is not immediately clear to someone viewing the code, so, like other such constants found in code, it is often called a magic number. This integer subtraction and <b>bit</b> <b>shift</b> results in a longword which when treated as a floating point number is a rough approximation for the inverse square root of the input number. [...] One iteration of Newton's method is performed to gain some accuracy, and the code is finished. [...] The algorithm generates reasonably accurate results using a unique first approximation for Newton's method; however, it is much slower and less accurate than using the SSE instruction rsqrtss on x86 processors also released in 1999.|$|E
2500|$|The {{reason that}} the dyadic {{transformation}} is also called the bit-shift map is that when [...] is written in binary notation, the map moves the binary point one place to the right (and if the bit {{to the left of}} the binary point has become a [...] "1", this [...] "1" [...] is changed to a [...] "0"). [...] A cycle of length 3, for example, occurs if an iterate has a 3-bit repeating sequence in its binary expansion (which is not also a one-bit repeating sequence): 001, 010, 100, 110, 101, or 011. The iterate 001001001... maps into 010010010..., which maps into 100100100..., which in turn maps into the original 001001001...; so this is a 3-cycle of the <b>bit</b> <b>shift</b> map. [...] And the other three binary-expansion repeating sequences give the 3-cycle 110110110... → 101101101... → 011011011... → 110110110.... Either of these 3-cycles can be converted to fraction form: for example, the first-given 3-cycle can be written as 1/7 → 2/7 → 4/7 → 1/7. [...] Using the above translation from the bit-shift map to the [...] logistic map gives the corresponding logistic cycle [...]611260467... → [...]950484434... → [...]188255099... → [...]611260467... We could similarly translate the other bit-shift 3-cycle into its corresponding logistic cycle. [...] Likewise, cycles of any length [...] can be found in the bit-shift map and then translated into the corresponding logistic cycles.|$|E
5000|$|The r = 4 {{case of the}} {{logistic}} map is this {{is related}} to the <b>bit</b> <b>shift</b> map in variable x by ...|$|E
5000|$|Keyboard scan (up to 64 keys) + 2 {{modifier}} <b>bits</b> (<b>Shift,</b> Control) ...|$|R
50|$|A typical initial guess can {{be found}} by {{rounding}} b to a nearby power of 2, then using <b>bit</b> <b>shifts</b> to compute its reciprocal.|$|R
50|$|ALU shift {{operations}} cause operand A (or B) {{to shift}} {{left or right}} (depending on the opcode) and the shifted operand appears at Y. Simple ALUs typically can shift the operand by only one bit position, whereas more complex ALUs employ barrel shifters {{that allow them to}} shift the operand by an arbitrary number of bits in one operation. In all single-bit <b>shift</b> operations, the <b>bit</b> <b>shifted</b> out of the operand appears on carry-out; the value of the <b>bit</b> <b>shifted</b> into the operand depends on the type of shift.|$|R
50|$|Likewise, {{division}} by 10 can {{be expressed}} as a multiplication by 3435973837 (0xCCCCCCCD) followed by division by 235 (or 35 right <b>bit</b> <b>shift).</b>|$|E
5000|$|The [...] case of {{the tent}} map is a {{non-linear}} transformation of both the <b>bit</b> <b>shift</b> map and the r=4 {{case of the}} logistic map.|$|E
5000|$|The dyadic {{transformation}} (also {{known as}} the dyadic map, <b>bit</b> <b>shift</b> map, 2x mod 1 map, Bernoulli map, doubling map or sawtooth map) is the mapping (i.e., recurrence relation) ...|$|E
50|$|This formula {{requires}} only k multiplications and k additions, for any array that can fit in memory. Moreover, if any coefficient is a fixed power of 2, the multiplication {{can be replaced}} by <b>bit</b> <b>shifting.</b>|$|R
5000|$|In base 2, long {{multiplication}} reduces to {{a nearly}} trivial operation. For each '1' <b>bit</b> in the , <b>shift</b> the [...] an appropriate amount and then sum the shifted values. Depending on computer processor architecture and choice of multiplier, {{it may be}} faster to code this algorithm using hardware <b>bit</b> <b>shifts</b> and adds rather than depend on multiplication instructions, when the multiplier is fixed {{and the number of}} adds required is small.|$|R
30|$|The FPGA {{implementation}} stores 5 {{lines for}} each video in a temporary line cache {{to perform the}} interpolation. The arithmetics of the interpolation [16] can be efficiently implemented using adders and <b>bit</b> <b>shifts</b> only, due to the 'hardware friendly' choice of the interpolation coefficients.|$|R
50|$|The {{term was}} then {{generalized}} into any place where useless bits go, a useful computing concept {{known as the}} null device. The term bit bucket is also used in discussions of <b>bit</b> <b>shift</b> operations.|$|E
50|$|To {{obtain the}} bit mask needed for these operations, {{we can use}} a <b>bit</b> <b>shift</b> {{operator}} to shift the number 1 to the left by the appropriate number of places, as well as bitwise negation if necessary.|$|E
5000|$|The {{first three}} words, KX0, KX1, KX2 are set based on constants, the sub-cipher, {{and the length}} of the key. KX1 is {{computed}} with a multiplication; the other operations involved are an addition and a <b>bit</b> <b>shift.</b>|$|E
40|$|Abstract—Commonly in {{encryption}} or decryption process some of {{the characters}} are inter changed by using some encryption and decryption algorithms (like DES, IDEA) with key. But in <b>Bit</b> <b>Shifting</b> and Stuffing (BSS) system to represent a printable character it needs only seven bits as per its ASCII value. In computer system to represent a printable character it requires one byte, i. e. 8 bits. So a printable character occupies 7 bits and the last bit value is 0 which is not useful for the character. In BSS method we are stuffing a new bit {{in the place of}} unused <b>bit</b> which is <b>shifting</b> from another printable character. So in this BSS methodology after encryption, for every eight bytes of plain text it will generate seven bytes cipher text and in decryption, for every seven bytes of cipher text it will reproduce eight bytes of plain text. Keywords- Encryption, Decryption, <b>Bit</b> <b>Shifting</b> and Stuffing I...|$|R
50|$|Thus, the {{decision}} criterion changes from using floating-point operations to simple integer addition, subtraction, and <b>bit</b> <b>shifting</b> (for the multiply by 2 operations). If , then decrement the X value. If , then keep the same X value. Again, by reflecting these points {{in all the}} octants, a full circle results.|$|R
50|$|The {{algorithm}} uses a key size of 128, 192, or 256 bits. It {{operates on}} blocks of 128 bits using a 16-round Feistel network structure with key whitening. Designed for speed, Xenon's round function doesn't use any S-boxes. The only operations it uses are XOR, addition, multiplication, and <b>bit</b> <b>shifts.</b>|$|R
50|$|As a {{concrete}} fixed-point arithmetic example, for 32-bit unsigned integers, division by 3 {{can be replaced}} with a multiply by 2863311531&thinsp;&frasl;&thinsp;233, a multiplication by 2863311531 (hexadecimal 0xAAAAAAAB) followed by a 33 right <b>bit</b> <b>shift.</b> The value of 2863311531 is calculated as 233&thinsp;&frasl;&thinsp;3, then rounded up.|$|E
50|$|However, if this doubled {{amplitude}} {{exceeds the}} amount that can be represented with 16 bits, an arithmetic overflow occurs, audible as a very loud popping or cracking noise that occurs whenever the original signal crosses +16384/-16384 (the value of bit 14 lost in the <b>bit</b> <b>shift).</b>|$|E
5000|$|... where [...] and [...] are the {{components}} of [...] Restricting the angles [...] so that [...] takes on the values , the multiplication with the tangent can {{be replaced by a}} division by a power of two, which is efficiently done in digital computer hardware using a <b>bit</b> <b>shift.</b> The expression then becomes: ...|$|E
5000|$|<b>Bit</b> 5-7: <b>Shift</b> {{register}} {{settings for}} noises/distortion. Bit values described below: ...|$|R
30|$|It {{can also}} be {{observed}} in Tables 1 and 2 that the AvN Log-MAP HE algorithm performs the same overall number of operations as the AvN Log-MAP but instead of multiplications it realizes <b>bit</b> <b>shifts.</b> This feature of the AvN Log-MAP HE is favorable in hardware implementation of the algorithm and {{can be considered as}} an additional complexity reduction.|$|R
40|$|AbstractAn {{iterative}} modular {{multiplication algorithm}} designed for efficient implementation on a processor with limited capacity {{such as an}} 8 -bit microcontroller is proposed. It is a generalization of Chiou and Yang's algorithm and can be implemented in software without excessive <b>bit</b> <b>shifting.</b> A proof of correctness of the proposed algorithm is given together with a run-time analysis...|$|R
5000|$|... 65537 is {{also used}} as the modulus in some Lehmer random number generators, {{such as the one}} used by ZX Spectrum, which ensures that any seed value will be coprime to it (vital to ensure the maximum period) while also {{allowing}} efficient reduction by the modulus using a <b>bit</b> <b>shift</b> and subtract.|$|E
5000|$|The name <b>bit</b> <b>shift</b> map arises because, if {{the value}} of an iterate is written in binary notation, the next iterate is {{obtained}} by shifting the binary point one bit to the right, and if the bit {{to the left of the}} new binary point is a [...] "one", replacing it with a zero.|$|E
5000|$|This <b>bit</b> <b>shift</b> is {{implemented}} differently between module generations. In first-generation modules, this <b>bit</b> <b>shift</b> is {{performed at the}} connection between the data bus and DAC: Original (non-shifted) data bit # Connection -------------------------------------------------------------------------------- 15 14 13 12 11 10 09 08 07 06 05 04 03 02 01 00 Output of LA32 synthesizer chip 15 14 13 12 11 10 09 08 07 06 05 04 03 02 01 00 Input to reverberation chip 15 13 12 11 10 09 08 07 06 05 04 03 02 01 00 -- input to DAC | | | +- most significant data-carrying bit +- sign bitThis means that the reverberation chip will not [...] "see" [...] the overflow noise and thus not reverberate it. However, since bit 14 is dropped completely, the effective resolution is reduced to 15 bits, and since the DAC's least significant bit is not connected at all and thus not changing with the sign, additional one-bit noise is produced, audible at low signal levels.|$|E
40|$|Writing {{code that}} manipulates bit streams is a painful and {{error-prone}} programming task, often performed via bit twiddling {{techniques such as}} explicit <b>bit</b> <b>shifts</b> and <b>bit</b> masks in programmer-allocated buffers. Still, this kind of pro- gramming is necessary in many application areas ranging from decoding stream- ing media files to implementing network protocols. In this pa per we employ high...|$|R
40|$|IPsec Anti-Replay Algorithm without <b>Bit</b> <b>Shifting</b> This {{document}} {{presents an}} alternate method {{to do the}} anti-replay checks and updates for IP Authentication Header (AH) and Encapsulating Security Protocol (ESP). The method defined in this document obviates the need for <b>bit</b> <b>shifting</b> and it reduces {{the number of times}} an anti-replay window is adjusted. Status of This Memo This document is not an Internet Standards Track specification; it is published for informational purposes. This is a contribution to the RFC Series, independently of any other RFC stream. The RFC Editor has chosen to publish this document at its discretion and makes no statement about its value for implementation or deployment. Documents approved for publication by the RFC Editor are not a candidate for any level of Internet Standard; see Section 2 of RFC 5741. Information about the current status of this document, any errata, and how to provide feedback on it may be obtained a...|$|R
50|$|The 65CE02 uses a superset of the Rockwell 65SC02 {{instruction}} set. In {{addition to}} the enhancements and bug fixes included in the 65SC02, the 65CE02 includes new instructions for indirect jumps (allows the use of jump tables), 16-bit branches, <b>bit</b> <b>shifting</b> (ASR) and stack relative loads/stores. Several read-modify-write memory instructions (ASL/DEC/INC/PSH/ROR) were enhanced to support 16-bit values. Lastly, instructions supporting the new registers were added.|$|R
50|$|The {{simplification}} process can itself be greatly simplified by performing a <b>bit</b> <b>shift</b> operation: all digits {{to the right}} of the rightmost raised finger (i.e., all trailing zeros) are discarded and the rightmost raised finger is treated as the ones digit. The digits are added together using their now-shifted values to determine the numerator and the rightmost finger's original value is used to determine the denominator.|$|E
50|$|Some motion {{estimation}} algorithms {{can be performed}} using bit planes (e.g. after {{the application of a}} filter to turn salient edge features into binary values). This can sometimes provide a good enough approximation for correlation operations with minimal computational cost. This relies on an observation that the spatial information is more significant than the actual values. Convolutions may be reduced to <b>bit</b> <b>shift</b> and popcount operations, or performed in dedicated hardware.|$|E
50|$|For the {{extensive}} use of 8085 in various applications, the microprocessor is provided with an instruction set consisting of various instructions such as MOV, ADD, SUB, JMP, etc. These instructions are written {{in the form of}} a program which is used to perform various operations such as branching, addition, subtraction, bitwise logical, and <b>bit</b> <b>shift</b> operations. More complex operations and other arithmetic operations must be implemented in software. For example, multiplication is implemented using a multiplication algorithm.|$|E
5000|$|The {{objective}} of the algorithm {{is to find a}} path through the pixel grid using pixels which are {{as close as possible to}} solutions of [...] At each step, the path is extended by choosing the adjacent pixel which satisfies [...] but maximizes [...] Since the candidate pixels are adjacent, the arithmetic to calculate the latter expression is simplified, requiring only <b>bit</b> <b>shifts</b> and additions.|$|R
5000|$|At {{the start}} of each NICAM packet the {{pseudo-random}} <b>bit</b> generator's <b>shift</b> register is reset to all ones.|$|R
500|$|Newton's method, an {{iterative}} method to solve equations approximately, {{can also be}} used to calculate the logarithm, because its inverse function, the exponential function, can be computed efficiently. Using look-up tables, CORDIC-like methods can be used to compute logarithms if the only available operations are addition and <b>bit</b> <b>shifts.</b> Moreover, the binary logarithm algorithm calculates [...] recursively based on repeated squarings of x, taking advantage of the relation ...|$|R
