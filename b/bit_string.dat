414|570|Public
2500|$|... each vector node {{holding the}} {{amplitude}} {{and the state}} as the <b>bit</b> <b>string</b> of qubits). Here, however, the coefficients [...] are complex numbers, {{and it is the}} sum of the squares of the coefficients' absolute values, , that must equal 1. For each , the absolute value squared [...] gives the probability of the system being found after a measurement in the -th state. However, because a complex number encodes not just a magnitude but also a direction in the complex plane, the phase difference between any two coefficients (states) represents a meaningful parameter. This is a fundamental difference between quantum computing and probabilistic classical computing.|$|E
2500|$|The term two's {{complement}} {{can mean}} either a number format or a mathematical operator. For example, 0111 represents decimal 7 in two's-complement notation, but the two's complement of 7 in a 4-bit register {{is actually the}} [...] "1001" [...] <b>bit</b> <b>string</b> (the same as represents [...] in unsigned arithmetics) which is the two's complement representation of −7. The statement [...] "convert [...] to two's complement" [...] may be ambiguous, since it could describe either the process of representing [...] in two's-complement notation without changing its value, or the calculation of the two's complement, which is the arithmetic negative of [...] if two's complement representation is used.|$|E
5000|$|... by {{choosing}} a <b>bit</b> <b>string</b> {{that does not}} match the encoding of any value of the repeating component of the list, and inserting that <b>bit</b> <b>string</b> after the last item of the list; ...|$|E
40|$|For each {{function}} on <b>bit</b> <b>strings,</b> its restriction to <b>bit</b> <b>strings</b> of {{any given}} length can be computed by a finite instruction sequence that contains only instructions to set and get the content of Boolean registers, forward jump instructions, and a termination instruction. We describe instruction sequences of this kind that compute the function on <b>bit</b> <b>strings</b> that models multiplication on natural numbers less than $ 2 ^N$ {{with respect to their}} binary representation by <b>bit</b> <b>strings</b> of length $N$, for a fixed but arbitrary $N > 0 $, according to the long multiplication algorithm and the Karatsuba multiplication algorithm. We find among other things that the instruction sequence expressing the former algorithm is longer than the one expressing the latter algorithm only if the length of the <b>bit</b> <b>strings</b> involved is greater than $ 2 ^ 8 $. We also go into the use of an instruction sequence with backward jump instructions for expressing the long multiplication algorithm. This leads to an instruction sequence that it is shorter than the other two if the length of the <b>bit</b> <b>strings</b> involved is greater than $ 2 $. Comment: 14 pages, the preliminaries of this paper and arXiv: 1308. 0219 are the same; 16 pages, results sharpened and presentation improved; 22 pages, combined with arXiv: 1312. 181...|$|R
40|$|The Karatsuba {{multiplication}} algorithm is an algorithm for computing {{the product of}} two natural numbers represented in the binary number system. This means that the algorithm actually computes a function on <b>bit</b> <b>strings.</b> The restriction of this function to <b>bit</b> <b>strings</b> of any given length can be computed according to the Karatsuba {{multiplication algorithm}} by a finite instruction sequence that contains only instructions to set and get the content of Boolean registers, forward jump instructions, and a termination instruction. We describe the instruction sequences concerned for the restrictions to <b>bit</b> <b>strings</b> of the different lengths by uniform terms from an algebraic theory...|$|R
50|$|The {{mutation}} of <b>bit</b> <b>strings</b> ensue through <b>bit</b> flips {{at random}} positions.|$|R
5000|$|If w is the <b>bit</b> <b>string</b> {{then the}} world is created such that [...] is true. An {{intelligent}} agent has some facts about the word, represented by the <b>bit</b> <b>string</b> c, which gives the condition, ...|$|E
50|$|A brief {{notational}} aside: for a <b>bit</b> <b>string</b> s and nonnegative integer m, let sm {{denote the}} concatenation of s to itself m times. If t {{is also a}} <b>bit</b> <b>string</b> st denotes the concatenation of t to s.|$|E
50|$|A <b>bit</b> <b>string,</b> {{interpreted}} as a binary number, can be translated into a decimal number. For example, the lower case a, if represented by the <b>bit</b> <b>string</b> 01100001 (as {{it is in the}} standard ASCII code), can also be represented as the decimal number 97.|$|E
50|$|Note {{that the}} {{appended}} postfixes are written as <b>bit</b> <b>strings,</b> not hexadecimal digits.|$|R
5000|$|The final <b>bit</b> <b>strings</b> {{for each}} of the three {{calculations}} resulted as such: ...|$|R
50|$|Passwords: Low-entropy <b>bit</b> <b>strings</b> {{that are}} known to both the server and the peer.|$|R
50|$|Solomonoff's {{theory of}} {{inductive}} inference is also inductive inference. A <b>bit</b> <b>string</b> x is observed. Then consider all programs that generate strings starting with x. Cast {{in the form}} of inductive inference, the programs are theories that imply the observation of the <b>bit</b> <b>string</b> x.|$|E
5000|$|The {{widely used}} two's {{complement}} encoding {{does not allow}} a negative zero. In a 1+7-bit sign-and-magnitude representation for integers, negative zero {{is represented by the}} <b>bit</b> <b>string</b> [...] In an 8-bit one's complement representation, negative zero is represented by the <b>bit</b> <b>string</b> [...] In all three encodings, positive zero is represented by [...]|$|E
5000|$|Given {{an input}} <b>bit</b> <b>string</b> N, a padding {{function}} pad, a permutation function f that operates on bit blocks of width b, a rate r and an output length d, we have capacity c = b - r and the sponge construction Z = spongef,pad,r(N,d), yielding a <b>bit</b> <b>string</b> Z of length d, works as follows: ...|$|E
50|$|Symmetric keys: High-entropy <b>bit</b> <b>strings</b> {{that are}} known to both the server and the peer.|$|R
40|$|The secure hash {{function}} SHA- 256 {{is a function}} on <b>bit</b> <b>strings.</b> This means that its restriction to the <b>bit</b> <b>strings</b> of any given length can be computed by a finite instruction sequence that contains only instructions to set and get the content of Boolean registers, forward jump instructions, and a termination instruction. We describe such instruction sequences for the restrictions to <b>bit</b> <b>strings</b> of the different possible lengths by means of uniform terms from an algebraic theory. Comment: 14 pages; several minor errors corrected; counting error corrected; instruction sequence fault repaired; misunderstanding cleared up; a minor error corrected; 15 pages, presentation improved, a minor error corrected. preliminaries have text overlap with arXiv: 1301. 329...|$|R
5000|$|The binary {{operation}} XOR over <b>bit</b> <b>strings</b> of length [...] exhibits the following properties (where [...] denotes XOR): ...|$|R
5000|$|Using Dirac ket notation, if x1,x2, ...,xn is a {{classical}} <b>bit</b> <b>string,</b> then {{is a special}} n-qubit corresponding to the function which maps this classical <b>bit</b> <b>string</b> to 1 and maps all other bit strings to 0; these 2n special n-qubits are called computational basis states. All n-qubits are complex linear combinations of these computational basis states.|$|E
5000|$|Let , where [...] denotes {{concatenation}} and [...] {{is represented}} as a <b>bit</b> <b>string.</b>|$|E
5000|$|... bslbf: <b>bit</b> <b>string,</b> left bit first uimsbf: {{unsigned}} integer, {{most significant}} bit first ...|$|E
3000|$|... <b>bit</b> <b>strings</b> {{invariant}} under a {{cyclic shift}} by k positions. It follows {{that all the}} diagonal entries of [...]...|$|R
50|$|All {{conversion}} between <b>bits</b> <b>strings</b> {{and other}} forms is performed according to the big-endian (most significant bit first) convention.|$|R
5000|$|... {{interchange}} formats: encodings (<b>bit</b> <b>strings)</b> {{that may}} be used to exchange floating-point data in an efficient and compact form ...|$|R
5000|$|L, {{the label}} of the robot (typically taking {{the form of a}} <b>bit</b> <b>string)</b> ...|$|E
50|$|A code is a prefix code if no target <b>bit</b> <b>string</b> in {{the mapping}} is a prefix {{of the target}} <b>bit</b> <b>string</b> of a {{different}} source symbol in the same mapping. This means that symbols can be decoded instantaneously after their entire codeword is received. Other commonly used names for this concept are prefix-free code, instantaneous code, or context-free code.|$|E
5000|$|L3. Identity exists: {{there is}} a <b>bit</b> <b>string,</b> 0, (of length N) such that [...] for any ...|$|E
5000|$|Gurzadyan has coined [...] {{the concept}} of {{information}} panspermia which Webb [...] attributed as Solution 23 of Fermi Paradox. That concept includes {{the hypothesis that the}} Universe can be full of traveling extraterrestrial life streams as low-complexity compressed <b>bit</b> <b>strings</b> at von Neumann automata network. He has shown that human genome and hence the terrestrial life possess low Kolmogorov complexity and hence the corresponding <b>bit</b> <b>strings</b> can be transmitted by Arecibo-type antenna to Galactic distances.|$|R
3000|$|... <b>bit</b> <b>strings</b> {{and even}} for the other half. Applying again Eq. (36), we obtain always a {{positive}} sign. Hence, both traces [...]...|$|R
50|$|To {{support such}} deniable {{encryption}} systems, a few cryptographic algorithms {{are specifically designed}} to make ciphertext messages indistinguishable from random <b>bit</b> <b>strings.</b>|$|R
5000|$|... 32 bits - {{synchronization}} code (S-field): constant <b>bit</b> <b>string</b> AAAAE98AH for FP transmission, 55551675H for PP transmission ...|$|E
50|$|The pseudo-Hadamard {{transform}} is a reversible {{transformation of}} a <b>bit</b> <b>string</b> that provides cryptographic diffusion. See Hadamard transform.|$|E
5000|$|Following GLP, to sign {{a message}} m {{expressed}} as a <b>bit</b> <b>string,</b> the signing entity does the following: ...|$|E
5000|$|In fact, Dadda and Wallace {{multipliers}} {{have the}} same 3 steps for two <b>bit</b> <b>strings</b> [...] and [...] of lengths [...] and [...] respectively: ...|$|R
40|$|For each {{function}} on <b>bit</b> <b>strings,</b> its restriction to <b>bit</b> <b>strings</b> of {{any given}} length can be computed by a finite instruction sequence that contains only instructions to set and get the content of Boolean registers, forward jump instructions, and a termination instruction. Backward jump instructions are not necessary for this, but instruction sequences can be significantly shorter with them. We take the function on <b>bit</b> <b>strings</b> that models the multiplication of natural numbers on their representation in the binary number system to demonstrate this {{by means of a}} concrete example. The example is reason to discuss points concerning the halting problem and the concept of an algorithm. Comment: 17 pages, the preliminaries are about the same as the preliminaries in arXiv: 1308. 0219 [cs. PL] and arXiv: 1312. 1529 [cs. PL]; minor errors corrected, references added; section on indirect addressing adde...|$|R
40|$|Abstract. On {{top of the}} passively secure {{extension}} protocol of [IKNP 03] we build a new construction secure against active adversaries. We can replace the invocation of the hash function {{that is used to}} check the receiver is well-behaved with the XOR of <b>bit</b> <b>strings.</b> This is pos-sible by applying a cut-and-choose technique on the length of the <b>bit</b> <b>strings</b> that the receiver sends in the reversed OT. We also improve on the number of seeds required for the extension, both asymptotically and practically. Moreover, the protocol used to test receiver’s behaviour en-joys unconditional security. ...|$|R
