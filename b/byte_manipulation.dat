5|12|Public
5000|$|AVX-512 Vector <b>Byte</b> <b>Manipulation</b> Instructions (VBMI) adds vector byte {{permutation}} instructions {{which are}} not present in AVX-512BW.|$|E
50|$|The integer unit is {{responsible}} for executing integer instructions. It consists of the integer register file (IRF) and the E-box. The IRF contains thirty-two 64-bit registers and has four read ports and two write ports that are equally divided between the integer unit and the branch unit. The E-box contains an adder, a logic unit, barrel shifter, and multiplier. Except for multiply, shift, and <b>byte</b> <b>manipulation</b> instructions, most integer instructions are completed {{by the end of}} stage five and thus have a latency of one cycle. The barrel shifter is pipelined, but shift and <b>byte</b> <b>manipulation</b> instructions are not completed by the end of stage six, and thus have a latency of two cycles. The multiplier was not pipelined in order to save die area; thus multiply instructions have a variable latency of 19 to 23 cycles depending on the operands. In stage seven, integer instructions write their results to the IRF.|$|E
50|$|The CPU {{consisted}} of an ALU {{that was built}} around the Am2901 bit-sliced microprocessor. To this a <b>byte</b> <b>manipulation</b> unit was added which could perform the shifting, rotating and masking operation required for handling eight and sixteen bit data. Additional logic was provided to support both signed and unsigned two's complement comparisons in a single operation, multiple precision arithmetic and floating point normalization. Most operations could be performed in 150 ns, however the cycle time was variable from 125 ns to 200 ns under microprogram control so that timing could be optimized. A microsequencer, based around the Am2910, directed the control flow though the microprogram. It could perform branches, loops and subroutine calls most {{of which could be}} conditional on any of several CPU status conditions.|$|E
5000|$|Deuce A runtime {{environment}} for Java Software Transactional Memory using <b>byte</b> code <b>manipulation.</b>|$|R
25|$|Many stream ciphers {{are based}} on linear-feedback shift {{registers}} (LFSRs), which, while efficient in hardware, are less so in software. The design of RC4 avoids the use of LFSRs and is ideal for software implementation, as it requires only <b>byte</b> <b>manipulations.</b> It uses 256 bytes of memory for the state array, S through S, k bytes of memory for the key, key through key, and integer variables, i, j, and K. Performing a modular reduction of some value modulo 256 {{can be done with}} a bitwise AND with 255 (which is equivalent to taking the low-order byte of the value in question).|$|R
5000|$|Platform and CPU Information: Platform Detection, CPU Feature Detection, Byte Order and <b>Byte</b> Swapping, Bit <b>Manipulation</b> ...|$|R
40|$|This paper {{describes}} the logical {{structure of the}} RC 4000, a 24 -bit, binary com-puter designed for multiprogramming operation. The design is characterized by multiple accumulators, expandable storage, low-speed and high-speed data channels, storage protection, and program interruption. Processing operations include <b>byte</b> <b>manipulation,</b> word comparison, and integer and °oating-point arithmetic. Typical operation times are from 2. 5 to 5. 5 microseconds...|$|E
40|$|Abstract: This paper {{deals with}} class and {{interface}} name clashes in Java component systems that occur because of evolutionary changes during the lifecycle of a component application. We {{show that the}} standard facilities of the Java type system do not provide a satisfactory {{way to deal with}} the name clashes, and present a solution based on administering the names of classes and interfaces with a version identifier using a <b>byte</b> code <b>manipulation</b> tool. We provide a proof of concept implementation...|$|R
40|$|The term “Java” is used {{to denote}} two {{different}} concepts: the language itself and the related execution environment, the Java Virtual Machine (JVM), which executes byte code instructions. Several research projects deal with byte code-generating compilers or the implementation of new features via byte code transformations. Examples are code optimization, the implementation of parameterized types for Java, or the adaptation of run-time behavior through load-time transformations. Many programmers are doing this by implementing their own specialized <b>byte</b> code <b>manipulation</b> tools, which are, however, restricted {{in the range of}} their reusability. Therefore, we have developed a general purpose framework for the static analysis and dynamic creation or transformation of byte code. In this paper we present its main features and possible application areas...|$|R
40|$|The term "Java" is used {{to denote}} two {{different}} concepts: the language itself and the related execution environment, the Java Virtual Machine (JVM), which executes byte code instructions. Several research projects deal with byte code-generating compilers or the implementation of new features via byte code transformations. Examples are code optimization, the implementation of parameterized types for Java, or the adaptation of run-time behavior through load-time transformations. Many programmers are doing this by implementing their own specialized <b>byte</b> code <b>manipulation</b> tools, which are, however, restricted {{in the range of}} their reusability. Therefore, we have developed a general purpose framework for the static analysis and dynamic creation or transformation of byte code. In this paper we present its main features and possible application areas. 1 Introduction Many research projects deal with extensions of the Java language [13] or improvements of its run-time behavior. Implementing [...] ...|$|R
40|$|Extensions and {{improvements}} of the programming language Java and its related execution environment (Java Virtual Machine, JVM) {{are the subject}} {{of a large number of}} research projects and proposals. There are projects, for instance, to add parameterized types to Java, to implement "Aspect-Oriented Programming", and to improve the run-time performance. Since Java classes are compiled into portable binary class files (called byte code), it is the most convenient and platform-independent way to implement these improvements not by writing a new compiler or changing the JVM, but by transforming the byte code. These transformations can either be performed after compile-time, or at load-time. Many programmers are doing this by implementing their own specialized <b>byte</b> code <b>manipulation</b> tools, which are, however, restricted in the range of their re-usability. To deal with the necessary class file transformations, we introduce an API that helps developers to conveniently implement their transformat [...] ...|$|R
5000|$|WEP was the {{encryption}} standard firstly available for wireless networks. It can be deployed in 64 and 128 bit strength. 64 bit WEP has a secret key of 40 bits and an initialisation vector of 24 bits, {{and is often}} called 40 bit WEP. 128 bit WEP has a secret key of 104 bits and an initialisation vector of 24 bits, and is called 104 bit WEP. Association is possible using a password, an ASCII key, or a hexadecimal key.There are two methods for cracking WEP: the FMS attack and the chopping attack.The FMS attack - named after Fluhrer, Mantin, and Shamir - {{is based on a}} weakness of the RC4 encryption algorithm [...] The researchers found that 9000 of the possible 16 million initialisation vectors can be considered weak, and collecting enough of them allows the determination of the encryption key. To crack the WEP key in most cases, 5 million encrypted packets must be captured to collect about 3000 weak initialisation vectors. (In some cases 1500 vectors will do, in some other cases more than 5000 are needed for success.) The weak initialisation vectors are supplied to the Key Scheduling Algorithm (KSA) and the Pseudo Random Generator (PRNG) to determine the first byte of the WEP key. This procedure is then repeated for the remaining bytes of the key.The chopping attack chops the last byte off from the captured encrypted packets. This breaks the Cyclic Redundancy Check/Integrity Check Value (CRC/ICV). When all 8 bits of the removed byte were zero, the CRC of the shortened packet is made valid again by manipulation of the last four <b>bytes.</b> This <b>manipulation</b> is: result = original XOR certain value. The manipulated packet can then be retransmitted. This method enables the determination of the key by collecting unique initialisation vectors.The main problem with both the FMS attack and the chopping attack is that capturing enough packets can take weeks or sometimes months. Fortunately, the speed of capturing packets can be increased by injecting packets into the network. One or more Address Resolution Protocol (ARP) packets are usually collected to this end, and then transmitted to the access point repeatedly until enough response packets have been captured. ARP packets are a good choice because they have a recognizable size of 28 bytes.Waiting for a legitimate ARP packet can take awhile. ARP packets are most commonly transmitted during an authentication process. Rather than waiting for that, sending a deauthentication frame that pushes a client off the network will require that client to reauthenticate. This often creates an ARP packet.|$|R
40|$|Mälueraldamiste jälgija (Memory {{allocation}} tracker) on tööriist, mis registreerib objektide loomisi JVM’is. Tavaliselt, mälueraldamiste jälgija on profileerija alamosa. Sams eksisteerivad ka eraldiseisvad lahendused. Töö põhieesmärk on läbi vaadata ja võrrelda olemasolevate avatud lähtekoodiga mälueraldamiste jälgijaid. Selleks, et mõõta mälueraldamiste jälgijate effektivsus kasutasime SPECjvm 2008 jõudlustestide komplekt. Mälu kasutamise mõõtmiseks oli kirjatud oma JVM TI agent, mis perioodiliselt kirjutab kasutatud mälu suurus CSV faili. Töö käigus olid läbi vaadatud ja testitud selliseid mälueraldamiste jälgimise lahendusi: •	HRPOF – lihtne käsurea kasutajaliidesega profileerimise tööriist, mis pakutakse JavaDevelopment Kit (JDK) koosseisus. •	NetBeans profileerija – varem see oli eraldiseisav avatud lähtekoodiga uurimis proekt nimega JFluid. Praegu see on NetBeansi osa. •	TPTP profileerija – profileerija, mis kasutatakse Eclipse IDE’s. •	Project Allocation Instrumenter – mälu eraldamiste jälgija Google’st. On kirjutatud puhtas Javas. Kasutab java. lang. instrument API ja ASM raamistikku baitkoodi analüüsimiseks ja manipuleerimiseks. Neljast kahel mäluereldamiste jälgijatel olid probleemid stabiilsusega. NetBeans valesti muutus javazoom. jl. decoder. huffcodetab klassi baitkoodi, mille pärast ei saanud mpegaudio testi käivitada. Eclipse TPTP profileerija ei suutnud edukalt oma tööd lõpetada mitmel korral erinevate jõudlustestide käivitamise ajal. NetBeans profileerija on tehniliselt kõige arenenum ja kõike tõhusam mäluerdlamiste jälgimise lahendus. See ei ole üllatav, kuna Sun’i insenerid kirjutasid seda parrallelselt Java virtualse masina arenguga. Kõige problemaatilisem mälueraldamiste jälgimise mõttes oli sunflow jõudlustest. Koos TPTP profileerijaga ta jooksis umbes 300 korda aeglasemalt. HPROF’i ja Allocation Instrumenter’i tulemused ei olnud määrkimväärselt paremad. Ainult NetBeans profileerija said enam-vähem efektiivselt töötada sellel testil. Kõik läbi vaadatud lahendused, välja arvatud TPTP, kasutavad mälueraldamiste jälgmiseks baitkoodi manipuleerimist (ByteCode Instrumentation, BCI). Nad lisavad oma jälgimise meetodi väljakutse pärast iga objekti loomise baitkoodi (opcode new). TPTP oma tööks kasutab JVM TI sündmuseid. Erilist huvi pakkub Allocation Instrumenter Google’st. See raamistik võimaldab kirjutada mälueraldamiste jälgijat puhtas Java keeles. Potensiaalselt see teeb lahendus platvorimst sõltumatuks. Kuid veel eksisteerivad lahendamata probleeme jõudlusega. Minu tulevikuplaanis on aru saada, kas saab teha mälueraldamiste jälgimist. Memory leaks in Java are not {{the same}} as memory leaks in, for example, the C programming language. When a C-programmer wants to use memory on the heap, he should manually allocate a memory region. After application finishes using this memory, it should be manually freed. If the pointer to the allocated region is lost, then there is no appropriate way to release this memory. This situation is called a “memory leak”. In Java the Java Virtual Machine (JVM) handles all work with memory. When a developer wants to create and use a new object, the JVM allocates a necessary amount of memory. During an application’s life the JVM periodically checks for objects in memory that are not used anymore. Objects, which are not referenced, will be discarded and memory reclaimed to be used again. This process is called garbage collection. A memory leak in Java is a situation, where an application is not logically using objects, to which references still exist, meaning the Garbage Collector (GC) can’t mark them as unused and free memory. When memory management of JVM cannot allocate any more memory, java. lang. OutOfMemoryError exception is thrown. When a developer is faced with an “OutOfMemoryError” on production server, he can try to reproduce the problem in a test environment. Unfortunately, oftentimes test environments do not allow for reproduction of such errors. It’s not always possible to mimic all parameters of a real environment. Developer often doesn’t have all required input data or he just does not know how and why the memory leak occurred. This can be also caused by all sorts of bureaucratic obstacles and barriers in large companies with separate operations and development departments and developers just do not have full access to machines in a real environment. However, even if it is possible to search for memory leaks in a production environment – use of many developer’s tools, such as full-featured profilers is not possible, due to the memory and performance overhead not suitable for production environment. It is useful to apply all possible offline methods, such as analysis of heap dumps and collection of allocations’ logs. And when a memory leak is localized, only then it would be helpful to turn on an allocation tracker for a specific set of objects or allocation sites to find out what code is responsible for creating objects that are eventually leaked. In order to do it in a production environment, we need effective methods and algorithms for allocation tracking. Memory allocations tracker is a tool, which works in runtime and logs memory allocation by specific objects or sites. Usually it is a part of a profiler, but standalone solutions also exist. The aim of this work is to review and compare existing open source solutions for allocation tracking in JVM. The first chapter of this work describes benchmarking techniques, which will be used for comparison of different allocations trackers. In this work will SPECjvm 2008 will be used. It is a benchmark suite for measuring the performance of a Java Runtime Environment (JRE). It contains several real life applications and benchmarks focusing on core java functionality. The SPECjvm 2008 workload mimics a variety of common general-purpose application computations. As SPECjvm 2008 does not give any information about memory usage a lightweight JVM Tool Interface (JVM TI) agent was created. JVM TI allows a program to inspect the state and to control the execution of other application running in the JVM [1]. The agent works in a separate thread and writes memory usage statistics to a CSV file every second. The agent creates an insignificant overhead, so it does not distort the SPECjvm 2008 results. In the next chapters of this work open-source allocations trackers are reviewed. Their work principles, algorithms and memory structures are examined. For measuring allocations tracking efficiency the SPECjvm 2008 suite will be run with every tested allocations tracking solution. The obtained data allows comparing memory and performance overhead of different approaches in memory allocations tracking. Chapter 2 introduces HPROF – an example profiler, shipped with the Oracle Java Development Kit (JDK) and uses the JVM TI. In chapter 3 we review the NetBeans profiler, previously known as JFluid. This is full-weight Java profiler integrated with the NetBeans IDE. Chapter 4 is about Eclipse Test and Performance platform. This is a collection of open- source frameworks and services that allows software developers to build test and performance tools. In the last chapter results of using Google’s Allocation Instrumenter are presented. It uses java. lang. instrument package and ASM Java <b>byte</b> code <b>manipulation</b> and analysis framework. For each examined profiler brief description along with implementation details and benchmarking results are given...|$|R

