149|225|Public
25|$|With {{software}} and other non-animal methods, {{there is also}} no expensive disposal of equipment or hazardous material removal. Some programs also allow educators to customize lessons and include <b>built-in</b> <b>test</b> and quiz modules that can track student performance. Furthermore, animals (whether dead or alive) can be used only once, while non-animal resources can be used for many yearsâ€”an added benefit that could result in significant cost savings for teachers, school districts, and state educational systems.|$|E
2500|$|The poor {{reliability}} of the ALQ-99 jammer pod and frequent failures of the <b>Built-In</b> <b>Test</b> (BIT) have caused the crew to fly missions with undetected faults. [...] The ALQ-99 has also interfered with the aircraft's AESA radar and has imposed a high workload on the two-man crew, along with reducing the Growler's top speed.|$|E
2500|$|No fault found (NFF) is a {{term used}} {{in the field of}} maintenance, where a unit is removed from service {{following}} a complaint of a perceived fault by operators or an alarm from its BIT (<b>built-in</b> <b>test)</b> equipment. [...] The unit is then checked, but no anomaly is detected by the maintainer. Consequently, the unit is returned to service with no repair performed.|$|E
50|$|Self-testing code is {{software}} that incorporates <b>built-in</b> <b>tests</b> (see test-first development).|$|R
40|$|The aim is {{to create}} the {{theoretical}} bases, algorithms and practical circuits of the <b>built-in</b> <b>testing</b> oriented to the special features of the tested digital devices and providing a high test authenticity. The theoretical bases of the <b>built-in</b> <b>testing</b> oriented to the special features of the tested circuits have been developed. On base of the obtained results the <b>built-in</b> <b>testing</b> systems with discovery of the constant single circuit faults succeeded in construction. The method of signatures for multi-output circuits and also the test generator are introduced. Application field: digital electronic engineeringAvailable from VNTIC / VNTIC - Scientific & Technical Information Centre of RussiaSIGLERURussian Federatio...|$|R
40|$|Assembling new {{software}} systems from prefabricated components as an attractive alternative to traditional software development practices {{is more and}} more investigated. Component technologies like CCM,. Net or EJB are accompanied by model-based approaches like MDA. However, still the emphasis is rather on system design and development and not on system validation and testing. The expected reductions in development time and effort will only arise if separately developed components can be made to work effectively together with minimal effort. Lengthy and costly in situ validation and acceptance testing directly undermines the benefits of heterogeneous components and late system integration. This report describes the extension of contract-based <b>built-in</b> <b>tests</b> where components are equipped with the ability to check their execution environment at run-time with approaches to derive <b>built-in</b> <b>tests</b> from system models, represent them on model level, and to generate executable tests from these test models. This model-based approach increases the automation level in generating and realizing <b>built-in</b> <b>tests</b> and therefore also increases the quality of and reduces needed resources for developing <b>built-in</b> <b>tests...</b>|$|R
2500|$|RCDs can {{be tested}} with <b>built-in</b> <b>test</b> button to confirm {{functionality}} on a regular basis. RCDs may not operate correctly if wired improperly, so they are generally tested by the installer to verify correct operation. Use of a solenoid voltmeter from live to earth provides an external path and can test the wiring to the RCD. Such a test may be performed on installation of the device and at any [...] "downstream" [...] outlet.|$|E
5000|$|Diagnostic Testing via <b>built-in</b> <b>test</b> (BIT) or planned {{maintenance}} ...|$|E
5000|$|Fault {{detection}} {{coverage that}} system <b>built-in</b> <b>test</b> will realize ...|$|E
25|$|In the Python {{programming}} language, lazy {{functional code}} for generating regular numbers {{is used as}} one of the <b>built-in</b> <b>tests</b> for correctness of the language's implementation.|$|R
40|$|Component-based {{software}} engineering (CBSE) {{is expected to}} drastically reduce the time spent on developing software {{through the use of}} prefabricated components. However, some of the time gained on reusing components instead has to be spent on testing that components work as specified the new environment. The Component+ project aims at solving this by using <b>built-in</b> <b>tests.</b> This paper presents an architecture for the integration of <b>built-in</b> <b>tests</b> in software components that makes it possible to reuse tests and hence minimize the time spent on testing...|$|R
40|$|This report {{represents}} one of the two parts of the technological foundations of <b>Built-in</b> <b>Testing</b> (BIT) technology that has been developed within the European Union IST 5 th Framework Programme in the project Component+ (EC-IST- 1999 - 20162). The aim of this work is to devise the technological foundations of the <b>built-in</b> contract <b>testing</b> method for checking the pair-wise interactions of components in component-based software construction at integration and deployment time. Such pair-wise interactions are also referred to as contracts. <b>Built-in</b> contract <b>testing</b> is based on building test functionality into components, in particular tester components on the client side and testing interfaces on the server side of a pairwise contract. This report introduces the principles of <b>built-in</b> contract <b>testing,</b> and outlines how it may be integrated into a model driven software development process. It builts the foundation for the second report on Component+ Methodology - Built-In Contract Testing: Method and Process that concentrates more on the process of how to derive <b>built-in</b> contract <b>testing</b> artifacts from an overall model-driven development method...|$|R
50|$|BITE is {{an acronym}} for <b>built-in</b> <b>test</b> equipment.The BITE is {{characterized}} primarily as a passive fault management and diagnosis built into airborne systems to support the maintenance process. <b>Built-in</b> <b>test</b> equipment refers to multimeters, oscilloscopes, discharge probes, and frequency generators that are provided {{as part of the}} system to enable testing and perform diagnostics.|$|E
50|$|The <b>built-in</b> <b>test</b> {{equipment}} (BITE) on the BFSR aids {{in increasing}} reliability and allowing for easy calibration and fault detection of the radar on the field.|$|E
50|$|The acronym BIT {{is often}} used for this same {{function}} or, more specifically, {{in reference to the}} individual tests. BIT is an acronym for <b>built-in</b> <b>test.</b>|$|E
40|$|This report {{represents}} one of the two parts of the methodology and process of <b>Built-in</b> <b>Testing</b> (BIT) technology that has been developed within the European Union IST 5 th Framework Programme in the project Component+ (EC-IST- 1999 - 20162). The aim of this work is to devise a technology and methodology that can check the pairwise interactions of components in component-based software construction at integration and deployment time. Such pairwise interactions are also defined as contracts. <b>Built-in</b> contract <b>testing</b> is based on building test functionality into components, in particular tester components on the client side and testing interfaces on the server side of a pairwise contract. Since building test software into components has implications with the overall component-based development process, the technology is integrated and made to supplement an existing component-based development methodology, the KobrA method. This report initially outlines the concepts of the KobrA method that are important for <b>built-in</b> contract <b>testing,</b> provides a step-by-step guide on how to devise <b>built-in</b> contract <b>testing</b> artefacts {{on the basis of the}} KobrA method, and finally discusses further implications that <b>built-in</b> contract <b>testing</b> has on typical object and component technology concepts...|$|R
50|$|For ease of maintenance, Sniper's optical bed design, partitioning, and {{diagnostic}} capabilities permit two-level maintenance, eliminating costly intermediate-level support. Automated <b>built-in</b> <b>testing</b> allows {{maintenance personnel}} to isolate and replace a {{line replaceable unit}} in under 20 minutes to restore full mission-capable status.|$|R
50|$|AN/SPS-48E - Compared to the C variant, the SPS-48E {{has twice}} the {{radiated}} power, increased receiver sensitivity, four stage solid-state transmitter, half {{the components of}} a -48C and <b>built-in</b> <b>testing</b> for easier diagnostics. Originally developed {{as part of the}} New Threat Upgrade (NTU) Program to support the SM-2 Launch On Search (LOS) capability.|$|R
5000|$|A {{built-in}} self-test (BIST) or <b>built-in</b> <b>test</b> (BIT) is {{a mechanism}} that permits a machine to test itself. Engineers design BISTs to meet requirements such as: ...|$|E
5000|$|ARINC 604 is a {{standard}} and guidance {{for the purpose of}} designing and implementing <b>Built-In</b> <b>Test</b> Equipment. The standard also describes the Centralized Fault Display System.|$|E
50|$|Set up {{specific}} criteria for repair, including <b>Built-In</b> <b>Test</b> Equipment (BITE) requirements, testability, reliability, and maintainability; support equipment requirements; automatic test equipment; and manpower skills and facility requirements.|$|E
40|$|Assembling new {{software}} systems from prefabricated components {{is an attractive}} alternative to traditional software development practices. However, the expected reductions in development time and effort will only arise if separately developed components {{can be made to}} work effectively together with minimal effort. Lengthy and costly in-situ verification and acceptance testing directly undermines the benefits of heterogeneous components and late system integration. This chapter describes an approach that reduces manual system verification effort by equipping components with the ability to check their execution environment at run-time. When deployed in a new system, <b>built-in</b> contract <b>test</b> components check the contract-compliance of their server components, including the run-time system, and thus automatically verify their ability to fulfil their own obligations. The chapter first considers the principles behind <b>built-in</b> contract <b>testing,</b> and then describes how <b>built-in</b> <b>testing</b> can be made a natural part of component-based development...|$|R
40|$|This chapter {{describes}} a technology and methodology {{referred to as}} <b>built-in</b> contract <b>testing</b> that checks the pairwise interactions of components in component-based software construction at integration and deployment time. Such pairwise interactions are {{also referred to as}} contracts. <b>Built-in</b> contract <b>testing</b> is based on building test functionality into components, in particular tester components on the client side and testing interfaces on the server side of a pairwise contract. Since building test software into components has implications for the overall component-based development process, the technology is integrated with and made to supplement the entire development cycle starting from requirements specification activities and modeling. The chapter outlines typical specification concepts that are important for <b>built-in</b> contract <b>testing,</b> provides a guide on how to devise <b>built-in</b> contract <b>testing</b> artifacts on the basis of models, and discusses issued involved in using this approach with contemporary component technologies...|$|R
40|$|Services {{are used}} a lot {{nowadays}} in order to deploy large scale systems that should never be shut down such as internet shops, online banking applications, and surveillance systems. Because services can be updated at any given time, testing is required during runtime by its clients to validate that the updated service still performs as required. However, testing during runtime may interfere with the nominal operations of the service and its environment. Furthermore, only the methods exposed by the service through its interface are available to the clients, which reduces {{the ability to control}} and observe the service for testing purposes, i. e. its testability. <b>Built-in</b> <b>testing</b> can be used to increase the testability, and to ensure that other clients are not hindered while the service is being tested. However, in order to increase the testability of the service, methods will have {{to be added to the}} service, which decreases the modularity and evolvability of the service. In order to maintain the modularity of the service, aspects can be used to separate the test facilities and test cases from the service. An approach has been devised to achieve <b>built-in</b> <b>testing</b> for services through the use of aspects. Our feasibility study and evaluation demonstrate that and how aspects can be used to achieve <b>built-in</b> <b>testing</b> for services. Further evaluation is, however, required to assess how our approach holds up when applied to a large real world service-oriented system. Software EngineeringSoftware TechnologyElectrical Engineering, Mathematics and Computer Scienc...|$|R
50|$|The AQS-13A {{system was}} an upgrade {{to the basic}} AQS-13 system {{incorporated}} into fleet systems in the late-1960s/early-1970s. The upgrade was primarily to incorporate <b>built-in</b> <b>test</b> equipment (BITE) circuitry, providing a method for testing system circuitry in the sonar set.|$|E
50|$|Pre-flight safety {{checks of}} a {{fly-by-wire}} system are often performed using <b>built-in</b> <b>test</b> equipment (BITE). On programming the system, {{either by the}} pilot or groundcrew, a number of control movement steps are automatically performed. Any failure will be indicated to the crews.|$|E
50|$|Many modern {{aircraft}} {{systems are}} digital or digitally controlled. Very often, the digital system will include <b>Built-In</b> <b>Test</b> Equipment which records {{information about the}} operation of the system. This information may also be accessed to assist with the investigation of an accident or incident.|$|E
5000|$|<b>Built-In</b> Self <b>Tests</b> of Logic and Memory (LBIST and MBIST, respectively) (normally boot-time operations) ...|$|R
50|$|Keyword Testing: TestComplete has a <b>built-in</b> keyword-driven <b>test</b> {{editor that}} {{consists}} of keyword operations that correspond to automated testing actions.|$|R
40|$|International audienceRe-using {{embedded}} {{resources for}} implementing <b>built-in</b> self <b>test</b> mechanisms allows test cost reduction. In this paper we demonstrate how to implement cost-efficient <b>built-in</b> self <b>test</b> functions from the AES cryptoalgorithm hardware implementation in a secure system. Self-test {{of the proposed}} implementation is also presented. A statistical test suite and fault-simulation are used for evaluating {{the efficiency of the}} corresponding cryptocore as pseudo-random test pattern generator; an analytical approach demonstrates the low probability of aliasing when used for test response compaction...|$|R
50|$|In {{comparison}} to the first-generation LANTIRN, the radar range of the Blue Sky navigational pod is 25% longer than the 12 km range of TFR in AN/AAQ-13, but still less than the 24 km range of the second-generation LANTIRN. <b>Built-in</b> <b>test</b> (BITE) function is also incorporated.|$|E
50|$|The poor {{reliability}} of the ALQ-99 jammer pod and frequent failures of the <b>Built-In</b> <b>Test</b> (BIT) have caused the crew to fly missions with undetected faults. The ALQ-99 has also interfered with the aircraft's AESA radar and has imposed a high workload on the two-man crew, along with reducing the Growler's top speed.|$|E
50|$|The JY-9 {{has high}} {{anti-jamming}} and anti-clutter capability {{due to the}} use of advanced techniques, including pulse to pulse frequency agility, dual channel, JATS, wide operating band, low sidelobes, MTD automatic spectrum processing, automatic clutter map and automatic residue map. The mean time between failures is better than 900 hours with <b>Built-in</b> <b>test</b> equipment (BITE).|$|E
40|$|This {{work-in-progress}} paper discusses challenges with {{application of}} <b>Built-In</b> <b>Testing</b> (BIT) in component-based embedded-systems. Testing constitutes {{a large part}} of the time and budget in devel-opment of embedded software systems. Such systems are often mission-critical, making testing highly important, and at the same time testing em-bedded systems is challenging because of their lim-ited observability. We investigate the possible application of BIT in components for embedded systems, as a technique to advance the technology and knowledge for analysis and verification of func-tional correctness, real-time behavior, safety, and reliability of these systems. ...|$|R
5000|$|<b>Built-in</b> {{function}} to <b>test</b> the connection setup (port forwarding).|$|R
40|$|International audienceThis paper {{presents}} {{an overview of}} the work done so far related to the use of temperature sensors as performance monitors for RF and MMW circuits with the goal to implement <b>built-in</b> <b>testing</b> or self-calibration techniques. The strategy is to embed small temperature sensors on the same silicon die as the circuit under test, taking advantage of empty spaces in the layout. This paper reviews the physical principles, and presents examples that reveal how temperature sensors can be used as functional built-in testers serving to reduce testing costs and enhance yield as part of self-healing strategies...|$|R
