18|4|Public
500|$|After the sync field, all packets {{are made}} of 8-bit bytes, {{transmitted}} least-significant bit first. The first byte is a packet identifier (PID) byte. The PID is actually 4bits; the byte consists of the 4-bit PID followed by its <b>bitwise</b> <b>complement.</b> This redundancy helps detect errors. (Note also that a PID byte contains at most four consecutive 1bits, and thus never needs bit-stuffing, even when combined with the final 1bit in the sync byte. However, trailing 1bits in the PID may require bit-stuffing within the first few bits of the payload.) ...|$|E
5000|$|... pen = Pen (...) # accessing:pen.color = ~pen.color # <b>bitwise</b> <b>complement</b> ...|$|E
5000|$|The <b>bitwise</b> <b>{{complement}}</b> {{is equal}} to the two's complement of the value minus one. If two's complement arithmetic is used, then [...]|$|E
50|$|Note {{that the}} ones' {{complement}} {{representation of a}} negative number {{can be obtained from}} the sign-magnitude representation merely by <b>bitwise</b> <b>complementing</b> the magnitude.|$|R
50|$|Note: Entries in the R-column are <b>bitwise</b> <b>complements</b> (logical operator: negation) of the {{respective}} entries in the L-column. Entries in the G-column are the entries in the R-column in reverse bit order. See pictures of all codes against a colored background.|$|R
50|$|In other words, after {{appropriate}} padding, all 16-bit {{words are}} added using one's complement arithmetic. The sum is then <b>bitwise</b> <b>complemented</b> and inserted as the checksum field. A pseudo-header that mimics the IPv4 packet header {{used in the}} checksum computation {{is shown in the}} table below.|$|R
5000|$|In JavaScript, the tilde {{is used as}} a unary <b>bitwise</b> <b>complement</b> (or bitwise negation) {{operation}} (...) [...] Because JavaScript internally uses floats and the <b>bitwise</b> <b>complement</b> {{only works}} on integers, numbers are stripped of their decimal part before applying the operation. This has also given rise to using two tildes [...] as a shorthand for the mathematical floor function (numbers are stripped of their decimal part and changed into their complement, and then back. The net result is thus only the removal of the decimal part).|$|E
5000|$|... // accessing:Pen pen = new Pen (...)int color_tmp = 0;// ...pen.Color = 17;color_tmp = pen.Color;// ...pen.Color = ~pen.Color; // <b>bitwise</b> <b>complement</b> ...// another silly example:pen.Color += 1; // a lot {{clearer than}} [...] "pen.set_Color(pen.get_Color (...) + 1)"! ...|$|E
50|$|Finally, the <b>bitwise</b> <b>complement</b> of smallhash (still {{zero for}} files up to 300 KiB) is XORed {{together}} with the file size in bytes. The 160-bit UUHash is now the concatenation of the 128-bit MD5 hash and the final 32-bit smallhash value.|$|E
5000|$|The <b>bitwise</b> NOT, or <b>complement,</b> is a unary {{operation}} that performs logical negation on each bit, forming the ones' complement of the given binary value. Bits that are 0 become 1, {{and those that}} are 1 become 0. For example: ...|$|R
5000|$|... class Pen def {{initialize}} @color = 0 end [...] # Defines a getter for the @color field def color @color end # Defines a setter for the @color field def color=(value) @color = value endendpen = Pen.newpen.color = ~pen.color # <b>Bitwise</b> <b>complement</b> ...|$|E
5000|$|LAND [...] - [...] Logical bitwise {{and of all}} bits in operandsLOR [...] - [...] Logical bitwise or of all bits in operandsLNOT [...] - [...] Logical <b>bitwise</b> <b>complement</b> of all bits in operandLEQV [...] - [...] Logical bitwise {{equivalence}} of all bits in operands ...|$|E
5000|$|The ones' {{complement}} (~) or the <b>bitwise</b> <b>complement</b> gets us the {{complement of}} a given number. Thus we get the bits inverted, for every bit 1 the result is bit 0 and conversely for every bit 0 we have a bit 1. This operation {{should not be confused}} with logical negation [...] "!".|$|E
5000|$|... is the <b>bitwise</b> <b>complement</b> of x. This {{means that}} the work factor for a brute force attack is reduced {{by a factor of}} 2. Eli Biham also noticed that {{changing}} a full byte in all the key and data bytes leads to another complementation property. This reduces the work factor by 28.|$|E
50|$|Example {{of setting}} up EIGRP on a Cisco IOS router for a private network. The 0.0.15.255 {{wildcard}} in this example indicates a subnetwork with a maximum of 4094 hosts—it is the <b>bitwise</b> <b>complement</b> of the subnet mask 255.255.240.0. The no auto-summary command prevents automatic route summarization on classful boundaries, which would otherwise result in routing loops in discontiguous networks.|$|E
5000|$|DES {{exhibits}} the complementation property, namely thatwhere [...] is the <b>bitwise</b> <b>complement</b> of [...] denotes encryption {{with key}} [...] and [...] denote plaintext and ciphertext blocks respectively. The complementation property {{means that the}} work for a brute force attack could be reduced {{by a factor of}} 2 (or a single bit) under a chosen-plaintext assumption. By definition, this property also applies to TDES cipher.|$|E
50|$|Reasoning {{systems may}} employ the closed world {{assumption}} (CWA) or open world assumption (OWA). The OWA {{is often associated with}} ontological knowledge representation and the Semantic Web. Different systems exhibit a variety of approaches to negation. As well as logical or <b>bitwise</b> <b>complement,</b> systems may support existential forms of strong and weak negation including negation-as-failure and ‘inflationary’ negation (negation of non-ground atoms). Different reasoning systems may support monotonic or non-monotonic reasoning, stratification and other logical techniques.|$|E
5000|$|For {{unsigned}} integers, the <b>bitwise</b> <b>complement</b> of {{a number}} is the [...] "mirror reflection" [...] of the number across the half-way point of the unsigned integer's range. For example, for 8-bit unsigned integers, , which can be visualized on a graph as a downward line that effectively [...] "flips" [...] an increasing range from 0 to 255, to a decreasing range from 255 to 0. A simple but illustrative example use is to invert a grayscale image where each pixel is stored as an unsigned integer.|$|E
5000|$|After the sync field, all packets {{are made}} of 8-bit bytes, {{transmitted}} least-significant bit first. The first byte is a packet identifier (PID) byte. The PID is actually 4 bits; the byte consists of the 4-bit PID followed by its <b>bitwise</b> <b>complement.</b> This redundancy helps detect errors. (Note also that a PID byte contains at most four consecutive 1 bits, and thus never needs bit-stuffing, even when combined with the final 1 bit in the sync byte. However, trailing 1 bits in the PID may require bit-stuffing within the first few bits of the payload.) ...|$|E
40|$|In RFID systems, {{the reader}} is unable to {{discriminate}} concurrently reported IDs of tags from the overlapped signals, and a collision happens. Many algorithms for anticollision are proposed to improve the throughput and reduce the latency for tag identification. Existing anti-collision algorithms mainly employ CRC based collision detection functions for determining whether the collision happens. Generating CRC codes, however, requires complicated computations for both RF tags and readers, and hence incurs non-trivial time consumption, becoming the bottleneck. In this study, we design a Quick Collision Detection (QCD) scheme based on the <b>bitwise</b> <b>complement</b> function plus collision preamble, which significantly reduces the number of gates for computation and facilitates to simplify the IC design of RFID tags. The QCD scheme does not require any modification on upperlevel air protocols, {{so it can be}} seamlessly adopted by current anti-collision algorithms. Through comprehensive analysis and simulations, we show that QCD improves the identification efficiency by 40 %. © 2010 IEEE...|$|E
40|$|Steganographic systems {{attempt to}} hide {{communication}} by embedding messages in an innocuous looking cover medium. Current steganographic systems provide relatively secured hidden data with small capacity for steganographic messages. In this paper, {{a new technique}} is introduced to hide data in the least significant bits (LSB) of the discrete cosine transform (DCT) coefficients of JPEG images. This technique embeds data {{in a way that}} maximizes the ratio between even and odd DCT coefficients so as to preserve the first order statistics of JPEG images. Message bits are divided into segments and each segment is possibly modified by embedding the <b>bitwise</b> <b>complement</b> so as to ensure a high ratio between even and odd coefficients. The embedding process {{is referred to as the}} hiding appropriate messages (HAM) algorithm. The HAM algorithm searches for optimum segment length to offer high capacity, approximately 0. 36 bits/pixel, with statistically minimal changes compared to existing steganographic algorithms. A comparison between HAM and existing steganographic system is presented...|$|E
3000|$|GA {{technique}} was developed {{based on the}} Darwinian principle of the ‘survival of the fittest’ and the natural process of evolution through reproduction (Goldberg 1989). A solution for a given problem is represented {{in the form of}} a string, called “chromosome”, consisting of a set of elements, called “genes”, that hold a set of values for the optimization decision variables, in this study the pumping rate, Q j [...] as design variable. The fitness of each chromosome is determined by evaluating it against an objective function. The chromosome represents a feasible solution for the problem under study. The length of the chromosome equals the number of variables. A gene value is real coding (actual values). The concept of GA is based on the initial selection of a relatively small population. Each individual in the population represents a possible solution in the parameter space. The fitness of each individual is determined by the value of the objective function, calculated from a set of parameters. The natural evolutional processes of reproduction, selection, crossover, and mutation are applied using probability rules to evolve the new and better generations. The probabilistic rules allow some less fit individuals to survive. As shown in Fig.  7 (right), crossover is introduced within every substring corresponding to one point, and the number of the crossover variables is the same as the number of points. The <b>bitwise</b> <b>complement</b> mutation operator changes one binary value to the opposite within every substring such as 0 – 1 or 1 – 0. The details of multipoint crossover and multipoint mutation can be found in Liu et al. (1996).|$|E

