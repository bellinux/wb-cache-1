5|2|Public
40|$|NAND flash idiosyncrasies such as <b>bulk</b> <b>erase</b> {{and wear}} {{leveling}} results in non-linear and unpredictable read/write access times. In case of application domains such as streaming multimedia and real-time systems, a deterministic read/write access time is desired during design time. We propose a novel NAND flash translation layer called GFTL that guarantees fixed upper bounds (i. e., worst case service rates) for reads and writes that {{are comparable to}} a theoretical ideal case. Such guarantees are made possible by eliminating sources of non-determinism in GFTL design and using partial block cleaning. GFTL performs garbage collection in partial steps by dividing the garbage collection of a single block into several chunks, thereby interleaving and hiding the garbage collection latency while servicing requests. Further, GFTL guarantees are independent of flash utilization, size or state. Along with theoretical bounds, benchmark results show the efficacy of our approach. Based on our experiments, GFTL requires an additional 16 % of total blocks for flash management. GFTL service guarantees can be calculated from flash specifications. Thus, with GFTL, a designer can determine the service guarantees and size requirements apriori, during design time...|$|E
40|$|SSDs) {{have been}} rapidly adopted in laptops, desktops, and server storage systems because their {{performance}} {{is superior to}} that of traditional magnetic disks. However, NAND flash memory has some limitations such as out-of-place updates, <b>bulk</b> <b>erase</b> operations, and {{a limited number of}} write operations. To alleviate these unfavorable characteristics, various techniques for improving internal software and hardware components have been devised. In particular, the internal device cache of SSDs has {{a significant impact on the}} performance. The device cache is used for two main purposes: to absorb frequent read/write requests and to store logical-to-physical address mapping information. In the device cache, we observed that the optimal ratio of the data buffering and the address mapping space changes according to workload characteristics. To achieve optimal performance in SSDs, the device cache should be appropriately partitioned between the two main purposes. In this paper, we propose an adaptive partitioning scheme, which is based on a ghost caching mechanism, to adaptively tune the ratio of the buffering and the mapping space in the device cache according to the workload characteristics. The simulation results demonstrate that the performance of the proposed scheme approximates the best performance. I...|$|E
40|$|Abstract â€” Current {{generation}} {{embedded systems}} {{are capable of}} running applications that were realm of desktop systems a few years ago. Along with sophisticated processors, affordable storage due to NAND flash continues {{to be one of}} the enabling technologies driving the proliferation of embedded systems. NAND flash has its idiosyncrasies (eg: <b>bulk</b> <b>erase,</b> wearleveling) which results in a nonlinear and unpredictable read/write access times. In case of application domains such as streaming multimedia and real-time systems, a deterministic read/write access time is desired during design time. We propose a novel NAND flash translation layer called GFTL that guarantees fixed upper bounds (worst case service rates) for reads and writes that are comparable to a theoretical ideal case. Such guarantees are made possible by eliminating sources of non-determinism in GFTL design and using partial block cleaning. GFTL performs garbage collection in partial steps by dividing the garbage collection of a single block into several chunks, thereby interleaving and hiding the garbage collection latency while servicing requests. Further, GFTL guarantees are independent of flash utilization, size or state. Along with theoretical bounds, benchmark results show the efficacy of our approach. Based on experiments, GFTL requires an additional 16 % of total blocks for flash management. A proof for additional blocks required is provided for a general case. GFTL service guarantees can be calculated from flash specifications. Thus, with GFTL a designer can determine the service guarantees and size requirements apriori, during design time...|$|E
40|$|The {{properties}} of medium noise in magnetic recording are usually evaluated by using various different terms; namely, <b>bulk</b> <b>erased</b> noise, AC-biased noise, DC-magnetized noise and recorded signal noise. These evaluated medium noise, however, {{can be arranged}} by combining two elemental components. One is the random component which is originated from the rerecording phenomenon of <b>bulk</b> <b>erased</b> noise {{and the other is}} the modulated component resulted from bulky irregularities of the medium. The {{purpose of this paper is}} to present several data about the later component, the modulation noise, and to investigate the origins of this noise component. Modulation noise is not included in <b>bulk</b> <b>erased</b> noise or AC-biased noise but is included in DC-magnetized noise and recorded signal noise. In DC-magnetized noise, the modulation noise component yields a peculiar transformation of its noise spectrum in the lower frequency region; on the other hand, it produces a side band spectrum skirt beside the signal in the recorded signal noise spectrum. The magnitude of modulation noise takes a maximam at the unsaturated region of a medium and then it gradually decreases with increasing magnetizing level. The roughness of the medium surface and the clustering of magnetic perticles in the coating layer are considered to be the origins of moduration noise; however, as for recent magnetic tapes, the later term seems to be the main origin of the modulation noise...|$|R
5000|$|With the {{development}} of affordable EEPROM and flash memory, it became practical to attach the controller permanently to the board and to download program code from a host computer through a serial connection. This was termed [...] "in-circuit programming". Erasure of old programs {{was carried out by}} either over-writing them with a new download, or <b>bulk</b> <b>erasing</b> them electrically (for EEPROM). The latter method was slower, but could be carried out in-situ.|$|R

