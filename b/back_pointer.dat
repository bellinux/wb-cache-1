1|21|Public
50|$|In doubly linked lists or tree structures, a <b>back</b> <b>pointer</b> held on {{an element}} 'points back' to the item {{referring}} to the current element. These are useful for navigation and manipulation, {{at the expense of}} greater memory use.|$|E
5000|$|Here [...] is the {{probability}} of the most probable state sequence [...] responsible for the first [...] observations that have [...] as its final state. The Viterbi path can be retrieved by saving <b>back</b> <b>pointers</b> that remember which state [...] {{was used in the}} second equation. Let [...] be the function that returns the value of [...] used to compute [...] if , or [...] if [...] Then: ...|$|R
40|$|We saw {{earlier that}} it is {{possible}} to compute optimal global alignments in linear space (it can also be done for local alignments). Now we will look at how to speedup time in some cases. Similar sequences: Bounded dynamic programming If we believe that the two sequences x and y are similar then we might be able to optimally align them faster. For simplicity assume that m = n since our sequences are similar. If x and y align perfectly, then the optimal alignment corresponds to the diagonal in the dynamic programming table (now of size n × n). This is because all of the <b>back</b> <b>pointers</b> will be pointing diagonally. Therefore, if x and y are similar, we expect the alignment not to deviate much from the diagonal. For instance, consider the following two sequences x = GCGCATGGATTGAGCGA and y = TGCGCCATGGATGAGCA. Their optimal alignment is shown below:-GCGC-ATGGATTGAGCGA TGCGCCATGGAT-GAGC-A The following figure shows the alignment (<b>back</b> <b>pointers)</b> in the dynamic programming table. Figure 1 : The optimal alignment of x and y above Note that since x and y have the same length, their alignment will always contain gap pairs, i. e. for each gap in x there will be a corresponding gap in y. The deviation from the diagonal is at most equal to the number of gap pairs (i...|$|R
50|$|In the overtime, Diggins hit a three pointer, then Brittany Mallory {{hit back}} to <b>back</b> three <b>pointers</b> {{to give the}} Irish enough points for the win. Notre Dame won the game, 83-75.|$|R
40|$|International audienceReal-world data {{structures}} are often enhanced with additional pointers capturing alternative paths through a basic inductive skeleton (e. g., <b>back</b> <b>pointers,</b> head pointers). From the static analysis point of view, we must obtain several interlocking shape invariants. At the same time, {{it is well}} understood in abstract interpretation design that supporting a separation of concerns is critically important to designing powerful static analyses. Such a separation of concerns is often obtained via a reduced product on a case-by-case basis. In this paper, we lift this idea to abstract domains for shape analyses, introducing a domain combination operator for memory abstractions. As an example, we present simultaneous separating shape graphs, a product construction that combines instances of separation logic-based shape domains. The key enabler for this construction is a static analysis on inductive data structure definitions to derive relations between the skeleton and the alternative paths. From the engineering standpoint, this construction allows each component to reason independently about {{different aspects of the}} data structure invariant and then separately exchange information via a reduction operator. From the usability standpoint, we enable describing a data structure invariant in terms of several inductive definitions that hold simultaneously...|$|R
50|$|Thriller is a 1973 album by San Francisco funk group Cold Blood. Lydia Pense and {{the rest}} of Cold Blood were <b>backed</b> by The <b>Pointer</b> Sisters.|$|R
2500|$|The {{operator}} {{also had}} {{to be aware of}} the position of the spiral dial pointers on the two large dials on the <b>back.</b> The <b>pointer</b> had a [...] "follower" [...] that tracked the spiral incisions in the metal as the dials incorporated four and five full rotations of the pointers. When a pointer reached the terminal month location at either end of the spiral, the pointer's follower had to be manually moved to the other end of the spiral before proceeding further.|$|R
5000|$|To {{improve the}} {{performance}} of these sorts of operations (which are very common, and generally the point of using a DBMS), most DBMSs {{support the use of}} database indexes, which store all the values from a set of columns along with rowid <b>pointers</b> <b>back</b> into the original table. An index on the salary column would look something like this: ...|$|R
40|$|Abstract. This paper {{presents}} an axiomatic framework in Coq for verifying invariants on heap data {{structures such as}} lists and trees in a C-like language with a low-level store model. The goal of the framework is to detect common errors such as memory leaks, dangling pointers and looped data structures. The framework provides a language for expressing invariants, {{and a set of}} inference axioms for verifying them on code that manipulates the data structures. This work builds on the work done by Cook et al. which uses separation logic with recursive predicates to document data structure invariants. The key extension here is the ability to express and reason about data structures more complex than linked lists. The heap description includes a spatial component describing the basic set of lists and trees in the heap. New logical constructs are included to describe special pointer field invariants such as <b>back</b> <b>pointers.</b> We use the framework to formally prove in Coq the heap invariants of a small example program that generates a linked list representing the tree traversal of a tree. This proof guarantees the integrity of program’s data structures and that common errors such as memory leaks or dangling state in terms of a simpler concrete state. We also include a number of axioms for reasoning about the abstract state that are used in the Coq verification. Proving soundness of these abstract axioms in Coq remains future work. ...|$|R
50|$|When {{we go to}} load these nodes, however, {{we quickly}} {{discover}} that attempting to find a node based on its number is cumbersome and inefficient. We'd like our original data structure back so we can simply follow next pointers to traverse the list. To do this, we perform pointer swizzling, finding the address of each node and turning the id_number_of_next_node fields <b>back</b> into direct <b>pointers</b> to the right node.|$|R
2500|$|The USA faced Canada in {{the quarter}} finals. The teams were {{familiar}} with each other, as they had played in an exhibition [...] in France a week earlier. The game started slowly, with Canada holding an early 5–3 lead, when Ogunbowale scored seven straight points {{as part of a}} 13–0 run to open up a USA lead. Samuelson hit back to <b>back</b> three <b>pointers</b> in the second quarter and the USA held a comfortable 41–14 lead at the half. After a strong third quarter, the team from Canada came back and out scored the USA in the final period, but by then the game was out of reach. The USA won 86–45. Joyner Holmes was the leading scorer with 24 points.|$|R
40|$|One of {{the main}} {{challenges}} in the verification of software systems is the analysis of statically unbounded data structures with dynamic memory allocation, such as linked data structures and arrays. We describe Bohne, a new analysis for verifying data structures. Bohne verifies data structure operations and shows that 1) the operations preserve data structure invariants and 2) the operations satisfy their specifications {{expressed in terms of}} changes to the set of objects stored in the data structure. During the analysis, Bohne infers loop invariants in the form of disjunctions of universally quantified Boolean combinations of formulas, represented as sets of binary decision diagrams. To synthesize loop invariants of this form, Bohne uses a combination of decision procedures for Monadic Second-Order Logic over trees, SMT-LIB decision procedures (currently CVC Lite), first-order provers such as SPASS and E, and the automated reasoner within the Isabelle interactive theorem prover. This architecture shows that synthesized loop invariants can serve as a useful communication mechanism between different decision procedures. In addition, Bohne uses field constraint analysis, a combination mechanism that enables the use of uninterpreted function symbols within formulas of Monadic Second-Order Logic over trees. Using Bohne, we have verified operations on data structures such as linked lists with iterators and <b>back</b> <b>pointers,</b> trees with and without parent pointers, two-level skip lists, array data structures, and sorted lists. We have deployed Bohne in the Hob and Jahob data structure analysis systems, enabling us to combine Bohne with analyses of data structure clients and apply {{it in the context of}} larger programs. This paper describes the Bohne algorithm, the techniques that Bohne uses to reduce the amount of annotations and the running time of the analysis. ...|$|R
50|$|The GSU women's {{basketball}} game would precede the men's game, with fans pouring in before that game had begun. During {{the first half}} of the game, leading Sun Belt scorer Ryan Harrow fell with an injury to his knee, being helped off the court and unable to put pressure on his leg. He would check back into the game with 4:40 remaining in the first half only to be taken back out after 2 and a half minutes for the rest of the game. Without Harrow, the Panthers finished the first half with an 11-point lead. However, after returning for the second half, the Eagles would cut that lead to four with a score of 38-34 after back to <b>back</b> three <b>pointers</b> were scored along with a two-point jumper. R. J. Hunter went on to pull the lead back by scoring 10 consecutive points, after which the Eagles didn't threaten again. Sun Belt commissioner, Karl Benson, was present to present the Sun Belt trophy to the team after the win, which gave the Panthers back-to-back Sun Belt Basketball regular season titles.|$|R
50|$|The {{altitude}} wheel {{was connected}} to {{the main part of the}} calculator, a large metal cylinder marked with lines showing the time it would take for the bombs to reach the surface. There were multiple sets of lines for different bombs. The operator selected a value by rotating the cylinder with respect to fixed pointers on either end of the case. The air speed wheel {{was connected to}} a screw that moved another <b>pointer</b> <b>back</b> and forth along the long axis of the cylinder. The tip of the pointer was positioned so it could be read against the lines on the cylinder. The cylinder carried several sets of lines to account for the ballistics of different types of bombs and the number being dropped in a group, or stick.|$|R
50|$|AmigaOS {{is one of}} the few microkernel-based {{operating}} systems not to implement memory protection, though this lack is common amongst many of its contemporary {{operating systems}}. The lack of memory protection is because the 68000 CPU does not include a memory management unit and therefore there is no way to enforce protection of memory. Although this speeds and eases inter-process communication because programs can communicate by simply passing a <b>pointer</b> <b>back</b> and forth, the lack of memory protection made the AmigaOS more vulnerable to crashes from badly behaving programs than other multitasking systems that did implement memory protection, and Amiga OS is fundamentally incapable of enforcing any form of security model since any program had full access to the system. A co-operational memory protection feature was implemented in AmigaOS 4 and could be retrofitted to old AmigaOS systems using Enforcer or CyberGuard tools.|$|R
40|$|International audienceThis paper {{reports on}} the design and {{evaluation}} of UIMarks, a system that lets users specify on-screen targets and associated actions {{by means of a}} graphical marking language. UIMarks supplements traditional pointing by providing an alternative mode in which users can quickly activate these marks. Associated actions can range from basic pointing facilitation to complex sequences possibly involving user interaction: one can leave a mark on a palette to make it more reachable, but the mark can also be configured to wait for a click and then automatically move the <b>pointer</b> <b>back</b> to its original location, for example. The system has been implemented on two different platforms, Metisse and OS X. We compared it to traditional pointing on a set of elementary and composite tasks in an abstract setting. Although pure pointing was not improved, the programmable automation supported by the system proved very effective...|$|R
40|$|Shape {{analyses}} {{are concerned with}} precise abstractions of the heap to capture detailed structural properties. To do so, they need to build and decompose summaries of disjoint memory regions. Unfortunately, many data structure invariants require relations be tracked across disjoint regions, such as intricate numerical data invariants or structural invariants concerning <b>back</b> and cross <b>pointers.</b> In this paper, we identify issues inherent to analyzing relational structures domain for pure data properties and by user-supplied specifications of the data structure invariants to check. Particularly, it supports hybrid invariants about shape and data and features a generic mechanism for materializing summaries at the beginning, middle, or end of inductive structures. Around this domain, we build a shape analysis whose interesting components include a pre-analysis on the user-supplied specifications that guides the abstract interpretation and a widening operator over the combined shape and data domain. We then demonstrate our techniques on the proof of preservation of the red-black tree invariants during insertion. ...|$|R
40|$|Figure 1 : Sample use of UIMarks in a {{drag-and-drop}} situation. While dragging an icon (A), {{the user}} enters the UIMarks mode, points at a previously marked location using the bubble cursor technique (B), leaves the mode (C) and drops the icon (D). Here, the {{activation of the}} mark not only moved the cursor but also created a temporary mark at the initial cursor location. The user thus simply has to enter the mode again (E), point at the new mark (F) and leave the mode (G) to return there. This paper reports on the design and evaluation of UIMarks, a system that lets users specify on-screen targets and associated actions {{by means of a}} graphical marking language. UIMarks supplements traditional pointing by providing an alternative mode in which users can quickly activate these marks. Associated actions can range from basic pointing facilitation to complex sequences possibly involving user interaction: one can leave a mark on a palette to make it more reachable, but the mark can also be configured to wait for a click and then automatically move the <b>pointer</b> <b>back</b> to its original location, for example. The system has been implemented on two different platforms, Metisse and OS X. We compared it to traditional pointing on a set of elementary and composite tasks in an abstract setting. Although pure pointing was not improved, the programmable automation supported by the system proved very effective. ACM Classification: H. 5. 2 [Information interfaces and presentation]: User interfaces- Graphical user interfaces...|$|R
40|$|Information Storage Devices {{are one of}} {{the leaders}} in solid state audio {{recording}} & playback devices. The latest ISD 25 xx series provides high-quality, single-chip, nonvolatile record/playback for 45, 60, 75, 90 and now 120 seconds. These cmos devices include an on-chip oscillator, microphone preamplifier, automatic gain control, antialiasing filter, smoothing filter and speaker amplifier. In addition it is micro-processor compatible allowing complex messaging and addressing to be achieved. Recordings are stored in on-board non-volatile memory cells, providing zero power message storage. The proprietary storage method allows natural voice analog storage. The purpose of this Kit is to introduce you to this modern, new technology. Our Circuit. We now use the ISD 25120, 120 second audio recording IC in this kit. The ISD 25120 has several modes of operation We use it here as a multi-message recorder. You may record as many messages as you want up to 120 seconds of memory space. Put the SPDT switch into the Record position and just push & release the Start/Pause button to start recording. The Record LED goes on. Push the Start/Pause button to Pause- stop recording. That is the end of Message 1. Sometime later you can record a follow on message, Message 2, by pushing the Start/Pause button again. When you put the switch to Play the messages will playback. Only one message will be played back at a time. You must push Start/Pause again to get the next message. The Reset switch will move the internal address <b>pointer</b> <b>back</b> {{to the start of the}} memory space. Removing the power will not destroy the messages. You may, for example, record a long message, then send just the IC to someone through the mail then the friend could playback your message. This is the same as the 20 second Greeting Cards now on the market. They use a ISD 1420 chip-on-board IC. Build up the Kit and start playing with it. Far better to learn about it from actual use than reading pages about how it works! You can get more about applications and memory addressing of the ISD 2590 from the website a...|$|R

