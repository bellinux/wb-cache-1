34|106|Public
5000|$|<b>Branch</b> <b>table</b> {{method of}} {{applying}} name binding via <b>branch</b> <b>table</b> or function pointers ...|$|E
5000|$|Threaded code—similar to virtual method {{table or}} <b>branch</b> <b>table</b> ...|$|E
5000|$|Dispatch table a <b>branch</b> <b>table</b> {{by another}} name used for late binding ...|$|E
5000|$|Function pointer {{arrays of}} {{addresses}} to functions {{as used in}} <b>branch</b> <b>tables</b> ...|$|R
5000|$|... some {{computer}} architectures such as IBM/360 use <b>branch</b> <b>tables</b> for dispatching interrupts ...|$|R
50|$|There {{were nine}} sports at the 2011 Festival, two <b>branches,</b> <b>table</b> tennis and water polo, less than {{compared}} with the 2007 Youth Olympic Festival's programme. Medals were awarded {{in a total of}} 109 events.|$|R
5000|$|The actual {{method used}} to {{implement}} a <b>branch</b> <b>table</b> is usually based on: ...|$|E
5000|$|Switch {{statement}} a {{high level}} language conditional statement that may generate a <b>branch</b> <b>table</b> ...|$|E
5000|$|A simple {{example of}} <b>branch</b> <b>table</b> {{use in the}} 8-bit Microchip PIC {{assembly}} language is: ...|$|E
5000|$|Use of <b>branch</b> <b>tables</b> {{and other}} raw data {{encoding}} was {{common in the}} early days of computing when memory was expensive, CPUs were slower and compact data representation and efficient choice of alternatives were important. Nowadays, they are commonly still used in: ...|$|R
5000|$|The {{number of}} <b>branch</b> history <b>table</b> entries was doubled to 2,048.|$|R
5000|$|Then we add {{additional}} <b>branches</b> accordingto <b>Table</b> 1 until each bus {{is expressed}} in the matrix: ...|$|R
5000|$|Allow the {{compiler}} to 'choose' {{to generate}} a <b>branch</b> <b>table</b> on the remaining search keys (1-50).|$|E
5000|$|Virtual method table a <b>branch</b> <b>table</b> {{by another}} name with {{dynamically}} assigned pointers for dispatching (see Dispatch table) ...|$|E
50|$|Optimizing compilers such as GCC or Clang may {{compile a}} switch {{statement}} into either a <b>branch</b> <b>table</b> or a binary search through the {{values in the}} cases.A <b>branch</b> <b>table</b> allows the switch statement to determine with a small, constant number of comparisons which branch to execute {{without having to go}} through a list of comparisons, while a binary search takes only a logarithmic number of comparisons, measured in the number of cases in the switch statement.|$|E
50|$|Addition {{of global}} history, {{indirect}} prediction, and loop prediction to <b>branch</b> prediction <b>table.</b> Removal of local prediction.|$|R
5000|$|Often, {{the terms}} [...] "{{procedural}} programming" [...] and [...] "imperative programming" [...] are used synonymously. However, procedural programming {{relies heavily on}} blocks and scope, whereas imperative programming as a whole {{may or may not}} have such features. As such, procedural languages generally use reserved words that act on blocks, such as , , and , to implement control flow, whereas non-structured imperative languages use goto statements and <b>branch</b> <b>tables</b> for the same purpose.|$|R
50|$|The local {{predictor}} is a two-level table which {{records the}} history of individual branches. It consists of a 1,024-entry by 10-bit <b>branch</b> history <b>table.</b> A two-level table {{was used as the}} prediction accuracy {{is similar to that of}} a larger single-level table while requiring fewer bits of storage. It has a 1,024-entry <b>branch</b> prediction <b>table.</b> Each entry is a 3-bit saturating counter. The value of the counter determines whether the current branch is taken or not taken.|$|R
5000|$|... {{operating}} system development. In many {{operating system}}s, both system calls and library functions may be referenced by an integer index into a <b>branch</b> <b>table.</b>|$|E
50|$|In {{computer}} programming, a <b>branch</b> <b>table</b> or {{jump table}} is a method of transferring program control (branching) {{to another part of}} a program (or a different program that may have been dynamically loaded) using a table of branch or jump instructions. It is a form of multiway branch. The <b>branch</b> <b>table</b> construction is commonly used when programming in assembly language but may also be generated by a compiler, especially when implementing an optimized switch statement where known, small ranges are involved with few gaps.|$|E
5000|$|On {{systems that}} lack {{automatic}} virtual memory hardware, thunks can implement a limited form of virtual memory known as overlays. With overlays, a developer divides a program's code into segments {{that can be}} loaded and unloaded independently, and identifies the entry points into each segment. A segment that calls into another segment must do so indirectly via a <b>branch</b> <b>table.</b> When a segment is in memory, its <b>branch</b> <b>table</b> entries jump into the segment. When a segment is unloaded, its entries are replaced with [...] "reload thunks" [...] that can reload it on demand.|$|E
50|$|This example {{does not}} use any <b>branches</b> or <b>table</b> lookups {{in order to avoid}} side {{channels}} and is therefore suitable for use in cryptography.|$|R
50|$|Yocum Creek is {{a stream}} in Carroll County in noerthwest Arkansas. It is a {{tributary}} to the Long Creek <b>branch</b> of <b>Table</b> Rock Lake.|$|R
50|$|The global {{predictor}} is a single-level, 4096-entry <b>branch</b> history <b>table.</b> Each {{entry is}} a 2-bit saturating counter; {{the value of}} this counter determines whether the current branch is taken or not taken.|$|R
5000|$|A <b>branch</b> <b>table</b> {{consists}} of a serial list of unconditional branch instructions that is branched into using an offset created by multiplying a sequential index by the instruction length (the number of bytes in memory occupied by each branch instruction). It relies {{on the fact that}} machine code instructions for branching have a fixed length and can be executed extremely efficiently by most hardware, and is most useful when dealing with raw data values that may be easily converted to sequential index values. Given such data, a <b>branch</b> <b>table</b> can be extremely efficient. It usually {{consists of}} the following 3 steps: ...|$|E
5000|$|... improve {{compatibility}} with subsequent software versions. If {{the code of}} a function and the address of its entry point is changed, only the branch instruction in the <b>branch</b> <b>table</b> needs to be adjusted; application software compiled against the library, or for the operating system, does not need modification.|$|E
5000|$|C {{does not}} have dynamic dispatch, {{so it must be}} {{implemented}} manually in some form. Often an enum is used to identify the subtype of an object. Dynamic dispatch can be done by looking up this value in a function pointer <b>branch</b> <b>table.</b> Here is a simple example in C: ...|$|E
5000|$|Assembly {{language}} programmers (including optimizing compiler writers) {{are also}} able {{to benefit from the}} technique of dynamic loop unrolling, using a method similar to that used for efficient <b>branch</b> <b>tables.</b> Here the advantage is greatest where the maximum offset of any referenced field in a particular array is less than the maximum offset that can be specified in a machine instruction (which will be flagged by the assembler if exceeded). The example below is for IBM/360 or Z/Architecture assemblers and assumes a field of 100 bytes (at offset zero) is to be copied from array FROM to array TO - both having element lengths of 256 bytes with 50 entries ...|$|R
50|$|Internal WAGR {{publications}} usually identified railway {{lines as}} Lines, {{rather than as}} <b>Branch</b> Lines.Also <b>tables</b> and indexes of loads for locomotives created a large range of 'sections' that were either ganger related lengths, or related to gradients and conditions.|$|R
40|$|We derive {{relative}} proper {{motions of}} stars {{in the fields of}} globular clusters M 4, M 12, M 22, NGC 3201, NGC 6362 and NGC 6752 based on a uniform data set collected between 1997 and 2008. We assign a membership class for each star with a measured proper motion, and show that these membership classes can be successfully used to eliminate field stars from color-magnitude diagrams of the clusters. They also allow for the efficient selection of rare objects such as blue/yellow/red stragglers and stars from the asymptotic giant <b>branch.</b> <b>Tables</b> with proper motions and photometry of over 87000 stars are made publicly available via the Internet. Comment: 9 pages, 18 figure...|$|R
5000|$|To {{save the}} {{prediction}} graph over flash memory with overheads (SRAM capacity) minimized, the subsequent LBA information of each regular node is saved at the spare {{area of the}} corresponding page. It is because that the spare area of a page in current implementations has unused space, and the reading of a page usually comes with the reading of its data and spare areas simultaneously. In such a way, the accessing of the subsequent LBA information of a regular node comes with no extra cost. Since a branch node {{has more than one}} subsequent LBA’s, the spare area of the corresponding page might not have enough free space to store the information. Thus, a <b>branch</b> <b>table</b> is maintained to save the subsequent LBA information of all branch nodes. The starting entry address of the <b>branch</b> <b>table</b> that corresponds to a branch node can be saved at the spare area of the corresponding page. The starting entry records the number of subsequent LBA’s of the branch node, and the subsequent LBA’s are stored in the entries following the starting entry. The <b>branch</b> <b>table</b> can be saved on flash memory. During the run time, the entire table can be loaded into SRAM for better performance. If there is not enough SRAM space, parts of the table can be loaded in an [...] fashion.|$|E
5000|$|... {{transform}} the data into an offset into the <b>branch</b> <b>table.</b> This usually involves multiplying or shifting (effectively multiplying by {{a power of}} 2) it {{to take into account}} the instruction length. If a static translate table is used, this multiplying can be performed manually or by the compiler, without any run time cost.|$|E
50|$|In {{the table}} below, mileage is {{reckoned}} westbound from the P&LE Terminal in Pittsburgh. The original line continued east past that station {{for a little}} over two miles (listed in Youghiogheny <b>Branch</b> <b>table</b> below) to near 24th Street in the South Side neighborhood of Pittsburgh, where it met the Monongahela Connecting Railroad and the Pittsburgh, McKeesport & Youghiogheny (PM&Y).|$|E
40|$|Accurate branch {{prediction}} {{is essential for}} obtaining high performance in pipelined superscalar processors. Though many dynamic branch predictors have been proposed to obtain high prediction accuracy, they cannot perform as expected under context switches. It is observed that context switches, even at fairly large intervals, can seriously degrade the performance of dynamic branch predictors. In this paper we measure the effect of context switch on {{branch prediction}}, and present a new scheme which saves and restores <b>branch</b> predictor <b>table</b> when a context switch occurs. This scheme takes advantage of multiple small predictors which preserve <b>branch</b> predictor <b>tables</b> of independent processes. The effectiveness of reducing interprocess interference is evaluated by simulations. q 2002 Elsevier Scienc...|$|R
40|$|Due to the {{character}} of the original source materials and the nature of batch digitization, quality control issues may be present in this document. Please report any quality issues you encounter to digital@library. tamu. edu, referencing the URI of the item. Includes bibliographical references (leaves 48 - 51). Issued also on microfiche from Lange Micrographics. The technique of predicting branch directions before execution is defined as branch prediction. Conditional branches pose a hazard to the instruction flow since the instruction that executes after the branch is not known. When a branch appears, the next instruction is not known till the branch is executed. Either instruction fetch has to be halted or the branch direction has to be predicted. With some degree of probability the latter method of predicting branch directions has yielded good results. Several authors have suggested ways of predicting the direction of conditional branches with hardware that uses the history of previous branches. The branches are predicted statically, which occurs during compile time, or dynamically, which occurs during run-time. Dynamic methods have shown the better performance over static schemes. They employ one or two levels of history information and prediction accuracy scales proportional to the history information. So employing larger <b>branch</b> <b>tables,</b> which store the branch histories, we get good performance With reducing chip area, larger tables would occupy a significant portion of chip area. We propose a technique called software branch prediction, where the <b>branch</b> <b>tables</b> reside in the physical memory along with the application. The <b>branch</b> <b>tables</b> no longer reside in the hardware and so chip area occupied by the tables is freed. Software branch prediction performs as well as hardware predictions in terms of prediction accuracy, but the execution time of the application is increased by 50 - 100 %. Since accessing software tables takes longer than hardware tables, the execution time is higher. We need to identify ways to reduce the execution time. We propose one such mechanism called pivot branches. Pivot branches are branches whose execution can determine the direction taken by a few or more branches. We could predict more than one branch direction by correctly predicting pivot branches at one time. Two different methods were attempted to determine the existence of pivot branches. They are code inspection and inter-procedural path profiling. Path profiling was done on two SPEC benchmarks. The results did not clearly indicate if pivot branches exist, but it shows that there are gains doing predictions this way...|$|R
50|$|The I-box fetches and decodes VAX instructions. It also {{contains}} the 2 KB direct-mapped virtual instruction cache (VIC) and the 512-entry by 4-bit <b>branch</b> history <b>table.</b> The I-box aimed to fetch eight bytes of instruction {{data from the}} VIC during every cycle.|$|R
