4|71|Public
25|$|In MySQL the '&' has dual roles. As well as {{a logical}} AND, it {{additionally}} serves as the <b>bitwise</b> <b>operator</b> of an intersection between elements.|$|E
5000|$|Commonly, {{to achieve}} this process a page table {{implementation}} is used. The page table maps logical memory to physical memory. The page table uses a <b>bitwise</b> <b>operator</b> to mark if a page is valid or invalid. A valid page is one that currently resides in main memory. An invalid page is one that currently resides in secondary memory. When a process tries to access a page, the following steps are generally followed: ...|$|E
40|$|Cryptographic hash {{functions}} for calculating the message digest {{of a message}} has been in practical use as an effective measure to maintain message integrity since a few decades. This message digest is unique, irreversible and avoids all types of collisions for any given input string. The message digest calculated from this algorithm is propagated in the communication medium along with the original message from the sender side and on the receiver side integrity of the message can be verified by recalculating the message digest of the received message and comparing the two digest values. In this paper we have designed and developed a new algorithm for calculating the message digest of any message and implemented t using a high level programming language. An experimental analysis and comparison with the existing MD 5 hashing algorithm, which is predominantly {{being used as a}} cryptographic hashing tool, shows this algorithm to provide more randomness and greater strength from intrusion attacks. In this algorithm the plaintext message string is converted into binary string and fragmented into blocks of 128 bits after being padded with user defined padding bits. Then using a pseudo random number generator a key is generated for each block and operated with the respective block by a <b>bitwise</b> <b>operator.</b> This process is terated for the whole message and finally a fixed length message digest is obtained. Comment: 4 pages, 2 figures, 1 tabular data se...|$|E
5000|$|Logical and <b>bitwise</b> <b>operators</b> are unified. This {{is unlike}} some C-derived {{languages}} (such as Perl), which have separate logical and <b>bitwise</b> <b>operators.</b> This again {{is a traditional}} feature of BASIC.|$|R
50|$|In the C {{programming}} language, operations can {{be performed}} on a bit level using <b>bitwise</b> <b>operators.</b>|$|R
50|$|GLSL {{contains}} the operators in C and C++, {{with the exception}} of pointers. <b>Bitwise</b> <b>operators</b> were added in version 1.30.|$|R
5000|$|Another {{example is}} a {{pseudocode}} implementation of addition, showing how to calculate a sum of two integers [...] and [...] using <b>bitwise</b> <b>operators</b> and zero-testing: ...|$|R
40|$|John Wiley & Sons, Ltd. Hash {{functions}} are widely applied in network packet processing, and uniformity {{is one of}} their determinant attributes. This paper investigates into the impact of <b>bitwise</b> <b>operators</b> on the uniformity of such hash functions. To this end, we first define connection identifier as their input keyword, whose uniformity is quantized by deviation index. Then, we analyze the impact of all <b>bitwise</b> <b>operators</b> on the deviation indices of its operation results. As for binary <b>bitwise</b> <b>operators,</b> we give the conditions where AND, OR and XOR increase bit uniformity, respectively, and conclude that only XOR improves the uniformity of bits in the connection identifier effectively by verifying these conditions with real network traffic. Furthermore, we derive a positive linear relationship of the uniformity of a bit-stream and that of its any bit under simple independence assumption. As for unary <b>bitwise</b> <b>operators,</b> we prove that NOT keeps bit-stream uniformity as the same even combined with XOR. Nevertheless, we find that circular shift with XOR changes bit-stream uniformity with a great probability. In particular, a way is proposed to determine the optimal staggered number of two bitstreams before their XOR operation. Lastly, we provide guidelines to design uniform hash functions with circular shift and XOR...|$|R
5000|$|Like Applesoft BASIC, Lua has a floating-point type as its sole numeric type when {{configured}} for desktop computers, and it had no <b>bitwise</b> <b>operators</b> {{prior to}} Lua 5.2.|$|R
30|$|We {{presented}} a bitwise-based approach to present Web services and indexing technique. This representation {{allows us to}} use the <b>bitwise</b> <b>operators</b> in processing and further enjoy more improvement on performance.|$|R
50|$|C allows using <b>bitwise</b> <b>operators</b> {{to perform}} boolean operations. Care {{must be taken}} because the {{semantics}} are different when operands make use {{of more than one}} bit to represent a value.|$|R
5000|$|In Perl, strings {{can be used}} as {{expandable}} bit arrays. They can {{be manipulated}} using the usual <b>bitwise</b> <b>operators</b> (...) , and individual bits can be tested and set using the vec function.|$|R
50|$|This {{applies to}} <b>bitwise</b> <b>operators</b> as well, {{which means that}} even though they operate on only one bit at a time they cannot accept {{anything}} smaller than a byte as their input.|$|R
5000|$|The [...]NET Framework {{supplies}} a [...] collection class. It stores boolean values, supports {{random access}} and <b>bitwise</b> <b>operators,</b> can be iterated over, and its [...] property {{can be changed}} to grow or truncate it.|$|R
5000|$|Pascal {{has another}} more abstract, high level method {{of dealing with}} bitwise data, sets. Sets allow the {{programmer}} to set, clear, intersect, and unite bitwise data values, rather than using direct <b>bitwise</b> <b>operators</b> (which are available in modern Pascal as well). Example; ...|$|R
50|$|The {{following}} is a JavaScript implementation of the above algorithm for converting any number to a hexadecimal in String representation. Its purpose is to illustrate the above algorithm. To work with data seriously, however, {{it is much more}} advisable to work with <b>bitwise</b> <b>operators.</b>|$|R
50|$|In general, in {{languages}} offering this feature, most operators {{that can}} take a variable {{as one of their}} arguments and return a result of the same type have an augmented assignment equivalent that assigns the result back to the variable in place, including arithmetic operators, bitshift <b>operators,</b> and <b>bitwise</b> <b>operators.</b>|$|R
5000|$|In Applesoft BASIC, integer {{arithmetic}} {{was implemented}} {{on top of}} floating-point arithmetic, {{and there were no}} <b>bitwise</b> <b>operators</b> and no support for blitting of raster graphics (even though the language supported vector graphics on the Apple II's raster hardware). This caused games and other programs written in BASIC to run slower.|$|R
5000|$|The logical <b>bitwise</b> <b>operators</b> in C (and all {{programming}} languages that borrow precedence rules from C, for example, C++, Perl and PHP) have a {{precedence level}} that {{the creator of}} the C language considered unsatisfactory. However, many programmers have become accustomed to this order. The relative precedence levels of operators found in many C-style languages are as follows: ...|$|R
5000|$|Although {{machines}} {{often have}} efficient built-in instructions for performing arithmetic and logical operations, all these operations {{can be performed}} by combining the <b>bitwise</b> <b>operators</b> and zero-testing in various ways. [...] For example, here is a pseudocode implementation of ancient Egyptian multiplication showing how to multiply two arbitrary integers [...] and [...] ( [...] greater than [...] ) using only bitshifts and addition: ...|$|R
50|$|In Microsoft's SQL Server Transact-SQL (T-SQL) language, the tilde is a unary <b>Bitwise</b> NOT <b>operator.</b>|$|R
5000|$|... {{resemble}} the C <b>bitwise</b> exclusive-or <b>operators,</b> but {{are in fact}} the bc integer exponentiation operators.|$|R
50|$|Four of the <b>bitwise</b> <b>operators</b> have {{equivalent}} logical operators. They are {{equivalent in}} {{that they have the}} same truth tables. However, logical operators treat each operand as having only one value, either true or false, rather than treating each bit of an operand as an independent value. Logical operators consider zero false and any nonzero value true. Another difference is that logical operators perform short-circuit evaluation.|$|R
5000|$|CFScript uses ColdFusion {{expressions}}, {{which are}} not a superset or a subset of JavaScript expressions. In particular, ColdFusion expressions do not support <b>bitwise</b> <b>operators,</b> and the ColdFusion MOD or % operator operates differently from the corresponding JavaScript % operator: In ColdFusion, the operator does integer arithmetic and ignores fractional parts. ColdFusion expressions also support the EQV, IMP, CONTAINS, and DOES NOT CONTAIN operators that are not supported in JavaScript.|$|R
50|$|The {{precedence}} of the <b>bitwise</b> logical <b>operators</b> {{has been}} criticized. Conceptually, & and | are arithmetic operators like * and +.|$|R
50|$|For {{the time}} {{performance}} and the success rates, the bitwise similarity functions like Sørensen-Dice index, Tversky index or Hamming distance {{are all in the}} same category with similar success rates and running times. There are obviously slight differences but the idea behind bitwise operation, looses the string operations like deletion or addition. For example, a single bit addition to the front of one of the input strings would yield a catastrophic result on the similarity for <b>bitwise</b> <b>operators</b> while Levenshtein distance is successfully catching.|$|R
5000|$|In Java, {{the class}} [...] creates a bit array that is then {{manipulated}} with functions named after <b>bitwise</b> <b>operators</b> familiar to C programmers. Unlike the [...] in C++, the Java [...] {{does not have}} a [...] "size" [...] state (it has an effectively infinite size, initialized with 0 bits); a bit can be set or tested at any index. In addition, there is a class , which represents a Set of values of an enumerated type internally as a bit vector, as a safer alternative to bitfields.|$|R
40|$|Abstract—Template {{matching}} is {{a technique}} used in classifying an object by comparing portions of images with another image. Finding a given template in an image is typically performed by scanning the image and evaluating the similarity with the template. When the scanning {{is concerned with the}} entire image template matching is optimal. This paper considers a special case of template matching where the templates are binary. Although binary template matching has been studied extensively {{since the early days of}} pattern recognition, this technique seems not longer in use in Document Image Analysis (DIA). The major reasons are the time complexity, the no-invariance to scale and rotation and the lack of adaptability of similarity measures. However, different contributions have been investigated during the last years to improve these aspects: robustness and discrimination capability of similarity measures, their characterization, time-processing optimization with hardware support, etc. In this paper, we will review first some of the recent issues about binary template matching. We will present then a system exploiting <b>bitwise</b> <b>operators</b> and parallel processing supporting fast and accurate binary template matching for Manga copyright protection. This system is compared to a FFT-based template matching, and it outperforms both in processing-time and detection accuracy. Keywords—binary template matching & similarity measures, optimal, FFT, <b>bitwise</b> <b>operators,</b> parallel processing I...|$|R
5000|$|Example: for +2, {{which is}} 00000010 in binary (the ~ {{character}} is the C <b>bitwise</b> NOT <b>operator,</b> so ~X means [...] "invert all the bits in X"): ...|$|R
5000|$|There are six {{available}} comparison operators: [...] These operators {{can be used}} in both comparisons and loops. Note that there's also a <b>bitwise</b> AND <b>operator</b> which tests bits: ...|$|R
40|$|Abstract. Volumetric {{representations}} {{provide the}} localization of shapes in space. When such representation is created {{on the fly}} from the geometry, it becomes very useful {{for a wide range}} of applications (constructive solid geometry (CSG), shape repair, collision detection, etc. Using the advanced functionalities provided by recent GPUs (geometry shaders, 32 -bit integer texture format and <b>bitwise</b> <b>operators),</b> we show how to compute a robust scene voxelization and octree construction in a few milliseconds from any hardware-supported rasterizable geometry. Our hierarchical volumetric representation is thus especially well-suited for hierarchical computation of fully dynamic scenes. 1...|$|R
50|$|Pd's native objects {{range from}} the basic mathematical, logical, and <b>bitwise</b> <b>operators</b> found in every {{programming}} language to general and specialized audio-rate DSP functions (designated by a tilde (~) symbol), such as wavetable oscillators, the Fast Fourier transform (fft~), {{and a range of}} standard filters. Data can be loaded from file, read in from an audio board, MIDI, via Open Sound Control (OSC) through a Firewire, USB, or network connection, or generated on the fly, and stored in tables, which can then be read back and used as audio signals or control data.|$|R
5000|$|... #Subtitle level 3: Criticism of <b>bitwise</b> and {{equality}} <b>operators</b> precedence ...|$|R
30|$|The tool WSCOVER, {{developed}} in this research, has offered several useful functions {{that the other}} similar works do not support, including the capability of composing and verifying Web services, in an on-the-fly manner; and extending the model checker by applying the heuristics specifying the Web service nature. In addition, also through this paper, we have some contributions about the formal representation of Web service; the bitwise-based Web service indexing method to index the Web service repository using the <b>bitwise</b> <b>operators.</b> This helps {{the building of the}} index table as well as the retrieval of Web services more efficient.|$|R
50|$|The caret {{has many}} uses in {{programming}} languages. It can signify exponentiation, the <b>bitwise</b> XOR <b>operator,</b> string concatenation, and control characters in caret notation, among other uses. In regular expressions, the caret {{is used to}} {{mark the beginning of}} a string, or the beginning of a line within that string (depending on the regular expression dialect and specified options); if it begins a character class, it indicates that the inverse of the class is to be matched. Pascal uses the caret for declaring pointers and when dereferencing them. Go also uses it as a <b>bitwise</b> NOT <b>operator.</b>|$|R
40|$|This paper {{describes}} two vetsions {{of a novel}} apptoach {{to developing}} binary classifiers, based on two evolutionary computation paradigms: cellular programming and genetic programming. Such an approach achieves high computation efficiency both during evolution and at runtime. Evolution speed is optimized by allowing multiple solutions to be computed in parallel. Runtime performance is optimized explicitly using parallel computation {{in the case of}} cellular programming or implicitly taking advantage of the intrinsic parallelism of <b>bitwise</b> <b>operators</b> on standard sequential architectures in the case of genetic programming. The approach was tested on a digit recognition problem and compared with a reference classifier...|$|R
