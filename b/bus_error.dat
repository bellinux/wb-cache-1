27|28|Public
25|$|The MMU {{may also}} {{generate}} illegal access error conditions or invalid page faults upon illegal or non-existing memory accesses, respectively, leading to segmentation fault or <b>bus</b> <b>error</b> conditions when {{handled by the}} operating system.|$|E
2500|$|Normally, {{a target}} holds DEVSEL# {{asserted}} {{through the last}} data phase. [...] However, if a target deasserts DEVSEL# before disconnecting without data (asserting STOP#), this indicates a target abort, which is a fatal error condition. [...] The initiator may not retry, and typically treats it as a <b>bus</b> <b>error.</b> [...] Note that a target may not deassert DEVSEL# while waiting with TRDY# or STOP# low; it must do this {{at the beginning of}} a data phase.|$|E
2500|$|These {{problems}} were fixed {{in the next}} major revision of the 68k architecture, {{with the release of}} the MC68010. The <b>Bus</b> <b>Error</b> and Address Error exceptions push a large amount of internal state onto the supervisor stack in order to facilitate recovery, and the MOVE from SR instruction was made privileged. A new unprivileged [...] "MOVE from CCR" [...] instruction is provided for use in its place by user mode software; an operating system can trap and emulate user-mode MOVE from SR instructions if desired.|$|E
40|$|The Los Alamos Message Passing Interface (LA-MPI) is an {{end-to-end}} networkfailure-tolerant message-passing {{system designed}} for terascale clusters. LA-MPI is a standard-compliant implementation of MPI designed to tolerate networkrelated failures including I/O <b>bus</b> <b>errors,</b> network card errors, and wire-transmissio...|$|R
50|$|Intel's Pentium 4, Intel Xeon, P6 family {{processors}} {{as well as}} the Itanium architecture {{implement a}} machine check architecture that provides a mechanism for detecting and reporting hardware (machine) errors, such as: system <b>bus</b> <b>errors,</b> ECC errors, parity errors, cache errors, and translation lookaside buffer errors. It consists of a set of model-specific registers (MSRs) that are used to set up machine checking and additional banks of MSRs used for recording errors that are detected.|$|R
5000|$|System <b>bus</b> errors: (<b>error</b> {{communicating}} {{between the}} processor and the motherboard).|$|R
2500|$|The [...] "exception table" [...] ({{interrupt}} vector table interrupt vector addresses) {{is fixed}} at addresses 0 through 1023, permitting 256 32-bit vectors. The first vector (RESET) consists of 2 vectors, namely the starting stack address, and the starting code address. Vectors 3 through 15 {{are used to}} report various errors: <b>bus</b> <b>error,</b> address error, illegal instruction, zero division, CHK and CHK2 vector, privilege violation (to block privilege escalation), and some reserved vectors that became line 1010 emulator, line 1111 emulator, and hardware breakpoint. Vector 24 starts the real interrupts: spurious interrupt (no hardware acknowledgement), and level 1 through level 7 autovectors, then the 16 TRAP vectors, then some more reserved vectors, then the user defined vectors.|$|E
2500|$|The 68000 is also {{unable to}} easily support virtual memory, which {{requires}} {{the ability to}} trap and recover from a failed memory access. The 68000 does provide a <b>bus</b> <b>error</b> exception {{which can be used}} to trap, but it does not save enough processor state to resume the faulted instruction once the operating system has handled the exception. Several companies did succeed in making 68000-based Unix workstations with virtual memory that worked by using two 68000 chips running in parallel on different phased clocks. When the [...] "leading" [...] 68000 encountered a bad memory access, extra hardware would interrupt the [...] "main" [...] 68000 to prevent it from also encountering the bad memory access. This interrupt routine would handle the virtual memory functions and restart the [...] "leading" [...] 68000 in the correct state to continue properly synchronized operation when the [...] "main" [...] 68000 returned from the interrupt.|$|E
5000|$|Abort (ABORTB) {{input and}} {{associated}} vector supports processor repairs of <b>bus</b> <b>error</b> conditions, such as page faults and memory access violations.|$|E
50|$|All I/O on 2200 Series {{systems is}} handled by I/O {{processors}}. These processors offload {{large portions of}} the I/O path length and recovery, and by fully isolating the main system from I/O faults, interrupts, <b>bus</b> <b>errors,</b> etc. greatly improve reliability and availability. The I/O processors come in three different types (Storage, Communications, Clustering) but the only real difference is the firmware load.|$|R
50|$|To prevent <b>bus</b> <b>errors,</b> {{the chassis}} has three pins in each slot which {{correspond}} {{with the line}} card. Upon insertion, the longest of these makes first contact and stalls the bus (to avoid corruption). As the line card is pushed in further, the middle pin makes the data connection. Finally, the shortest pin removes the bus stall and allows the chassis to continue operation.|$|R
40|$|The Los Alamos Message Passing Interface (LA-MPI) is an {{end-to-end}} network-failure-tolerant message-passing {{system designed}} for terascale clusters. LA-MPI is a standardcompliant implementation of MPI designed to tolerate network-related failures including I/O <b>bus</b> <b>errors,</b> network card errors, and wire-transmission errors. This paper details the distinguishing features of LA-MPI, including support for concurrent {{use of multiple}} types of network interface, and reliable message transmission utilizing multiple network paths and routes between a given source and destination. In addition, performance measurements on production-grade platforms are presented...|$|R
50|$|The MMU {{may also}} {{generate}} illegal access error conditions or invalid page faults upon illegal or non-existing memory accesses, respectively, leading to segmentation fault or <b>bus</b> <b>error</b> conditions when {{handled by the}} operating system.|$|E
5000|$|The SIGBUS {{signal is}} sent to a process when it causes a <b>bus</b> <b>error.</b> The {{conditions}} {{that lead to the}} signal being sent are, for example, incorrect memory access alignment or non-existent physical address.|$|E
50|$|In a {{multiprocessor}} system, coprocessors {{could not}} be shared between CPUs. To avoid problems with returns from coprocessor, <b>bus</b> <b>error,</b> and address error exceptions, it was generally necessary in a multiprocessor system for all CPUs {{to be the same}} model, and for all FPUs to be the same model as well.|$|E
40|$|The {{flexible}} time-triggered on CAN is {{a protocol}} to support synchronous and asynchronous traffic over a CAN fieldbus. The use of redundant buses {{is a recent}} evolution to the main idea of FTT. Despite the reference FTT-CAN architecture support to master replication, the current FTT implementation does not support replicated masters together with bus media redundancy. This paper presents an evolution of the FTT-CAN master replication scheme targeted to a multi bus network and a mechanisms, located at the masters, to detect permanent <b>bus</b> <b>errors.</b> DET...|$|R
40|$|Nowadays, model-driven formal {{verification}} approaches are much researched for testing industrial control applications. However, these approaches can't check {{the system for}} <b>bus</b> <b>errors,</b> faulty hardware configurations and compatibility problems efficient. For sufficient testing, Hardware-in-the-Loop (HIL) test should be used. But the HIL-test is rarely used {{in the field of}} automation because of missing experience with it and great costs by using vendor-dependent solutions. This paper will discusses the current problems of HIL-tests for verifying the control applications and presents a promising vendor-independent approach for its implementation...|$|R
50|$|CPUs {{generally}} access data at {{the full}} width of their data bus at all times. To address bytes, they access memory at the full width of their data bus, then mask and shift {{to address the}} individual byte. Systems tolerate this inefficient algorithm, as it is an essential feature for most software, especially string processing. Unlike bytes, larger units can span two aligned addresses and would thus require more than one fetch on the data bus.It is possible for CPUs to support this, but this functionality is rarely required directly at the machine code level, thus CPU designers normally avoid implementing it and instead issue <b>bus</b> <b>errors</b> for unaligned memory access.|$|R
50|$|Once PCD was {{integrated}} into the product, the final results showed reduced startup time and great improvements in the system’s robustness, reliability and availability. The Debugging and remote debugging capabilities were also improved due to the extended debug information which was available {{in case of a}} crash (Segmentation fault, <b>bus</b> <b>error,</b> or similar).|$|E
50|$|FreeBSD, Linux and Solaris can {{signal a}} <b>bus</b> <b>error</b> when virtual memory pages cannot be paged in, e.g. {{because it has}} {{disappeared}} (e.g. accessing a memory-mapped file or executing a binary image which has been truncated while the program was running), or because a just-created memory-mapped file cannot be physically allocated, because the disk is full.|$|E
50|$|The default {{action for}} a {{segmentation}} fault or <b>bus</b> <b>error</b> is abnormal {{termination of the}} process that triggered it. A core file may be generated to aid debugging, and other platform-dependent actions may also be performed. For example, Linux systems using the grsecurity patch may log SIGSEGV signals in order to monitor for possible intrusion attempts using buffer overflows.|$|E
30|$|The control {{strategy}} proposed above {{is based upon}} (7) and {{is only applicable to}} minimize the <b>bus</b> voltage <b>errors</b> of two MGs. Due to this limitation, the topology for n bus MGs connected with multiple tie-lines and the impact of Z_tie variation in the system have not been considered in this paper.|$|R
40|$|The Transportation Safety Analysis Division at the University of Michigan Transportation Research Institute (UMTRI) {{initiated}} the Buses Involved in Fatal Accidents (BIFA) project in 2000 to collect more {{detailed information about}} buses involved in fatal crashes. The BIFA project {{is supported by the}} Federal Motor Carrier Safety Administration. Previous work using BIFA data showed significant differences between different bus operations in terms of crash types, when and where the crashes occurred, the incidence of <b>bus</b> driver <b>error,</b> and previous driver record of the drivers. Using BIFA data for 1999 - 2005, the present study focuses on factors associated with driver <b>errors</b> in fatal <b>bus</b> crashes involving different bus operator types. Five different carrier types are identified: School, transit, intercity, charter/tour, and “other” bus operators. There are substantial differences between these carrier types that are reflected in rates of <b>bus</b> driver <b>errors</b> in crashes and in the previous driving record of the bus drivers. Many factors are identified that are associated with driver <b>error,</b> including <b>bus</b> operation type, age, sex, hours driving, trip type, method of compensation, and previous driving record. A logistic regression model was used to model the probability of driver <b>error.</b> <b>Bus</b> operation type, previous violations, and previous crashes were significant parameters in the model. The other factors were not significant...|$|R
40|$|The {{controller}} {{area network}} (CAN) protocol was initially developed for the automotive industry to support low-level communication services between modules in distributed car control systems. Nowadays CAN is used in many other real-time applications, some of them requiring dependable behavior. When designing CAN based dependable systems the bus topology of CAN is a {{single point of failure}} {{that needs to be addressed}} either through bus replication or by adopting alternative topologies with better fault-tolerance capabilities, e. g., star topologies. This paper proposes a set of components, an architecture and protocols to enable the dynamic management of the topology of CAN networks made of several replicated buses, both to increase the total available bandwidth and to reconfigure the network upon <b>bus</b> permanent <b>error.</b> In many operational scenarios, the proposed solution could be plugged into existing systems to improve its resilience to <b>bus</b> permanent <b>errors,</b> without changing the code running in the nodes. DET...|$|R
50|$|Illegal accesses and invalid page faults, as invalid conditions, {{can result}} in a {{segmentation}} fault or <b>bus</b> <b>error,</b> resulting in programming termination (crash) or core dump, depending on the operating system environment. Often these problems are caused by software bugs, but hardware memory errors, such as those caused by overclocking, may corrupt pointers and make correct software fail. It can also crash the operating system.|$|E
50|$|In computing, a <b>bus</b> <b>error</b> is a fault {{raised by}} hardware, notifying an {{operating}} system (OS) that a process {{is trying to}} access memory that the CPU cannot physically address: an invalid address for the address bus, hence the name. In modern use on most architectures these are much rarer than segmentation faults, which occur primarily due to memory access violations: problems in the logical address or permissions.|$|E
50|$|At the {{hardware}} level, the fault is initially {{raised by the}} memory management unit (MMU) on illegal access (if the referenced memory exists), {{as part of its}} memory protection feature, or an invalid page fault (if the referenced memory does not exist). If the problem is not an invalid logical address but instead an invalid physical address, a <b>bus</b> <b>error</b> is raised instead, though these are not always distinguished.|$|E
50|$|Motorola 68000 (address is {{represented}} in 24 bits). Could {{have one or two}} autoincrement register operands. The 68010+ resolved the problem by saving the processor's internal state on <b>bus</b> or address <b>errors.</b>|$|R
40|$|In recent years, {{scripting}} languages such as Perl, Python, and Tcl {{have become}} popular development tools {{for the creation}} of sophisticated application software. One of the most useful features of these languages is their ability to easily interact with compiled languages such as C and C++. Although this mixed language approach has many benefits, one of the greatest drawbacks is the complexity of debugging that results from using interpreted and compiled code in the same application. In part, {{this is due to the}} fact that scripting language interpreters are unable to recover from catastrophic errors in compiled extension code. Moreover, traditional C/C++ debuggers do not provide a satisfactory degree of integration with interpreted languages. This paper describes an experimental system in which fatal extension errors such as segmentation faults, <b>bus</b> <b>errors,</b> and failed assertions are handled as scripting language exceptions. This system, which has been implemented as a general purpose shared library, requires no modifications to the target scripting language, introduces no performance penalty, and simplifies the debugging of mixed interpreted-compiled application software...|$|R
40|$|Single-bus CANopen {{systems have}} not been enough for large systems, where CANopen allows use of {{existing}} tools and good selection of standardized components. Still CANopen documentation is single-bus oriented, but does not limit the systems into single bus level. Many things, like signal oriented communications model, support more complex systems. Typically {{there are more than}} enough maximum supported amount of nodes and COB-Ids but not enough transmission bandwidth to carry all signals of the system in the desired time windows. This paper presents one solution, where every bus is still 100 % CANopen conformant. Dividing a large system into smaller subsystems makes it easier to schedule signals into PDOs, to monitor buses by keeping subsystem specific signals local to appropriate subsystem and to decrease the coverage of fatal <b>bus</b> <b>errors.</b> Special gateways are introduced for signals, SDO- and EMCY-protocol. Also protocols and services restricted into one hierarchy level and reasons for the restriction are explained. The biggest challenges are found in EMCY-protocol and signal scheduling over multiple independent bus segments. In those issues there are also the biggest risk for application dependencies. Hopefully this paper is a trigger for official documentation and advanced development of multilevel CANopen networking...|$|R
50|$|On POSIX-compliant platforms, bus errors usually {{result in}} the SIGBUS signal {{being sent to the}} process that caused the error. SIGBUS can also be caused by any general device fault that the {{computer}} detects, though a <b>bus</b> <b>error</b> rarely means that the computer hardware is physically broken—it is normally caused by a bug in a program's source code. Bus errors may also be raised for certain other paging errors; see below.|$|E
5000|$|Normally, {{a target}} holds DEVSEL# {{asserted}} {{through the last}} data phase. However, if a target deasserts DEVSEL# before disconnecting without data (asserting STOP#), this indicates a target abort, which is a fatal error condition. The initiator may not retry, and typically treats it as a <b>bus</b> <b>error.</b> Note that a target may not deassert DEVSEL# while waiting with TRDY# or STOP# low; it must do this {{at the beginning of}} a data phase.|$|E
5000|$|These {{problems}} were fixed {{in the next}} major revision of the 68k architecture, {{with the release of}} the MC68010. The <b>Bus</b> <b>Error</b> and Address Error exceptions push a large amount of internal state onto the supervisor stack in order to facilitate recovery, and the MOVE from SR instruction was made privileged. A new unprivileged [...] "MOVE from CCR" [...] instruction is provided for use in its place by user mode software; an operating system can trap and emulate user-mode MOVE from SR instructions if desired.|$|E
40|$|Abstract:- Intelligent Platform Management Interface (IPMI) defines common {{interfaces}} to server‟s hardware {{that used}} to monitor a server‟s physical health such as fans, voltage, temperature, power supplies, power status, and chassis. The server‟s physical health gets report to Baseboard Management Controller (BMC) by different sensors that built into the system. All the sensors information is provided by Sensor Data Records (SDRs). SDRs provide the data records that contain information about the type and number of sensors in the platform, sensor threshold support, chassis intrusion, power supply monitoring, fan speeds, fan presence, board voltages, board temperatures, <b>bus</b> <b>errors,</b> memory errors. SDR are created manually by the users using the information provided by Configuration sheet. In this paper the need to automate the generation of SDR is discussed in two ways: the SDR mapping to the spreadsheets and provided the details without spreadsheets. This paper proposed a solution by implementing of the SDR creation automation tool. We proposed a prototype including an implementation of IPMI‟s Sensor Data Records format module that {{has been applied to}} different configuration sheet provided by different engineers. Any changes to the configuration sheet values get updated by using the SDR generation tool. Keywords:- Baseboard Management controller, Field Replacement U nit, IPMI, sensors I...|$|R
40|$|Recently, {{there are}} lots of control {{equipments}} in a train such as traction control, air conditioners and even internet access. For this reason, vehicle network must allow for the big amount of transmission data and must ensure the high reliability. After investigating about characteristics of multifunction vehicle <b>bus,</b> an <b>error</b> detection and analysis system is proposed. The proposed error analysis system can be used to verify high reliability of data transmission over multifunction vehicle bus. We explain how to implement the embedded error analysis system based on an ARM processor. The proposed system can detect all kinds of errors that IEC 61375 standard refers to...|$|R
50|$|By using a CRC {{checksum}} {{rather than}} simple additive checksums as {{contained within the}} UDP and TCP transports, errors generated internal to NICs can be detected as well. Both TCP and UDP have proven ineffective at detecting <b>bus</b> specific bit <b>errors,</b> since these errors with simple summations tend to be self-cancelling. Testing that led to adoption of RFC 3309 compiled evidence based upon simulated error injection against real data that demonstrated as much as 2% of these errors were not being detected.|$|R
