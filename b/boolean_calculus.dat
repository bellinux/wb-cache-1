5|30|Public
25|$|The basic {{operations}} of <b>Boolean</b> <b>calculus</b> are as follows.|$|E
40|$|The {{development}} of <b>Boolean</b> <b>calculus</b> for {{its application to}} developing digital system design methodologies that would reduce system complexity, size, cost, speed, power requirements, etc., is discussed. Synthesis procedures for logic circuits are examined particularly asynchronous circuits using clock triggered flip flops...|$|E
40|$|The {{concept of}} Boolean {{integration}} is developed, and different Boolean integral operators are introduced. Given {{the changes in}} a desired function {{in terms of the}} changes in its arguments, the ways of 'integrating' (i. e. realizing) such a function, if it exists, are presented. The necessary and sufficient conditions for integrating, in different senses, the expression specifying the changes are obtained. <b>Boolean</b> <b>calculus</b> has applications in the design of logic circuits and in fault analysis...|$|E
40|$|The {{concept of}} Boolean {{integration}} is introduced and developed. When {{the changes in}} a desired function are specified in terms of changes in its arguments, then ways of 'integrating' (i. e., realizing) the function, if it exists, are presented. <b>Boolean</b> integral <b>calculus</b> has applications in design of logic circuits...|$|R
40|$|Abstract- The optimal {{design of}} a {{non-deterministic}} finite state machine by solving and resolving Boolean equations is shown, {{taking advantage of the}} relationships between single Boolean functions, sets of Boolean functions, Boolean equations, and their solutions. The <b>Boolean</b> Differential <b>Calculus</b> is used to point out the key ideas of the applied resolvability theory...|$|R
40|$|We {{conservatively}} extend classical elementary {{differential calculus}} to the Cartesian closed category of convergence spaces. By specializing results about the convergence space representation of directed graphs, we use Cayley graphs {{to obtain a}} differential calculus on groups, from which we then extract a <b>Boolean</b> differential <b>calculus,</b> in which both linearity and the product rule, also called the Leibniz identity, are satisfied. Comment: 12 pages, 4 figures. First author {{was supported in part}} by an NRC Fellowship. Second Author {{was supported in part by}} AFRL Contract No. F 8713 - 13 - 2 - 0116 G...|$|R
40|$|AbstractIn {{this paper}} we propose a slight {{modification}} of the Knuth and Bendix completion procedure for solving the equality problem in nonequational theories defined by a set of Horn clauses. We prove that the completeness property of this procedure is then preserved, provided that a weak axiomatization of <b>boolean</b> <b>calculus</b> and equality has been given to the procedure. In particular, we need only the reflexivity axiom for equality. Another application of the Knuth and Bendix procedure is the proof by induction (Musser, 1980; Huet-Hullot, 1982 and others). We show that our version of the completion procedure can be used for proving universally quantified formulas (not only equations) in the initial model defined by a set of Horn clauses. Experimental results, and comparisons with other resolution/paramodulation-based methods, in particular the methods proposed by Lankford (1975) and Peterson (1983), are included in the paper...|$|E
40|$|This letter {{addresses}} {{the problem of}} delay fault test generation in circuits using macros whose implementation is not known. The proposed approach uses a new signal representation {{that allows us to}} evaluate any kind of sensitization conditions (robust, non-robust, and functional) by means of <b>Boolean</b> differential <b>calculus.</b> Such an approach makes use of binary decision diagrams to support the computation of sensitization conditions for each macro along a path and of Boolean satisfiability to justify such conditions at primary inputs. Results are shown for a set of benchmarks...|$|R
40|$|Abstract—This paper aims at the classiffication of bent {{functions}} {{in order to}} allow their construction without searching or sieving. We focus on the characterization of bent {{functions in}} the context of Specialized Normal Forms. Furthermore we want to express bent functions in terms of derivative operations of the <b>Boolean</b> Differential <b>Calculus.</b> In order to solve these problems, we study bent functions of two and four variables in detail. This exploration leads finally to Boolean differential equations that will allow the direct calculation of bent functions. Keywords-bent function; classification; specialized normal form; Boolean Differential Calculus; Boolean differential equation; XBOOLE...|$|R
40|$|Abstract- In {{this paper}} an {{algorithm}} is proposed for mining multilevel association rules. A Boolean Matrix based approach has been employed to discover frequent itemsets, the item forming a rule come from different levels. It adopts <b>Boolean</b> relational <b>calculus</b> to discover maximum frequent itemsets at lower level. When using this algorithm first time, it scans the database once and will generate the association rules. Apriori property is used in prune the item sets. It {{is not necessary to}} scan the database again; it uses Boolean logical operation to generate the multilevel association rules and also use top-down progressive deepening method...|$|R
40|$|The <b>Boolean</b> Differential <b>Calculus</b> (BDC) {{is a very}} {{powerful}} theory that extends the structure of a Boolean Algebra significantly. Based on a small number of definitions, many theorems have been proven. The available operations have been efficiently implemented in several software packages. There is a very wide field of applications. While a Boolean Algebra is focused on values of logic functions, the BDC allows the evaluation of changes of function values. Such changes can be explored for pairs of function values as well as for whole subspaces. Due to the same basic data structures, the BDC ca...|$|R
40|$|Abstract- A system {{equation}} {{with certain}} properties describes implicitly function sets {{as the basis}} for an optimal design of a digital circuit. A necessary condition for the realization of a digital circuit is that the associated system equation is resolvable [2], [4]. This paper shows how the resolvability of the system equation can be checked and how the explicit description of the circuit functions can be calculated. Basic knowledge of the <b>Boolean</b> Differential <b>Calculus</b> is used to point out the theory of resolvability. This theory and its transformation into efficient algorithms are demonstrated by an example (the optimal design of a non-deterministic finite state machine) ...|$|R
40|$|Abstract. The skew <b>Boolean</b> propositional <b>calculus</b> (SBP C) is a {{generalization}} {{of the classical}} propositional calculus that arises naturally {{in the study of}} certain well-known deductive systems. In this article, we consider a candidate presentation of SBP C and prove it constitutes a Hilbert-style axiomatization. The problem reduces to establishing that the logic presented by the candidate axiomatization is algebraizable in the sense of Blok and Pigozzi. In turn, this is equivalent to verifying four particular formulas are derivable from the candidate presentation. Automated deduction methods {{played a central role in}} proving these four theorems. In particular, our approach relied heavily on the method of proof sketches. 1...|$|R
40|$|Linear {{representations}} for a subclass of boolean symmetric functions {{selected by}} a parity condition are shown {{to constitute a}} generalization of the linear constraints on probabilities introduced by Boole. These linear constraints are necessary to compute probabilities of events with relations between the. arbitrarily specified with propositional <b>calculus</b> <b>boolean</b> formulas. Comment: Appears in Proceedings of the Second Conference on Uncertainty in Artificial Intelligence (UAI 1986...|$|R
50|$|TK Solver {{includes}} roughly 150 built-in functions: mathematical, trigonometric, <b>Boolean,</b> numerical <b>calculus,</b> matrix operations, database access, {{and programming}} functions, including string handling and calls to externally compiled routines. Users may also define {{three types of}} functions: declarative rule functions; list functions, for table lookups and other operations involving pairs of lists; and procedure functions, for loops and other procedural operations which may also process or result in arrays (lists of lists). The complete NIST database of thermodynamic and transport properties is included, with built-in functions for accessing it. TK Solver is also the platform for engineering applications marketed by UTS, including Advanced Spring Design, Integrated Gear Software, Interactive Roark’s Formulas, Heat Transfer on TK, and Dynamics and Vibration Analysis.|$|R
40|$|AbstractStatic Single-Assignment (SSA) form is an {{efficient}} intermediate representation used in virtual machines and modern compilers. It provides data flow information that simplifies {{the implementation of}} standard program optimisations such as constant propagation, dead code elimination, and partial redundancy elimination. Constructing SSA form involves the computation of graph relations such as dominance, and non-iterated and iterated dominance frontier. Although there exist efficient graph algorithms for these relations, the algorithms are elaborate to implement. In this paper we introduce {{a new approach to}} compute the dominance relation, the dominance frontiers, and the iterated dominance frontiers based on <b>Boolean</b> matrix <b>calculus.</b> We implemented our approach in an optimising backend for LCC bytecode and compared its performance with the state-of-the-art approaches. We use the Spec 95 benchmark suite for our experimental evaluation...|$|R
40|$|Abstract- A gate level {{probabilistic}} {{error propagation}} model is presented which takes as input the Boolean {{function of the}} gate, the signal and error probabilities of the gate inputs, and the gate error probability and produces the error probability at {{the output of the}} gate. The presented model uses the <b>Boolean</b> difference <b>calculus</b> and {{can be applied to the}} problem of calculating the error probability at the primary outputs of a multi-level Boolean circuit with a time complexity which is linear in the number of gates in the circuit. This is done by starting from the primary inputs and moving toward the primary outputs by using a post-order traversal. Experimental results demonstrate the accuracy and efficiency of the proposed approach compared to the other known methods for error calculation in VLSI circuits. I...|$|R
40|$|Protective {{controllers}} {{prevent the}} occurrence of forbidden states in chemical processes. In this paper we present a new and systematic approach to design a protective controller {{with respect to the}} standardized concept in process industries `Safety of Process Plants Using Process Control Systems' [1]. The plant is modelled by means of finite automata. For an efficient solution of the controller synthesis task the system is described in the formalism of the <b>Boolean</b> Differential <b>Calculus.</b> An algorithm for the synthesis of the protective controller is proposed. As an example it is applied to a simple subsystem of a chemical process. 1 Introduction Protective controllers in chemical processes guarantee the safety of the plant and the product quality. Despite of their relevance to plant safety protective controllers are usually designed at a "round table", with a very weak methodical base concerning the theory of Discrete Event Systems (DES). In this paper a new approach for a methodical d [...] ...|$|R
40|$|Abstract—This paper explores {{derivative}} {{operations of}} the <b>Boolean</b> differential <b>calculus</b> for lattices of Boolean functions. Such operations are needed to design circuits with short delay and low power consumption [3] {{as well as to}} calculate minimal complete sets of fitting test patterns [4]. It will be shown that each derivative operation of a lattice of Boolean functions creates again a lattice of Boolean functions. The created lattice can be the same lattice as the given one, but in most cases the created lattice of Boolean functions is simpler than the given lattice. There is a direct mapping of an incompletely specified Boolean function to a lattice of Boolean functions. We will show that such lattices of Boolean functions are only a subclass of all lattices of Boolean functions. A unique general specification of a lattice of Boolean functions will be given. Index Terms—Boolean function; lattice; Boolean Differential Calculus; derivative operation; incompletely specified Boolea...|$|R
40|$|Abstract: This paper aims at the {{identification}} of classes of bent functions {{in order to allow}} their construction without searching or sieving. In order to reach this aim, we studied first the relationship between bent functions and complexity classes defined by the Specific Normal Forms of all Boolean functions. As result of this exploration we found classes of bent functions which are embedded in different complexity classes defined by the Specific Normal Form. In the second step to reach our global aim, we utilized the found classes of bent functions in order to express bent functions in terms of derivative operations of the <b>Boolean</b> Differential <b>Calculus.</b> In detail, we studied bent functions of two and four variables. This exploration leads finally to Boolean differential equations that will allow the direct calculation of all bent functions of two and four variables. A given generalization allows to calculate subsets of bent functions for each even number of Boolean variables...|$|R
50|$|The existential graphs are {{a curious}} {{offspring}} of Peirce the logician/mathematician with Peirce {{the founder of}} a major strand of semiotics. Peirce's graphical logic {{is but one of}} his many accomplishments in logic and mathematics. In a series of papers beginning in 1867, and culminating with his classic paper in the 1885 American Journal of Mathematics, Peirce developed much of the two-element <b>Boolean</b> algebra, propositional <b>calculus,</b> quantification and the predicate calculus, and some rudimentary set theory. Model theorists consider Peirce the first of their kind. He also extended De Morgan's relation algebra. He stopped short of metalogic (which eluded even Principia Mathematica).|$|R
40|$|Abstract—This paper explores lattices of Boolean {{functions}} {{which are}} built by derivative {{operations of the}} <b>Boolean</b> Differential <b>Calculus</b> [2], [8], [9]. Such operations are needed to design circuits with short delay and low power consumption [11] {{as well as to}} calculate minimal complete sets of fitting test patterns [12]. It will be shown that each derivative operation of a lattice of Boolean functions creates again a lattice of Boolean functions. The created lattice can be the same lattice as the given one, but in most cases the created lattice of Boolean functions is simpler than the given lattice. Both the condition for the first case and a procedure to calculate the simpler lattice in the second case will be given. There is a direct mapping of an incompletely specified Boolean function to a lattice of Boolean functions. It will be shown that such lattices of Boolean functions are only a subclass of all lattices of Boolean functions. A unique general specification of a lattice of Boolean functions will be given. Index Terms—Boolean function; lattice; Boolean Differential Calculus; derivative operation; incompletely specified Boolea...|$|R
40|$|We {{analyze the}} {{complexity}} of decision problems for <b>Boolean</b> Nonassociative Lambek <b>Calculus</b> admitting empty antecedent of sequents (BFNL^*), and the consequence relation of Distributive Full Nonassociative Lambek Calculus (DFNL). We construct a polynomial reduction from modal logic K into BFNL^*. As a consequence, we prove that the decision problem for BFNL^* is PSPACE-hard. We also prove that the same result holds for the consequence relation of DFNL, by reducing BFNL^* in polynomial time to DFNL enriched with finite set of assumptions. Finally, we prove analogous results for variants of BFNL^*, including BFNL^*e (BFNL^* with exchange), modal extensions of BFNL^*_i and BFNL^*_ei for i ∈{K, T, K 4, S 4, S 5 }. Comment: 12 page...|$|R
40|$|We study a {{subspace}} of the Fock space, called Boolean Fock space, and {{its associated}} non-commutative processes obtained by combinations of annihilators and creators. These processes include the Boolean Brownian and Poisson processes obtained by replacing the classical convolution by its Boolean counterpart, and a family of Bernoulli processes. Using a quantum stochastic calculus constructed by time changes, we complete the existing non-commutative relations between basic probability laws. In particular the uniform distribution has {{the role played by}} the exponential law in the classical setting of tensor independence. Key words: Quantum stochastic <b>calculus,</b> <b>Boolean</b> independence, uniform measure. Mathematics Subject Classication: 81 S 25, 46 L 50, 60 H 07, 60 E 05. ...|$|R
40|$|Abstract — The expressiveness of Boolean Algebras is {{significantly}} extended by the <b>Boolean</b> Differential <b>Calculus</b> (BDC). The additionally defined differentials of Boolean variables, differentials and further differential operators of Boolean functions {{as well as}} several derivative operations of Boolean functions allow to model changes of function values together with changes of the values of variables and many other properties of Boolean functions. A Boolean equation equals two given Boolean functions. Its solution is a set of Boolean vectors. We introduce in this paper Boolean Differential Equations (BDE). A BDE is an equation that includes derivative operations and differential operators of an unknown Boolean function. We show in this paper that, completely different from a Boolean equation, the solution of a Boolean differential equation is a set of Boolean functions. Hence, Boolean differential equations allow to describe and handle sets of Boolean functions. For an easier understanding we repeat the definition of the derivative operations and explain the essentials of Boolean differential equations using an example of the most restricted BDE. For a special class of Boolean differential equations we introduce the theoretical background for its solution and give a very simple solution algorithm. Furthermore we show how more general classes can be solved. I...|$|R
5000|$|Many {{aspects of}} inquiry can be {{recognized}} and usefully studied in very basic logical settings, even simpler than the level of syllogism, for example, {{in the realm of}} reasoning that is variously known as <b>Boolean</b> algebra, propositional <b>calculus,</b> sentential calculus, or zeroth-order logic. By way of approaching the learning curve on the gentlest availing slope, we may well begin at the level of zeroth-order inquiry, in effect, taking the syllogistic approach to inquiry only so far as the propositional or sentential aspects of the associated reasoning processes are concerned. One of the bonuses of doing this in the context of Peirce's logical work is that it provides us with doubly instructive exercises in the use of his logical graphs, taken at the level of his so-called [...] "alpha graphs".|$|R
40|$|A {{systematic}} {{procedure for}} transforming {{a set of}} logical statements or logical conditions imposed on a model into an Integer Linear Progamming (ILP) formulation Mixed Integer Programming (MIP) formulation is presented. An ILP stated as a system of linear constraints involving integer variables and an objective function, provides a powerful representation of decision problems through a tightly interrelated closed system of choices. It supports direct representation of logical (<b>Boolean</b> or prepositional <b>calculus)</b> expressions. Binary variables (hereafter called logical variables) are first introduced and methods of logically connecting these to other variables are then presented. Simple constraints can be combined to construct logical relationships and the methods of formulating these are discussed. A reformulation procedure which uses the extended reverse polish representation of a compound logical form is then described. These reformulation procedures are illustrated by two examples. A scheme of implementation. ithin an LP modelling system is outlined...|$|R
40|$|Most of the {{structures}} one deals with in Computer Science have a discrete and effective character: (finite) graphs, nets, trees in programming and formal languages, algorithms over finite strings or natural numbers, circuits etc [...] . By continuous structures we mean "smooth" spaces, usually of cardinality not less than continuum, where interesting topological or order properties give some information on, say, classes of functions over them. By discussing results from various areas of Mathematical Computer Science, we stress the role of continuous structures as tools for proving results about discrete or even finite structures. In particular we overview results concerning functionals in computability theory, trees in lambda <b>calculus,</b> <b>boolean</b> circuits in complexity theory and relate the finitary/combinatorial nature {{of the problems with}} their continuous solutions. We mostly focus on the methodology, and just hint to the technical aspects of the results presented. 2. 1 Introduction In order [...] ...|$|R
40|$|Signal is a {{synchronous}} language {{designed to}} program real-time systems. Because of its equational style, its compilation requires the statical resolution {{of a system}} of boolean equations; the variables being clocks. This report discusses the arborescent representation of Signal clocks. We introduce a bdd-based data structure called hierarchy. Through the factorization of boolean functions, we show that hierarchies are a canonical form of clocks. We also show that this canonical form optimizes the sequential code generated from a Signal program. We finally link hierarchies to the well known ordering problem of bdds. Key-words: Signal, bdd, clock <b>calculus,</b> <b>boolean</b> lattice (R'esum'e : tsvp) Centre National de la Recherche Scientifique Institut National de Recherche en Informatique (URA 227) Universit e de Rennes 1 [...] Insa de Rennes et en Automatique [...] unit e de recherche de Rennes Forme Canonique Arborescente des Expressions Bool'eennes R'esum'e : Signal est un langage synchrone [...] ...|$|R
40|$|Frequent pattern mining {{is one of}} {{the active}} {{research}} themes in data mining. It {{plays an important role in}} all data mining tasks such as clustering, classification, prediction, and association analysis. Identifying all frequent patterns is the most time consuming process due to a massive number of patterns generated. A reasonable solution is identifying efficient method to finding frequent patterns without candidate generation. In this paper, we present An Evolutionary algorithm for mining association rules using Boolean approach for mining association rules in large databases of sales transactions. Traditional association rule algorithms adopt an iterative method to discovery, which requires very large calculations and a complicated transaction process. Because of this, a new association rule algorithm is proposed in this paper. This new algorithm scanning the database once and avoiding generating candidate itemsets in computing frequent itemset and adopts a <b>Boolean</b> vector “relational <b>calculus</b> ” method to discovering frequent itemsets. Experimental results show that this algorithm can quickly discover frequent itemsets and effectively mine potential association rules...|$|R
40|$|We {{show that}} an LK proof of size m of a {{monotone}} sequent (a sequent that contains only formulas in the basis;) {{can be turned}} into a proof containing only monotone formulas of size m O(logm) and with the number of proof lines polynomial in m. Also we show that some interesting special cases, namely the functional and the onto versions of PHP and a version of the Matching Principle, have polynomial size monotone proofs. 1 Introduction The study of the propositional monotone sequent calculus was proposed in [Pud 98] in an attempt to find a proof complexity version of the monotone <b>Boolean</b> circuits. This <b>calculus</b> is simply the restriction of the full propositional sequent calculus to formulas in basis f; g. Further motivation for this calculus is given {{by the fact that it}} can be viewed as an extension of resolution and as a subsystem of the intuitionistic propositional calculus [Bil 00]. Classical results of Razborov [Razb 85] and others in computational complexity theory show that monot [...] ...|$|R
40|$|Abstract. Typed {{models of}} connector/component {{composition}} specify interfaces describing ports of components and connectors. Typing ensures that these ports are plugged together appropriately, so that data can flow {{out of each}} output port and into an input port. These interfaces typically consider the direction of data flow {{and the type of}} values flowing. Com-ponents, connectors, and systems are often parameterised {{in such a way that}} the parameters affect the interfaces. Typing such connector fami-lies is challenging. This paper takes a first step towards addressing this problem by presenting a calculus of connector families with integer and <b>boolean</b> parameters. The <b>calculus</b> is based on monoidal categories, with a dependent type system that describes the parameterised interfaces of these connectors. As an example, we demonstrate how to define n-ary Reo connectors in the calculus. The paper focusses on the structure of connectors—well-connectedness—and less on their behaviour, making it easily applicable to a wide range of coordination and component-based models. A type-checking algorithm based on constraints is used to anal-yse connector families, supported by a proof-of-concept implementation. ...|$|R
40|$|Delay {{fault testing}} and at-speed testing {{are widely used}} to verify the timing of {{synchronous}} digital IC’s. The importance of these techniques is still growing because of the relevant IC’s parameters uncertainties which characterize the current technologies. In order to drive this process, several fault models and test generation techniques have been developed that target different trade-offs between accuracy and efficiency. The largest fraction of these approaches is based upon gate level descriptions of the circuit. In case the basic building blocks are more complex than logic gates and their implementation is not known, functional level approaches have been proposed. For instance, {{this is the case}} for look-up tables based Field Programmable Gate Arrays (FPGAs) and it may be a perspective for deep submicron circuits that exploit logic bricks as basic building blocks. This class of circuits has been referred to as macro or module based. In this context, the main activities performed during the tree years of my PhD are related to the timing failures problems in module-based CMOS VLSI circuits. The attention to module-based (or block-based) circuits follows the current VLSI physical design trends that attempt to limit the parametric failures due to the scaling of technology toward nanometric feature sizes. In such technologies, in fact, the traditional design paradigms that are based on small (i. e gate level) cells may produce high levels of variability, thus resulting in parametric defects. The use of highly regular cell structures, called logic bricks has been proposed to solve these problems thus increasing the yield of VLSI circuits. A brick comprises a logic function created from a small set of logic primitives that are mapped on to a micro-regular fabric. Such logic function is typically more complex that those implemented in traditional VLSI libraries. Field Programmable Gate Array (FPGA) technology also exploits a module based design approach. Unlike logic bricks, FPGAs are completely programmable, because they are based on look up tables (a n-bit LUT can accomplish every n-bit function), but the drawback is related to the implementation of the LUT, that is unknown to designer and not optimized for regularity. In this scenario, the delay fault testing became a big issue, since {{it is very difficult to}} study a circuit built using modules whose implementation in not known, either for technological and for intellectual property reasons. Moreover, the aggressive timing policies used in today’s ICs make the need for delay fault testing more relevant. The main PhD activity, that will be explained in detail in this thesis, is related to a new method that we propose to generate test vectors for path delay faults in circuits based on modules. In particular, we consider the single path delay fault model in combinational circuits or in (enhanced) full-scan ones that are composed of functional blocks whose implementation is not known. In such circuits a path fault is detected by suitable conditions so that a test pair is able to propagate a transition through the path under test, in order to detect a path delay fault. In order to identify such conditions, we introduced a new signal representation that enables the use of <b>boolean</b> differential <b>calculus.</b> Also, additional conditions to prevent invalidation of tests by hazards have been identified. We suppose that the dynamic behavior of the block is modeled using input delays such as in the timing arc delay model. We target simple combinational blocks such as logic bricks, that are expected to present up to 8 - 10 inputs and a low logic depth. The used method is scalable, to generate conditions for path delay fault tests also at gate level. In order to assess the feasibility of the proposed approach, I realized a software, written in C/C++, that permits to find out robust and non-robust test pairs, starting from the BLIF description of a module based circuit. Such a software uses a BDD description of the blocks’ functions on which we apply Boolean Differences to obtain local sensitization conditions at module level. Since there are circuits whose BDD structure may be very large and it may be inefficient (in some cases also infeasible) to treat it, we translate functions obtained at macros level to a CNF description. After that, a SAT solver generates the test pairs at circuit level starting from the conjunction of all the CNF functions. The software tool was used to verify the proposed approach on a set of benchmarks (both combinational or full-scan) from ITC’ 99 and ISCAS’ 85 sets. Such benchmarks allowed to show the feasibility of the proposed approach, although they are not fully representative of the target circuits for which the method was developed. Another significant work, carried out during my PhD period, also deal with testing of macro-based circuits, but it concerns specifically logic bricks. In particular, a method for high quality functional fault simulation and test generation for such circuits was conceived and a software tool that implements it was developed. For both the approaches, results showed the feasibility of them, but also highlighted possibilities to improve and extend the work done...|$|R

