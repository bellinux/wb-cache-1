0|18|Public
5000|$|Graphical capabilities: 64-bit GUI acceleration, blitter, <b>bit</b> <b>blit</b> ...|$|R
50|$|The 1973 Xerox Alto, {{where the}} term <b>bit</b> <b>blit</b> originated, {{had a bit}} block {{transfer}} instruction implemented in microcode, making it much faster than the same operation written on the CPU. The microcode was implemented by Dan Ingalls.|$|R
50|$|<b>Bit</b> <b>blit</b> (also written BITBLT, BIT BLT, BitBLT, Bit BLT, Bit Blt etc., {{which stands}} for bit block transfer) is a data {{operation}} commonly used in computer graphics in which several bitmaps are combined into one using a boolean function.|$|R
50|$|The {{development}} of fast methods for various <b>bit</b> <b>blit</b> operations gave impetus {{to the evolution}} of computer displays from using character graphics to using bitmap graphics for everything. Machines that rely heavily on the performance of 2D graphics (such as video game consoles) often have special-purpose circuitry called a blitter.|$|R
5000|$|The blitter is a {{sub-component}} of Agnus. [...] "Blit" [...] is {{shorthand for}} [...] "block image transfer" [...] or <b>bit</b> <b>blit.</b> The blitter {{is a highly}} parallel memory transfer and logic operation unit. It has three modes of operation: copying blocks of memory, filling blocks (e.g. polygon filling) and line drawing.|$|R
5000|$|The Alto helped popularize {{the use of}} raster {{graphics}} model for all output, including text and graphics. It also introduced {{the concept of the}} bit block transfer operation (<b>bit</b> <b>blit,</b> BitBLT), as the fundamental programming interface to the display. Despite its small memory size, many innovative programs were written for the Alto, including: ...|$|R
50|$|A blitter is a circuit, {{sometimes}} as a coprocessor or a logic block on a microprocessor, {{dedicated to the}} rapid movement and modification of data within a computer's memory. A blitter can copy large quantities of data from one memory area to another relatively quickly, and in parallel with the CPU, while freeing up the CPU's more complex capabilities for other operations. A typical use for a blitter is the movement of a bitmap, such as windows and fonts in a graphical user interface or images and backgrounds in a 2D computer game. The name comes from the <b>bit</b> <b>blit</b> operation of the 1973 Xerox Alto, which stands for bit-block transfer. A blit operation {{is more than a}} memory copy, because it can involve data that's not byte aligned (hence the <b>bit</b> in <b>bit</b> <b>blit),</b> handling transparent pixels (pixels which should not overwrite the destination data), and various ways of combining the source and destination data.|$|R
50|$|MicroAngelo also {{supported}} a light pen, connected through input terminals {{on the top}} of the card. The Screenware software automatically converted the coordinates into the card's coordinates. Screenware also included routines for drawing movable cursors in hardware (as opposed to <b>bit</b> <b>bliting),</b> and the cursor could be made to follow the light pen simply by reading the pen coordinates and feeding them into the cursor.|$|R
5000|$|In 1984, Ingalls {{received}} the ACM Grace Murray Hopper Award for Outstanding Young Scientist, for his Xerox PARC research, including <b>bit</b> <b>blit.</b> [...] In 1987, with Alan Kay, and Adele Goldberg, he {{received the}} ACM Software System Award, {{for his work on}} Smalltalk, the first fully object-oriented software system.In 2002, he was co-recipient, with Adele Goldberg, of the Dr. Dobb's Excellence in Programming award.|$|R
50|$|One of {{the first}} systems with a {{compositing}} windowing system was the Commodore Amiga, released in 1985. Applications could first request a region of memory outside the current display region for use as bitmap. The Amiga windowing system would then use a series of <b>bit</b> <b>blits</b> using the system's hardware blitter to build a composite of these applications' bitmaps - along with buttons and sliders - in display memory, without requiring these applications to redraw any of their bitmaps.|$|R
5000|$|The folk {{etymology}} for the Blit name is that {{it stands}} for Bell Labs Intelligent Terminal, and its creators have also joked that it actually stood for Bacon, Lettuce, and Interactive Tomato. However, Rob Pike's paper on the Blit explains that it was named after the second syllable of <b>bit</b> <b>blit,</b> a common name for the bit-block transfer operation that is fundamental to the terminal's graphics. [...] Its original nickname was the jerq, inspired by Three Rivers' PERQ graphic workstation.|$|R
50|$|Daniel Henry Holmes Ingalls Jr. (born 1944) is {{a pioneer}} of {{object-oriented}} computer programming and the principal architect, designer and implementer of five generations of Smalltalk environments. He designed the bytecoded virtual machine that made Smalltalk practical in 1976. He also invented <b>bit</b> <b>blit,</b> the general-purpose graphical operation that underlies most bitmap graphics systems today, and pop-up menus. He designed the generalizations of BitBlt to arbitrary color depth, with built-in scaling, rotation, and anti-aliasing. His major contributions to the Squeak system include the original concept of a Smalltalk written in itself and made portable and efficient by a Smalltalk-to-C translator.|$|R
50|$|During the mid-1980s, Amiga OS {{contained}} an early {{example of a}} compositing window manager called Intuition (one of the low-level libraries of AmigaOS, which was present in Amiga system ROMs), capable of recognizing which windows or portions of them were covered, and which windows were in the foreground and fully visible, so it could draw only parts of the screen that required refresh. Additionally, Intuition supported compositing. Applications could first request a region of memory outside the current display region for use as bitmap. The Amiga windowing system would then use a series of <b>bit</b> <b>blits</b> using the system's hardware blitter to build a composite of these applications' bitmaps, along with buttons and sliders, in display memory, without requiring these applications to redraw any of their bitmaps.|$|R
50|$|While early accelerators {{focused on}} {{improving}} {{the performance of}} 2D GUI systems, most modern accelerators focus on producing 3D imagery in real time. A common design is to send commands to the graphics accelerator using a library such as OpenGL or Direct3D. The graphics driver then translates those commands to instructions for the accelerator's graphics processing unit (GPU). The GPU uses those microinstructions to compute the rasterized results. Those results are <b>bit</b> <b>blitted</b> to the framebuffer. The framebuffer's signal is then produced in combination with built-in video overlay devices (usually used to produce the mouse cursor without modifying the framebuffer's data) and any analog special effects that are produced by modifying the output signal. An example of such analog modification was the spatial anti-aliasing technique used by the 3dfx Voodoo cards. These cards add a slight blur to output signal that makes aliasing of the rasterized graphics much less obvious.|$|R
25|$|The 256-element free Boolean algebra {{on three}} {{generators}} is deployed in computer displays based on raster graphics, which use <b>bit</b> <b>blit</b> to manipulate whole regions consisting of pixels, relying on Boolean operations to specify how the source region should {{be combined with}} the destination, typically {{with the help of}} a third region called the mask. Modern video cards offer all 223=256 ternary operations for this purpose, with the choice of operation being a one-byte (8-bit) parameter. The constants SRC = 0xaa or 10101010, DST = 0xcc or 11001100, and MSK = 0xf0 or 11110000 allow Boolean operations such as (SRC^DST) (meaning XOR the source and destination and then AND the result with the mask) to be written directly as a constant denoting a byte calculated at compile time, 0x60 in the (SRC^DST) example, 0x66 if just SRC^DST, etc. At run time the video card interprets the byte as the raster operation indicated by the original expression in a uniform way that requires remarkably little hardware and which takes time completely independent of the complexity of the expression.|$|R
500|$|For example, the {{original}} window system, called 8Â½, exploited these possibilities as follows. Plan 9 represents the user interface on a terminal {{by means of}} three pseudo-files: , which can be read by a program to get notification of mouse movements and button clicks, , {{which can be used}} to perform textual input/output, and , writing to which enacts graphics operations (see <b>bit</b> <b>blit).</b> The window system multiplexes these devices: when creating a new window to run some program in, it first sets up a new namespace in which , [...] and [...] are connected to itself, hiding the actual device files to which it itself has access. The window system thus receives all input and output commands from the program and handles these appropriately, by sending output to the actual screen device and giving the currently focused program the keyboard and mouse input. The program does not need to know if it is communicating directly with the operating system's device drivers, or with the window system; it only has to assume that its namespace is set up so that these special files provide the kind of input and accept the kind of messages that it expects.|$|R

