334|402|Public
5|$|In {{computer}} science, Putnam {{is known}} for the Davis–Putnam algorithm for the Boolean satisfiability problem (SAT), developed with Martin Davis in 1960. The algorithm finds {{if there is a}} set of true or false values that satisfies a given <b>Boolean</b> <b>expression</b> so that the entire expression becomes true. In 1962, they further refined the algorithm with the help of George Logemann and Donald W. Loveland. It became known as the DPLL algorithm. This algorithm is efficient and still forms the basis of most complete SAT solvers.|$|E
25|$|An {{instance}} of the Boolean satisfiability problem is a <b>Boolean</b> <b>expression</b> that combines Boolean variables using Boolean operators.|$|E
25|$|The <b>Boolean</b> <b>expression</b> {{uses the}} {{variables}} {{set out in}} the following table. Here, q∈Q, −p(n)≤i≤p(n), j∈Σ, and 0≤k≤p(n).|$|E
40|$|<b>Boolean</b> <b>expressions</b> are {{extensively}} used {{in software}} specifications. It {{is important to}} generate a small-sized test set for <b>Boolean</b> <b>expressions</b> without sacrificing the fault-detection capability. MUMCUT is an efficient test case generation strategy for <b>Boolean</b> <b>expressions</b> in Irreducible Disjointed Normal Form (IDNF). In the real world, however, <b>Boolean</b> <b>expressions</b> written by a software designer or programmer are not normally in IDNF. In this paper, we apply MUMCUT to generate test cases for general <b>Boolean</b> <b>expressions</b> and develop a mutation-based empirical evaluation {{on the effectiveness of}} this application. The experimental data show that MUMCUT can still detect single seeded faults in up to 98. 20 % of general <b>Boolean</b> <b>expressions.</b> We also analyze patterns where test cases generated by MUMCUT cannot detect the seeded faults...|$|R
40|$|Regulatory network {{analysis}} and other bioinformatics tasks require {{the ability to}} induce and represent arbitrary <b>boolean</b> <b>expressions</b> from data sources. We introduce a novel framework, called BLOSOM, for mining (frequent) <b>boolean</b> <b>expressions</b> over binary-valued datasets. <b>Boolean</b> <b>expressions</b> can be grouped into four categories: pure conjunctions, pure disjunctions, conjunction of disjunctions, and disjunction of conjunctions. Our main focus on mining the simplest expressions (the minimal generators), but we also propose closure operators that yield closed (or unique maximal) <b>boolean</b> <b>expressions.</b> BLOSOM efficiently mines frequent <b>boolean</b> <b>expressions</b> by utilizing a number of methodical pruning techniques. Experiments showcase the behaviorofBLOSOMfordifferentinputsettingsandparameterthresholds. Applicationstudies on gene expression and gene regulation patterns showcase the effectiveness of our approach...|$|R
40|$|We {{introduce}} a novel framework, called BLOSOM, for mining (frequent) <b>boolean</b> <b>expressions</b> over binary-valued datasets. We organize {{the space of}} <b>boolean</b> <b>expressions</b> into four categories: pure conjunctions, pure disjunctions, conjunction of disjunctions, and disjunction of conjunctions. We focus on mining the simplest expressions (the minimal generators) for each class. We also propose a closure operator for each class that yields closed <b>boolean</b> <b>expressions.</b> BLOSOM efficiently mines frequent <b>boolean</b> <b>expressions</b> by utilizing a number of methodical pruning techniques. Experiments showcase the behavior of BLOSOM, and an application study on real datasets is also given. 1...|$|R
25|$|For each input, I, we {{specify a}} <b>Boolean</b> <b>expression</b> which is satisfiable if {{and only if}} the machine M accepts I.|$|E
25|$|Therefore, it is {{possible}} to evaluate the effect of single or multiple gene deletions by evaluation of the GPR as a <b>Boolean</b> <b>expression.</b> If the GPR evaluates to false, the reaction is constrained to zero in the model prior to performing FBA. Thus gene knockouts can be simulated using FBA.|$|E
25|$|In logic, a {{functionally}} {{complete set}} of logical connectives or Boolean operators is one {{which can be used}} to express all possible truth tables by combining members of the set into a <b>Boolean</b> <b>expression.</b> A well-known {{complete set of}} connectives is {AND,NOT}, consisting of binary conjunction and negation. Each of the singleton sets {NAND} and {NOR} is functionally complete.|$|E
40|$|We {{present a}} Unison {{algorithm}} to evaluate <b>Boolean</b> <b>expressions.</b> This novel algorithm, {{based on the}} total differential of a Boolean function, enables fast evaluation of <b>Boolean</b> <b>expressions</b> in software. Any combination of Boolean operations can be packed into the bits of one computer word and evaluated in parallel by bitwise logical operations. Sample runs of the Unison algorithm show that many Boolean operations can be evaluated in one clock cycle. The Unison algorithm is able to evaluate <b>Boolean</b> <b>expressions</b> at an execution speed that is comparable to compiled evaluation while retaining the flexibility of interpreted approaches. Keywords: Boolean differential, <b>Boolean</b> evaluation, <b>Boolean</b> <b>expressions,</b> Unison algorithm. 1 Introduction Efficient evaluation of <b>Boolean</b> <b>expressions</b> {{is an important part}} of many software systems. Some applications include: data base search [11], programming environments [6], modeling of digital circuits and software systems [2], debugging [9], event recording [...] ...|$|R
5000|$|<b>Boolean</b> <b>expressions</b> are {{represented}} very similarly to algebraic expressions, {{the only difference}} being the specific values and operators used. <b>Boolean</b> <b>expressions</b> use true and false as constant values, and the operators include [...] (AND), [...] (OR), [...] (NOT).|$|R
50|$|Provision for nested <b>Boolean</b> <b>expressions.</b>|$|R
25|$|The two-element Boolean algebra is {{also used}} for circuit design in {{electrical}} engineering; here 0 and 1 represent the two different states of one bit in a digital circuit, typically high and low voltage. Circuits are described by expressions containing variables, and two such expressions are equal for all values of the variables {{if and only if}} the corresponding circuits have the same input-output behavior. Furthermore, every possible input-output behavior can be modeled by a suitable <b>Boolean</b> <b>expression.</b>|$|E
25|$|The {{required}} Boolean {{results are}} transferred from a truth table onto a two-dimensional grid where, in Karnaugh maps, the cells are ordered in Gray code, and each cell position represents one combination of input conditions, while each cell value represents the corresponding output value. Optimal groups of 1s or 0s are identified, which represent {{the terms of}} a canonical form of the logic in the original truth table. These terms can be used to write a minimal <b>Boolean</b> <b>expression</b> representing the required logic.|$|E
500|$|Formulas in {{this form}} are known as 2-CNF formulas. The [...] "2" [...] in this name stands {{for the number of}} literals per clause, and [...] "CNF" [...] stands for conjunctive normal form, a type of <b>Boolean</b> <b>expression</b> {{in the form of a}} {{conjunction}} of disjunctions. They are also called Krom formulas, after the work of UC Davis mathematician Melven R. Krom, whose 1967 paper was one of the earliest works on the 2-satisfiability problem.|$|E
40|$|I {{present an}} {{interpretation}} of machine language programs as <b>boolean</b> <b>expressions.</b> Source language programs may also be so interpreted. The correctness of a code generator can then be expressed as a simple relationship between <b>boolean</b> <b>expressions.</b> Code generators can then be calculated from their specification...|$|R
40|$|<b>Boolean</b> <b>expressions</b> play a {{major role}} in {{computer}} science. They can be used to represent sets, formulas of propositional logic and digital circuits. In this paper we present an algorithm to compute the most general unifier (mgu) of <b>boolean</b> <b>expressions,</b> which is unique, if it exists. The fact that there is always at most one mgu, i. e. the theory of <b>boolean</b> <b>expressions</b> is unitary, is of particular importance for the embedding of the data type ‘boolean expression’ into logic programming. First experiemes with an integration into a PROLOG system are shown...|$|R
5000|$|... #Subtitle level 4: Treatment of non-boolean {{values in}} <b>boolean</b> <b>expressions</b> ...|$|R
500|$|A 2-satisfiability {{problem may}} be {{described}} using a <b>Boolean</b> <b>expression</b> with a special restricted form. It is a conjunction (a Boolean and operation) of clauses, where each clause is a disjunction (a Boolean or operation) of two variables or negated variables. The variables or their negations appearing in this formula are known as literals. For example, the following formula is in conjunctive normal form, with seven variables, eleven clauses, and 22 literals: ...|$|E
2500|$|In most dialects of Lisp {{including}} Common Lisp, by convention {{the value}} NIL evaluates {{to the value}} false in a <b>boolean</b> <b>expression.</b> In Scheme, since the IEEE standard in 1991, all values except #f, including NIL's equivalent in Scheme which is written as ' (...) , evaluate to the value true in a <b>boolean</b> <b>expression.</b> (R5RS sec. 6.3.1) ...|$|E
2500|$|<b>Boolean</b> <b>{{expression}},</b> {{an expression}} in {{a programming language}} that produces a Boolean value when evaluated ...|$|E
40|$|A {{great amount}} of fault-based testing {{strategies}} have been proposed to generate test cases for detecting certain types of faults in Boolean specifications. However, most of the previous studies on these strategies were focused on the <b>Boolean</b> <b>expressions</b> in the disjunctive normal form (DNF), even the irredundant DNF (IDNF) -little work has been conducted to comprehensively investigate their performance on general Boolean specifications. In this study, we {{conducted a series of}} experiments to evaluate and compare 18 fault-based testing strategies using over 4000 randomly generated fault-seeded <b>Boolean</b> <b>expressions.</b> In the experiments, a testing strategy is regarded as effective and efficient if it can detect most of the seeded faults using a small number of test cases. Our experimental results show that if a testing strategy is highly effective and efficient when testing the <b>Boolean</b> <b>expressions</b> in the IDNF, it also shows high effectiveness and efficiency on general <b>Boolean</b> <b>expressions.</b> It is found that one family of fault-based testing strategies, namely MUMCUT, normally deliver the best performance among all the 18 strategies. Our study provides an in-depth understanding and insight of fault-based testing for general <b>Boolean</b> <b>expressions...</b>|$|R
5000|$|... Input transducers, output transducers, logic gates, <b>boolean</b> <b>expressions,</b> truth {{tables and}} transistors.|$|R
40|$|BE-Tree {{is a novel}} dynamic tree data {{structure}} designed to efficientlyindexBooleanexpressionsoverahigh-dimensionaldiscrete space. BE-Tree copes with both high-dimensionality and expressiveness of <b>Boolean</b> <b>expressions</b> by introducing a novel two-phase space-cuttingtechnique thatspecificallyutilizesthediscreteandfinitedomainpropertiesofthespace. Furthermore, BE-Treeemploys self-adjustment policies to dynamically adapt the tree as the workload changes. We conduct a comprehensive evaluation to demonstratethesuperiorityof BE-Treeincomparisonwithstate-of-the-art index structures designed for matching <b>Boolean</b> <b>expressions...</b>|$|R
2500|$|Define the <b>Boolean</b> <b>expression</b> B {{to be the}} {{conjunction}} of the sub-expressions in the following table, for all −p(n)≤i≤p(n) and 0≤k≤p(n): ...|$|E
2500|$|When ST_Relate(a,b)='0FFFFF212', the {{returned}} DE-9IM code have the semantic of [...] "Intersects(a,b) & Crosses(a,b) & Within(a,b) & CoveredBy(a,b)", that is, returns true on the <b>boolean</b> <b>expression</b> ST_Intersects(a,b) AND ST_Crosses(a,b) AND ST_Within(a,b) AND [...] ST_Coveredby(a,b).|$|E
2500|$|An {{instance}} of the 2-satisfiability problem, that is, a <b>Boolean</b> <b>expression</b> in conjunctive normal form with two variables or negations of variables per clause, may be transformed into an implication graph by replacing each clause [...] by the two implications ...|$|E
40|$|<b>Boolean</b> <b>expressions</b> {{are widely}} used to model {{decisions}} or conditions of a specification or source program. The MUMCUT, {{which is designed to}} detect seven common faults where <b>Boolean</b> <b>expressions</b> under test are assumed to be in Irredundant Disjunctive Normal Form (IDNF), is an efficient fault-based test case selection strategy in terms of the fault-detection capacity and the size of selected test suite. Folio-wing up our previous work that reported the fault-detection capacity of the MUMCUT when it is applied to general form <b>Boolean</b> <b>expressions,</b> in this paper we present the characteristic of the types of single faults committed in general <b>Boolean</b> <b>expressions</b> that a MUMCUT test suite fails to detect, analyze the certainty why a MUMCUT test suite fails to detect these types of undetected faults, and provide some extensions to enhance the detection capacity of the MUMCUT for these types of undetected faults. Abstract not available...|$|R
5000|$|Pseudo-operators ANDTH and OREL, and ANF and ORF for Short-circuit {{evaluation}} of <b>Boolean</b> <b>expressions.</b>|$|R
5000|$|... CMOS and TTL IC comparison, logic gates, truth tables, <b>boolean</b> <b>expressions</b> and NAND equivalents.|$|R
2500|$|Given any {{decision}} problem in NP, construct a non-deterministic machine that solves it in polynomial time. Then for each input to that machine, build a <b>Boolean</b> <b>expression</b> {{which says that}} the input is passed to the machine, the machine runs correctly, and the machine halts and answers [...] "yes". Then the expression can be satisfied {{if and only if}} there is a way for the machine to run correctly and answer [...] "yes", so the satisfiability of the constructed expression is equivalent to asking whether or not the machine will answer [...] "yes".|$|E
50|$|A simple form of {{predicate}} is a <b>Boolean</b> <b>expression,</b> {{in which}} case the inputs to the expression are themselves Boolean values, combined using Boolean operations. Similarly, a <b>Boolean</b> <b>expression</b> with inputs predicates is itself a more complex predicate.|$|E
50|$|In {{computer}} science, a <b>Boolean</b> <b>expression</b> is {{an expression}} in a programming language that produces a Boolean value when evaluated, i.e. one of true or false. A <b>Boolean</b> <b>expression</b> may be composed {{of a combination of}} the Boolean constants true or false, Boolean-typed variables, Boolean-valued operators, and Boolean-valued functions.|$|E
50|$|For TRUE/1 and FALSE/0, the Fuzzy {{expressions}} {{produce the}} same result as the <b>Boolean</b> <b>expressions.</b>|$|R
50|$|<b>Boolean</b> <b>expressions</b> {{correspond}} to propositional formulas in logic {{and are a}} special case of Boolean circuits.|$|R
50|$|SETL {{provides}} quantified <b>boolean</b> <b>expressions</b> constructed {{using the}} universal and existential quantifiers of first-order predicate logic.|$|R
