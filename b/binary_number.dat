467|772|Public
5|$|Integer {{powers of}} 2 are {{important}} in computer science. The positive integer powers 2n give the number of possible values for an n-bit integer <b>binary</b> <b>number,</b> e.g. 28 = 256 different values for 1byte. For a given number the <b>binary</b> <b>number</b> system denotes {{on one side of}} the binary point all the positive integer powers of 2, that are contained in the integer part of this number, and the negative powers to the other side of the binary point represent the fractional part. This system is consistently used to represent numbers in computers for hardware reasons.|$|E
5|$|The {{name for}} this rule, Rule 184, is the Wolfram code {{describing}} the state table above: the bottom row of the table, 10111000, when viewed as a <b>binary</b> <b>number,</b> {{is equal to the}} decimal number 184.|$|E
5|$|One of the {{original}} slogans of the Whopper advertised by Burger King was There are 1024 ways to have a Whopper; the claim {{is based on an}} exponential function of whether the sandwich has the ingredient or not, represented by a <b>binary</b> <b>number</b> of 0 or 1, raised to the power of number of possible ingredients at the time, ten, thus 210 =1,024. This claim was later expanded to There are 221,184 possible ways for a customer to order a Whopper sandwich. Other slogans include It takes two hands to handle a Whopper and Burger King: Home of the Whopper.|$|E
5000|$|The MK-52 {{is fully}} capable of {{performing}} Boolean operations on <b>binary</b> <b>numbers.</b> The following example demonstrates the OR logical operation on the <b>binary</b> <b>numbers</b> [...] and : ...|$|R
40|$|In this paper, we {{consider}} procedures for logic and arithmetic operations with DNA molecules. We first show a DNA representation of n <b>binary</b> <b>numbers</b> of m bits, and propose a procedure to assign {{the same values}} for the representation. The representation enables addressing feature, and the procedure is applicable to n <b>binary</b> <b>numbers</b> of m bits in O(1) steps in parallel. Next, we propose a procedure for logic operations. The procedure enables any boolean operation whose input and output are defined by a truth table, and executes different kinds of boolean operations simultaneously for any pair of n <b>binary</b> <b>numbers</b> of m bits in O(1) lab steps using O(mn) DNA strands. Finally, we propose a procedure for additions of pairs of two <b>binary</b> <b>numbers.</b> The procedure executes O(n) additions of two m-bit <b>binary</b> <b>numbers</b> in O(1) steps using O(mn) DNA strands...|$|R
50|$|However, as {{the logical}} right-shift inserts value 0 bits {{into the most}} {{significant}} bit, instead of copying the sign bit, it is ideal for unsigned <b>binary</b> <b>numbers,</b> while the arithmetic right-shift is ideal for signed two's complement <b>binary</b> <b>numbers.</b>|$|R
25|$|SZTAKI Desktop Grid {{searches}} for generalized <b>binary</b> <b>number</b> systems up to dimension 11.|$|E
25|$|The {{result is}} a signed <b>binary</b> <b>number</b> {{representing}} the decimal value −5 in two's-complement form. The most significant bit is 1, so the value represented is negative.|$|E
25|$|In {{mathematics}} and digital electronics, a <b>binary</b> <b>number</b> {{is a number}} expressed in the base-2 numeral system or binary numeral system, which uses only two symbols: typically 0 (zero) and 1 (one).|$|E
50|$|For example, using Σ = { 0,1 }, {{the regular}} {{expression}} (0+1+ε)⋅(0+1) denotes {{the set of}} all <b>binary</b> <b>numbers</b> {{with one or two}} digits (leading zero allowed), while 1⋅(0+1)*⋅0 denotes the (infinite) set of all even <b>binary</b> <b>numbers</b> (no leading zeroes).|$|R
40|$|In this paper, we {{consider}} addressable procedures with DNA strands for logic and arithmetic operations. Using a theoretical model for DNA computing, we first show a DNA representation of ¨ <b>binary</b> <b>numbers</b> of © bits, and propose a procedure to assign {{values for the}} representation. The procedure is applicable to ¨ <b>binary</b> <b>numbers</b> of © bits in ������ � lab steps in parallel. Next, we propose a procedure for logic operations. The procedure enables any boolean operation whose input and output are defined by a truth table, and executes different kinds of boolean operations simultaneously for any pair of ¨ <b>binary</b> <b>numbers</b> of © bits in ������ � lab steps using ����©�¨� � DNA strands. Finally, we propose a procedure for additions of pairs of two <b>binary</b> <b>numbers.</b> The procedure works in ������ � lab steps using ����©�¨� � DNA strands for ����¨� � additions of two ©-bit <b>binary</b> <b>numbers.</b> Key words: DNA computing, logic and arithmetic operations...|$|R
50|$|The {{construction}} of the halved cube graph can be reformulated in terms of <b>binary</b> <b>numbers.</b> The vertices of a hypercube may be labeled by <b>binary</b> <b>numbers</b> {{in such a way}} that two vertices are adjacent exactly when they differ in a single bit.The demicube may be constructed from the hypercube as the convex hull of the subset of <b>binary</b> <b>numbers</b> with an even number of nonzero bits (the evil numbers), and its edges connect pairs of numbers whose Hamming distance is exactly two.|$|R
25|$|A two's-complement {{number system}} encodes {{positive}} and negative numbers in a <b>binary</b> <b>number</b> representation. The weight of each bit is a power of two, except for the most significant bit, whose weight is the negative of the corresponding power of two.|$|E
25|$|The modern <b>binary</b> <b>number</b> {{system was}} studied in Europe in the 16th and 17th centuries by Thomas Harriot, Juan Caramuel y Lobkowitz, and Gottfried Leibniz. However, systems related to binary numbers have {{appeared}} earlier in multiple cultures including ancient Egypt, China, and India. Leibniz was specifically {{inspired by the}} Chinese I Ching.|$|E
25|$|Many of {{the costumes}} seen in Episodes 1 to 4 {{can be seen}} again during {{sequences}} at Milliway's in Episode 5. In Episode 5 the writing at the start showing 42 crossed out several times also includes the number 101010 which is the 42nd number in the <b>binary</b> <b>number</b> base.|$|E
3000|$|... “Repairs” are {{automatically}} generated by naively testing random <b>binary</b> <b>numbers</b> for resistance {{against the current}} attack. If software is generated which resists the attack, then the node replaces its software with this new variant. Each attempted repair consists of testing ten randomly generated <b>binary</b> <b>numbers.</b>|$|R
40|$|Abstract: In this paper, {{we propose}} two {{procedures}} for multiplication and division using DNA strands. We first show a procedure for multiplication {{of a pair}} of two <b>binary</b> <b>numbers.</b> The procedure executes multiplication for two <b>binary</b> <b>numbers</b> of m bits in O(logm) steps using O(m 2) DNA strands. The procedure mainly consists of bit-shift and addition operations. We next show a procedure for division {{of a pair of}} two <b>binary</b> <b>numbers.</b> The procedure executes division for two <b>binary</b> <b>numbers</b> of m bits in O(logm) steps using O(m 2) DNA strands. The procedure first computes a reciprocal of a number using Newton’s method, and then, computes a quotient of the division using multiplication and subtraction. The procedure also computes a remainder of the division using multiplication and subtraction...|$|R
50|$|A similar {{conversion}} between run-length-encoded <b>binary</b> <b>numbers</b> {{and continued}} fractions {{can also be}} used to evaluate Minkowski's question mark function; however,in the Calkin-Wilf tree the <b>binary</b> <b>numbers</b> are integers (positions in the breadth-first traversal) while in the question mark function they are real numbers between 0 and 1.|$|R
25|$|The two's {{complement}} {{of the minimum}} number in the range {{will not have the}} desired effect of negating the number. For example, the two's {{complement of}} −128 in an 8-bit system results in the same <b>binary</b> <b>number.</b> This is because a positive value of 128 cannot be represented with an 8-bit signed binary numeral.|$|E
25|$|In a {{fractional}} <b>binary</b> <b>number</b> such as 0.110101101012, {{the first}} digit is , the second , etc. So {{if there is}} a 1 in the first place after the decimal, then the number is at least , and vice versa. Double that number is at least 1. This suggests the algorithm: Repeatedly double the number to be converted, record if the result is at least 1, and then throw away the integer part.|$|E
25|$|A {{random access}} list {{is a list}} with support for fast random access to read or modify any element in the list. One {{possible}} implementation is a skew binary random access list using the skew <b>binary</b> <b>number</b> system, which involves a list of trees with special properties; this allows worst-case constant time head/cons operations, and worst-case logarithmic time random access to an element by index. Random access lists can be implemented as persistent data structures.|$|E
5000|$|Change the <b>binary</b> <b>numbers</b> into bars. [...] "Zero" [...] bits in the {{resulting}} <b>binary</b> <b>numbers</b> correspond to {{spaces in the}} barcode, while [...] "one" [...] bits correspond to printed bars, with the least significant bit of each number corresponding to the rightmost bar in each subfield of the barcode.|$|R
5000|$|Double dabble, an {{algorithm}} for converting <b>binary</b> <b>numbers</b> to BCD ...|$|R
5000|$|... #Caption: Bijection between 3 bit <b>binary</b> <b>numbers</b> and {{compositions}} of 4 ...|$|R
25|$|Blaise Pascal (1623–1662) {{invented the}} {{mechanical}} calculator in 1642. The introduction of his Pascaline in 1645 launched {{the development of}} mechanical calculators first in Europe and then all over the world. Gottfried Leibniz (1646–1716), building on Pascal's work, {{became one of the}} most prolific inventors in the field of mechanical calculators; he was the first to describe a pinwheel calculator, in 1685, and invented the Leibniz wheel, used in the arithmometer, the first mass-produced mechanical calculator. He also refined the <b>binary</b> <b>number</b> system, foundation of virtually all modern computer architectures.|$|E
25|$|In {{the upper}} {{left-hand}} corner is {{a drawing of}} the phonograph record and the stylus carried with it. The stylus is in the correct position to play the record from the beginning. Written around it in binary arithmetic is the correct time of one rotation of the record, 3.6 seconds, expressed in time units of 0.70 billionths of a second, the time period associated with a fundamental transition of the hydrogen atom. The drawing indicates that the record should be played from the outside in. Below this drawing is a side view of the record and stylus, with a <b>binary</b> <b>number</b> giving the time to play {{one side of the}} record – about an hour.|$|E
25|$|The scribes {{of ancient}} Egypt used two {{different}} systems for their fractions, Egyptian fractions (not {{related to the}} <b>binary</b> <b>number</b> system) and Horus-Eye fractions (so called because many historians of mathematics believe that the symbols used for this system could be arranged to form the eye of Horus, although this has been disputed). Horus-Eye fractions are a binary numbering system for fractional quantities of grain, liquids, or other measures, in which {{a fraction of a}} hekat is expressed as a sum of the binary fractions 1/2, 1/4, 1/8, 1/16, 1/32, and 1/64. Early forms of this system can be found in documents from the Fifth Dynasty of Egypt, approximately 2400 BC, and its fully developed hieroglyphic form dates to the Nineteenth Dynasty of Egypt, approximately 1200 BC.|$|E
5000|$|... antidiagonals of the negated binary Walsh matrix read as <b>binary</b> <b>numbers</b> ...|$|R
40|$|We {{express the}} basis vectors of Cartan {{fundamental}} representations of unitary groups by <b>binary</b> <b>numbers.</b> We determine {{the expression of}} Gel'fand basis of SU (3) based on the usual subatomic quarks notations and we represent it by <b>binary</b> <b>numbers.</b> By analogy with the mesons and quarks we find a new property of prime numbers. 1...|$|R
2500|$|<b>Binary</b> <b>numbers</b> {{can also}} be multiplied with bits after a binary point: ...|$|R
25|$|For {{very large}} numbers, these simple methods are inefficient because they perform {{a large number}} of multiplications or {{divisions}} where one operand is very large. A simple divide-and-conquer algorithm is more effective asymptotically: given a <b>binary</b> <b>number,</b> it is divided by 10k, where k is chosen so that the quotient roughly equals the remainder; then each of these pieces is converted to decimal and the two are concatenated. Given a decimal number, it can be split into two pieces of about the same size, each of which is converted to binary, whereupon the first converted piece is multiplied by 10k and added to the second converted piece, where k is the number of decimal digits in the second, least-significant piece before conversion.|$|E
500|$|The name [...] of Rule 90 {{comes from}} Stephen Wolfram's binary-decimal {{notation}} for one-dimensional cellular automaton rules. To calculate the notation for the rule, concatenate the new {{states in the}} rule table into a single <b>binary</b> <b>number,</b> and convert the number into decimal: 010110102=9010. Rule 90 has also been called the Sierpiński automaton, due to the characteristic Sierpiński triangle shape it generates, and the Martin–Odlyzko–Wolfram cellular automaton after the early research of [...] on this automaton.|$|E
500|$|Negative zero {{is another}} {{redundant}} feature of {{many ways of}} writing numbers. In number systems, such as the real numbers, where [...] "0" [...] denotes the additive identity and is neither positive nor negative, the usual interpretation of [...] "−0" [...] is that it should denote the additive inverse of 0, which forces −0=0. Nonetheless, some scientific applications use separate positive and negative zeroes, as do some computing <b>binary</b> <b>number</b> systems (for example integers stored in the sign and magnitude or ones' complement formats, or floating point numbers as specified by the IEEE floating-point standard).|$|E
2500|$|To {{multiply}} {{a pair of}} <b>binary</b> <b>numbers,</b> first {{mark the}} two numbers ...|$|R
2500|$|For example, the <b>binary</b> <b>numbers</b> 1011 and 1010 are multiplied as follows: ...|$|R
5000|$|<b>Binary</b> <b>numbers</b> {{can also}} be multiplied with bits after a binary point: ...|$|R
