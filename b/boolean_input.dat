26|117|Public
50|$|PDP-14: A {{machine with}} 12-bit instructions, {{intended}} as an industrial controller (PLC). It has no data memory or data registers; instructions can test <b>Boolean</b> <b>input</b> signals, set or clear Boolean output signals, jump conditional or unconditionally, or call a subroutine. Later versions (for example, the PDP-14/30) {{are based on}} PDP-8 physical packaging technology. I/O is line voltage.|$|E
5000|$|When {{using an}} integer {{representation}} of a truth table, the output value of the LUT {{can be obtained by}} calculating a bit index k based on the input values of the LUT, in which case the LUT's output value is the kth bit of the integer. For example, to evaluate the output value of a LUT given an array of n <b>boolean</b> <b>input</b> values, the bit index of the truth table's output value can be computed as follows: if the ith input is true, let , else let [...] Then the kth bit of the binary representation of the truth table is the LUT's output value, where [...]|$|E
5000|$|The MOSFETs are n-type {{enhancement}} mode transistors, {{arranged in a}} so-called [...] "pull-down network" [...] (PDN) between the logic gate output and negative supply voltage (typically the ground). A pull up (i.e. a [...] "load" [...] that {{can be thought of}} as a resistor, see below) is placed between the positive supply voltage and each logic gate output. Any logic gate, including the logical inverter, can then be implemented by designing a network of parallel and/or series circuits, such that if the desired output for a certain combination of <b>boolean</b> <b>input</b> values is zero (or false), the PDN will be active, meaning that at least one transistor is allowing a current path between the negative supply and the output. This causes a voltage drop over the load, and thus a low voltage at the output, representing the zero.|$|E
40|$|The {{purpose of}} this paper is to design a control law for {{continuous}} systems with <b>Boolean</b> <b>inputs</b> allowing the output to track a desired trajectory. Such systems are controlled by items of commutation. This type of systems, with <b>Boolean</b> <b>inputs,</b> has found increasing use in the electric industry. Power supplies include such systems and a power converter represents one of theses systems. For instance, in power electronics the control variable is the switching OFF and ON of components such as thyristors or transistors. In this paper, a method is proposed for the designing of a control law in state space for such systems. This approach is implemented in simulation for the control of an electronic circuit...|$|R
50|$|By {{using the}} method {{described}} in #SAT, we must face a problem that for any fi the degree of the resulting polynomial may double with each quantifier. In order to prevent this, we must introduce a new reduction operator R which will reduce the degrees of the polynomial without changing their behavior on <b>Boolean</b> <b>inputs.</b>|$|R
30|$|The four {{dimensions}} {{for which we}} were able to associate statistical results were further integrated into a criteria tree using the SMCE (Spatial Multi-Criteria Evaluation) module of the Ilwis software (ITC 2001), and weighted according to expert judgment and scenario testing. In the criteria tree, there were also spatial constrains (barren land and parks) as <b>Boolean</b> <b>inputs</b> (true/false), but these constrains were not considered during weighting.|$|R
30|$|The {{product of}} factors can be {{transformed}} using a transformation function f. For example, a sigmoid function for a <b>Boolean</b> <b>input</b> matrix, or a rounding function {{in the case of}} integer input matrix.|$|E
40|$|<b>Boolean</b> <b>input</b> {{systems are}} in common {{used in the}} {{electric}} industry. Power supplies include such systems and the power converter represents these. For instance, in power electronics, the control variable are the switching ON and OFF of components as thyristors or transistors. The {{purpose of this paper}} is to use neural network (NN) to control continuous systems with Boolean inputs. This method is based on classification of system variations associated with input configurations. The classical supervised backpropagation algorithm is used to train the networks. The training of the artificial neural network and the control of <b>Boolean</b> <b>input</b> systems are presented. The design procedure of control systems is implemented on a nonlinear system. We apply those results to control an electrical system composed of an induction machine and its power converter...|$|E
40|$|To date, {{research}} into the implementation of autonomous self-replicating systems has focused either on highly abstract logical models, or on physical systems that are deliberately engineered in some way {{so as to make}} the problem more tractable [1]. There are also several system-level proposals for physical self-replicating systems. A simulation environment is presented at a level of abstraction that supports motion, connection and disconnection of parts, and which enforces the conservation of matter. This level of abstraction lies somewhere between cellular automaton models and real physical systems. The simulation environment is a 3 D kinematic automaton in which cubic parts can be placed into a discrete space and connected together to make machines. The environment supports six part types: A wire part receives a <b>boolean</b> <b>input</b> value at its base and propagates this value to all five of its outputs after one time unit. A nor-gate part receives <b>boolean</b> <b>input</b> values from all five of its inputs, and propagates the logical NOR of these values to its output after one time unit. A slide part receives a <b>boolean</b> <b>input</b> value from its input. If this value is true, then one time unit later it will move any part directly opposite its input. A rotate part receives a <b>boolean</b> <b>input</b> value from its input. If this value is true then one time unit later it will rotate any part directly opposite its input. A connect part receives a <b>boolean</b> <b>input</b> value from its input. If this value is true then one time unit later it will connect together the part lying opposite its input to a neighbouring part. A disconnect part receives a <b>boolean</b> <b>input</b> value from its input. If this value is true then one time unit later it will disconnect the part lying opposite its input from a neighbouring part. The simulation environment has previously been described in [2]. A self-replicating programmable constructing machine (SRPC) with an architecture similar to that in [3] has been implemented in this environment. The machine can take a disorganised collection of parts as its input and construct machines from these parts according to a sequence of instructions. As a special case, it can be programmed to construct a replica of itself. The machine is made from 59, 504 parts, of which 49, 152 make up the machine's memory. By demonstrating that an SRPC can be implemented in this environment, it is shown that some of the results already obtained about SRPCs in cellular automaton environments can be extended into the domain of kinematic systems, and also that consideration of the kinematical concepts of motion and connectivity along with the conservation of matter does not introduce any barrier to the existence of such machines. References: [1] Freitas and Merkle (2004), Kinematic Self Replicating Machines, Landes Bioscience [2] Stevens (2009), Parts closure in a kinematic self-replicating programmable constructor, Artificial Life and Robotics 13 (2) 508 - 511 [3] von Neumann and Burks (1966), Theory of Self-Reproducing Automata, Univ. of Illinois Pres...|$|E
50|$|A Boolean {{function}} {{describes how}} {{to determine a}} Boolean value output based on some logical calculation from <b>Boolean</b> <b>inputs.</b> Such functions play a basic role in questions of complexity theory {{as well as the}} design of circuits and chips for digital computers. The properties of Boolean functions {{play a critical role in}} cryptography, particularly in the design of symmetric key algorithms (see substitution box).|$|R
40|$|We address {{verification}} of imprecise datapath circuits with sequential elements. Using Arithmetic Transform (AT) and its extensions, we verify the sequential datapath circuits with finite precision. An efficient {{formulation of the}} precision verification {{is presented as a}} polynomial maximization search over <b>Boolean</b> <b>inputs.</b> Using a branch-and-bound search for the precision error and the block-level composition of ATs, we verify the approximated, rounded and truncated pipelined datapaths. 1...|$|R
40|$|Search {{methods for}} rule {{extraction}} from neural networks work by finding those combinations of inputs {{that make the}} neuron active. By sorting the input weights to a neuron and ordering the weights suitably, {{it is possible to}} prune the search space. Based on this observation, we present an algorithm for rule extraction from feedforward neural networks with <b>boolean</b> <b>inputs</b> and analyze its properties. Â© Elsevie...|$|R
40|$|This paper {{presents}} {{some results}} on the learned synthesis of boolean functions using adaptive tree networks (ALNs) whose elements, after training and elimination of redundant elements, perform logical operations AND and OR. This is logically equivalent to a tree of NAND gates. To compute an output, a tree is applied to a <b>boolean</b> <b>input</b> vector, and its vector of complements...|$|E
40|$|A state-machine {{language}} supporting both integer and <b>Boolean</b> <b>input</b> {{and output}} signals permits unied description throughout the design process, permits rapid interactive debugging, generates e cient behavioral simulation code, and produces compact but non-compromised output for logic optimization. The compiler is built upon Ordered Ternary Decision Diagrams, which insures correct simulation {{behavior in the}} presence of &quot; input values. Mapping of integer tests into OTDDs, and the e ects of OTDD bit ordering on simulation code size and e ciency, are brie y discussed. ...|$|E
40|$|Abstract: In this paper, a {{strategy}} {{based on the}} Sliding Mode Control(SMC) is used to achieve the <b>Boolean</b> <b>input</b> for DC-DC buck converter. Three diÂ¤erent surfaces are proposed in order to design integer order and fractional order controller. Unlike conventional methods, sliding mode controllers designed through this methodology directly produce Boolean control actions, avoiding the usability of pulse-width modulation (PWM) generally used to control power converters. Simulations are carried out using Matlab/SIMULINK and the results show the e Â¢ ciency of the proposed method to control DC-DC buck converter...|$|E
50|$|The {{following}} is a simple pseudocode implementation of a single TLU which takes <b>boolean</b> <b>inputs</b> (true or false), and returns a single boolean output when activated. An object-oriented model is used. No method of training is defined, since several exist. If a purely functional model were used, the class TLU below would be replaced with a function TLU with input parameters threshold, weights, and inputs that returned a boolean value.|$|R
5000|$|Now we can {{see that}} the {{reduction}} operation R, doesnt change the degree of the polynomial. Also it is important to see that the Rx operation doesnt change the value of the function on <b>boolean</b> <b>inputs.</b> So f0 is still the truth value of Ï, but the Rx value produces a result that is linear in x. Also after any [...] we add [...] in Ïâ² {{in order to reduce the}} degree down to 1 after arithmetizing [...]|$|R
40|$|Abstract In {{this paper}} we {{consider}} discrete-time piecewise affine hybrid systems with <b>Boolean</b> <b>inputs,</b> outputs and states and {{we show that}} they can be represented in a canonical form where the logic variables influence the switching between different submodels but not the continuous-valued dynamics. We exploit this representation for studying Lagrange stability and developing performance analysis procedures based on linear matrix inequalities. Moreover, by using arguments from dissipativity theory for nonlinear systems, we generalize our approach to solve the H â analysis problem...|$|R
40|$|In an {{anonymous}} ring of n processors, all processors are totally indistinguishable except for their input values. These values {{are not necessarily}} distinct, i. e., they form a multiset, and this makes many problems particularly difficult. We consider the problem of distributively sorting such a multiset on the ring, and we give a complete characterization of {{the relationship with the}} problems of leader election for vertices and edges. For <b>Boolean</b> <b>input</b> values and prime n; we also establish a lower bound, and a reasonably close upper bound on the message complexity valid for sorting and leader election...|$|E
30|$|The {{next step}} from the ConSert {{perspective}} {{is to determine}} the demands (i.e., service-related demands as well as RtEs) that relate to the identified guarantees. This relation is modeled by means of a Boolean function, where the demands are input variables and the guarantee is the output variable. There is also a corresponding graphical specification technique based on directed acyclic graphs, where each function is represented by a tuple (D, R, BG, E, g): a set of <b>Boolean</b> <b>input</b> variables D representing service-related demands and RtEs R, a set of Boolean gates BG, a set of directed edges E connecting the elements, and a Boolean output variable g.|$|E
40|$|Circuits of {{threshold}} elements (<b>Boolean</b> <b>input,</b> Boolean output neurons) {{have been}} shown to be surprisingly powerful. Useful functions such as XOR, ADD and MULTIPLY can be implemented by such circuits more efficiently than by traditional AND/OR circuits. In view of that, we have designed and built a programmable threshold element. The weights are stored on polysilicon floating gates, providing long-term retention without refresh. The weight value is increased using tunneling and decreased via hot electron injection. A weight is stored on a single transistor allowing the development of dense arrays of threshold elements. A 16 -input programmable neuron was fabricated in the standard 2 pm double- poly, analog process available from MOSIS. A long term goal of this research is to incorporate programmable threshold elements, as building blocks in Field Programmable Gate Arrays. ...|$|E
40|$|This paper {{deals with}} the problem of real time {{simulation}} of processes with <b>boolean</b> <b>inputs</b> and outputs. A language for this purpose and the programs that processes it is presented. The language allows the description of processes with simultaneous evolutions as a timed petri net type of description is used. Random failures can also be Introduced in the behaviour of the model. The language allows the control of a semlgraphic CRT in order to facilitate the task of following the model behaviour...|$|R
50|$|Now {{imagine that}} the inputs are driven not by an m-bit address, but by m {{independent}} logic signals. Theoretically, there are 22m possible Boolean functions of these m <b>input</b> signals. By <b>Boolean</b> function {{in this context is}} meant a single function that maps each of the 2m possible combinations of the m <b>Boolean</b> <b>inputs</b> to a single Boolean output. There are 22m possible distinct ways to map each of 2m <b>inputs</b> to a <b>Boolean</b> value, which explains why there are 22m such Boolean functions of m inputs.|$|R
40|$|We {{investigate}} {{the distribution of}} performance of the Boolean functions of 3 <b>Boolean</b> <b>inputs</b> (particularly that of the parity functions), the always-on- 6 and even- 6 parity functions. We us enumeration, uniform Monte-Carlo random sampling and sampling random full trees. As expected XOR dramatically changes the fitness distributions. In all cases once some minimum size threshold has been exceeded, the distribution of performance is approximately independent of program length. However {{the distribution of the}} performance of full trees is different from that of asymmetric trees and varies with tree depth...|$|R
3000|$|This paper {{presents}} {{a new type}} of orbits, called Boolean Orbits, that permit one to deal effectively with strong symmetries as well as partial and total symmetries. Boolean orbits are computed with respect to the <b>Boolean</b> <b>input</b> vectors of a function rather than with respect to the variables. (Again, {{it is important to note}} that Boolean orbits are properties of permutation groups, not of Boolean functions.) Permutations of degree [...] n [...] can operate on n-element vectors by permuting the indices of the elements. For example, one can apply the permutation (1,Â  2,Â  3) to the vector [...] (v_ 1,v_ 2,v_ 3 [...]) [...] to obtain [...] (v_ 3,v_ 1,v_ 2 [...]) [...]. Applying this permutation to the specific vector (1,Â  1,Â  0) yields the vector (0,Â  1,Â  1). The concept of Boolean orbits is formalized in the following definition.|$|E
40|$|Abstract. Breast {{cancer relapse}} {{prediction}} {{is an important}} step in the complex decision-making process of deciding the type of treatment to be applied to patients after surgery. Some non-linear models, like neural networks, have been successfully applied to this task but they suffer from the problem of extracting the underlying rules, and knowing how the methods operate can help {{to a better understanding of}} the cancer relapse problem. A recently introduced constructive algorithm (DASG) that creates compact neural network architectures is applied to a dataset of early breast cancer patients with the aim of testing the predictive ability of the new method. The DASG method works with <b>Boolean</b> <b>input</b> data and for that reason a transformation procedure was applied to the original data. The degradation in the predictive performance due to the transformation of the data is also analyzed using the new method and other standard algorithms. ...|$|E
40|$|NOTE: Text or symbols not renderable {{in plain}} ASCII are {{indicated}} by [ [...] . ]. Abstract is included in. pdf document. Circuits of threshold elements (<b>Boolean</b> <b>input,</b> Boolean output neurons) {{have been shown}} to be surprisingly powerful. Useful functions such as XOR, ADD and MULTIPLY can be implemented by such circuits more efficiently than by traditional AND/OR cir- cuits. In view of that, we have designed and built a programmable threshold element. The weights are stored on polysilicon floating gates, providing long-term retention without refresh. The weight value is increased using tunneling and decreased via hot electron injection. A weight is stored on a single transistor allowing the development of dense arrays of threshold elements. A 16 -input programmable neuron was fabricated in the standard 2 [ [...] . ] double-poly, analog process available from MOSIS. A long term goal of this research is to incorporate programmable threshold elements, as building blocks in Field Programmable Gate Arrays...|$|E
40|$|AbstractThe {{computation}} {{of specific}} functions using the most general form of concurrent-read-concurrent-write parallel RAM is considered. It is shown {{that such a}} machine can compute any function of <b>Boolean</b> <b>inputs</b> in time log n â log log n + O(1) given a polynomial number of processors and memory cells and that this bound is tight for integer addition. Despite this evidence {{of the power of}} the model we show that a very simple function, namely parity, requires time Î© (log n) to compute given a polynomial bound on the number of processors, independent of the number of memory cells...|$|R
40|$|A {{predicate}} {{is called}} approximation resistant {{if it is}} NP-hard to approximate the corresponding constraint satisfaction problem significantly better than what is achieved by the naive algorithm that picks an assignment uniformly at random. In this paper we study predicates of <b>Boolean</b> <b>inputs</b> where {{the width of the}} predicate is allowed to grow. Samorodnitsky and Trevisan proved that, assuming the Unique Games Conjecture, there is a family of very sparse predicates that are approximation resistant. We prove that, under the same conjecture, any predicate implied by their predicate remains approximation resistant and that, with high probability, this condition applies to a randomly chosen predicate...|$|R
40|$|Abstract. Mimicking {{biological}} neurons {{by focusing}} on the excitatory/inhibitory decoding performed by the dendritic trees is a different and attractive alternative to the integrate-and-fire McCullogh-Pitts neuron stylisation. In such alternative analogy, neurons {{can be seen as a}} set of RAM nodes addressed by <b>Boolean</b> <b>inputs</b> and producing <b>Boolean</b> outputs. The shortening of the semantic gap between the synaptic-centric model introduced by the McCullogh-Pitts neuron and the dominating, binary digital, computational environment, is among the interesting benefits of the weightless neural approach. This paper presents an overview of the most representative paradigms of weightless neural systems and corresponding applications, at abstraction levels ranging from pattern recognition to artificial consciousness. ...|$|R
40|$|Abstract. The paper explores a {{utilization}} of Boolean factorization {{as a method}} for data preprocessing in classification of Boolean data. In previous papers, we demonstrated that data preprocessing consisting in replacing the original Boolean attributes by factors, i. e. new Boolean attributes that are obtained from the original ones by Boolean factorization, improves the quality of classification. The aim {{of this paper is}} to explore the question of how the various Boolean factorization methods that were proposed in the literature impact the quality of classification. In particular, we compare three factorization methods, present experimental results, and outline issues for future research. 1 Problem Setting In classification of Boolean data, the objects to classify are described by Boolean (binary, yes-no) attributes. As with the other classification problems, one may be interested in preprocessing of the input attributes to improve the quality of classification. With <b>Boolean</b> <b>input</b> attributes, we might want to limit ourselve...|$|E
40|$|Current logic {{synthesis}} {{techniques are}} ineffective for arithmetic circuits. They perform poorly for XOR-dominated circuits, {{and those with}} a high fan-in dependency between inputs and outputs. Multipliers are particularly challenging {{because of the high}} fanout that results from the partial product generator. Many optimizers, therefore employ libraries of hand-optimized arithmetic components, but cannot optimize across component boundaries. To remedy this situation, we introduce a new logic synthesis algorithm that analyzes the cofactors of the <b>Boolean</b> <b>input</b> expressions. To the best of our knowledge, this approach is the first general logic synthesis algorithm that can handle complex arithmetic circuits such as multipliers of non-trivial size without having any prior knowledge about the functionality of the circuit; it can also optimize larger composite arithmetic circuits that contain a variety of components. The approach reduces the delay of the composite circuits by 15 â 40 % compared to the use of locally optimized library components without cross-component optimization...|$|E
40|$|This {{paper is}} {{concerned}} with the problem of constructing a mapping from an arbitrary input space into a binary output space f 0; 1 g d, based on a given data set X partitioned into classes. The aim is to reduce the total amount of information, while keeping the most relevant of it for the partitioning. An additional constraint to our problem is that the mapping must have a simple interpretation. Thus, each of the d discriminants is related to one original attribute (e. g. linear combinations of original attributes are not admitted). Beyond data compression, the targeted application is a preprocessing for classication techniques that require <b>Boolean</b> <b>input</b> data. While other existing techniques for this problem are constructive (increasing d iteratively, such as decision trees), the method proposed here proceeds by starting with a very large dimension d, and by reducing it iteratively. Acknowledgements: The support of the Swiss National Science Foundation under grant 2000 - 053902 [...] . ...|$|E
40|$|The {{computation}} {{of specific}} functions using the most general form of concurrent-read-concurrent-write parallel RAM is considered. It is shown {{that such a}} machine can compute any function of <b>Boolean</b> <b>inputs</b> in time log n- log log n + 0 (1) given a polynomial number of processors and memory cells and that this bound is tight for integer addition. Despite this evidence {{of the power of}} the model we show that a very simple function, namely parity, requires time Q (Jiogn) to compute given a polynomial bound on the number of processors, independent of the number of memory cells. 13 â 1988 Academic Press, Inc 1...|$|R
40|$|AbstractLinear {{threshold}} functions (for {{real and}} <b>Boolean</b> <b>inputs)</b> have received much attention, {{for they are}} the component parts of many artificial neural networks. Linear threshold functions are exactly those functions such that {{the positive and negative}} examples are separated by a hyperplane. One extension of this notion is to allow separators to be surfaces whose equations are polynomials of at most a given degree (linear separation being the degree- 1 case). We investigate the representational and expressive power of polynomial separators. Restricting to the Boolean domain, by using an upper bound on the number of functions defined on 0, 1 n by polynomial separators having at most a given degree, we show, as conjectured by Wang and Williams (1991), that for almost every Boolean function, one needs a polynomial surface of degree at least ân 2 â in order to separate the negative examples from the positive examples. Further, we show that, for odd n, at most half of all Boolean functions are realizable by a separating surface of degree ân 2 â. We then compute the Vapnik-Chervonenkis dimension of the class of functions realized by polynomial separating surfaces of at most a given degree, both for the case of <b>Boolean</b> <b>inputs</b> and real inputs. In the case of linear separators, the VC dimensions coincide for these two cases, but for surfaces of higher degree, there is a strict divergence. We then use these results on the VC dimension to quantify the sample size required for valid generalization in Valiant's probably approximately correct framework (Valiant, 1984; Blumer et al., 1989) ...|$|R
40|$|Abstract â The {{problem of}} finding optimal {{querying}} policy, for expected query complexity of symmetric boolean threshold functions was solved in [1] {{in the context}} of collocated networks. In this paper, instead of considering the optimal policy to compute the functions, we define the problem of verification of the function value. We use this idea to provide a simpler proof of the optimal querying policy for threshold functions. The method is more generic and is extended to delta and some other symmetric functions. We also provide some partial results for interval functions and finally address a question posed in [1]. Recently we have extended these results to any symmetric function of <b>boolean</b> <b>inputs,</b> which we mention at the end. I...|$|R
