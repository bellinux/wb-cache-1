6|1074|Public
50|$|Although {{there is}} no universally {{agreed-upon}} guideline {{regarding the use of}} compound words in the English language, in recent decades written English has displayed a noticeable trend towards increased use of compounds. Recently, many words have been made by taking syllables of words and compounding them, such as pixel (picture element) and <b>bit</b> (<b>binary</b> <b>digit).</b> This is called a syllabic abbreviation.|$|E
5000|$|Flip-flops and latches {{are used}} as data storage elements. A {{flip-flop}} stores a single <b>bit</b> (<b>binary</b> <b>digit)</b> of data; one of its two states represents a [...] "one" [...] and the other represents a [...] "zero". Such data storage {{can be used for}} storage of state, and such a circuit is described as sequential logic. When used in a finite-state machine, the output and next state depend not only on its current input, but also on its current state (and hence, previous inputs). It can also be used for counting of pulses, and for synchronizing variably-timed input signals to some reference timing signal.|$|E
5000|$|The {{symbol rate}} {{is related to}} gross bit rate {{expressed}} in bit/s.The term baud has sometimes incorrectly been used to mean bit rate, since these rates are the same in old modems {{as well as in}} the simplest digital communication links using only one bit per symbol, such that binary digit [...] "0" [...] is represented by one symbol, and binary digit [...] "1" [...] by another symbol. In more advanced modems and data transmission techniques, a symbol may have more than two states, so it may represent more than one bit. A <b>bit</b> (<b>binary</b> <b>digit)</b> always represents one of two states.|$|E
2500|$|Any number can be {{represented}} by a sequence of <b>bits</b> (<b>binary</b> <b>digits),</b> which in turn may {{be represented}} by any mechanism capable of being in two mutually exclusive states. Any of the following rows of symbols can [...] be interpreted as the binary numeric value of 667: ...|$|R
5000|$|In {{electronic}} terms, using <b>bits</b> (<b>binary</b> <b>digits),</b> {{this means}} that {{even if we have}} n one-bit adders at our disposal, we still have to allow a time proportional to n to allow a possible carry to propagate {{from one end of the}} number to the other. Until we have done this, ...|$|R
5000|$|Very often, but not always, the UI {{coincides with}} the bit time, i.e. with the time {{interval}} taken to transmit one <b>bit</b> (<b>binary</b> information <b>digit).</b>|$|R
5000|$|A {{general purpose}} {{computer}} has four main components: the arithmetic logic unit (ALU), the control unit, the memory, and the input and output devices (collectively termed I/O). These parts are interconnected by buses, often made of groups of wires.Inside each of these parts are thousands to trillions of small electrical circuits which can be turned off or on {{by means of an}} electronic switch. Each circuit represents a <b>bit</b> (<b>binary</b> <b>digit)</b> of information so that when the circuit is on it represents a [...] "1", and when off it represents a [...] "0" [...] (in positive logic representation). The circuits are arranged in logic gates so that {{one or more of the}} circuits may control the state of one or more of the other circuits.|$|E
40|$|The {{generation}} of uniform pseudo-random numbers between 0 and 1 {{is important in}} many numerical simulations. The purpose of this report is to explore the best generator(s) of such random numbers in terms of statistical properties and speed. While attempting {{to find the best}} generator in general, the specific goal of this report is to find the best generator for Latin hypercube sampling [Iman and Shortencarier, 1984]. This report starts by giving some background on uniform random numbers and the three basic types of generators: linear congruential, lagged Fibonacci, and combined. Next, some general coding issues are covered. Then some random number generators, the MCNP linear congruential generator and some implementations of the addition lagged Fibonacci generators, are tested in several ways to assess the quality of the random numbers they generate. This is followed by timing results are given for several different generators. Finally, conclusions and recommendations are given. 1 Uniform Random Numbers and Random Bits For most applications, the type of random sequence desired is R n, a sequence of random real numbers uniformly distributed between 0 and 1. Due to the finite accuracy to which a computer can represent a real number, what is actually generated is a series of integers, X n, uniformly distributed between 0 and m, the modulus. The random numbers, R n, are then generated by the following formula: m is usually 2 N where N is often related to the number of binary bits in the integer variable type used to store X n. For some applications, not only is it important for the sequence R n to be random, but also for the sequences of each individual <b>bit</b> (<b>binary</b> <b>digit)</b> representing X n to be random. This {{is referred to as the}} bitwise behavior of the random number generator (RNG) ...|$|E
40|$|Understanding the {{magnetic}} behaviour of thin film elements is of major importance for {{the magnetic}} sensor and storage industries, but also for fundamental micromagnetics. To store digital information, each memory element must support two distinct remanent magnetisation configurations that can be switched between using an applied field. In magnetoresistive random access memory (MRAM), a low switching field and reproducible reversal behaviour are desirable properties. The low field keeps the power consumption to a minimum and the reproducility enables efficient writing and read back of data. However, simple geometric structures are able to support a variety of metastable remanent configurations which can be problematic for device applications. For example, with rectangular elements, the switching fields are history dependent, {{and there is the}} possibility of flux-closure formation on repeated switching. This means different field strengths may be required to reverse the magnetisation of the same <b>bit</b> (<b>binary</b> <b>digit)</b> during different field cycles, and the information stored in a cell could be accidentally lost. In addition, the miniaturisation of these elements faces the problem that the coercivity is inversely proportional to element width for a given thickness; a factor which limits their use in high density arrays. The optimum geometry for supporting the stored information is therefore an important issue. In this thesis, different element shapes designed to tackle these problems have been investigated using transmission electron microscopy (TEM) backed by micromagnetic simulations. It has been found that variations in element geometry and symmetry can lead to a greater control of the states that can be formed. Alongside this work on patterned elements, continuous film multilayer samples in the form of magnetic tunnel junctions (MTJs) have also been studied. These multilayer structures serve as storage cells in MRAM devices so their successful operation is of the utmost importance to the development of this technology. At the most basic level, MTJs comprise two ferromagnetic layers separated by a layer of electrical insulator. Whilst one magnetic layer is fixed (pinned layer), the other is free to switch direction when an external field is applied (free layer). Ideally the free layer hysteresis loop would be centred at zero field, but because of magnetostatic interactions caused by layer roughness, the ferromagnets couple to one another and the hysteresis loop is offset. This shift means that the fields required to switch the cell in opposite directions are different. In collaboration with Philips Research in Eindhoven, the magnetic and physical structure of new MTJ stacks incorporating an artifical antiferromagnet (AAF) in the free layer were studied using TEM. An AAF consists of two ferromagnetic layers coupled anti-parallel through a thin layer of non-magnetic metal, typically Ru. These samples were found to reduce the offset field by up to 36 % when compared to the basic MTJ stack. Whilst this research is valuable to the magnetic storage industry, the information it provides on these complicated magnetic systems is equally beneficial for solid state physics. EThOS - Electronic Theses Online ServiceGBUnited Kingdo...|$|E
5000|$|The {{main purpose}} and {{fundamental}} emphasis {{is to maintain}} the United States leading place in high-performance or high-speed computing. The NREN {{is intended to be}} a gigabit network that is able to move one billion <b>bits</b> (<b>binary</b> <b>digits)</b> of data per second, or the equivalent of 30,000 pages of text. The intention was to connect a moderate number of diverse and geographically dispersed computers with the intention of acquiring experience in techniques for offering remote login access from one computer to another through a series of intermediate computers. The initial practical application, even though not originally planned, was the electronic mail.|$|R
5000|$|Sequences {{where each}} weight {{is not an}} {{integral}} multiple of the previous weight may also be used, but then every integer {{may not have a}} unique representation. For example, Fibonacci coding uses the digits 0 and 1, weighted according to the Fibonacci sequence (1, 2, 3, 5, 8, ...); a unique representation of all non-negative integers may be ensured by forbidding consecutive 1s. Binary-coded decimal (BCD) are mixed base systems where <b>bits</b> (<b>binary</b> <b>digits)</b> are used to express decimal digits. E.g., in 1001 0011, each group of four bits may represent a decimal digit (in this example 9 and 3, so the eight bits combined represent decimal 93). The weights associated with these 8 positions are 80, 40, 20, 10, 8, 4, 2 and 1. Uniqueness is ensured by requiring that, in each group of four bits, if the first bit is 1, the next two must be 00.|$|R
50|$|A <b>bit</b> is a <b>binary</b> <b>digit</b> that {{represents}} one of two states. The concept of a bit {{can be understood as}} a value of either 1 or 0, on or off, yes or no, true or false, or encoded by a switch or toggle of some kind.|$|R
50|$|In binary (base-2), a full space {{can be used}} {{between groups}} of four digits, {{corresponding}} to a nibble, or equivalently to a hexadecimal digit. For integer numbers, dots are used as well to separate groups of four <b>bits.</b> Alternatively, <b>binary</b> <b>digits</b> may be grouped by threes, corresponding to an octal digit. Similarly, in hexadecimal (base-16), full spaces are usually used to group digits into twos, making each group correspond to a byte. Additionally, groups of eight bytes are often separated by a hyphen.|$|R
25|$|Whereas in {{elementary}} algebra expressions denote mainly numbers, in Boolean algebra they denote the truth values false and true. These values are represented with the <b>bits</b> (or <b>binary</b> <b>digits),</b> namely 0 and 1. They do not behave like the integers 0 and 1, for which 1 + 1 = 2, {{but may be}} identified with {{the elements of the}} two-element field GF(2), that is, integer arithmetic modulo 2, for which 1 + 1 = 0. Addition and multiplication then play the Boolean roles of XOR (exclusive-or) and AND (conjunction) respectively, with disjunction x∨y (inclusive-or) definable as x + y + xy.|$|R
50|$|A modern digital {{computer}} represents data using the binary numeral system. Text, numbers, pictures, audio, and nearly {{any other form}} of information can be converted into a string of <b>bits,</b> or <b>binary</b> <b>digits,</b> each of which has a value of 1 or 0. The most common unit of storage is the byte, equal to 8 bits. A piece of information can be handled by any computer or device whose storage space is large enough to accommodate the binary representation of the piece of information, or simply data. For example, the complete works of Shakespeare, about 1250 pages in print, can be stored in about five megabytes (40 million bits) with one byte per character.|$|R
40|$|The thesis goal is {{to develop}} a {{computer}} system for hand printed digit recognition based on an investigation into various feature extractors and neural network strategies. Features such as subwindow pixel summation, moments, and orientation vectors will be among those investigated. Morphological thinning of characters prior to feature extraction will be used to assess the impact on network training and testing. Different strategies for implementing a multilayer perceptron neural network will be investigated. A high-level language called MatLab will be used for neural network algorithm development and quick prototyping. The feature extractors will be developed to operate on small (less than or equal to 256 <b>bits)</b> <b>binary</b> hand printed <b>digits</b> (0, 1, 2, 3, 4, 5, 6, 7, 8, 9) ...|$|R
25|$|In computers, {{the main}} numeral systems {{are based on}} the {{positional}} system in base2 (binary numeral system), with two <b>binary</b> <b>digits,</b> 0 and 1. Positional systems obtained by grouping <b>binary</b> <b>digits</b> by three (octal numeral system) or four (hexadecimal numeral system) are commonly used. For very large integers, bases232 or 264 (grouping <b>binary</b> <b>digits</b> by 32 or 64, the length of the machine word) are used, as, for example, in GMP.|$|R
50|$|In 1998 Simon Plouffe gave a ruler and compass {{algorithm}} {{that can}} be used to compute <b>binary</b> <b>digits</b> of certain numbers.The algorithm involves the repeated doubling of an angle and becomes physically impractical after about 20 <b>binary</b> <b>digits.</b>|$|R
50|$|The {{symbol for}} <b>binary</b> <b>digit</b> is either simply bit (recommended by the IEC 80000-13:2008 standard) or {{lowercase}} b (recommended by the IEEE 1541-2002 standard). A {{group of eight}} <b>binary</b> <b>digits</b> is commonly called one byte, but historically {{the size of the}} byte is not strictly defined.|$|R
5000|$|The bit (a {{portmanteau}} of <b>binary</b> <b>digit)</b> is a {{basic unit}} of information used in computing and digital communications. A <b>binary</b> <b>digit</b> can have only one of two values, and may be physically represented with a two-state device. These state values are most commonly represented as either a [...]|$|R
50|$|The octal and {{hexadecimal}} {{systems are}} often used in computing because of their ease as shorthand for <b>binary.</b> Every hexadecimal <b>digit</b> corresponds to a sequence of four <b>binary</b> <b>digits,</b> since sixteen is the fourth power of two; for example, hexadecimal 7816 is binary 2. A similar relationship holds between every octal digit and every possible sequence of three <b>binary</b> <b>digits,</b> since eight is the cube of two.|$|R
5000|$|Equivalently, {{expressed}} as strings of <b>binary</b> <b>digits,</b> the codewords are: ...|$|R
5000|$|... so the 8th to 11th <b>binary</b> <b>digits</b> in the <b>binary</b> {{expansion}} of ln(2) are 1, 0, 1, 1. Note {{that we have}} not calculated the values of the first seven <b>binary</b> <b>digits</b> - indeed, all information about them has been intentionally discarded by using modular arithmetic in the [...] "head" [...] sum.|$|R
50|$|Append the {{remaining}} N <b>binary</b> <b>digits</b> to this representation of N+1.|$|R
5000|$|The Ehrenfeucht-Mycielski {{sequence}}, {{a sequence}} of <b>binary</b> <b>digits</b> with pseudorandom properties ...|$|R
5000|$|... 18 <b>binary</b> <b>digits</b> have [...] (1000000 octal, 40000 hexadecimal) {{distinct}} combinations.|$|R
40|$|Abstraction is a {{powerful}} thing. During the 19 th century, the industrial revolution was built on many powerful abstractions, such as mass, energy, work, and power. During the 20 th century, the information revolution was built on many powerful abstractions, such as <b>binary</b> <b>digit</b> or <b>bit,</b> <b>binary</b> coding, and algorithmic complexity. Here, we propose an abstraction that {{will be important to}} the service revolution of the 21 st century: the service system, which is a configuration of people, technologies, and other resources that interact with other service systems to create mutual value. Many systems can be viewed as service systems, including families, cities, and companies, among many others. In this paper, we show how the service-system abstraction can be used to understand how value is created, in the process unifying concepts from many disciplines and creating the foundation for an integrated science of service...|$|R
5000|$|Append the {{remaining}} N <b>binary</b> <b>digits</b> of x to this representation of N.|$|R
40|$|AbstractA {{new family}} of {{increasing}} sequences of positive integers is proposed. The integers n {{for which the}} sum of <b>binary</b> <b>digits</b> {{is equal to the}} sum of <b>binary</b> <b>digits</b> of n 2 are an example of sequence of this family and this sequence is more accurately studied. Some structure and asymptotic properties are proved and a conjecture about its counting function is discussed...|$|R
50|$|The {{message is}} written with only four basic symbols {{representing}} the <b>binary</b> <b>digits</b> one and zero and {{open and close}} brackets. Numbers are represented as a string of <b>binary</b> <b>digits</b> between a pair of brackets and expressions are represented as a string of numbers between brackets. Identifiers for operations are arbitrarily-assigned numbers and their functions can be defined within the message itself.|$|R
2500|$|... 1995– Simon Plouffe discovers Bailey–Borwein–Plouffe formula {{capable of}} finding the nth <b>binary</b> <b>digit</b> of π.|$|R
5000|$|... {{which is}} maximum at [...] when , thus {{providing}} a minimum precision of [...] <b>binary</b> <b>digits.</b>|$|R
5000|$|<b>Binary</b> <b>digits</b> of pi from forty {{trillion}} minus {{three to}} forty trillion sixty-four (February 9, 1999): ...|$|R
5000|$|<b>Binary</b> <b>digits</b> of pi {{from one}} {{quadrillion}} minus {{three to one}} quadrillion sixty (September 11, 2000): ...|$|R
40|$|A {{new family}} of {{sequences}} is proposed. An example of sequence {{of this family}} is more accurately studied. This sequence is composed by the integers $n$ for which the sum of <b>binary</b> <b>digits</b> {{is equal to the}} sum of <b>binary</b> <b>digits</b> of $n^ 2 $. Some structure and asymptotic properties are proved and a conjecture about its counting function is discussed. Comment: 10 page...|$|R
50|$|Separate X {{into the}} highest power of 2 it {{contains}} (2N) {{and the remaining}} N <b>binary</b> <b>digits.</b>|$|R
