168|379|Public
25|$|In some {{programming}} languages, given a two-argument function f (or a <b>binary</b> <b>operator),</b> {{the outer}} product of f and two one-dimensional arrays A and B is a two-dimensional array C such that C = f(A,B). This is syntactically represented in various ways: in APL, as the infix <b>binary</b> <b>operator</b> °.f; in R, as the function outer(A, B, f); in Mathematica, as Outer. In MATLAB, the function kron(A,B) {{is used for}} this product. These often generalize to multi-dimensional arguments, and more than two arguments.|$|E
25|$|In the 20th century, {{following}} {{the development of}} formal logic, the ampersand became a commonly used logical notation for the <b>binary</b> <b>operator</b> or sentential connective AND. This usage was adopted in computing.|$|E
25|$|In the C and C++ {{programming}} languages, the comma operator (represented by the token ,) is a <b>binary</b> <b>operator</b> that evaluates {{its first}} operand and discards the result, and then evaluates the second operand and returns this value (and type).|$|E
5000|$|... #Subtitle level 3: Condensed truth {{tables for}} <b>binary</b> <b>operators</b> ...|$|R
40|$|AbstractThis paper proposes rule formats for Structural Operational Semantics guaranteeing {{that certain}} <b>binary</b> <b>operators</b> are left {{distributive}} {{with respect to}} a set of <b>binary</b> <b>operators.</b> Examples of left-distributivity laws from the literature are shown to be instances of the provided formats. Some conditions ensuring the invalidity of the left-distributivity law are also offered...|$|R
5000|$|A {{concrete}} function may be {{also referred}} to as an operator. In two-valued logic there are 2 nullary operators (constants), 4 unary <b>operators,</b> 16 <b>binary</b> <b>operators,</b> 256 ternary operators, and [...] n-ary operators. In three-valued logic there are 3 nullary operators (constants), 27 unary <b>operators,</b> 19683 <b>binary</b> <b>operators,</b> 7625597484987 ternary operators, and [...] n-ary operators. In k-valued logic, there are k nullary operators, [...] unary <b>operators,</b> [...] <b>binary</b> <b>operators,</b> [...] ternary operators, and [...] n-ary operators. An n-ary operator in k-valued logic is a function from [...] Therefore, the number of such operators is , which is how the above numbers were derived.|$|R
25|$|To {{alleviate}} this, we {{can define}} operations for chaining these computations together. The bind <b>binary</b> <b>operator</b> (>>=) chains {{the results of}} one computation that could fail, into a function that chooses another computation that could fail. If the first argument is Nothing, the second argument (the function) is ignored and the entire operation simply fails. If the first argument is Just x, we pass x to the function {{to get a new}} Maybe value, {{which may or may not}} result in a Just value.|$|E
25|$|Identity elements: The numbers {{zero and}} one are {{abstracted}} {{to give the}} notion of an identity element for an operation. Zero is the identity element for addition and one is the identity element for multiplication. For a general <b>binary</b> <b>operator</b> ∗ the identity element e must satisfy a ∗ e = a and e ∗ a = a, and is necessarily unique, if it exists. This holds for addition as a + 0 = a and 0 + a = a and multiplication a × 1 = a and 1 × a = a. Not all sets and operator combinations have an identity element; for example, the set of positive natural numbers (1, 2, 3,...) has no identity element for addition.|$|E
2500|$|... op + = (vector a,b) vector: [...] # <b>binary</b> <b>operator</b> {{definition}} [...] # ...|$|E
40|$|Abstract. This paper proposes rule formats for Structural Operational Semantics guaranteeing {{that certain}} <b>binary</b> <b>operators</b> are left {{distributive}} {{with respect to}} a set of <b>binary</b> <b>operators.</b> Examples of left-distributivity laws from the literature are shown to be instances of the provided for-mats. Some conditions ensuring the impossibility of the validity of the left-distributivity law are also offered. ...|$|R
50|$|Additional <b>binary</b> <b>operators</b> {{are also}} {{relevant}} to temporal logics, q.v. Linear Temporal Logic.|$|R
5000|$|... the {{algorithm}} must {{be modified to}} accept only <b>binary</b> <b>operators</b> whose precedence is > min_precedence.|$|R
2500|$|Assignment {{operators}} ( [...] etc.) are {{combinations of}} a <b>binary</b> <b>operator</b> and the assignment operator (...) {{and will be}} evaluated using the ordinary operators, which can be overloaded.|$|E
2500|$|C'n is {{the number}} of {{different}} ways n+1 factors can be completely parenthesized (or the number of ways of associating n applications of a <b>binary</b> <b>operator).</b> For n = 3, for example, we have the following five different parenthesizations of four factors: ...|$|E
2500|$|Successive {{applications}} of a <b>binary</b> <b>operator</b> {{can be represented}} {{in terms of a}} full binary tree. (A rooted binary tree is full if every vertex has either two children or no children.) It follows that C'n is the number of full binary trees with n+1 leaves: ...|$|E
40|$|The {{absorption}} {{identities in}} algebra give {{a relationship between}} two associative and commutative <b>binary</b> <b>operators</b> join and meet. We generalize these operators into {{a new class of}} <b>binary</b> <b>operators</b> and study their structures in the context of absorption equation and show that the study of absorption equation involving triangular norms, triangular conorms, uninorms and nullnorms in the literature are special cases of our stud...|$|R
5000|$|Given a set [...] and two <b>binary</b> <b>operators</b> ∗ and + on , we {{say that}} the operation: ...|$|R
5000|$|Algebraic {{expression}} trees represent expressions {{that contain}} numbers, variables, and unary and <b>binary</b> <b>operators.</b> Some {{of the common}} operators are × (multiplication), ÷ (division), + (addition), − (subtraction), ^ (exponentiation), and - (negation). The operators are contained in the internal nodes of the tree, with the numbers and variables in the leaf nodes. The nodes of <b>binary</b> <b>operators</b> have two child nodes, and the unary operators have one child node.|$|R
2500|$|The {{fundamental}} noncommutative <b>binary</b> <b>operator</b> in {{the phase}} space formulation that replaces the standard operator multiplication {{is the star}} product, represented by the symbol ★. [...] Each representation of the phase-space distribution has a different characteristic star product. [...] For concreteness, we restrict this discussion to the star product relevant to the Wigner-Weyl representation.|$|E
2500|$|An {{additive}} monad is a monad {{endowed with}} a monadic zero mzero and a <b>binary</b> <b>operator</b> mplus satisfying the monoid laws, with the monadic zero as unit. The operator mplus has type M t → M t → M t (where M is the monad constructor and {{t is the}} underlying data type), satisfies the associative law and has the zero as both left and right identity. That is: ...|$|E
2500|$|For example, the {{following}} code defines a <b>binary</b> <b>operator</b> [...] as safe division that avoids dividing by zero, using the Maybe monad and its constructors [...] and [...] The monadic values x and y {{may have the}} form Nothing or Just i, where i is an integer. The integer values contained within x and y are extracted into the plain values a and b, which are processed by the plain division operator [...] "" [...] only when b is not zero.|$|E
5000|$|Unary {{operators}} are well-formed formulas whenever B (...) is well-formed. <b>Binary</b> <b>operators</b> are well-formed formulas whenever B (...) and C (...) are well-formed.|$|R
5000|$|Functions {{which are}} defined as taking several {{parameters}} can always be partially applied. <b>Binary</b> <b>operators</b> can be partially applied using section notation: ...|$|R
5000|$|Formulas as {{they are}} {{commonly}} written use infix notation for <b>binary</b> <b>operators,</b> such as addition, multiplication, division and subtraction. This notation also uses: ...|$|R
5000|$|Likewise, reduce is a {{function}} that collapses a list into a single value by repeated application of a <b>binary</b> <b>operator.</b> It is written / in BMF.Taking [...] as a suitable <b>binary</b> <b>operator</b> with neutral element e, we have ...|$|E
5000|$|... netCDF <b>Binary</b> <b>Operator</b> (includes ncadd, ncsubtract, ncmultiply, ncdivide) ...|$|E
5000|$|Elvis operator, , or {{sometimes}} , as a shorthand <b>binary</b> <b>operator</b> ...|$|E
50|$|Most of {{what follows}} is about <b>binary</b> <b>{{operator}}s.</b> An example of a unary operator whose standard notation is reverse Polish notation is the factorial.|$|R
40|$|We extend Knuth’s 16 Boolean <b>binary</b> logic <b>{{operators}}</b> to {{fuzzy logic}} and neutro-sophic logic <b>binary</b> <b>operators.</b> Then we generalize them to n–ary fuzzy logic and neutrosophic logic operators using the smarandache codification of the Venn diagram and a defined vector neutrosophic law. In such way, new operators in neutrosophic logic/set/probability are built...|$|R
5000|$|Nial {{like other}} APL derived {{languages}} allow {{the unification of}} <b>binary</b> <b>operators</b> and operations. Thus the below notations have the same meaning.Note: [...] is same as ...|$|R
5000|$|DEFINE <b>BINARY</b> <b>OPERATOR</b> defined-op, PRECEDENCE rank existing-op MODE STRUCTURE mode-options ...|$|E
5000|$|A <b>binary</b> <b>operator</b> {{is one of}} the following, having {{semantics}} {{similar to}} their C counterparts: ...|$|E
5000|$|The Fantom {{programming}} language has the [...] <b>binary</b> <b>operator</b> that compares its first operand with [...]|$|E
5000|$|Assume that ⅋ is {{any of the}} <b>binary</b> <b>operators</b> times, plus, with or par (but not linear implication). The {{following}} is not in general an equivalence, only an implication: ...|$|R
5000|$|The {{modification}} {{operators are}} {{a subset of the}} <b>binary</b> <b>operators</b> such that for all v, [...] is a bijective function, and hence invertible, where [...] is a modification operator: ...|$|R
5000|$|... "Not" [...] is a unary operator, {{it takes}} a single term (¬P). The rest are <b>binary</b> <b>operators,</b> taking two terms to make a {{compound}} statement (P &and; Q, P &or; Q, P → Q, P ↔ Q).|$|R
