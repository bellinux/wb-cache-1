1067|0|Public
5|$|Another {{method of}} {{constructing}} hash functions with both high quality and practical speed is tabulation hashing. In this method, the hash value for a key {{is computed by}} using each byte of the key as an index into a table of random numbers (with a different table for each byte position). The numbers from those table cells are then combined by a <b>bitwise</b> exclusive or operation. Hash functions constructed this way are only 3-independent. Nevertheless, linear probing using these hash functions takes constant expected time per operation. Both tabulation hashing and standard methods for generating 5-independent hash functions are limited to keys that have a fixed number of bits. To handle strings or other types of variable-length keys, {{it is possible to}} compose a simpler universal hashing technique that maps the keys to intermediate values and a higher quality (5-independent or tabulation) hash function that maps the intermediate values to hash table indices.|$|E
5|$|Integer sorting {{algorithms}} {{are usually}} {{designed to work}} in either the pointer machine or random access machine models of computing. The main {{difference between these two}} models is in how memory may be addressed. The random access machine allows any value that is stored in a register to be used as the address of memory read and write operations, with unit cost per operation. This ability allows certain complex operations on data to be implemented quickly using table lookups. In contrast, in the pointer machine model, read and write operations use addresses stored in pointers, and it is not allowed to perform arithmetic operations on these pointers. In both models, data values may be added, and <b>bitwise</b> Boolean operations and binary shift operations may typically also be performed on them, in unit time per operation. Different integer sorting algorithms make different assumptions, however, about whether integer multiplication is also allowed as a unit-time operation. Other more specialized models of computation such as the parallel random access machine have also been considered.|$|E
25|$|The Department of Computer Science and Engineering organises <b>Bitwise</b> IIT Kharagpur, {{an online}} {{programming}} contest annually in February. Programming and algorithmic challenges {{are given in}} a span of 12 hours. In <b>Bitwise</b> 2011, 5000 teams participated from 80 countries. <b>Bitwise</b> 2012 was held on 12 February 2012.|$|E
25|$|The {{result of}} the <b>bitwise</b> AND {{operation}} of IP address and the subnet mask is the network prefix 192.168.5.0. The host part, which is 130, is derived by the <b>bitwise</b> AND operation of the address and the one's complement of the subnet mask.|$|E
25|$|Other <b>bitwise</b> {{operations}} {{are similar to}} arithmetic operations.|$|E
25|$|Some PIDs {{are to be}} {{interpreted}} specially, and aren't necessarily exactly <b>bitwise</b> encoded, or in any scale.|$|E
25|$|However, {{the values}} from this table may be {{combined}} by a more complicated function than <b>bitwise</b> exclusive or.|$|E
25|$|In MySQL the '&' has dual roles. As well as {{a logical}} AND, it {{additionally}} serves as the <b>bitwise</b> operator of an intersection between elements.|$|E
25|$|Martin Richards {{published}} {{a program to}} count solutions to the n-queens problem using <b>bitwise</b> operations.. However, this solution has already been published by Zongyan Qiu.|$|E
25|$|Some keys, such as {{floating}} point numbers, {{can lead to}} long chains and prefixes that are not particularly meaningful. Nevertheless, a <b>bitwise</b> trie can handle standard IEEE single and double format {{floating point}} numbers.|$|E
25|$|The logical {{instructions}} {{consist of}} those for performing <b>bitwise</b> logical operations and conditional moves on the integer registers. The <b>bitwise</b> logical instructions perform AND, NAND, NOR, OR, XNOR, and XOR between two registers or a register and literal. The conditional move instructions test a register as a signed quadword to zero and move if the specified condition is true. The specified conditions are equality, inequality, {{less than or}} equal to, less than, greater than or equal to, and greater than. The shift instructions perform arithmetic right shift, and logical left and right shifts. The shift amount is given by a register or literal. Logical and shift instructions use the integer operate instruction formats.|$|E
25|$|Programs {{that need}} to use processor-specific {{instructions}} not implemented in a compiler. A common example is the <b>bitwise</b> rotation instruction {{at the core of}} many encryption algorithms, as well as querying the parity of a byte or the 4-bit carry of an addition.|$|E
25|$|As JavaScript has unusual {{limitations}} – such as no explicit integer type, only double-precision binary {{floating point}} – languages that compile to JavaScript {{and do not}} take care to use the integer-converting shift and <b>bitwise</b> logical operators may have slightly different behavior than in other environments.|$|E
25|$|In {{computer}} science, modular arithmetic {{is often}} applied in <b>bitwise</b> operations and other operations involving fixed-width, cyclic data structures. The modulo operation, as implemented in many programming languages and calculators, is {{an application of}} modular arithmetic that is often used in this context. XOR {{is the sum of}} 2 bits, modulo 2.|$|E
25|$|MIPS I has {{instructions}} to perform <b>bitwise</b> logical AND, OR, XOR, and NOR. These instructions source their operands from two GPRs {{and write the}} result to a third GPR. The AND, OR, and XOR instructions can alternatively source one of the operands from a 16-bit immediate (which is zero-extended to 32 bits).|$|E
25|$|For IPv4, {{a network}} {{may also be}} {{characterized}} by its subnet mask, which is the bitmask that when applied by a <b>bitwise</b> AND operation to any IP address in the network, yields the routing prefix. Subnet masks are also expressed in dot-decimal notation like an address. For example, 255.255.255.0 is the network mask for the 192.168.1.0/24 prefix.|$|E
25|$|Though tries {{are usually}} keyed by {{character}} strings, {{they need not}} be. The same algorithms {{can be adapted to}} serve similar functions of ordered lists of any construct, e.g. permutations on a list of digits or shapes. In particular, a <b>bitwise</b> trie is keyed on the individual bits making up any fixed-length binary datum, such as an integer or memory address.|$|E
25|$|From {{this bit}} vector viewpoint, a {{concrete}} Boolean algebra {{can be defined}} equivalently as a nonempty set of bit vectors all of the same length (more generally, indexed by the same set) and closed under the bit vector operations of <b>bitwise</b> ∧, ∨, and ¬, as in 1010∧0110 = 0010, 1010∨0110 = 1110, and ¬1010 = 0101, the bit vector realizations of intersection, union, and complement respectively.|$|E
25|$|The {{key idea}} of {{tabulation}} hashing is {{to view a}} key as a vector of t r-bit numbers, use a lookup table filled with random values to compute a hash value {{for each of the}} r-bit numbers representing a given key, and combine these values with the <b>bitwise</b> binary exclusive or operation. The choice of r should be made {{in such a way that}} this table is not too large; e.g., so that it fits into the computer's cache memory.|$|E
25|$|A {{minimum weight}} {{basis of a}} graphic matroid is a minimum {{spanning}} tree (or minimum spanning forest, if the underlying graph is disconnected). Algorithms for computing minimum spanning trees have been intensively studied; it is known how {{to solve the problem}} in linear randomized expected time in a comparison model of computation, or in linear time in a model of computation in which the edge weights are small integers and <b>bitwise</b> operations are allowed on their binary representations. The fastest known time bound that has been proven for a deterministic algorithm is slightly superlinear.|$|E
25|$|A {{number is}} a square if every number in its {{exponent}} vector is even. For example, the vectors (3,0,0,1) and (1,2,0,1) add to (4,2,0,2), so (56)(126) is a square. Searching for a square requires knowledge {{only of the}} parity of the numbers in the vectors, so {{it is possible to}} reduce the entire vector mod 2 and perform addition of elements mod 2: (1,0,0,1) + (1,0,0,1) = (0,0,0,0). This is particularly efficient in practical implementations, as the vectors can be represented as bitsets and addition mod 2 reduces to <b>bitwise</b> XOR.|$|E
25|$|Many stream ciphers {{are based}} on linear-feedback shift {{registers}} (LFSRs), which, while efficient in hardware, are less so in software. The design of RC4 avoids the use of LFSRs and is ideal for software implementation, as it requires only byte manipulations. It uses 256 bytes of memory for the state array, S through S, k bytes of memory for the key, key through key, and integer variables, i, j, and K. Performing a modular reduction of some value modulo 256 {{can be done with}} a <b>bitwise</b> AND with 255 (which is equivalent to taking the low-order byte of the value in question).|$|E
25|$|Although it is {{possible}} to partially circumvent this problem with conversion code and using larger data types, it makes using Java cumbersome for handling the unsigned data. While a 32-bit signed integer may be used to hold a 16-bit unsigned value with relative ease, a 32-bit unsigned value would require a 64-bit signed integer. Additionally, a 64-bit unsigned value cannot be stored using any integer type in Java because no type larger than 64 bits exists in the Java language. If abstracted using functions, function calls become necessary for many operations which are native to some other languages. Alternatively, it {{is possible}} to use Java's signed integers to emulate unsigned integers of the same size, but this requires detailed knowledge of complex <b>bitwise</b> operations.|$|E
25|$|Although {{this process}} might sound slow, {{it is very}} cache-local and highly {{parallelizable}} {{due to the lack}} of register dependencies and therefore in fact has excellent performance on modern out-of-order execution CPUs. A red-black tree for example performs much better on paper, but is highly cache-unfriendly and causes multiple pipeline and TLB stalls on modern CPUs which makes that algorithm bound by memory latency rather than CPU speed. In comparison, a <b>bitwise</b> trie rarely accesses memory, and when it does, it does so only to read, thus avoiding SMP cache coherency overhead. Hence, it is increasingly becoming the algorithm of choice for code that performs many rapid insertions and deletions, such as memory allocators (e.g., recent versions of the famous Doug Lea's allocator (dlmalloc) and its descendents).|$|E
25|$|The first {{instance}} of tabulation hashing is Zobrist hashing, {{a method for}} hashing positions in abstract board games such as chess named after Albert Lindsey Zobrist, who published it in 1970. In this method, a random bitstring is generated for each game feature such as {{a combination of a}} chess piece and a square of the chessboard. Then, to hash any game position, the bitstrings for the features of that position are combined by a <b>bitwise</b> exclusive or. The resulting hash value can then be used as an index into a transposition table. Because each move typically changes {{only a small number of}} game features, the Zobrist value of the position after a move can be updated quickly from the value of the position before the move, without needing to loop over all of the features of the position.|$|E
25|$|In a {{complete}} binary tree, a node's breadth-index (i − (2d − 1)) {{can be used}} as traversal instructions from the root. Reading <b>bitwise</b> from left to right, starting at bit d − 1, where d is the node's distance from the root (d = ⌊log2(i+1)⌋) and the node in question is not the root itself (d > 0). When the breadth-index is masked at bit d − 1, the bit values 0 and 1 mean to step either left or right, respectively. The process continues by successively checking the next bit to the right until there are no more. The rightmost bit indicates the final traversal from the desired node's parent to the node itself. There is a time-space trade-off between iterating {{a complete}} binary tree this way versus each node having pointer/s to its sibling/s.|$|E
500|$|After the sync field, all packets {{are made}} of 8-bit bytes, {{transmitted}} least-significant bit first. The first byte is a packet identifier (PID) byte. The PID is actually 4bits; the byte consists of the 4-bit PID followed by its <b>bitwise</b> complement. This redundancy helps detect errors. (Note also that a PID byte contains at most four consecutive 1bits, and thus never needs bit-stuffing, even when combined with the final 1bit in the sync byte. However, trailing 1bits in the PID may require bit-stuffing within the first few bits of the payload.) ...|$|E
500|$|Python has {{the usual}} C {{arithmetic}} operators (+, -, *, /, %). It also has ** for exponentiation, e.g. 5**3 == 125 and 9**0.5 == 3.0, {{and a new}} matrix multiply @ operator is included in version 3.5. Additionally, it has a unary operator (~), which essentially inverts all the bytes of its one argument. For integers, this means ~x=-x-1. Other operators include <b>bitwise</b> shift operators x << y, which shifts x to the left y places, the same as x*(2**y) , and x >> y, which shifts x to the right y places, the same as x/(2**y) [...]|$|E
500|$|In practice, {{computational}} addition may {{be achieved}} via XOR and AND <b>bitwise</b> logical operations {{in conjunction with}} bitshift operations {{as shown in the}} pseudocode below. Both XOR and AND gates are straightforward to realize in digital logic allowing the realization of full adder circuits which in turn may be combined into more complex logical operations. In modern digital computers, integer addition is typically the fastest arithmetic instruction, yet it has the largest impact on performance, since it underlies all floating-point operations as well as such basic tasks as address generation during memory access and fetching instructions during branching. To increase speed, modern designs calculate digits in parallel; these schemes go by such names as carry select, carry lookahead, and the Ling pseudocarry. Many implementations are, in fact, hybrids of these last three designs. Unlike addition on paper, addition on a computer often changes the addends. On the ancient abacus and adding board, both addends are destroyed, leaving only the sum. The influence of the abacus on mathematical thinking was strong enough that early Latin texts often claimed that in the process of adding [...] "a number to a number", both numbers vanish. In modern times, the ADD instruction of a microprocessor often replaces the augend with the sum but preserves the addend. In a high-level programming language, evaluating [...] does not change either a or b; if the goal is to replace a with the sum this must be explicitly requested, typically with the statement [...] Some languages such as C or C++ allow this to be abbreviated as [...]|$|E
2500|$|Encode {{the secret}} as an {{arbitrary}} length binary number s. Give to each player i (except one) a random number pi {{with the same}} length as s. Give to the last player the result of (s XOR p1 XOR p2 XOR ... XOR p'n−1) where XOR is <b>bitwise</b> exclusive or. The secret is the <b>bitwise</b> XOR of all the players' numbers (p).|$|E
2500|$|EAX = ~ECX [...] // perform <b>bitwise</b> NOT on ECX {{and store}} the result in EAX ...|$|E
2500|$|DL & $08 [...] // perform <b>bitwise</b> AND on DL with 0x08 {{and store}} the result in DL ...|$|E
2500|$|The {{following}} Python code shows {{a simple}} function which will convert an unsigned input integer to a two's complement signed integer using the above logic with <b>bitwise</b> operators: ...|$|E
2500|$|<b>Bitwise</b> tries {{are much}} the same as a normal character-based trie except that {{individual}} bits are used to traverse what effectively becomes a form of binary tree. Generally, implementations use a special CPU instruction to very quickly find the first set bit in a fixed length key (e.g., GCC's __builtin_clz (...) intrinsic). This value is then used to index a 32- or 64-entry table which points to the first item in the <b>bitwise</b> trie with that number of leading zero bits. The search then proceeds by testing each subsequent bit in the key and choosing child or child appropriately until the item is found.|$|E
2500|$|There are six {{available}} comparison operators: < > = <= >= !=. These operators {{can be used}} in both comparisons and loops. Note that there's also a <b>bitwise</b> AND operator which tests bits: ...|$|E
2500|$|To get the two's {{complement}} of a binary number, the bits are inverted, or [...] "flipped", {{by using the}} <b>bitwise</b> NOT operation; the value of 1 is then added to the resulting value, ignoring the overflow which occurs when taking the two's {{complement of}} 0.|$|E
