197|20|Public
25|$|<b>Bubble</b> <b>sort</b> has {{worst-case}} {{and average}} complexity both О(n2), where n {{is the number}} of items being sorted. There exist many sorting algorithms, such as merge sort with substantially better worst-case or average complexity of O(nlogn). Even other О(n2) sorting algorithms, such as insertion sort, tend to have better performance than <b>bubble</b> <b>sort.</b> Therefore, <b>bubble</b> <b>sort</b> is not a practical sorting algorithm when n is large.|$|E
25|$|<b>Bubble</b> <b>sort</b> also interacts poorly {{with modern}} CPU hardware. It {{produces}} {{at least twice}} as many writes as insertion sort, twice as many cache misses, and asymptotically more branch mispredictions. Experiments by Astrachan sorting strings in Java show <b>bubble</b> <b>sort</b> to be roughly one-fifth as fast as an insertion sort and 70% as fast as a selection sort.|$|E
25|$|Due to its simplicity, <b>bubble</b> <b>sort</b> {{is often}} used to {{introduce}} the concept of an algorithm, or a sorting algorithm, to introductory computer science students. However, some researchers such as Owen Astrachan have {{gone to great lengths to}} disparage <b>bubble</b> <b>sort</b> and its continued popularity in computer science education, recommending that it no longer even be taught.|$|E
3000|$|... particlebase is not optimal {{because we}} just arrange SU order in a {{sequential}} way. Intuitively, we can use sorting algorithm to rearrange SU order to achieve higher objective (fitness) value. <b>Bubble</b> <b>Sorting</b> is a classical sorting algorithm with complexity O(n 2). In this article, we use a modified <b>bubble</b> <b>sorting</b> algorithm to rearrange SU order. We denote the SU order as a 1 ×K dimension vector K and the element of K indicates the SU index. fitness [...]...|$|R
50|$|Depth sorting uses bin sorting because objects {{only need}} to be {{approximately}} in order. The buffering demands memory but {{does not have the}} same time overheads as <b>bubble</b> <b>sorting</b> or quicksort. Colour keying is implemented by varying levels of white according to depth.|$|R
40|$|The {{sensitivity}} and efficiency in contrast-enhanced ultrasound imaging and therapy can potentially be increased {{by the use}} of resonant monodisperse bubbles. However, bubbles of the same size may respond differently to ultrasound due to differences in their phospholipid shell. In an acoustic <b>bubble</b> <b>sorting</b> chip, resonant <b>bubbles</b> can be separated from the polydisperse agent. Here, a sample of acoustically <b>sorted</b> <b>bubbles</b> is characterized by measuring scattering and attenuation simultaneously using narrowband acoustic pulses at peak negative pressures of 10, 25, and 50 kPa over a 0. 7 - 5. 5 [*]MHz frequency range. A second sample is characterized by attenuation measurements at acoustic pressures ranging from 5 to 75 kPa in steps of 2. 5 kPa. Scattering and attenuation coefficients were modeled by integration over the pressure and frequency dependent response of all bubbles located within the non-uniform acoustic characterization beam. For all driving pressures and frequencies employed here, the coefficients could be modeled using a single and unique set of shell parameters confirming that acoustically <b>sorted</b> <b>bubbles</b> provide a uniform acoustic response. Moreover, it is shown that it is crucial to include the pressure distribution of the acoustic characterization beam in the modeling to accurately determine shell parameters of non-linearly oscillating bubbles...|$|R
25|$|Odd-even sort is a {{parallel}} version of <b>bubble</b> <b>sort,</b> for message passing systems.|$|E
25|$|<b>Bubble</b> <b>sort</b> is {{asymptotically}} {{equivalent in}} running time to insertion sort {{in the worst}} case, but the two algorithms differ greatly {{in the number of}} swaps necessary. Experimental results such as those of Astrachan have also shown that insertion sort performs considerably better even on random lists. For these reasons many modern algorithm textbooks avoid using the <b>bubble</b> <b>sort</b> algorithm in favor of insertion sort.|$|E
25|$|Polynomial time: if {{the time}} is a power of the input size. E.g. the <b>bubble</b> <b>sort</b> {{algorithm}} has quadratic time complexity.|$|E
40|$|AbstractVersions of Hoare logic {{have been}} {{introduced}} to prove partial and total correctness properties of programs. In this paper it is shown how a Hoare-like proof system for while programs may be extended to prove properties of the computation time as well. It should be stressed that the system {{does not require the}} programs to be modified by inserting explicit operations upon a clock variable. We generalize the notions of arithmetically sound and complete and show that the proof system satisfies these. Also we derive formal rules corresponding to the informal rules for determining the computation time of while programs. The applicability of the proof system is illustrated by an example, the <b>bubble</b> <b>sorting</b> algorithm...|$|R
40|$|An {{ultrasound}} {{contrast agent}} (UCA) suspension contains encapsulated microbubbles {{with a wide}} size distribution, with radii ranging from 1 to 10 μm. Medical transducers typically operate at a single frequency, therefore only a small selection of bubbles will resonate to the driving ultrasound pulse. Thus, the sensitivity can be improved by narrowing down the size distribution. Here, we present a simple lab-on-a-chip method to sort the population of microbubbles on-chip using a traveling ultrasound wave. First, we explore the physical parameter space of acoustic <b>bubble</b> <b>sorting</b> using well-defined <b>bubble</b> sizes formed in a flow-focusing device, then we demonstrate successful acoustic sorting of a commercial UCA. This novel sorting strategy may lead to an overall improvement of the sensitivity of contrast ultrasound by more than 10 dB...|$|R
2500|$|The {{distance}} and direction that elements must move during the <b>sort</b> determine <b>bubble</b> <b>sort's</b> performance because elements move {{in different directions}} at different speeds. An element that must move {{toward the end of}} the list can move quickly because it can take part in successive swaps. For example, the largest element in the list will win every swap, so it moves to its sorted position on the first pass even if it starts near the beginning. On the other hand, an element that must move toward the beginning of the list cannot move faster than one step per pass, so elements move toward the beginning very slowly. If the smallest element is at the end of the list, it will take [...] passes to move it to the beginning. This has led to these types of elements being named rabbits and turtles, respectively, after the characters in Aesop's fable of The Tortoise and the Hare.|$|R
25|$|<b>Bubble</b> <b>sort</b> {{should be}} avoided {{in the case of}} large collections. It will not be {{efficient}} {{in the case of a}} reverse-ordered collection.|$|E
25|$|Various {{efforts have}} been made to {{eliminate}} turtles to improve upon the speed of <b>bubble</b> <b>sort.</b> Cocktail sort is a bi-directional <b>bubble</b> <b>sort</b> that goes from beginning to end, and then reverses itself, going end to beginning. It can move turtles fairly well, but it retains O(n2) worst-case complexity. Comb sort compares elements separated by large gaps, and can move turtles extremely quickly before proceeding to smaller and smaller gaps to smooth out the list. Its average speed is comparable to faster algorithms like quicksort.|$|E
25|$|In {{computer}} graphics <b>bubble</b> <b>sort</b> is popular for its capability {{to detect a}} very small error (like swap of just two elements) in almost-sorted arrays and fix it with just linear complexity (2n). For example, it is used in a polygon filling algorithm, where bounding lines are sorted by their x coordinate at a specific scan line (a line parallel to the x axis) and with incrementing y their order changes (two elements are swapped) only at intersections of two lines. <b>Bubble</b> <b>sort</b> is a stable sort algorithm, like insertion sort.|$|E
40|$|Abstract. We have {{examined}} {{a number of}} candidates for the minimum-surface-energy arrangement of two-dimensional clusters composed of N bubbles of area 1 and N bubbles of area λ (λ ≤ 1). These include hexagonal <b>bubbles</b> <b>sorted</b> into two monodisperse honeycomb tilings, and various mixed periodic tilings with at most four bubbles per unit cell. We identify, {{as a function of}} λ, the minimal configuration for N →∞. For finite N, the energy of the external (i. e., cluster-gas) boundary and that of the interface between honeycombs in “phase-separated ” clusters have to be taken into account. We estimate these contributions and find the lowest total energy configuration for each pair (N,λ). As λ is varied, this alternates between a circular cluster of one of the mixed tilings, and “partial wetting ” of the monodisperse honeycomb of bubble area 1 by the monodisperse honeycomb of bubble area λ. PACS. 83. 80. Iz Emulsions and foams – 82. 70. Rr Aerosols and foams – 02. 70. Rr General statistical methods...|$|R
40|$|In this study, a novel {{compression}} and decompression algorithm, namely the selected discrete cosine transform (DCT), is presented for implementation in networked motion control systems. The proposed method {{relies on the}} utilization of a selection algorithm based on <b>bubble</b> <b>sorting</b> to choose the highest power coefficients of the signal obtained by using DCT. In order to better illustrate {{the effectiveness of the}} proposed method, comparisons are made with the methods existing in the literature. To this aim, the basics of the compression schemes used in the comparison, namely, the DCT, discrete Fourier transform, and wavelet packet transform, are also briefly discussed followed by the derivation of the proposed method. The algorithmic bases of all four schemes are given to provide further reference for practical applications. The proposed method is tested on an experimental platform consisting of a single-single-degree-of-freedom master and slave systems, and the results are comparatively analyzed based on relevant performance evaluation metrics. The obtained results demonstrate the improvement achieved by the proposed compression scheme over the existing compression methods used in network-based motion control applications, hence proving the feasibility of the approach in tele-operation systems...|$|R
40|$|A {{numerical}} {{method for}} computing the subsonic flow around multi-element airfoil systems was developed, allowing for flow separation at {{one or more}} elements. Besides multiple rear separation also <b>sort</b> <b>bubbles</b> on the upper surface and cove bubbles can approximately be taken into account. Also, compressibility effects for pure subsonic flow are approximately accounted for. After presentation the method is applied to several examples and improved in some details. Finally, the present limitations and desirable extensions are discussed...|$|R
25|$|Alternate modifications, {{such as the}} {{cocktail}} shaker sort attempt to improve on the <b>bubble</b> <b>sort</b> performance while keeping the same idea of repeatedly comparing and swapping adjacent items.|$|E
25|$|The only {{significant}} advantage that <b>bubble</b> <b>sort</b> has over most other implementations, even quicksort, but not insertion sort, {{is that the}} ability to detect that the list is sorted efficiently is built into the algorithm. When the list is already sorted (best-case), the complexity of <b>bubble</b> <b>sort</b> is only O(n). By contrast, most other algorithms, even those with better average-case complexity, perform their entire sorting process on the set and thus are more complex. However, not only does insertion sort have this mechanism too, but it also performs better on a list that is substantially sorted (having a small number of inversions).|$|E
25|$|<b>Bubble</b> <b>sort</b> is {{a simple}} sorting {{algorithm}}. The algorithm starts {{at the beginning of}} the data set. It compares the first two elements, and if the first is greater than the second, it swaps them. It continues doing this for each pair of adjacent elements to the end of the data set. It then starts again with the first two elements, repeating until no swaps have occurred on the last pass. This algorithm's average time and worst-case performance is O(n2), so it is rarely used to sort large, unordered data sets. <b>Bubble</b> <b>sort</b> can be used to sort a small number of items (where its asymptotic inefficiency is not a high penalty). <b>Bubble</b> <b>sort</b> can also be used efficiently on a list of any length that is nearly sorted (that is, the elements are not significantly out of place). For example, if any number of elements are out of place by only one position (e.g. 0123546789 and 1032547698), bubble sort's exchange will get them in order on the first pass, the second pass will find all elements in order, so the sort will take only 2n time.|$|E
40|$|The paper gives {{a method}} of {{learning}} programming the <b>bubble</b> and selection <b>sorting</b> algorithms through developing interactive applications in Excel and coding the just acquired step of the solution in Delphi Pascal. The method was tried in nine 90 minute lessons with 83 participants, which were gymnasium students, undergraduate, master and PhD students of Teaching Informatics, and university Informatics teachers. The participants were given questionnaires to find out their opinion on the method. The results are discussed...|$|R
50|$|At a {{point where}} three or more <b>bubbles</b> meet, they <b>sort</b> {{themselves}} out so that only three bubble walls meet along a line. Since the surface tension is the same {{in each of the}} three surfaces, the three angles between them must be equal to 120°. Only four bubble walls can meet at a point, with the lines where triplets of bubble walls meet separated by cos−1(−1/3) ≈ 109.47°. All these rules, known as Plateau's laws, determine how a foam is built from bubbles.|$|R
40|$|The {{equilibrium}} {{states of}} 2 D non-coarsening fluid foams, which consist of bubbles with fixed areas, correspond to local minima {{of the total}} perimeter. (1) The authors find an approximate value of the global minimum, and determine directly from an image how far a foam is from its ground state. (2) For (small) area disorder, small <b>bubbles</b> tend to <b>sort</b> inwards and large bubbles outwards. (3) Topological charges of the same sign repel while charges of opposite sign attract. (4) They discuss boundary conditions and {{the uniqueness of the}} pattern for fixed topology...|$|R
25|$|For more {{restricted}} data, such as {{numbers in}} a fixed interval, distribution sorts such as counting sort or radix sort are widely used. <b>Bubble</b> <b>sort</b> and variants are rarely used in practice, but are {{commonly found in}} teaching and theoretical discussions.|$|E
25|$|General method: insertion, exchange, selection, merging, etc. Exchange sorts include <b>bubble</b> <b>sort</b> and quicksort. Selection sorts include shaker sort and heapsort. Also {{whether the}} {{algorithm}} is serial or parallel. The {{remainder of this}} discussion almost exclusively concentrates upon serial algorithms and assumes serial operation.|$|E
25|$|Although <b>bubble</b> <b>sort</b> {{is one of}} the {{simplest}} sorting algorithms to understand and implement, its O(n2) complexity means that its efficiency decreases dramatically on lists of more than a small number of elements. Even among simple O(n2) sorting algorithms, algorithms like insertion sort are usually considerably more efficient.|$|E
60|$|Oh what a {{ghost of}} {{dead and buried}} wealth had Peter Goldthwaite raised to scare himself out of his scanty wits withal! Here was the semblance of an incalculable sum, enough to {{purchase}} the whole town and build every street anew, but which, vast as it was, no sane man would have given a solid sixpence for. What, then, in sober earnest, were the delusive treasures of the chest? Why, here were old provincial bills of credit and treasury notes and bills of land-banks, and all other <b>bubbles</b> of the <b>sort,</b> from the first issue--above {{a century and a}} half ago--down nearly to the Revolution. Bills of a thousand pounds were intermixed with parchment pennies, and worth no more than they.|$|R
40|$|Safe, high-rate and {{cost-effective}} cell sorting {{is important for}} clinical cell isolation. However, commercial fluorescence-activated cell sorters (FACS) are expensive and prone to aerosol-induced sample contamination. Here we report a microfluidic cell sorter allowing high rate and fully enclosed cell sorting. The sorter chip consists of an array of micro heating hotspots. Pulsed resistive heating in the hotspots produces numerous micro vapor bubbles with short duration, which {{gives rise to a}} rapid jet flow for cell sorting. With this method, we demonstrated high sorting rate comparable to commercial FACS and the significant enrichment of rare cancer cells. This vapor <b>bubble</b> based cell <b>sorting</b> method can be a powerful tool for contamination-free and affordable clinical cell sorting such as circulating tumor cell isolation and cancer cell therapy. status: publishe...|$|R
40|$|Over {{the past}} few years, the {{presence}} of game-based learning in Slovenian education has increased significantly. To further such utilization, an educational computer game was made, {{as a part of}} project within a computer science didactics class in the 4 th year of studies at Faculty of Education, University of Ljubljana, to help pupils learn and understand <b>sorting</b> algorithms, specifically <b>bubble</b> and selection <b>sort.</b> Both algorithms are introduced to pupils through an entertaining story, that later requires a construction of pseudo codes and tests the pupil’s newly acquired knowledge. The game doesn’t require any prior programming knowledge, which increases its usability and eases the teacher’s incorporation of the game into a structured lesson. This paper presents the production and conceptual development of the game, with a focus on representation of algorithms in a pupil friendly, logical, explanatory and motivational way, {{as well as on the}} game itself...|$|R
25|$|<b>Bubble</b> <b>sort,</b> and {{variants}} such as {{the cocktail}} sort, are simple but highly inefficient sorts. They are thus frequently seen in introductory texts, and are of some theoretical interest due to ease of analysis, but they are rarely used in practice, and primarily of recreational interest. Some variants, {{such as the}} Shell sort, have open questions about their behavior.|$|E
25|$|Shellsort {{was invented}} by Donald Shell in 1959. It {{improves}} upon <b>bubble</b> <b>sort</b> and insertion sort by moving out of order elements more than one position at a time. The concept behind Shellsort is that both of these algorithms perform in O(kn) time, where k is the greatest distance between two out-of-place elements. This means that generally, they perform in O(n2), but for data that is mostly sorted, {{with only a few}} elements out of place, they perform faster. So, by first sorting elements far away, and progressively shrinking the gap between the elements to sort, the final sort computes much faster. One implementation can be described as arranging the data sequence in a two-dimensional array and then sorting the columns of the array using insertion sort.|$|E
25|$|From the {{beginning}} of computing, the sorting problem has attracted {{a great deal of}} research, perhaps due to the complexity of solving it efficiently despite its simple, familiar statement. Among the authors of early sorting algorithms around 1951 was Betty Holberton (née Snyder), who worked on ENIAC and UNIVAC. <b>Bubble</b> <b>sort</b> was analyzed as early as 1956. Comparison sorting algorithms have a fundamental requirement of Ω(n log n) comparisons (some input sequences will require a multiple of n log n comparisons); algorithms not based on comparisons, such as counting sort, can have better performance. Although many consider sorting a solved problemasymptotically optimal algorithms have been known since the mid-20th centuryuseful new algorithms are still being invented, with the now widely used Timsort dating to 2002, and the library sort being first published in 2006.|$|E
40|$|Sorting {{has been}} a {{profound}} area for the algorithmic researchers and many resources are invested to suggest more works for sorting algorithms. For this purpose, many existing sorting algorithms were observed {{in terms of the}} efficiency of the algorithmic complexity. In this paper we implemented the <b>bubble</b> and merge <b>sort</b> algorithms using Message Passing Interface (MPI) approach. The proposed work tested on two standard datasets (text file) with different size. The main idea of the proposed algorithm is distributing the elements of the input datasets into many additional temporary sub-arrays according to a number of characters in each word. The sizes of each of these sub-arrays are decided depending on a number of elements with the same number of characters in the input array. We implemented MPI using Intel core i 7 - 3610 QM,(8 CPUs),using two approaches (vectors of string and array 3 D). Finally, we get the data structure effects on the performance of the algorithm for that we choice the second approach. Comment: 5 pages, 5 figures. arXiv admin note: substantial text overlap with arXiv: 1407. 660...|$|R
40|$|MEMS micro-T-switches {{actuated}} via electrochemical <b>bubbles</b> for cell <b>sorting</b> {{applications in}} a monolithic chip level are proposed and successfully demonstrated. The electrolysis-bubble actuator, {{which has the}} features of low operation temperature and high surface-tension force, is developed to actuate the micro-T-switch sorting structure in our device. The double T-structure design, the T-shape microchannel with the movable micro-T-switch structure located at the junction of the T-shape microchannel, with the electrolysis-bubble actuator makes an activebinary switch function available for cell sorting applications. The room temperature operation and the low voltage required for electrolysis actuation minimize the possibility of cell-damage that happens in the conventional high electric separation instruments, such as flow cytometry. The function of our micro-T-switch chip with a low required actuation voltage of 3. 0 y 3. 5 V is demonstrated by using human hepatoma cells in this paper. The pH-value measurements characterize the pH-value variation and distribution in the actuating chambers and the mainstream microchannels to trace the possible liver-cell injury due to the pH-value variation during electrolysis-actuation operation. The 84. 1 % cell viability in the sorted human hepatoma cells through our micro-T-switch sorter is observed via the fluorescence assay technique. Furthermore, 70. 2 % of total injected cells recover in culture after sorting and grow into colonies after micro-T-switch sorting operation. In this paper, we describe the design, microfabrication, and characterization of our micro-T-switch cell-sorting chip. We also report the cell-sorting demonstration and the cell viability results for the mammalian liver cells through our micro-T-switch cell-sorting chip...|$|R
40|$|Sorting {{is one of}} {{the most}} {{important}} and well studied problems in Computer Science. Many good algorithms are known which offer various trade-offs in efficiency, simplicity, memory use, and other factors. However, these algorithms do not take into account features of modern computer architectures that significantly influence performance. Caches and branch predictors are two such features, and while there has been a significant amount of research into the cache performance of general purpose sorting algorithms, there has been little research on their branch prediction properties. In this paper we empirically examine the behaviour of the branches in all the most common sorting algorithms. We also consider the interaction of cache optimization on the predictability of the branches in these algorithms. We find insertion sort to have the fewest branch mispredictions of any comparison-based <b>sorting</b> algorithm, that <b>bubble</b> and shaker <b>sort</b> operate in a fashion which makes their branches highly unpredictable, that the unpredictability of shellsort’s branches improves its caching behaviour and that several cache optimizations have little effect on mergesort’s branch mispredictions. We find also that optimizations to quicksort – for example the choice of pivot – have a strong influence on the predictability of its branches. We point out a simple way of removing branch instructions from a classic heapsort implementation, and show also that unrolling a loop in a cache optimized heapsort implementation improves the predicitability of its branches. Finally, we note that when sorting random data two-level adaptive branch predictors are usually no better than simpler bimodal predictors. This is despite the fact that two-level adaptive predictors are almost always superior to bimodal predictors in general...|$|R
