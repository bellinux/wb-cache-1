377|222|Public
25|$|The PPE and <b>bus</b> <b>architecture</b> {{includes}} various {{modes of}} operation giving different levels of memory protection, allowing areas of memory {{to be protected from}} access by specific processes running on the SPEs or the PPE.|$|E
25|$|By this point, the four-year-old Athlon EV6 <b>bus</b> <b>architecture</b> had scaled to its limit. To {{maintain}} or exceed {{the performance of}} Intel's newer processors would require a significant redesign. The K7 derived Athlons were replaced in March 2003 by the Athlon 64 family, which featured an on-chip memory controller and a completely new HyperTransport bus to replace EV6.|$|E
25|$|Internally, the Athlon is a fully seventh {{generation}} x86 processor, {{the first}} of its kind. Like the AMD K5 and K6, the Athlon dynamically buffers internal micro-instructions at runtime resulting from parallel x86 instruction decoding. The CPU is an out-of-order design, again like previous post-5x86 AMD CPUs. The Athlon utilizes the Alpha 21264's EV6 <b>bus</b> <b>architecture</b> with double data rate (DDR) technology. This means that at 100MHz, the Athlon front side bus actually transfers at a rate similar to a 200MHz single data rate bus (referred to as 200MT/s), which was superior to the method used on Intel's Pentium III (with SDR bus speeds of 100MHz and 133MHz).|$|E
40|$|Abstract—The ever {{increasing}} complexity and heterogeneity of modern System-on-Chip designs demands {{validation of the}} system performance as early as possible. The on-chip <b>bus</b> <b>architectures</b> {{play an important role}} to meet the design performance. Today many heterogeneous on-chip <b>bus</b> <b>architectures</b> are defined to address the design exploration. In this paper we introduce an efficient modeling style of heterogeneous <b>bus</b> <b>architectures</b> at high levels of abstraction. We capture different <b>bus</b> <b>architectures</b> by using a generic, parameterizable bus model, which captures performance issues without significant loss of accuracy. Our modeling style is based on the SystemC language, a special channel library and attached coding style. The combination provides the ground layer for the efficient and fast simulation, which in turn enables the validation of the functionality and performance of the system at high abstraction levels. The approach has been successfully used from defining the Executable Specifications at the functional level to the architecture explorations with HW/SW integration for an IPv...|$|R
50|$|Testing for jitter and its {{measurement}} is {{of growing}} importance to electronics engineers {{because of increased}} clock frequencies in digital electronic circuitry to achieve higher device performance. Higher clock frequencies have commensurately smaller eye openings, and thus impose tighter tolerances on jitter. For example, modern computer motherboards have serial <b>bus</b> <b>architectures</b> with eye openings of 160 picoseconds or less. This is extremely small compared to parallel <b>bus</b> <b>architectures</b> with equivalent performance, which may have eye openings {{on the order of}} 1000 picoseconds.|$|R
50|$|SCSI (Small Computer Systems Interface) {{falls in}} the mega{{transfer}} range of data transfer rate, while newer <b>bus</b> <b>architectures</b> like the front side bus, Quick Path Interconnect, PCI Express and HyperTransport operate {{at the rate of}} a few GT/s.|$|R
2500|$|Since such a <b>bus</b> <b>architecture</b> cannot keep up {{with the}} data {{requirements}} of the LHC experiments, ...|$|E
2500|$|The {{electrical}} system was completely revised for 2008. [...] Changes included a 180-amp alternator, twin electric cooling fans, electronic throttles, and completely new VENOM engine management system. CAN <b>bus</b> <b>architecture</b> has been combined with pre-existing systems {{to allow for}} regulatory compliance. The fuel system was upgraded to include a higher-capacity fuel pump and filtration system.|$|E
5000|$|... #Caption: Figure 1: Sample MIL-STD-1553B Multiplex Data <b>Bus</b> <b>Architecture</b> ...|$|E
5000|$|... 1. Cost: Logic analyzers usually carry {{higher prices}} than bus analyzers. The {{converse}} {{of this fact}} is that a logic analyzer {{can be used with}} a variety of <b>bus</b> <b>architectures,</b> whereas a <b>bus</b> analyzer is only good with one architecture.|$|R
50|$|There are {{standards}} for jitter measurement in serial <b>bus</b> <b>architectures.</b> The standards cover jitter tolerance, jitter transfer function and jitter generation, with the required values for these attributes varying among different applications. Where applicable, compliant systems {{are required to}} conform to these standards.|$|R
40|$|Means for {{evaluating}} data <b>bus</b> <b>architectures</b> and protocols for highly integrated {{flight control system}} applications are needed. Described are the criteria and plans to do this by using the NASA/Ames Intelligent Redundant Actuation System (IRAS) experimental set-up. Candidate <b>bus</b> <b>architectures</b> differ from one another in terms of: topology, access control, message transfer schemes, message characteristics, initialization. data flow control, transmission rates, fault tolerance, and time synchronization. The evaluation criteria are developed relative to these features. A preliminary, analytical evaluation of four candidate busses (MIL-STD- 1553 B, DATAC, Ethernet, and HSIS) is described. A bus must be exercised in a real-time environment to evaluate its dynamic characteristics. A plan for real-time evaluation of these four busses {{using a combination of}} hardware and simulation techniques is presented...|$|R
50|$|The Simple <b>Bus</b> <b>Architecture</b> is a {{simplified}} {{version of the}} Wishbone specification.|$|E
5000|$|OpenCores Wishbone bus - Free {{and open}} <b>bus</b> <b>architecture</b> (formerly from Silicore) ...|$|E
50|$|All {{three models}} all {{featured}} the Megabus, {{which was a}} proprietary asynchronous <b>bus</b> <b>architecture.</b>|$|E
40|$|Abstract- In {{this paper}} {{we present a}} static {{performance}} estimation technique of on-chip <b>bus</b> <b>architectures.</b> The proposed technique requires the static scheduling of function blocks of a task to analyze bus conflicts caused by simultaneous accesses from processing elements to which the function blocks are mapped. To apply it to multi-task applications, the concurrent execution of function blocks of different tasks also should be considered. Since tasks are scheduled independently, considering all cases of concurrency in each processing element is impractical. Therefore we make an average estimate {{on the effect of}} other tasks with respect to a bus request rate and bus access time. The proposed technique was incorporated with our exploration framework for onchip <b>bus</b> <b>architectures.</b> Its viability and efficiency are validated by a real-life example...|$|R
40|$|The {{shortcomings}} of conventional <b>bus</b> <b>architectures</b> are {{in terms of}} scalability and the ever increasing demand of more bandwidth. And also the feature size of sub-micron domain is decreasing {{making it difficult for}} <b>bus</b> <b>architectures</b> to fulfill the requirements of modern System on Chip (SoC) systems. Network on chip (NoC) architectures presents a solution to the earlier mentioned shortcomings by employing a packet based network for inter IP communications. A pivotal feature of NoC systems is the topology in which the system is arranged. Several parameters which are topology dependent like hop count, path diversity, degree and other various parameters affect the system performance. We propose a novel topology forNoC architecture which has been thoroughly compared with the existing topologies on the basis of different network parameters...|$|R
40|$|Abstract—In {{this paper}} {{we present a}} static {{performance}} estimation technique of on-chip <b>bus</b> <b>architectures.</b> The proposed technique requires the static scheduling of function blocks of a task to analyze bus conflicts caused by simultaneous accesses from processing elements to which function blocks are mapped. To apply it to multitask applications, the concurrent execution of the function blocks of different tasks also should be considered. Since tasks are scheduled independently, considering all cases of concurrency in each processing element is impractical. Therefore we make an average estimate {{on the effects of}} other tasks with respect to bus request rate and bus access time. The proposed technique was incorporated with our exploration framework for on-chip <b>bus</b> <b>architectures.</b> Its viability and efficiency are validated by a preliminary example. Index Terms—Performance estimation, multitask application, on-chip bus, design space exploration, queuing theory I...|$|R
5000|$|... 2008 {{demonstration}} of the COPACOBANA V4-SX35, a 128 Virtex-4 SX35 FPGA cluster (COPACOBANA shared <b>bus</b> <b>architecture)</b> ...|$|E
50|$|AHB is a bus {{protocol}} {{introduced in}} Advanced Microcontroller <b>Bus</b> <b>Architecture</b> version 2 published by ARM Ltd company.|$|E
50|$|The {{original}} front-side <b>bus</b> <b>architecture</b> {{has been}} replaced by HyperTransport, Intel QuickPath Interconnect or Direct Media Interface in modern volume CPUs.|$|E
40|$|The paper {{considers}} the 'ijk forms' of LU and Cholesky factorization on certain parallel computers. This extends an earlier analysis for vector computers. Attention {{is restricted to}} local memory systems with processors {{that may or may}} not have vector capability. Special attention is given to <b>bus</b> <b>architectures</b> but qualitative analyses are given for other interconnection systems...|$|R
40|$|Thanks to CAN <b>Bus</b> <b>architectures,</b> Electronic Control Units and Wireless communication, today’s {{agricultural}} machines provide detailed process data {{that can be}} used for improving productivity in farm and contractor’s enterprises. We explain current efforts within the research project AGATA 1 to set up an appropriate infrastructure, basic principles for analysis and implementation in real harvest scenarios...|$|R
5000|$|For many <b>bus</b> <b>architectures</b> like PCI Express, PCI, SAS, SATA, and USB, {{engineers}} {{also use}} a [...] "Bus Exerciser" [...] or “Protocol Exerciser”. Such exercisers can emulate partial or full communication stacks which comply with the specific bus communication standard, thus allowing engineers to surgically control and generate bus traffic to test, debug and validate their designs.|$|R
50|$|UPA: An {{interconnect}} <b>bus</b> <b>architecture</b> {{introduced by}} Sun Microsystems in 1995. It had a 64-bit bus clocked at 67 or 83 MHz.|$|E
50|$|The 32-bit {{microarchitecture}} features Advanced Microcontroller <b>Bus</b> <b>Architecture</b> (AMBA) {{support and}} includes SJTAG for In-circuit emulation. It is implemented on the Sunplus SPG290 system-on-a-chip (SoC).|$|E
50|$|In 1989 {{he started}} {{designing}} the Zorro III expansion <b>bus</b> <b>architecture,</b> and in 1990, with Greg Berlin, Hedley Davis, Jeff Boyer, and Scott Hood, created the Amiga 3000.|$|E
5000|$|In computing, bus {{mastering}} is {{a feature}} supported by many <b>bus</b> <b>architectures</b> that enables a device {{connected to the}} bus to initiate transactions. It is {{also referred to as}} first-party DMA, in contrast with [...] "third-party DMA" [...] where a system DMA controller (also known as peripheral processor, I/O processor, or channel) actually does the transfer.|$|R
50|$|Some {{types of}} buses allow only one device (typically the CPU, or its proxy) to {{initiate}} transactions. Most modern <b>bus</b> <b>architectures,</b> such as PCI, allow multiple devices to bus master because it significantly improves performance for general-purpose operating systems. Some real-time operating systems prohibit peripherals from becoming bus masters, because the scheduler {{can no longer}} arbitrate for the bus and hence cannot provide deterministic latency.|$|R
5000|$|STD Bus {{is popular}} {{worldwide}} {{and is an}} approved standard under IEEE-961. The STD Bus {{has a number of}} advantages over other <b>bus</b> <b>architectures</b> used in industrial applications such as the PC bus and Multibus. Its simple interface, smaller card size (4.5" [...] x 6.5"); solid, nearly square peripheral cards, and strong card mounts, tolerate shock and vibrations making the STD Bus ideal for rugged industrial environments.|$|R
50|$|Its main legacy was a <b>bus</b> <b>architecture</b> called NuBus {{that was}} later adopted by Apple Computer for its Macintosh II and by NeXT, and {{influenced}} {{the design of the}} PCI bus.|$|E
50|$|The SPARC Enterprise AT7480 was speculated to be a quad socket model {{reported}} to handle {{as many as}} 128 hardware threads, based on the PCI Express <b>bus</b> <b>architecture</b> with Open Boot firmware.|$|E
50|$|The {{system used}} a passive <b>bus</b> <b>architecture</b> with no {{motherboard}} - all electronics were contained {{on a number}} of cards interconnected by ribbon cable. The only microprocessor offered was a 4 MHz Z80A.|$|E
40|$|System on Chip {{architectures}} {{have emerged}} as ubiquitous option for compute intensive applications, due to the tremendous flexibility provided by them with respect to design reuse and extendibility. Many single shared <b>bus</b> <b>architectures</b> have been proposed for connecting various modules in such systems. However increasing levels of integration, number of components connected to the <b>bus,</b> renders such <b>architectures</b> infeasible. Meeting the power budget constraint {{continues to be a}} major challenge for the designers architecting such systems. To counter the problem of growing power consumption, hierarchical <b>bus</b> <b>architectures</b> and partitioned memory systems have been the popular solutions. Such partitioned approaches along with partitioned shared memory systems may give significant benefits in both performance and power reduction. Moreover operating the different buses in different frequencies based on the communication needs of the buses may further reduce the total power consumption. In this paper we present a way to perform memory and bus partitioning and allocate variable frequencies to different bus segments to reduce the power consumption of the system without affecting the performance. We use an evolutionary algorithm followed by an iterative search based frequency allocation algorithm to solve the problem. Our effectiveness of our proposed results is validated on a systemC based cycle-accurate bus simulator presented in [ML 04]...|$|R
40|$|Graduation date: 1990 This paper {{discusses}} the design strategies for interface of <b>bus</b> <b>architectures.</b> It also describes {{the design of}} interface between the two popular <b>bus</b> <b>architectures,</b> the Micro Channel and the Nu Bus. The main objective of this thesis {{is to develop a}} procedure for bus interface design and use this procedure to design a Micro Channel Interface for the Nu Bus. The different problems, to be considered while designing an interface between two system buses, are identified and several methods of solving these problems are discussed. Several methods of implementing the interfaces are also discussed. A Micro Channel slave interface is designed using the procedure developed. A Custom VLSI bus controller approach is chosen for the design. The interface is designed {{in such a way that}} it can be easily identified as two blocks and a VLSI component can be designed for each of the blocks. This interface may prove to be useful to design cards for the Micro Channel which can be used on the Nu Bus systems...|$|R
5|$|A {{symmetric}} multiprocessor (SMP) is {{a computer}} system with multiple identical processors that share memory and connect via a bus. Bus contention prevents <b>bus</b> <b>architectures</b> from scaling. As a result, SMPs generally do not comprise more than 32processors. Because of {{the small size of}} the processors and the significant reduction in the requirements for bus bandwidth achieved by large caches, such symmetric multiprocessors are extremely cost-effective, provided that a sufficient amount of memory bandwidth exists.|$|R
