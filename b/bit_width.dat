124|94|Public
25|$|DDR {{memory bus}} width per channel is 64 bits (72 for ECC memory). Total module <b>bit</b> <b>width</b> {{is a product}} of bits per chip by number of chips. It also equals number of ranks (rows) multiplied by DDR memory bus width. Consequently, a module with a greater number of chips or using ×8 chips instead of ×4 will have more ranks.|$|E
25|$|An image {{starts with}} a fixed-length Image Descriptor, which may specify the {{presence}} and size of a Local Color Table (which follows next if present). The image data follows: one byte giving the <b>bit</b> <b>width</b> of the unencoded symbols (which {{must be at least}} 2 bits wide, even for bi-color images), followed by a linked list of sub-blocks containing the LZW-encoded data.|$|E
5000|$|Optimization of <b>bit</b> <b>width</b> {{of digital}} data path (according to the dynamic ranges of signal) {{can reduce the}} area, cost, and power {{consumption}} of digital circuits and systems while improving their performance. Optimal <b>bit</b> <b>width</b> of digital data path is the smallest <b>bit</b> <b>width</b> that can satisfy the required signal-to-noise ratio and avoid overflow at the same time.|$|E
30|$|In {{a similar}} way, we perform the {{exploration}} {{for the other}} two parts, and acquire the precision threshold 10, 12, and 16 for the SQRT, SINE, and WFLD parts, respectively. However, as the above results are acquired with two out of the three <b>bit</b> <b>widths</b> set to very large values, the practical solution shall be lightly larger than these values. Meanwhile, constrained by the current I/O bandwidth of 64 [*]bits per second, {{the sum of the}} <b>bit</b> <b>widths</b> for SQRT and WFLD parts shall be less than 30. We perform further experiments for bit-width values around the initial guess point, and find out that <b>bit</b> <b>widths</b> of 12, 16, and 16 for the three parts provide a DI value of 131.5 and also meet the bandwidth requirement.|$|R
3000|$|... (3)Adjust the fixed-point bit {{precisions}} (including <b>bit</b> <b>widths</b> and {{binary point}} position) for each XSG block of the system.|$|R
5000|$|Format Conversion while copying between certain 32/64/128 bit prestructured, typed {{resources}} and compressed {{representations of the}} same <b>bit</b> <b>widths.</b>|$|R
50|$|The {{first part}} of the word {{specifies}} the operation to be performed, the second part is the <b>bit</b> <b>width</b> of the operation, the third part provides information for locating the second operand.|$|E
50|$|The TMS9900 CPU also {{contains}} a 16-bit shift register ("CRU") designed for interfacing with external shift registers, with dedicated instructions supporting access to fields of 1-16 <b>bit</b> <b>width</b> {{out of a total}} of 4096 addressable bits.|$|E
50|$|The 11 <b>bit</b> <b>width</b> of the {{exponent}} {{allows the}} representation of numbers between 10−308 and 10308, with full 15-17 decimal digits precision. By compromising precision, the subnormal representation allows even smaller values up to about 5 × 10−324.|$|E
30|$|Our {{proposed}} {{method has}} been tested for various <b>bit</b> <b>widths</b> that are multiples of eight and results are compared with prior work [2] and tabulated in Table  4. From the analysis made for various <b>bit</b> <b>widths,</b> it is inferred that our method needs (N/ 2)[*]+[*] 3 multiplexers. Due to reduction in multiplexers, overall area, delay and power are reduced for TP multiplier. For the previous implementation of TP technique [2], the multiplexer utilisation has been formulated as N[*]+[*] 3. This reduction in multiplexer utilisation in our proposed work reduces the design complexity of TP multiplier.|$|R
40|$|This paper {{presents}} an analytical {{framework for the}} implementation of digital infinite impulse response filters in fixed-point hardware on field programmable gate arrays. This analysis is necessary because FPGAs, unlike fixed register size digital signal processors, allow custom <b>bit</b> <b>widths.</b> Within the framework, the designer determines the number of bits necessary for representing the constant coefficients and the internal signals in the filter. The coefficient <b>bit</b> <b>widths</b> are determined by accounting for the sensitivity of the filter’s pole and zero locations with respect to the coefficient perturbations. The internal signal <b>bit</b> <b>widths</b> are determined by calculating theoretical bounds on the ranges of the signals, and on the errors introduced by truncation in the fixed-point hardware. The bounds tell how many bits are required at any point in the computation in order to avoid overflow and guarantee a prescribed degree of accuracy in the filter output. The bounds form the basis for a methodology for the fixed-point digital filter implementation. The methodology is applied to the implementation of a second-order filter used as a compensator in a magnetic bearing control system...|$|R
30|$|The current tools support two {{different}} number representations, fixed-point, and floating-point numbers (the value simulator for LNS {{is still in}} progress). For all the different number formats, the users can also specify arbitrary <b>bit</b> <b>widths</b> for each different variable.|$|R
5000|$|Some languages, {{such as the}} [...]NET Framework and LLVM, also leave {{shifting}} by the <b>bit</b> <b>width</b> {{and above}} unspecified (.NET) or undefined (LLVM). [...] Others choose to specify the behavior of their most common target platforms, such as C# which specifies the x86 behavior.|$|E
50|$|All {{currently}} relevant C standards (ISO/IEC 9899:1999 to 2011) leave {{a definition}} gap for {{cases where the}} number of shifts is equal to or bigger {{than the number of}} bits in the operands {{in a way that the}} result is undefined. This helps allow C compilers to emit efficient code for various platforms by allowing direct use of the native shift instructions which have differing behavior. For example, shift-left-word in PowerPC chooses the more-intuitive behavior where shifting by the <b>bit</b> <b>width</b> or above gives zero, whereas SHL in x86 chooses to mask the shift amount to the lower bits to reduce the maximum execution time of the instructions, and as such a shift by the <b>bit</b> <b>width</b> doesn't change the value.|$|E
5000|$|The {{addition}} {{operation in}} all RBRs is carry-free, {{which means that}} the carry does not have to propagate through the full width of the addition unit. In effect, the addition in all RBRs is a constant-time operation. The addition will always take {{the same amount of time}} independently of the bit-width of the operands. This does not imply that the addition is always faster in an RBR than its two's complement equivalent, but that the addition will eventually be faster in an RBR with increasing <b>bit</b> <b>width</b> because the two's complement addition unit's delay is proportional to log(n) (where n is the <b>bit</b> <b>width).</b> [...] Addition in an RBR takes a constant time because each digit of the result can be calculated independently of one another, implying that each digit of the result can be calculated in parallel.|$|E
50|$|Both Java and C# support signed {{integers}} with <b>bit</b> <b>widths</b> of 8, 16, 32 and 64 bits. They use {{the same}} name/aliases for the types, except for the 8-bit integer that is called a byte in Java and a sbyte (signed byte) in C#.|$|R
40|$|AbstractWe motivate, {{define and}} design a simple static {{analysis}} {{to check that}} comparisons of floating point values use compatible <b>bit</b> <b>widths</b> and thus compatible precision ranges. Precision mismatches arise due to the difference in <b>bit</b> <b>widths</b> of processor internal floating point registers (typically 80 or 64 bits) and their corresponding widths when stored in memory (64 or 32 bits). The analysis guarantees that floating point values from memory (i. e. array elements, instance and static fields) are not compared against floating point numbers in registers (i. e. arguments or locals). Without such an analysis, static symbolic verification is unsound and hence may report false negatives. The static analysis is fully implemented in Clousot, our static contract checker based on abstract interpretation...|$|R
30|$|Lee et al. [6] {{present a}} static {{precision}} analysis technique which uses affine arithmetic to derive an error {{model of the}} design and applies simulated annealing to find out minimum <b>bit</b> <b>widths</b> to satisfy the given error requirement. A similar approach is shown in a bit-width optimization tool called Prcis [7].|$|R
5000|$|Disk (virtual memory, file system) (1 GiB to 256 TiB) [...] - [...] very slow, {{due to the}} {{narrower}} (in <b>bit</b> <b>width),</b> physically {{much longer}} data channel between the main board of the computer and the disk devices, and due to the extraneous software protocol needed {{on the top of}} the slow hardware interface ...|$|E
50|$|Each suffix {{tends to}} {{indicate}} a general trend of features and limitations that are common when applied to different lines of card and different graphics cores. These {{are related to the}} number of processing units (pipelines) available, the <b>bit</b> <b>width</b> of the video RAM interface, and the clock speed of the graphics core and video RAM.|$|E
50|$|For large rate changes, a CIC has a {{significant}} advantage over a FIR filter with respect to architectural and computational efficiency. Additionally, CIC filters can typically be reconfigured for different rates by changing {{nothing more than the}} decimation/interpolation section assuming the <b>bit</b> <b>width</b> of the integrators and comb sections meets certain mathematical criteria based on the maximum possible rate change.|$|E
50|$|In computing, a {{syllable}} is a {{name for}} a platform-dependent unit of information storage. Depending on the target hardware, various <b>bit</b> <b>widths</b> (and sometimes internal groupings) are associated with it. Commonly used in the 1960s and 1970s, the term has mostly fallen into disuse in favour of terms like byte or word.|$|R
40|$|A digital single {{sideband}} modulator (DSSM) for a digital radio frequency memory (DRFM) {{was designed and}} implemented in a commercial 90 -nm radiation-hardened-by-design (RHBD) structured ASIC by Thomas Pemberton in citePemberton. This thesis synthesized the same DSSM structure in a non-hardened 90 -nm commercial process and compared the synthesis results of the two for power, delay, and area. The number of I/O bits and taps in citePemberton and this thesis were purposely made high to create a large target for radiation testing. As should be expected, the RHBD DSSM reported greater power and area. However, the RHBD power models were only estimates. This thesis also showed {{the costs and benefits}} for varying <b>bit</b> <b>widths,</b> number of filter taps, and ROM sizes in the DSSM, synthesized at a typical characterization corner. One of the designs was also synthesized at two more characterization corners. Finally, another design variation was tested with extra piping in the Hilbert filter. All of these circuits were measured for power, timing, critical path, area, and spur-free dynamic range (SFDR). Chip area was found to be solely dependent on the number of I/O pads and thus went up with greater I/O <b>bit</b> <b>widths.</b> Greater I/O <b>bit</b> <b>widths</b> and number of taps also led to more cell area and power consumption. The 16 -bit/ 153 -tap and 24 -bit/ 101 -tap typical-corner DSSM 2 ̆ 7 s and the 16 -bit/ 101 -tap slow-corner DSSM could not meet the synthesis target of 100 MHz. Setup circuitry for the ROM address became the critical path for some of the designs partly {{due to the fact that}} the address was set up on the falling edge of the clock but loaded on the rising edge. Increasing I/O <b>bit</b> <b>widths</b> and the number of filter taps improved frequency response and SFDR. Finally, increasing ROM size increased maximum SFDR for a select range of input frequencies. For SFDR, the predominant spur was the suppressed sideband, which was poorly suppressed...|$|R
50|$|C# {{supports}} unsigned {{in addition}} to the signed integer types. The unsigned types are byte, ushort, uint and ulong for 8, 16, 32 and 64 <b>bit</b> <b>widths,</b> respectively. Unsigned arithmetic operating on the types are supported as well. For example, adding two unsigned integers (uints) still yields a uint as a result; not a long or signed integer.|$|R
50|$|DDR {{memory bus}} width per channel is 64 bits (72 for ECC memory). Total module <b>bit</b> <b>width</b> {{is a product}} of bits per chip by number of chips. It also equals number of ranks (rows) multiplied by DDR memory bus width. Consequently, a module with greater amount of chips or using ×8 chips instead of ×4 will have more ranks.|$|E
50|$|An image {{starts with}} a fixed-length Image Descriptor, which may specify the {{presence}} and size of a Local Color Table (which follows next if present). The image data follows: one byte giving the <b>bit</b> <b>width</b> of the unencoded symbols (which {{must be at least}} 2 bits wide, even for bi-color images), followed by a linked list of sub-blocks containing the LZW-encoded data.|$|E
50|$|A Verilog module {{may take}} {{one or more}} parameters, to which their actual values are {{assigned}} upon the instantiation of the module. One example is a generic register array where the array width is given via a parameter. Such the array, combined with a generic wire vector, can make a generic buffer or memory module with an arbitrary <b>bit</b> <b>width</b> out of a single module implementation.|$|E
50|$|The Serial Low-power Inter-chip Media Bus (SLIMbus&#8480;) is a {{standard}} interface between baseband or application processors and peripheral components in mobile terminals. It was developed within the MIPI&reg; Alliance, founded by ARM, Nokia, STMicroelectronics and Texas Instruments. The interface supports many digital audio components simultaneously, and carries multiple digital audio data streams at differing sample rates and <b>bit</b> <b>widths.</b>|$|R
30|$|Based on the {{exploration}} results of different number representations, the fixed-point design with <b>bit</b> <b>widths</b> of 12, 16, and 16 for three different parts is selected in our hardware implementation. The design produces images containing {{the same pattern}} as the double-precision floating-point implementation, and has the smallest bit-width values, that is, the lowest resource cost among all the different number representations.|$|R
40|$|Abstract—We {{present a}} {{flexible}} hardware architecture for precise gamma correction via piece-wise linear polynomial approximations. Arbitrary gamma values, input <b>bit</b> <b>widths,</b> and output <b>bit</b> <b>widths</b> are supported. The gamma correction curve is segmented via {{a combination of}} uniform segments and segments whose sizes vary by powers of two. This segmentation method minimizes the number of segments required, while providing an efficient way for indexing the polynomial coefficients. The outputs are guaranteed to be accurate to one unit in the last place through an analytical bit-width analysis methodology. Hardware realizations of various gamma correction designs are demonstrated on a Xilinx Virtex- 4 field-programmable gate array (FPGA). A pipelined 12 -bit input/ 8 -bit output design on an XC 4 VLX 100 - 12 FPGA occupies 146 slices and one digital signal processing slice. It is capable of performing 378 million gamma correction operations per second. Index Terms—Displays, field programmable gate arrays (FPGAs), fixed-point arithmetic, video signal processing. I...|$|R
5000|$|The {{example is}} a small {{combinatorial}} design, more specifically the binary to Gray code converter:def bin2gray(B, G, width): [...] """ [...] Gray encoder. B -- input intbv signal, binary encoded G -- output intbv signal, gray encoded width -- <b>bit</b> <b>width</b> [...] """ [...] @always_comb def logic (...) : Bext = intbv(0)width+1: Bext: = B for i in range(width): G.nexti = Bexti+1 ^ Bexti return logic ...|$|E
50|$|CPUs have a <b>bit</b> <b>width</b> {{which they}} are {{designed}} toward and can carry out bitwise operations in one cycle in this width. So, on a 64-bit or more CPU, 64-bit operations can occur in one instruction. There may be support for higher or lower width instructions. Many 32-bit CPUs may have some 64-bit instructions and those may take more than one cycle or otherwise be handicapped compared to their 32-bit instructions.|$|E
5000|$|Bit slicing is a {{technique}} for constructing a processor from modules of processors of smaller <b>bit</b> <b>width,</b> {{for the purpose of}} increasing the word length; in theory to make an arbitrary n-bit CPU. Each of these component modules processes one bit field or [...] "slice" [...] of an operand. The grouped processing components would then have the capability to process the chosen full word-length of a particular software design.|$|E
40|$|The {{synthesis}} of electronic circuits on system level offers {{the possibility to}} find better locations of the A/D interfaces and to determine parameters like clock rates and <b>bit</b> <b>widths.</b> KANDIS, a tool for (K) construction of mixed ANalog/DIgital Systems, uses a structureoriented expert system for these tasks. The main idea is the succesive construction on functional and algorithmic blocks with different kinds of tools and the permanent exchange of resource limitations with constraint propagation...|$|R
5000|$|ALGOL 68's elem {{operator}} {{is effectively}} [...] "MSB 1 bit numbering" [...] as the bits are numbered {{from left to}} right, with the first bit (bits elem 1) being the [...] "most significant bit", and the expression (<b>bits</b> elem <b>bits</b> <b>width)</b> giving the [...] "least significant bit". Similarly, when bits are coerced (typecast) to an array of Boolean (bool bits), the first element of this array (bitsbits) is again the [...] "most significant bit".|$|R
5000|$|The {{system was}} {{engineered}} {{to use as}} little core memory as possible, {{as it was a}} very expensive item. They used a memory system which had 25 <b>bits</b> <b>width,</b> and could be configured with from 8,192 words to 32,768 words of memory. Memory was built in stacks of 29 planes of 4,096 cores: 25 for the data word, two for [...] "modulo-3 check" [...] bits, and two for spares. Each memory cabinet held up to four stacks (16,384 words).|$|R
