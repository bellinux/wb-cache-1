143|858|Public
5|$|The language, and {{implementations}} thereof, {{should provide}} support for software engineering principles such as strong type checking, array <b>bounds</b> <b>checking,</b> detection of attempts to use uninitialized variables, and automatic garbage collection. Software robustness, durability, and programmer productivity are important.|$|E
5|$|The {{affected}} {{versions of}} OpenSSL allocate a memory buffer for {{the message to}} be returned based on the length field in the requesting message, {{without regard to the}} actual size of that message's payload. Because of this failure to do proper <b>bounds</b> <b>checking,</b> the message returned consists of the payload, possibly followed by whatever else {{happened to be in the}} allocated memory buffer.|$|E
25|$|A buffer {{overflow}} occurs when data written to a buffer also corrupts data values in memory addresses {{adjacent to the}} destination buffer due to insufficient <b>bounds</b> <b>checking.</b> This can occur when copying data from one buffer to another without first checking that the data fits within the destination buffer.|$|E
40|$|The {{ability to}} check memory {{references}} against their associated array/buffer bounds helps programmers to detect programming errors involving address overruns {{early on and}} thus avoid many difficult bugs down the line. This paper proposes a novel approach called Cash to the array <b>bound</b> <b>checking</b> problem that exploits the segmentation feature in the virtual memory hardware of the X 86 architecture. The Cash approach allocates a separate segment to each static array or dynamically allocated buffer, and generates the instructions for array references {{in such a way}} that the segment limit check in X 86 ’s virtual memory protection mechanism performs the necessary array <b>bound</b> <b>checking</b> for free. In those cases that hardware <b>bound</b> <b>checking</b> is not possible, it falls back to software <b>bound</b> <b>checking.</b> As a result, Cash does not need to pay per-reference software checking overhead in most cases. However, the Cash approach incurs a fixed set-up overhead for each use of an array, which may involve multiple array references. The existence of this overhead requires compiler writers to judiciously apply the proposed technique to minimize the performance cost of array <b>bound</b> <b>checking.</b> This paper presents the detailed design and implementation of the Cash compiler, and a comprehensive evaluation of various performance tradeoffs associated with the proposed array <b>bound</b> <b>checking</b> technique. For the set of complicated network applications we tested, including Apache, Sendmail, Bind, etc., the latency penalty of Cash’s <b>bound</b> <b>checking</b> mechanism is between 2. 5 % to 9. 8 % when compared with the baseline case that does not perform any <b>bound</b> <b>checking.</b> ...|$|R
40|$|Buffer {{overflow}} attacks {{cause serious}} security problems. Array & pointer <b>bound</b> <b>checking</b> {{is one of}} the most effective approaches for defending against buffer overflow attacks when source code is available. However; original array & pointer <b>bound</b> <b>checking</b> causes too much overhead since it is designed to catch memory errors and it puts too many checks. In this paper, we propose an efficient array & pointer <b>bound</b> <b>checking</b> strategy to defend against buffer overflow attacks. In our strategy, only the bounds of write operations are checked. We discuss the optimization strategy via hardware/software and conduct experiments. The experimental results show that our strategy can greatly reduce the overhead of array & pointer <b>bound</b> <b>checking.</b> Our conclusion is that based on our strategy, array & pointer <b>bound</b> <b>checking</b> can be a practical solution for defending systems against buffer overflow attacks with tolerable overhead. Department of ComputingRefereed conference pape...|$|R
40|$|Compiler {{optimization}} {{technology has}} been steadily advancing as more sophisticated processors hit the market. For high end embedded processors, today’s most advanced compilers take advantage of both CPU specific and application specific information to optimize code intelligently for optimal result. This paper discusses one such sophisticated optimization technique which combines array <b>bound</b> <b>check</b> optimization together with redundancy elimination combined with folding. The array <b>bound</b> <b>check</b> optimization described in this paper reduces the run time overhead by eliminating unnecessary <b>bound</b> <b>checks.</b> The results and comparisons demonstrate number of advantages of this method over the existing methods...|$|R
25|$|Programming {{languages}} {{commonly associated}} with buffer overflows include C and C++, which provide no built-in protection against accessing or overwriting data {{in any part of}} memory and do not automatically check that data written to an array (the built-in buffer type) is within the boundaries of that array. <b>Bounds</b> <b>checking</b> can prevent buffer overflows, but requires additional code and processing time. Modern operating systems use a variety of techniques to combat malicious buffer overflows, notably by randomizing the layout of memory, or deliberately leaving space between buffers and looking for actions that write into those areas ("canaries").|$|E
2500|$|Languages {{that are}} {{strongly}} typed and don't allow direct memory access, such as COBOL, Java, Python, and others, prevent buffer overflow from occurring in most cases. Many programming languages other than C/C++ provide runtime checking {{and in some}} cases even compile-time checking which might send a warning or raise an exception when C or C++ would overwrite data and continue to execute further instructions until erroneous results are obtained which might or might not cause the program to crash. [...] Examples of such languages include Ada, Eiffel, Lisp, Modula-2, Smalltalk, OCaml and such C-derivatives as Cyclone, Rust and D. The Java and [...]NET Framework bytecode environments also require <b>bounds</b> <b>checking</b> on all arrays. Nearly every interpreted language will protect against buffer overflows, signaling a well-defined error condition. Often where a language provides enough type information to do <b>bounds</b> <b>checking</b> an option is provided to enable or disable it. Static code analysis can remove many dynamic bound and type checks, but poor implementations and awkward cases can significantly decrease performance. Software engineers must carefully consider the tradeoffs of safety versus performance costs when deciding which language and compiler setting to use.|$|E
2500|$|Well-written {{and tested}} {{abstract}} data type libraries which centralize and automatically perform buffer management, including <b>bounds</b> <b>checking,</b> can reduce the occurrence and impact of buffer overflows. [...] The two main building-block data types in these languages in which buffer overflows commonly occur are strings and arrays; thus, libraries preventing buffer overflows in these data types can provide {{the vast majority of}} the necessary coverage. [...] Still, failure to use these safe libraries correctly can result in buffer overflows and other vulnerabilities; and naturally, any bug in the library itself is a potential vulnerability. [...] "Safe" [...] library implementations include [...] "The Better String Library", Vstr [...] and Erwin. The OpenBSD operating system's C library provides the strlcpy and strlcat functions, but these are more limited than full safe library implementations.|$|E
40|$|Abstract. We {{present a}} {{high-level}} approach to array <b>bound</b> <b>check</b> op-timization that is neither hampered by recursive functions, nor disabled {{by the presence}} of partially redundant checks. Our approach combines a forward analysis to infer precise contextual constraint at designated pro-gram points, and a backward method for deriving a safety pre-condition for each <b>bound</b> <b>check.</b> Both analyses are formulated {{with the help of a}} practical constraint solver based on Presburger formulae; resulting in an accurate and fully automatable optimization. The derived pre-conditions are also used to guide <b>bound</b> <b>check</b> specialization, for the purpose of elim-inating partially redundant checks. ...|$|R
40|$|Part 7 : Software Security and PrivacyInternational audienceUnsafe {{memory accesses}} in {{programs}} written using popular programming languages like C and C++ {{have been among}} the leading causes of software vulnerability. Memory safety checkers, such as Softbound, enforce memory spatial safety by checking if accesses to array elements are within the corresponding array <b>bounds.</b> However, such <b>checks</b> often result in high execution time overhead due to the cost of executing the instructions associated with the <b>bound</b> <b>checks.</b> To mitigate this problem, techniques to eliminate redundant <b>bound</b> <b>checks</b> are needed. In this paper, we propose a novel framework, SIMBER, to eliminate redundant memory <b>bound</b> <b>checks</b> via statistical inference. In contrast to the existing techniques that primarily rely on static code analysis, our solution leverages a simple, model-based inference to identify redundant <b>bound</b> <b>checks</b> based on runtime statistics from past program executions. We construct a knowledge base containing sufficient conditions using variables inside functions, which are then applied adaptively to avoid future redundant checks at a function-level granularity. Our experimental results on real-world applications show that SIMBER achieves zero false positives. Also, our approach reduces the performance overhead by up to 86. 94 % over Softbound, and incurs a modest 1. 7 % code size increase on average to circumvent the redundant <b>bound</b> <b>checks</b> inserted by Softbound...|$|R
40|$|<b>Bound</b> <b>checks</b> are {{introduced}} in {{programs for the}} run-time detection of array bound violations. Compiletime optimizations are employed to reduce the execution time overhead due to <b>bound</b> <b>checks.</b> The optimizations reduce the program execution time through elimination of checks and propagation of checks out of loops. An execution of the optimized program terminates with an array bound violation {{if and only if}} the same outcome would have resulted during the execution of the program containing all array <b>bound</b> <b>checks.</b> However, {{the point at which the}} array bound violation occurs may not be the same. Experimental results indicate that the number of <b>bound</b> <b>checks</b> performed during the execution of a program is greatly reduced using these techniques. Categories and Subject Descriptors: D. 2. 5 [Software Engineering]: Testing and Debugging-error handling and recovery; D. 3. 4 [Programming Languages]: Processors-optimization, compilers. General Terms: Languages, Reliability Additional Key Words and Phrase [...] ...|$|R
2500|$|Assembly and C/C++ {{are popular}} {{programming}} languages that {{are vulnerable to}} buffer overflow, {{in part because they}} allow direct access to memory and are not strongly typed. C provides no built-in protection against accessing or overwriting data in any part of memory; more specifically, it does not check that data written to a buffer is within the boundaries of that buffer. The standard C++ libraries provide many ways of safely buffering data, and C++'s Standard Template Library (STL) provides containers that can optionally perform <b>bounds</b> <b>checking</b> if the programmer explicitly calls for checks while accessing data. For example, a vector's member function at (...) performs a bounds check and throws an out_of_range exception if the bounds check fails. However, C++ behaves just like C if the bounds check is not explicitly called. Techniques to avoid buffer overflows also exist for C.|$|E
2500|$|Programming {{languages}} include {{features to}} help prevent bugs, such as static type systems, restricted namespaces and modular programming. For example, when a programmer writes (pseudocode) LET REAL_VALUE PI = [...] "THREE AND A BIT", although this may be syntactically correct, the code fails a type check. Compiled languages catch this without having to run the program. Interpreted languages catch such errors at runtime. Some languages deliberate exclude features that easily lead to bugs, {{at the expense of}} slower performance: the general principle being that, it is almost always better to write simpler, slower code than inscrutable code that runs slightly faster, especially considering that maintenance cost is substantial. For example, the Java programming language does not support pointer arithmetic; implementations of some languages such as Pascal and scripting languages often have runtime <b>bounds</b> <b>checking</b> of arrays, at least in a debugging build.|$|E
50|$|Because {{performing}} <b>bounds</b> <b>checking</b> during every usage is time-consuming, it is {{not always}} done. Bounds-checking elimination is a compiler optimization technique that eliminates unneeded <b>bounds</b> <b>checking.</b>|$|E
40|$|ABSTRACTArray <b>bound</b> <b>checking</b> is {{critical}} for code safety and debugging but users {{are not ready to}} trade much execution time forit. A considerable research work has been carried out during the past 25 years but experimental results are scarce. Com-mercial implementations are limited to intraprocedural array <b>bound</b> <b>checking</b> and are not really fulfilling user expectationsfor compilation and execution times. Instead of designing a new specific algorithm, we imple-mented two algorithms representative of the main published approaches by re-using static analysis techniques available inPIPS, an interprocedural parallelizer. The first algorithm is based on redundant <b>bound</b> <b>checking</b> elimination. The secondone is based on insertion of unavoidable tests. Results with the SPEC CFP 95 benchmarks show that com-mercial products could easily be improved using automatic analysis techniques and that user expectations can be ful-filled for most benchmarks. However, additional techniques should be used to obtain excellent results for all benchmarks. Our approach to optimize <b>bound</b> <b>checking</b> can also be ap-plied to other imperative languages such as Fortran, Pascal, Java when used for scientific applications. Keywordsarray reference, array <b>bound</b> <b>checking,</b> range checking, subscript out of range, bound violation, program verification. 1 INTRODUCTIONArray <b>bound</b> <b>checking</b> refers to determining whether all array references are within their declared range in all of theiruses in a program. These array <b>bound</b> <b>checks</b> may be analyzed intraprocedurally or interprocedurally, depending onthe need for accuracy. Such checking is desirable for any program, regardless of the language it is written in, sincebound violations are among the most common programming errors. Subscripting arrays beyond their declared sizes may result in unexpected results, security holes or failures. For the safetyof execution, some languages such as Java require that a program only be allowed to access elements of an array that arepart of the defined extent of the array...|$|R
40|$|Array <b>bound</b> <b>checking</b> is {{critical}} for code safety and debugging but users {{are not ready to}} trade much execution time for it. A considerable research work has been carried out during the past 25 years but experimental results are scarce. Commercial implementations are limited to intraprocedural array <b>bound</b> <b>checking</b> and are not really fulfilling user expectations for compilation and execution times...|$|R
40|$|We {{present a}} type-based {{approach}} to eliminating array <b>bound</b> <b>checking</b> and list tag checking by conservatively extending Standard ML with a restricted form of dependent types. This enables the programmer to capture more invariants through types while type-checking remains decidable {{in theory and}} can still be performed efficiently in practice. We illustrate our approach through concrete examples and present the result of our preliminary experiments which support support the feasibility and effectiveness of our approach. 1 Introduction The absence of run-time array <b>bound</b> <b>checks</b> is an infamous source of fatal errors for programs in languages such as C. Nonetheless, compilers offer the option to omit array <b>bound</b> <b>checks,</b> since they can {{turn out to be}} expensive in practice (Chow 1983; Gupta 1994). In statically typed languages such as ML, one would like to provide strong guarantees about the safety of all operations, so array <b>bound</b> <b>checks</b> cannot be omitted in general. The same is true for Ja [...] ...|$|R
50|$|<b>Bounds</b> <b>checking</b> is a compiler-based {{technique}} that adds run-time bounds information for each allocated block of memory, and checks all pointers against those at run-time. For C and C++, <b>bounds</b> <b>checking</b> {{can be performed}} at pointer calculation time or at dereference time.|$|E
5000|$|... "Fat" [...] {{pointers}} support pointer arithmetic with run-time <b>bounds</b> <b>checking</b> ...|$|E
5000|$|Pointer {{manipulation}} of buffers that {{may interfere with}} later <b>bounds</b> <b>checking,</b> e.g.: ...|$|E
40|$|We {{present an}} {{extension}} of field analysis (see [4]) called related field analysis which is a general technique for proving relationships between two or more fields of an object. We demonstrate the feasibility and applicability of related field analysis by applying it {{to the problem of}} removing array <b>bounds</b> <b>checks.</b> For array <b>bounds</b> <b>check</b> removal, we define a pair of related fields to be an integer field and an array field for which the integer field has a known relationship to the length of the array. This related field information can then be used to remove array <b>bounds</b> <b>checks</b> from accesses to the array field. Our results show that related field analysis can remove an average of 50 % of the dynamic array <b>bounds</b> <b>checks</b> {{on a wide range of}} applications. We describe the implementation of related field analysis in the Swift optimizing compiler for Java, as well as the optimizations that exploit the results of related field analysis. ...|$|R
40|$|Optimization of array <b>bound</b> <b>checking</b> at compile-time is {{performed}} {{in order to}} reduce the overhead of the run-time checking. There are many researches in this field but the results seem not very highly appreciated, even with the commercial compilers. This paper describes two techniques for array <b>bound</b> <b>checking</b> implemented in our research compiler PIPS. It also gives experimental results together with the comparison of different approaches...|$|R
40|$|We present L 0, {{a purely}} {{functional}} programing language supporting nested regular data parallelism and targeting massively parallel SIMD hardware such as modern graphics processing units (GPUs). L 0 incorporates the following novel features: • A type system for in-place modification and aliasing of arrays and array slices that ensures referential transparency, {{which in turn}} supports equational reasoning. • An assertion language for expressing <b>bounds</b> <b>checks</b> on dynamically allocated arrays, which can often be checked statically to eliminate dynamic <b>bounds</b> <b>checks.</b> • Compiler optimisations for hoisting <b>bounds</b> <b>checks</b> out of inner loops and performing loop fusion based on structural transformations. We show that: • The type system is simpler than existing linear and unique typin...|$|R
50|$|Bounds-checking elimination: Many languages, {{for example}} Java, enforce <b>bounds</b> <b>checking</b> of all array accesses. This is a severe {{performance}} bottleneck on certain {{applications such as}} scientific code. Bounds-checking elimination allows the compiler to safely remove <b>bounds</b> <b>checking</b> in many situations where it can determine that the index must fall within valid bounds, for example {{if it is a}} simple loop variable.|$|E
5000|$|Many {{programming}} languages, such as C, never perform automatic <b>bounds</b> <b>checking</b> {{to raise}} speed. However, this leaves many off-by-one errors and buffer overflows uncaught. Many programmers believe these languages sacrifice {{too much for}} rapid execution. In his 1980 Turing Award lecture, C. A. R. Hoare described his experience {{in the design of}} ALGOL 60, a language that included <b>bounds</b> <b>checking,</b> saying: ...|$|E
5000|$|The Java {{language}} requires specific {{behavior in}} the case of an out-of-bounds array access, which generally requires <b>bounds</b> <b>checking</b> of array accesses. This eliminates a possible source of instability but usually at the cost of slowing execution. In some cases, especially since Java 7, compiler analysis can prove a bounds check unneeded and eliminate it. C++ has no required behavior for out-of-bounds access of native arrays, thus requiring no <b>bounds</b> <b>checking</b> for native arrays. C++ standard library collections like std::vector, however, offer optional <b>bounds</b> <b>checking.</b> In summary, Java arrays are [...] "usually safe; slightly constrained; often have overhead" [...] while C++ native arrays [...] "have optional overhead; are slightly unconstrained; are possibly unsafe." ...|$|E
40|$|AbstractWhenever {{an array}} element is accessed, Java virtual {{machines}} execute a compare instruction {{to ensure that}} the index value is within the valid bounds. This reduces the execution speed of Java programs. Array <b>bounds</b> <b>check</b> elimination identifies situations in which such checks are redundant and can be removed. We present an array <b>bounds</b> <b>check</b> elimination algorithm for the Java HotSpot™ VM based on static analysis in the just-in-time compiler. The algorithm works on an intermediate representation in static single assignment form and maintains conditions for index expressions. It fully removes <b>bounds</b> <b>checks</b> if it can be proven that they never fail. Whenever possible, it moves <b>bounds</b> <b>checks</b> out of loops. The static number of checks remains the same, but a check inside a loop is likely to be executed more often. If such a check fails, the executing program falls back to interpreted mode, avoiding the problem that an exception is thrown at the wrong place. The evaluation shows a speedup near to the theoretical maximum for the scientific SciMark benchmark suite and also significant improvements for some Java Grande benchmarks. The algorithm slightly increases the execution speed for the SPECjvm 98 benchmark suite. The evaluation of the DaCapo benchmarks shows that array <b>bounds</b> <b>checks</b> do not {{have a significant impact on}} the performance of object-oriented applications...|$|R
40|$|We {{present a}} {{high-level}} approach to array <b>bound</b> <b>check</b> optimization that is neither hampered by recursive functions, nor disabled {{by the presence}} of partially redundant checks. Our approach combines a forward analysis to infer precise contextual constraint at designated program points, and a backward method for deriving a safety pre-condition for each <b>bound</b> <b>check.</b> Both analyses are formulated {{with the help of a}} practical constraint solver based on Presburger formula...|$|R
40|$|ABSTRACT Array <b>bound</b> <b>checking</b> is {{critical}} for code safety and debugging but users {{are not ready to}} trade much execution time for it. A considerable research work has been carried out during the past 25 years but experimental results are scarce. Commercial implementations are limited to intraprocedural array <b>bound</b> <b>checking</b> and are not really fulfilling user expectations fot compilation and execution times. Instead of designing a new specific algorithm, we implemented two algorithms representative of the main published approaches by re-using automatic parallelization techniques available in PIPS, an interprocedural parallelizer. The first algorithm is based on redundant <b>bound</b> <b>checking</b> elimination. The second one is based on insertion of unavoidable tests. Results with the SPEC CFP 95 benchmarks show that commercial products could easily be improved using automatic parallelization techniques and that user expectations can be fulfilled for most benchmarks. However, additional techniques would have be used to obtain excellent results for all benchmarks. Our approach to optimize <b>bound</b> <b>checking</b> can also be applied to other imperative languages such as Fortran, Pascal, Java when used for scientific applications...|$|R
5000|$|... string-manipulation routines, {{including}} [...] and , {{for lack}} of <b>bounds</b> <b>checking</b> and possible buffer overflows if the bounds aren't checked manually; ...|$|E
50|$|Mainstream {{languages}} that enforce {{run time}} checking include Ada, C#, Haskell, Java, JavaScript, Lisp, PHP, Python, Ruby, and Visual Basic. The D and OCaml languages have run time <b>bounds</b> <b>checking</b> that is enabled or disabled with a compiler switch. C# also supports unsafe regions: sections of code that (among other things) temporarily suspend <b>bounds</b> <b>checking</b> to raise efficiency. These {{are useful for}} speeding up small time-critical bottlenecks without sacrificing {{the safety of a}} whole program.|$|E
5000|$|Since arrays {{are always}} {{accessed}} (in effect) via pointers, array accesses are typically not checked against the underlying array size, although some compilers may provide <b>bounds</b> <b>checking</b> as an option. [...] Array bounds violations are therefore possible and rather common in carelessly written code, {{and can lead}} to various repercussions, including illegal memory accesses, corruption of data, buffer overruns, and run-time exceptions. If <b>bounds</b> <b>checking</b> is desired, it must be done manually.|$|E
40|$|Whenever {{an array}} element is accessed, Java virtual {{machines}} execute a compare instruction {{to ensure that}} the index value is within the valid bounds. This reduces the execution speed of Java programs. Array <b>bounds</b> <b>check</b> elimination identifies situations in which such checks are redundant and can be removed. We present an array <b>bounds</b> <b>check</b> elimination algorithm for the Java HotSpot TM VM based on static analysis in the just-in-time compiler. The algorithm works on an intermediate representation in static single assignment form and maintains conditions for index expressions. It fully removes <b>bounds</b> <b>checks</b> if it can be proven that they never fail. Whenever possible, it moves <b>bounds</b> <b>checks</b> out of loops. The static number of checks remains the same, but a check inside a loop is likely to be executed more often. If such a check fails, the executing program falls back to interpreted mode, avoiding the problem that an exception is thrown at the wrong place. The evaluation shows a speedup near to the theoretical maximum for the scientific SciMark benchmark suite (40 % on average). The algorithm also improves the execution speed for the SPECjvm 98 benchmark suite (2 % on average, 12 % maximum) ...|$|R
50|$|One common {{example is}} {{accessing}} an array element, modifying it, and storing the modified {{value in the}} same array at the same location. Normally, this example {{would result in a}} <b>bounds</b> <b>check</b> when the element is read from the array and a second <b>bounds</b> <b>check</b> when the modified element is stored using the same array index. Bounds-checking elimination could eliminate the second check if the compiler or runtime can determine that neither the array size nor the index could change between the two array operations.|$|R
40|$|Array <b>bound</b> <b>checking</b> is {{critical}} for code safety and debugging but users {{are not ready to}} trade much execution time for it. A considerable research work has been carried out during the past 25 years but experimental results are scarce. Commercial implementations are limited to intraprocedural array <b>bound</b> <b>checking</b> and are not really fullling user expectations fot compilation and execution times. Instead of designing a new specic algorithm, we implemented two algorithms representative of the main published approaches by re-using automatic parallelization techniques available in PIPS, an interprocedural parallelizer. The rst algorithm is based on redundant <b>bound</b> <b>checking</b> elimination. The second one is based on insertion of unavoidable tests. Results with the SPEC CFP 95 benchmarks show that commercial products could easily be improved using automatic parallelization techniques and that user expectations can be fullled for most benchmarks. However, additional techniques would have be [...] ...|$|R
