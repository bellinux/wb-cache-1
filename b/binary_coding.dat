237|5012|Public
25|$|The Selectric {{mechanism}} was {{notable for}} using internal mechanical <b>binary</b> <b>coding</b> and two mechanical digital-to-analog converters, called whiffletree linkages, {{to select the}} character to be typed.|$|E
5000|$|... #Caption: Fibonacci, Elias Gamma, and Elias Delta vs <b>binary</b> <b>coding</b> ...|$|E
5000|$|Bencode {{is a very}} {{specialized}} kind of <b>binary</b> <b>coding</b> {{with some}} unique properties: ...|$|E
40|$|AbstractSome nontrivial {{properties}} of perfect <b>binary</b> <b>codes</b> are discussed. We consider some constructions of perfect <b>binary</b> <b>codes</b> {{with the purpose}} to outline bounds {{on the number of}} nonequivalent perfect <b>binary</b> <b>codes</b> and we present the best known lower and upper bounds on the number of different perfect <b>binary</b> <b>codes...</b>|$|R
40|$|The paper {{approaches}} the low-level {{details of the}} code generated by compilers whose format permits outside actions. <b>Binary</b> <b>code</b> modifications are manually done when the internal format is known and understood, or automatically by certain tools developed to process the <b>binary</b> <b>code.</b> The <b>binary</b> <b>code</b> instrumentation goals may be various from security increasing and bug fixing to development of malicious software. The paper highlights the <b>binary</b> <b>code</b> instrumentation techniques by code injection to increase the security and reliability of a software application. Also, the paper offers examples for <b>binary</b> <b>code</b> formats understanding and how the <b>binary</b> <b>code</b> injection may be applied...|$|R
40|$|Different {{strategies}} for binary analysis {{are widely used}} in systems dealing with software maintenance and system security. <b>Binary</b> <b>code</b> is self-contained; though {{it is easy to}} execute, {{it is not easy to}} read and understand. Binary analysis tools are useful in software maintenance because the binary of software has all the information necessary to recover the source code. It is also incredibly important and sensitive in the domain of security. Malicious <b>binary</b> <b>code</b> can infect other applications, hide in their <b>binary</b> <b>code,</b> contaminate the whole system or travel through Internet and attack other systems. This makes it imperative for security personnel to scan and analyze <b>binary</b> <b>codes</b> with the aid of the <b>binary</b> <b>code</b> analysis tools. On the other hand, crackers can reverse engineer the <b>binary</b> <b>code</b> to assembly code in order to break the secrets embedded in the <b>binary</b> <b>code,</b> such as registration number, password or secret algorithms. This motivates researches to prevent malicious monitoring by <b>binary</b> <b>code</b> analysis tools. Evidently, binary analysis tools play an important doublesided role in security. This paper surveys <b>binary</b> <b>code</b> analysis from the most fundamental perspective views: the <b>binary</b> <b>code</b> formats, several of the most basic analysis tools, such as disassembler, debugger and the instrumentation tools based on them. The previous research on binary analysis are investigated and summarized and a new approach of analysis, disasembler-based binary interpreter, is proposed and discussed. 1...|$|R
5000|$|A {{bipolar signal}} {{may have a}} two-state non-return-to-zero (NRZ) or a {{three-state}} return-to-zero (RZ) <b>binary</b> <b>coding</b> scheme.|$|E
50|$|There {{is also a}} mixed version {{where the}} code is binary, but the {{transport}} layer is SOAP. This is a compromise between efficient <b>binary</b> <b>coding</b> and firewall-friendly transmission. <b>Binary</b> <b>coding</b> always requires UA Secure Conversation.The authentication uses X.509 certificates exclusively. It relies on the application developer to choose which certificate store the UA application gets bound to. For instance, {{it is possible to}} use the public key infrastructure (PKI) of an Active Directory.|$|E
50|$|The Selectric {{mechanism}} was {{notable for}} using internal mechanical <b>binary</b> <b>coding</b> and two mechanical digital-to-analog converters, called whiffletree linkages, {{to select the}} character to be typed.|$|E
30|$|Hinton et al. [34] {{describe}} a Deep Learning generative model {{to learn the}} <b>binary</b> <b>codes</b> for documents. The lowest layer of the Deep Learning network represents the word-count vector of the document which accounts as high-dimensional data, while the highest layer represents the learnt <b>binary</b> <b>code</b> of the document. Using 128 -bit codes, the authors demonstrate that the <b>binary</b> <b>codes</b> of the documents that are semantically similar lay relatively closer in the Hamming space. The <b>binary</b> <b>code</b> of the documents can then be used for information retrieval. For each query document, its Hamming distance compared to all other documents in the data is computed and the top D similar documents are retrieved. <b>Binary</b> <b>codes</b> require relatively little storage space, and in addition they allow relatively quicker searches by using algorithms such as fast-bit counting to compute the Hamming distance between two <b>binary</b> <b>codes.</b> The authors conclude that using these <b>binary</b> <b>codes</b> for document retrieval is more accurate and faster than semantic-based analysis.|$|R
30|$|Instead {{of using}} a code with base 3 to encode the three states, LTP uses two <b>binary</b> <b>codes</b> {{representing}} the positive and the negative components of the ternary <b>code,</b> i.e., two <b>binary</b> <b>codes</b> coding for the two states {- 1, 1 }. These <b>binary</b> <b>codes</b> are collected in two separate histograms and, as a last step, the histograms are concatenated to form the LTP feature vector.|$|R
40|$|Some {{mutually}} quasi-unbiased weighing matrices {{are constructed}} from <b>binary</b> <b>codes</b> satisfying certain conditions. Motivated by this, in this note, we study <b>binary</b> <b>codes</b> satisfying the conditions. The weight distributions of <b>binary</b> <b>codes</b> satisfying {{the conditions are}} determined. We also give a classification of <b>binary</b> <b>codes</b> of lengths $ 8, 16 $ and <b>binary</b> maximal <b>codes</b> of length $ 32 $ satisfying the conditions. As an application, sets of $ 8 $ mutually quasi-unbiased weighing matrices for parameters $(16, 16, 4, 64) $ and $ 4 $ mutually quasi-unbiased weighing matrices for parameters $(32, 32, 4, 256) $ are constructed for the first time. Comment: 14 page...|$|R
50|$|Signs of the Inka Khipu: <b>Binary</b> <b>Coding</b> in the Andean Knotted-String Records. Austin, TX: University of Texas Press, 2003. Spanish edition: Signos del Khipu Inka: Codigo Binario. Cusco, Peru: Centro Bartolome de las Casas, 2005.|$|E
50|$|CVT16 is a {{revision}} of part of the SSE5 instruction set proposal announced on August 30, 2007, which is supplemented by the XOP and FMA4 instruction sets. This revision makes the <b>binary</b> <b>coding</b> of the proposed new instructions more compatible with Intel's AVX instruction extensions, while the functionality of the instructions is unchanged.|$|E
50|$|State encoding: The {{complexity}} of the combinational logic depends on the assignment of codes {{to each of the}} states in the FSM. This is also referred to as state assignment. A good state assignment reduces the cost of implementation significantly. There are many encoding techniques such as Gray coding, <b>Binary</b> <b>coding,</b> One-Hot coding, etc.|$|E
40|$|We give a {{classification}} of singly-even self-dual <b>binary</b> <b>codes</b> of length 32, by enumerating all neighbours {{of the known}} 85 doubly-even self-dual <b>binary</b> <b>codes</b> of length 32. There are 3, 210 singly-even self-dual <b>binary</b> <b>codes</b> of length 32 up to equivalence. This agrees in number with the enumeration by Bilous and van Rees, who enumer-ated these codes by a different method. ...|$|R
40|$|Binary {{encoding}} on high-dimensional {{data points}} has {{attracted much attention}} due to its computational and storage efficiency. While numerous efforts {{have been made to}} encode data points into <b>binary</b> <b>codes,</b> how to calculate the effective distance on <b>binary</b> <b>codes</b> to approximate the original distance is rarely addressed. In this paper, we propose an effective distance measurement for <b>binary</b> <b>code</b> ranking. In our approach, the <b>binary</b> <b>code</b> is firstly decomposed into multiple sub codes, each of which generates a query-dependent distance lookup table. Then the distance between the query and the <b>binary</b> <b>code</b> is constructed as the aggregation of the distances from all sub codes by looking up their respective tables. The entries of the lookup tables are optimized by minimizing the misalignment between the approximate distance and the original distance. Such a scheme is applied to both the symmetric distance and the asymmetric distance. Extensive experimental results show superior performance of the proposed approach over state-of-the-art methods on three real-world high-dimensional datasets for <b>binary</b> <b>code</b> ranking...|$|R
40|$|We {{explore the}} {{connection}} between simple polytopes and self-dual <b>binary</b> <b>codes</b> via the theory of small covers. We first show that a small cover M^n over a simple n-polytope P^n produces a self-dual code {{in the sense of}} Kreck-Puppe if and only if P^n is n-colorable and n is odd. Then we show how to describe such a self-dual <b>binary</b> <b>code</b> in terms of the combinatorial information of P^n. Moreover, we can define a family of <b>binary</b> <b>codes</b> B_k(P^n), 0 ≤ k≤ n, from an arbitrary simple n-polytope P^n. We will give some necessary and sufficient conditions for B_k(P^n) to be a self-dual code. A spinoff of our study of such <b>binary</b> <b>codes</b> gives some new ways to judge whether a simple n-polytope P^n is n-colorable in terms of the associated <b>binary</b> <b>codes</b> B_k(P^n). In addition, we prove that the minimum distance of the self-dual <b>binary</b> <b>code</b> obtained from a 3 -colorable simple 3 -polytope is always 4. Comment: 27 pages, 5 figure...|$|R
5000|$|<b>Binary</b> <b>coding</b> {{systems of}} complex numbers, i. e. systems with the digits , are of {{practical}} interest.Listed below are some coding systems [...] (all are special {{cases of the}} systems above) and resp. codes for the (decimal) numbers [...]The standard binary (which requires a sign) and the [...] "negabinary" [...] systems are also listed for comparison. They {{do not have a}} genuine expansion for [...]|$|E
50|$|The first {{transmission}} of speech by digital techniques, the SIGSALY encryption equipment, conveyed high-level Allied communications during World War II. In 1943 the Bell Labs researchers {{who designed the}} SIGSALY system {{became aware of the}} use of PCM <b>binary</b> <b>coding</b> as already proposed by Alec Reeves. In 1949, for the Canadian Navy's DATAR system, Ferranti Canada built a working PCM radio system that was able to transmit digitized radar data over long distances.|$|E
50|$|Different {{versions}} of the mill are intended for different markets, and {{are said to have}} different instruction set architectures, different numbers of execution units, different pipeline timings, and thus, very different binaries. To accommodate these, compilers are required to emit a specification which is then recompiled into an executable binary by a recompiler supplied by the Mill Computing company. In this way, code that can be distributed is adapted to specifics of the exact model's pipeline, <b>binary</b> <b>coding,</b> etc.|$|E
50|$|Build {{automation}} is {{the process}} of automating the creation of a software build and the associated processes including: compiling computer source <b>code</b> into <b>binary</b> <b>code,</b> packaging <b>binary</b> <b>code,</b> and running automated tests.|$|R
30|$|In our implementation, as {{described}} above, the interval coded with zero is half-bound while in [21] it is open. Instead {{of using a}} code with base 3 to encode the three states in Eq. 5, LTP uses two <b>binary</b> <b>codes</b> representing the positive and the negative components of the ternary <b>code,</b> i.e., two <b>binary</b> <b>codes</b> coding for the two states {− 1, 1 }. These <b>binary</b> <b>codes</b> are collected in two separate histograms, and as a last step, the histograms are concatenated to form the LTP feature vector [21].|$|R
40|$|Abstract—We {{investigate}} a <b>binary</b> <b>code,</b> which is implemented by serially concatenating a multiplexer, a multilevel delay proces-sor, and a signal mapper to a binary turbo encoder. To achieve improved convergence behavior, we modify the <b>binary</b> <b>code</b> by passing {{only a fraction}} of the bits in the turbo code through the multilevel delay processor and the signal mapper. Two decoding methods are discussed and their performances are evaluated. Index Terms—Turbo <b>codes,</b> concatenated <b>codes,</b> <b>binary</b> <b>codes.</b> I...|$|R
5000|$|Rare or Threatened Australian Plants, usually {{abbreviated}} to ROTAP, {{is a list}} of rare or threatened Australian plant taxa. Developed and maintained by the CSIRO, the most recent edition lists 5031 taxa. The list uses a <b>binary</b> <b>coding</b> system based on the IUCN Red List categories for [...] "Presumed Extinct", [...] "Endangered", [...] "Vulnerable", [...] "Rare" [...] or [...] "Poorly Known". However, it also provides for additional information such as geographic range and occurrence in protected areas.|$|E
50|$|In typical machine {{learning}} algorithms, these functions produce a scalar output. Recent development of kernel methods for functions with vector-valued output is due, {{at least in}} part, to interest in simultaneously solving related problems. Kernels which capture {{the relationship between the}} problems allow them to borrow strength from each other. Algorithms of this type include multi-task learning (also called multi-output learning or vector-valued learning), transfer learning, and co-kriging. Multi-label classification can be interpreted as mapping inputs to (<b>binary)</b> <b>coding</b> vectors with length equal to the number of classes.|$|E
5000|$|Gray Encoding: The address {{lines of}} a bus {{in most of the}} {{computing}} systems increase in consecutive numerical values due to spatial locality. If we use regular <b>binary</b> <b>coding</b> for the bus, we are not assured of minimal hamming distance between 2 consecutive addresses. Using gray codes for encoding the address lines will lead to a hamming distance of 1 between any 2 consecutive address bus values (as long as spatial locality holds). There are variations to this scheme named Shifted gray encoding to reduce the delay overhead.|$|E
40|$|Hashing based {{methods have}} {{attracted}} considerable attention for efficient cross-modal retrieval on large-scale multimedia data. The core problem of cross-modal hashing {{is how to}} learn compact <b>binary</b> <b>codes</b> that construct the underlying correlations between heterogeneous features from different modalities. A majority of recent approaches aim at learning hash functions to preserve the pairwise similarities defined by given class labels. However, these methods fail to explicitly explore the discriminative property of class labels during hash function learning. In addition, they usually discard the discrete constraints imposed on the to-be-learned <b>binary</b> <b>codes,</b> and compromise to solve a relaxed problem with quantization to obtain the approximate binary solution. Therefore, the <b>binary</b> <b>codes</b> generated by these methods are suboptimal and less discriminative to different classes. To overcome these drawbacks, we propose a novel cross-modal hashing method, termed discrete cross-modal hashing (DCH), which directly learns discriminative <b>binary</b> <b>codes</b> while retaining the discrete constraints. Specifically, DCH learns modality-specific hash functions for generating unified <b>binary</b> <b>codes,</b> and these <b>binary</b> <b>codes</b> are viewed as representative features for discriminative classification with class labels. An effective discrete optimization algorithm is developed for DCH to jointly learn the modality-specific hash function and the unified <b>binary</b> <b>codes.</b> Extensive experiments on three benchmark data sets highlight the superiority of DCH under various cross-modal scenarios and show its state-of-the-art performance. </p...|$|R
40|$|In this paper, the undetected error {{probability}} for large <b>binary</b> <b>codes</b> is studied. It is shown {{that if the}} size of the code is sufficiently large (for given length), then the code is good for error detection (in the technical sense). Index Terms- Undetected {{error probability}}, error detection, <b>binary</b> <b>codes,</b> good codes. ...|$|R
40|$|In this paper, we {{introduce}} a Graph based <b>Binary</b> <b>Code</b> Execution Path Exploration Platform. In the graph, a node {{is defined as}} a conditional branch instruction, and an edge is defined as the other instructions. We implemented prototype of the proposed method and works well on real <b>binary</b> <b>code.</b> Experimental results show proposed method correctly explores execution path of target <b>binary</b> <b>code.</b> We expect our method can help Software Assurance, Secure Programming, and Malware Analysis mor...|$|R
50|$|For counters, Gray coding gives minimum {{switching}} activity, {{and thus}} is suitable for low-power designs. Gray encoding suits best when state change are sequential. In arbitrary state changing, FSM Gray code fails for low-power designs. For such FSM, one-hot encoding guarantees switching of two bits for every state change. But since the number of state variables needed {{is equal to the}} number of states, as states increase, one-hot encoding becomes an impractical solution, mainly because with an increased number of inputs and outputs to the circuit, complexity and capacitive load increase. <b>Binary</b> <b>coding</b> is worst for low power since the maximum Hamming distance is equal to the number of state variables.|$|E
5000|$|Directional survey {{measurements}} are taken by three orthogonally mounted accelerometers to measure inclination, and three orthogonally mounted magnetometers which measure direction (azimuth). Gyroscopic tools {{may be used}} to measure Azimuth where the survey is measured in a location with disruptive external magnetic influences, inside [...] "casing", for example, where the hole is lined with steel tubulars (tubes). These sensors, as well as any additional sensors to measure rock formation density, porosity, pressure or other data, are connected, physically and digitally, to a logic unit which converts the information into binary digits which are then transmitted to surface using [...] "mud pulse telemetry" [...] (MPT, a <b>binary</b> <b>coding</b> transmission system used with fluids, such as, combinatorial, Manchester encoding, split-phase, among others).|$|E
5000|$|The n-ary Huffman {{algorithm}} {{uses the}} {0, 1, ... n − 1} alphabet to encode message and build an n-ary tree. This approach was considered by Huffman in his original paper. The same algorithm applies as for binary (n equals 2) codes, {{except that the}} n least probable symbols are taken together, instead of just the 2 least probable. Note that for n greater than 2, not all sets of source words can properly form an n-ary tree for Huffman coding. In these cases, additional 0-probability place holders must be added. This is because the tree must form an n to 1 contractor; for <b>binary</b> <b>coding,</b> this is a 2 to 1 contractor, and any sized set can form such a contractor. If the number of source words is congruent to 1 modulo n-1, then the set of source words will form a proper Huffman tree.|$|E
40|$|Binary hashing {{has been}} widely used for {{efficient}} simi-larity search due to its query and storage efficiency. In most existing binary hashing methods, the high-dimensional da-ta are embedded into Hamming space and the distance or similarity of two points are approximated by the Hamming distance between their <b>binary</b> <b>codes.</b> The Hamming dis-tance calculation is efficient, however, in practice, there are often lots of results sharing the same Hamming distance to a query, which makes this distance measure ambiguous and poses a critical issue for similarity search where ranking is important. In this paper, we propose a weighted Hamming distance ranking algorithm (WhRank) to rank the <b>binary</b> <b>codes</b> of hashing methods. By assigning different bit-level weights to different hash bits, the returned <b>binary</b> <b>codes</b> are ranked at a finer-grained <b>binary</b> <b>code</b> level. We give an algorithm to learn the data-adaptive and query-sensitive weight for each hash bit. Evaluations on two large-scale image data sets demonstrate the efficacy of our weighted Hamming distance for <b>binary</b> <b>code</b> ranking. 1...|$|R
40|$|This paper tackles the {{efficiency}} problem of making recom-mendations {{in the context}} of large user and item spaces. In particular, we address the problem of learning <b>binary</b> <b>codes</b> for collaborative filtering, which enables us to effi-ciently make recommendations with time complexity that is independent {{of the total number of}} items. We propose to construct <b>binary</b> <b>codes</b> for users and items such that the preference of users over items can be accurately preserved by the Hamming distance between their respective <b>binary</b> <b>codes.</b> By using two loss functions measuring the degree of divergence between the training and predicted ratings, we formulate the problem of learning <b>binary</b> <b>codes</b> as a discrete optimization problem. Although this optimization problem is intractable in general, we develop effective relaxations that can be efficiently solved by existing methods. Moreover, we investigate two methods to obtain the <b>binary</b> <b>codes</b> from the relaxed solutions. Evaluations are conducted on three public-domain data sets and the results suggest that our pro-posed method outperforms several baseline alternatives...|$|R
50|$|Executor {{translates}} 68k big-endian <b>binary</b> <b>code</b> into x86 little-endian <b>binary</b> <b>code.</b> Executor {{can only}} run Macintosh {{programs designed to}} run on 68000-based Macintosh hardware. Executor can mimic either Macintosh System 7.0.0, or System 6.0.7 for older applications that are incompatible with System 7.0.0.|$|R
