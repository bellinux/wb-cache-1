61|87|Public
5000|$|Depending on how {{the system}} failed, there can be two {{different}} recovery procedures used. Generally, the procedures involves restoring data that has been collected from a backup device and then running the transaction processing again. Two types of recovery are <b>backward</b> <b>recovery</b> and forward recovery: ...|$|E
40|$|Compensation {{is widely}} used in {{advanced}} transaction models {{as a means of}} <b>backward</b> <b>recovery</b> from a failure. However, traditional compensation notions are not sufficient for handling failures in business processes if state changes involve consumable resources that cannot be undone. This paper presents a <b>backward</b> <b>recovery</b> mechanism to support the business process management domain. The proposed mechanism resets a business process to an acceptable state by re-executing all or a part of its activities that are failed or already completed successfully. The paper classifies <b>backward</b> <b>recovery</b> types into compensate, rework, and complement, and discusses their semantics. Then, the paper classifies the types of process activities based on resource constraints. By exploiting the meaning of activity types and <b>backward</b> <b>recovery</b> types, the paper presents guidelines that determine if a business process can be restored to an acceptable state...|$|E
40|$|A general model {{allowing}} a unified understanding of programmed exception handling (forward recovery) and default exception handling (<b>backward</b> <b>recovery)</b> in systems structured as hierarchies of data abstrac-tions is presented. The cause-effect relationship between software design faults and failure occu-rrences is explored and {{the adequacy of}} <b>backward</b> <b>recovery</b> in providing effective software-fault tolerance is discussed...|$|E
40|$|This survey covers <b>backward</b> error <b>recovery</b> {{techniques}} for distributed systems specially the distributed mobile systems. <b>Backward</b> error <b>recovery</b> protocols have been classified into user triggered checkpointing and transparent checkpointing. Transparent checkpointing can be uncoordinated checkpointing, Coordinated checkpointing, Quasi Synchronous or communication-induced checkpointing and Message Logging based Checkpointing. Through out this survey we, highlight the research {{issues that are}} at the core of <b>backward</b> error <b>recovery</b> and present the solutions that currently address them...|$|R
40|$|For {{implementing}} fault-tolerance in multicomputer systems, <b>backward</b> error <b>recovery,</b> {{based on}} checkpointing and rollback, is often used. During failurefree operation, the process states are regularly saved, {{and after a}} fault is detected, the system is rolled back to a previously saved state. We can distinguish four classes of techniques: semi-automatic techniques, message logging, coordinated checkpointing and hybrid techniques. In this paper a survey is given, and the possibly involved overhead is discussed. This will allow the user to choose an optimal checkpointing and rollback technique for given facilities and applications. Keywords [...] -fault-tolerance, <b>backward</b> error <b>recovery,</b> checkpointing, rollback 1. Introduction Fault-tolerance is essential to work reliably, because {{the probability that a}} failure occurs is not negligible in large systems. Implementing fault-tolerance in multicomputers (multiprocessors as well as distributed systems) by <b>backward</b> error <b>recovery</b> {{can be seen as a}} [...] ...|$|R
40|$|This paper {{deals with}} human error resistance. In {{the first part}} of it, a short state-of-theart of human error resistance, i. e., error {{prevention}} and error correction will be presented. Then, error correction, which is usually divided into three sequential tasks: detection, explanation, and recovery will be described. The second part of the paper will put emphasis on error recovery, which is our main object of study. First and foremost, through an example, we will see what makes the distinction between forward and <b>backward</b> error <b>recovery,</b> i. e., how the system is able to restore its previous state after an error occurrence. In addition to it, the three different kinds of <b>backward</b> error <b>recovery</b> [...] undo, cancel, and stop [...] will be illustrated. Then, the limits of the current distinction between forward and <b>backward</b> error <b>recovery</b> will be highlighted. As a consequence, the paper proposes a new representation of error recovery based on two dimensions: error additional cost and [...] ...|$|R
40|$|The Distributed Systems Technology Centre (DSTC) {{framework}} for workflow specification, verification and management captures workflows transaction-like behavior for long lasting processes. FlowBack is an advanced prototype functionally enhancing an existing workflow management system by providing process <b>backward</b> <b>recovery.</b> It {{is based on}} extensive theoretical research ([3], [4], [5], [6], [8], [9]), and its architecture and construction assumptions are product independent. FlowBack clearly demonstrates {{the extent to which}} generic <b>backward</b> <b>recovery</b> can be automated and system supported. The provision of a solution for handling exceptional business process behavior requiring <b>backward</b> <b>recovery</b> makes workflow solutions more suitable for a large class of applications, therefore opening up new dimensions within the market. For the demonstration purpose, FlowBack operates with IBM FlowMark, one of the leading workflow products...|$|E
40|$|This paper {{describes}} experiences {{from the}} implementation of <b>backward</b> <b>recovery</b> for a commercial production workflow system. As {{a result of our}} research we found that compensation based backwards recovery is the most suitable approach for an external solution. Most importantly, the work has demonstrated that providing business level <b>backward</b> <b>recovery</b> is possible in the workflow domain, and that external, design-level work is relevant for product enhancement. The production workflow system used for {{the implementation of}} our work is IBM MQ Workflow. The advanced prototype is named FlowBack...|$|E
30|$|Design issue III - {{execution}} of variants: Variants can be executed either sequentially or in parallel. The execution schemes should provide all variants with {{exactly the same}} experience of the system state when their respective executions start to ensure consistency of input data (Nascimento et al. [2013]), which be {{can be achieved by}} employing <b>backward</b> <b>recovery</b> or forward recovery (Section 5). Sequential {{execution of}}ten requires the use of checkpoints (it usually employs <b>backward</b> <b>recovery),</b> and parallel execution often requires the use of algorithms to ensure consistency of input data (it usually employs forward recovery by invoking all the variants and coordinating their execution through a synchronization regime) (Pullum [2001]; Wilfredo [2000]).|$|E
40|$|It {{is pointed}} out that the {{increasing}} computation power and rapidly falling cost of microprocessors and memories have given an impetus to the development of distributed computing systems. There are a number of potential benefits. A number of issues have to be resolved, however, before the full potential of a distributed processing system can be realized. The present investigation is concerned with one such issue, taking into account the effectiveness of implementing recovery blocks (RB's) in <b>backward</b> error <b>recovery</b> for a set of cooperating processes. A quantitative evaluation of three different recovery blocks employed in <b>backward</b> error <b>recovery</b> for concurrent processing is performed...|$|R
40|$|Abstract. This paper {{deals with}} human error resistance. In {{the first part}} of it, a short state-ofthe-art of human error resistance, i. e., error {{prevention}} and error correction will be presented. Then, error correction, which is usually divided into three sequential tasks: detection, explanation, and recovery will be described. The second part of the paper will put emphasis on error recovery, which is our main object of study. First and foremost, through an example, we will see what makes the distinction between forward and <b>backward</b> error <b>recovery,</b> i. e., how the system is able to restore its previous state after an error occurrence. In addition to it, the three different kinds of <b>backward</b> error <b>recovery</b> – undo, cancel, and stop – will be illustrated. Then, the limits of the current distinction between forward and <b>backward</b> error <b>recovery</b> will be highlighted. As a consequence, the paper proposes a new representation of error recovery based on two dimensions: error additional cost and system state degradation. In the context of time-critical systems, another dimension will be introduced: time. 1...|$|R
40|$|We {{consider}} {{the problem of}} defining and, most important, of using, the <b>backward</b> error <b>recovery</b> technique, in a concurrent (and distributed) Ada program. The best known <b>backward</b> error <b>recovery</b> technique for concurrent programs is the conversation, the implementation of which {{is presented in the}} first part of the paper. However, the conversation scheme can be insufficient for implementing non determinism and for satisfying certain fault tolerant requirements. In the second part of the paper, we analyze well-known programming paradigms, such as the dinining philosophers and the producer-consumer. A number of problems are pointed out, which require an extension of the conversation scheme and the integration with other fault tolerance mechanisms, in order to reach a higher degree of reliability...|$|R
40|$|International audienceFailures {{during the}} {{execution}} of Transactional Composite Web Services (TCWSs) can be repaired by forward or back–ward recovery processes, according to the component WSs transactional properties. In previous works, we presented TCWS fault tolerant execution approaches relying on WSs replacement, on a compensation protocol, and on unrolling processes of Colored Petri-Nets (CPNs) to support forward and <b>backward</b> <b>recovery.</b> We represent a TCWS and its corresponding <b>backward</b> <b>recovery</b> process by CPNs. Even though these recovery processes ensure system consistency, <b>backward</b> <b>recovery</b> means that users do not get the desired answer to their queries and forward recovery could imply long waiting time for users to ﬁnally get the desired response. In this paper, we present an alternative fault tolerant approach in which, in case of failures, the unrolling process of the CPN controlling {{the execution of}} a TCWS is check–pointed and the execution ﬂow goes on {{as much as it}} is possible. In this way, users can have partial responses as soon as they are received and can re-submit the checkpointed CPN to re-start its execution from an advanced point of execution (checkpoint). We present the checkpointing algorithm integrated to our previous work...|$|E
40|$|The {{notion of}} {{compensation}} {{is widely used}} as means of <b>backward</b> <b>recovery</b> in long-lived transactions as well as business processes supported by workflow management systems. In general, it is non-trivial to design compensating tasks for tasks {{in the context of}} a workflow. Actually, a task does not have to be compensatable. In this paper we first look into the requirements that a compensating task has to satisfy. Then we introduce a new mechanism called confirmation. With the help of confirmation, we can modify some non-compensatable tasks so that they become compensatable. This greatly improves <b>backward</b> <b>recovery</b> for workflow applications in case of failures. To effectively incorporate confirmation and compensation into the workflow management environment, a three level bottom-up workflow design method is introduced. The implementation issues of this design are also discussed...|$|E
30|$|Error {{recovery}} {{is the process}} in which the erroneous state is substituted with an error-free state (Lee and Anderson [1990]). Error {{recovery is}} performed using either <b>backward</b> <b>recovery</b> or forward recovery. On the one hand, <b>backward</b> <b>recovery</b> attempts to return the system to a correct or error-free state by restoring or rolling back the system to a previously saved state, which is assumed to be error-free. On the other hand, forward recovery attempts to return the system to a correct or error-free state by finding a new state from which the system can continue operation. Compared to backward error recovery, forward recovery is usually more efficient in terms of the overhead (e.g. time and memory) it imposes (Lee and Anderson [1990]). On the other hand, it is usually not possible to design general forward recovery mechanisms.|$|E
40|$|We {{present a}} {{quantitative}} comparison of two popular approaches for recovering from CPU errors: Quadruple Modular Redundancy and <b>Backward</b> Error <b>Recovery.</b> Both {{are used in}} existing fault-tolerant systems offering basically the same main features and, in particular, the same fault-tolerance services (transparent recovery for hardware faults). We show {{that the use of}} performability measures is richer than classical dependability analysis. Given that they take into account not only reliability aspects but also performance metrics, they allow a deeper insight into the behaviour of the considered systems. For instance, they allow the user to identify different mission lengths leading to better adaptation of each type of architecture. Key-words: <b>Backward</b> error <b>recovery,</b> dependability measures, fault-tolerant computing systems, performability, quadruple modular redundancy, repairable systems. (R'esum'e : tsvp) CENTRE NATIONAL DE LA RECHERCHE SCIENTIFIQUE Centre National de la Recherche Sci [...] ...|$|R
40|$|Fault-tolerant {{techniques}} are often employed to pro-vide predictable {{performance in the}} presence of mal-function of embedded real-tame systems. Our research addresses the problem of restoring real-time systems to a prior state when a fault generates errors. I n this paper, we first define the state restoration problem in real-time systems, explaining when is necessary to re-store a real-time system to a prior state. W e then make a thorough comparison of two important state restora-tion schemes, viz. <b>backward</b> error <b>recovery</b> and failure recovery, in an integrated framework. The comparisons give us an an-depth study of both schemes and allow us to characterize the kinds of fault-tolerant problems in real-time applications that each scheme is best suited to deal with. Finally, we propose a novel technique to avoid the domino effect that m a y arise when <b>backward</b> error <b>recovery</b> takes place. ...|$|R
40|$|Atomic actions {{represents}} {{a powerful tool}} for system structuring, controlling accesses to shared data implementing <b>backward</b> error <b>recovery</b> techniques. In this paper properties of atomic actions are analyzed, specifically referring to crash recovery problems. In order to guarantee consistency of shared data in spite of crashes, programs implementing atomic actions must satisfy some constraints...|$|R
40|$|Abstract. The {{difference}} between Collaborative Business Processes (CBP) and ordinary sequential business processes (BP) {{is in the}} necessity for decentralized coordination, flexible <b>backward</b> <b>recovery,</b> participants notification about the current state, fast adaptability to changes in participants ’ work, multiple information systems, individual authorization settings of the participants, etc. The paper presents a literature survey of four CBP paradigms (namely oriented on activity flows, documents, cases, and business artifacts) conducted {{from the perspective of}} a vendor of the Enterprise Resource Planning (ERP) system. Restrictions of the case are implicit information flows in BPs, diversity of ERP integrations with customers ’ information systems (IS), a lack of mechanisms for BP monitoring, <b>backward</b> <b>recovery</b> and for user notification about the current state and tasks as well as inability to make changes in customers ’ ISs. The paradigms are reviewed and analyzed regarding these restrictions...|$|E
40|$|We {{investigate}} {{public key}} encryption that allows the originator of a ciphertext to retrieve a “forgotten ” plaintext from the ciphertext. This type of {{public key encryption}} with “backward recovery ” contrasts more widely analyzed public key encryption with “forward secrecy”. We advocate that together they form {{the two sides of}} a whole coin, whereby offering complementary roles in data security, especially in cloud computing, 3 G/ 4 G communications and other emerging computing and communication platforms. We formalize the notion of public key encryption with <b>backward</b> <b>recovery,</b> and present two construction methods together with formal analyses of their security. The first method embodies a generic public key encryption scheme with <b>backward</b> <b>recovery</b> using the “encrypt then sign ” paradigm, whereas the second method provides a more efficient scheme that is built on Hofheinz and Kiltz’s public key encryption in conjunction with target collision resistant hashing. Security of the first method is proved in a two-user setting, whereas the second is in a more general multi-user setting. ...|$|E
40|$|This paper proposes an {{approach}} for using backward error recovery in Ada. We do not discuss {{advantages and disadvantages}} of Ada, nor propose new run-time algorithms for Ada, but we try to offer practical method for using <b>backward</b> <b>recovery</b> and software diversity within this language. We believe that Ada has sufficient facilities to allow using software diversity in developing fault-tolerant systems. However, previous researchers have noted problems in attempting to use this possibility, and restrictive rules are necessary to avoid these problems. We consider "conversations " for coordinated <b>backward</b> <b>recovery</b> of concurrent processes and propose: i) a restricted scheme similar to Kim's "concurrent recovery block", but providing for deadlines on the execution of the diverse modules; ii) programming rules for applying this scheme to Ada procedures; and iii) a way for automatically enforcing these rules through a source code pre-processor. Two of the main advantages of this scheme are its functioning within this widely used conventional industrial language and its suitability for real-time systems of an iterative type and with time constraints. ...|$|E
40|$|<b>Backward</b> error <b>recovery</b> {{is one of}} {{the most}} used schemes to ensure {{fault-tolerance}} in distributed systems. It consists, upon the occurrence of a failure, in restoring a distributed computation to an error-free global state from which it can be resumed to produce a correct behavior. Checkpointing {{is one of the}} techniques to pursue the <b>backward</b> error <b>recovery.</b> In this paper, we present a general framework that takes a semantic including missing and orphan messages into account. Notions of missings and orphans are revisited by considering additional underlying mechanism available on channels and semantics of messages. This framework allows, first, to state and prove a theorem to determine if an arbitrary set of checkpoints is consistent and, second, to define formally the domino effect. Further, we show how previously published uncoordinated checkpointing algorithms can be described in our context and some example of uncoordinated checkpointing algorithms that ensure domino-free rollback [...] ...|$|R
40|$|Abstract. The Simultaneous Optical Multiprocessor Exchange Bus (SOME-Bus) is a low-latency, {{high-bandwidth}} interconnection network which directly links arbitrary {{pairs of}} processor nodes without contention, and can efficiently interconnect {{over one hundred}} nodes. Each node has a dedicated output channel {{and an array of}} receivers, with one receiver dedicated to every other node’s output channel. The SOME-Bus eliminates the need for global arbitration and provides bandwidth that scales directly with the number of nodes in the system. Under the distributed shared memory (DSM) paradigm, the SOME-bus allows strong integration of the transmitter, receiver and cache controller hardware to produce a highly integrated system-wide cache coherence mechanism. <b>Backward</b> Error <b>Recovery</b> fault-tolerance techniques can rely on DSM data replication and SOME-Bus broadcasts with little additional network traffic and corresponding performance degradation. This paper uses extensive simulation to examine the performance of the SOME-Bus architecture under DSM and <b>Backward</b> Error <b>Recovery.</b> ...|$|R
40|$|Distributed Shared Memory (dsm) {{architectures}} {{are attractive}} to execute high performance parallel applications. Made up {{of a large}} number of components, these architectures have however a high probability of failure. We propose a protocol to tolerate node failures in two classes of dsm architectures: Cache Only Memory Architectures (coma) and Distributed Virtual Shared Memory (svm) systems. The proposed solution is based on <b>backward</b> error <b>recovery</b> and consists of an extension to the existing coherence protocols to manage data used by processors for the computation and recovery data, used for fault tolerance. The implementation of the protocol in a coma architecture has been evaluated by simulation. The protocol has also been implemented in a svm system on a network of workstations. Both simulation results and measurements show that our solution is efficient and scalable. Key-words: Distributed Shared Memory, Fault Tolerance, Coherence Protocol, <b>Backward</b> Error <b>Recovery,</b> Scalability, [...] ...|$|R
40|$|<b>Backward</b> <b>recovery</b> through {{checkpointing}} and rollback is {{a popular}} approach in modern processors to providing recovery from transient and intermittent faults. 1 This approach is especially attractive when designers can implement it with very low overhead, typically using dedicated hardware support. The many proposals for low-overhead checkpointing and rollback schemes differ {{in a variety of}} ways, including the level of the memory hierarchy checkpointed and the organization of the checkpoint relative to the active data. Schemes that checkpoint at the cache level occupy an especially attractive design point. 2, 3 The hardware for thes...|$|E
40|$|Compensation is {{a widely}} used concept for {{maintaining}} atomicity in both the advanced transaction models and transactional workflow systems. Some Web service protocols also adopt the compensation mechanism for failure recovery when providing transaction management. However, the compensation mechanisms used in these models or protocols are too fixed and cannot satisfy the various requirements of different applications. In this paper, a multiple-compensation mechanism is proposed and defined explicitly in a business process model. An algorithm on how to implement this multiple-compensation mechanism for <b>backward</b> <b>recovery</b> is designed and its computation complexity is analysed...|$|E
40|$|This paper {{addresses}} {{the definition of}} recovery lines {{in the context of}} <b>backward</b> <b>recovery</b> whose aim is to cope with failures in distributed sytems. A general framework that allows for several semantics of recovery lines is introduced. Key notions such as missing messages and orphan messages are precisely defined and their impact on the definition of consistency of recovery lines is carefully analyzed. Basic mechanisms such as local checkpointing, messages identification and (optimistic or pessimistic) messages logging are then discussed as an illustration of (coordinated or uncoordinated) checkpointing protocols...|$|E
40|$|International audienceScalable {{shared memory}} multiprocessors are {{promising}} architectures to achieve teraflops computational power. As they contain {{a large number}} of processor and memory elements, such machines have a high probability of failure. In this paper, we investigate an approach based on <b>backward</b> error <b>recovery</b> to provide a highly available scalable shared memory architecture tolerating transient and permanent processor and memory failures...|$|R
40|$|<b>Backward</b> error <b>recovery</b> {{is one of}} {{the most}} used schemes to ensure fault-tolera- nce in {{distributed}} systems. It consists, upon the occurrence of a failure, in restoring a distributed computation to an error-free global state from which it can be resumed to produce a correct behavior. Checkpointing {{is one of the}} techniques to pursue the <b>backward</b> error <b>recovery.</b> In this paper, we present a general framework that takes a semantic including missing and orphan messages into account. Notions of missings and orphans are revisited by considering additional underlying mechanism available on channels and semantics of messages. This framework allows, first, to state and prove a theorem to determine if an arbitrary set of checkpoints is consistent and, second, to define formally the domino effect. Further, we show how previously published uncoordinated checkpointing algorithms can be described in our context and some example of uncoordinated checkpointin- g algorithms that ensure domino-free rollback recovery are also given...|$|R
40|$|This paper {{discusses}} {{the stability of}} a feasible pre-run-time schedule for a transient overload introduced by processes re-execution during an error recovery action. It shows that the stability of a schedule strictly tuned to meet hard deadlines is very small, invalidating thus <b>backward</b> error <b>recovery.</b> However, {{the stability of the}} schedule always increases when a real-time process is considered as having a nominal and a hard deadline separated by a non-zero grace time. This is true for sets of processes having arbitrary precedence and exclusion constraints, and executed on a single or multiprocessor based architecture. Grace time is not just the key element for the realistic estimation of the timing constraints of real-time error processing techniques. It also allows <b>backward</b> error <b>recovery</b> to be included in very efficient pre-run-time scheduled systems when the conditions stated in this paper are satisfied. This is a very important conclusion, as it shows that fault-tolerant hard real-time systems {{do not have to be}} extremely expensive and complex. [URL]...|$|R
40|$|Techniques for {{structuring}} forward {{error recovery}} measures in asynchronous systems are proposed, and recent ideas of atomic actions are generalized {{so as to}} support fault-tolerant interactions between processes. In particular, the proposal generalizes the form of simple recovery facilities supported by nested atomic actions in which the exception mechanisms only permit backward error recovery. It allows for construction of systems employing both forward and backward error recovery and thus allows for exploitation of the complementary benefits of the two schemes. <b>Backward</b> <b>recovery,</b> forward recovery, and normal processing activities can occur concurrently within the organization proposed...|$|E
40|$|This paper {{presents}} {{the development of}} an event based Discrete Event Simulation (DES) for a recovery algorithm known <b>Backward</b> <b>Recovery</b> Global Preemptive Utility Accrual Scheduling (BR_GPUAS). This algorithm implements the <b>Backward</b> <b>Recovery</b> (BR) mechanism as a fault recovery solution under the existing Time/Utility Function/ Utility Accrual (TUF/UA) scheduling domain for multiprocessor environment. The BR mechanism attempts to take the faulty tasks back to its initial safe state and then proceeds to re-execute the affected section of the faulty tasks to enable recovery. Considering that faults may occur in the components of any system; a fault tolerance system that can nullify the erroneous effect is necessary to be developed. Current TUF/UA scheduling algorithm uses the abortion recovery mechanism and it simply aborts the erroneous task as their fault recovery solution. None of the existing algorithm in TUF/UA scheduling domain in multiprocessor scheduling environment have considered the transient fault and implement the BR mechanism as a fault recovery mechanism to nullify the erroneous effect and solve the recovery problem in this domain. The developed BR_GPUAS simulator has derived the set of parameter, events and performance metrics according to a detailed analysis of the base model. Simulation results revealed that BR_GPUAS algorithm can saved almost 20 - 30 % of the accumulated utilities making it reliable and efficient for the real-time application in the multiprocessor scheduling environment...|$|E
40|$|Abstract. In {{order to}} create {{innovative}} business products, share knowledge between people and businesses, or increase the control and quality of services, {{more and more often}} enterprise business processes involve in collaborations by delegating or providing some pieces of work to other enterprises. Necessity to cooperate in the cross-enterprise setting leads to Collaborative Business Processes (CBPs). The difference between CBPs and Business Processes (BPs) is in the decentralized coordination, flexible <b>backward</b> <b>recovery,</b> participants notification about the state, efficient adaptability to changes, presence of multiple information systems, and individual authorization settings. In the paper we consider a specific case of CBPs where multiple collaborating partners use Enterprise Resource Planning (ERP) system of the same vendor. The vendor can see (e. g., monitor) the changes of data elements, but does not have explicit process awareness in the ERP system to support flow of activities in the cross-enterprise setting. The paper also discusses different settings of cross-enterprise CBP and shows simplified enterprise models behind the vendor possibilities to positively impact collaborative processes. The restrictions of the vendor are implicit information flows in BP, diversity of ERP integrations with third party Information Systems (IS), the lack of mechanisms for monitoring BP instances, <b>backward</b> <b>recovery,</b> user notification about the current state and tasks, and inability to make explicit changes in customers ’ ISs...|$|E
40|$|<b>Backward</b> error <b>recovery</b> {{is one of}} {{the most}} used schemes to ensure {{fault-tolerance}} in distributed systems. It consists, upon the occurrence of a failure, in restoring a distributed computation in an error-free global state from which it can be resumed to produce a correct behaviour. Checkpointing {{is one of the}} techniques to pursue the <b>backward</b> error <b>recovery.</b> As we consider large-scale distributed systems, on one side a coordinated approach to take checkpoints is not practicable, on the other side for an uncoordinated approach the probability to have a domino effect during a recovery could be no longer negligible. In this paper, we present a framework that allows first to define formally the domino effect and second to state and prove a theorem to determine if an arbitrary set of checkpoints is consistent. This theorem is very general as it considers a semantic including missing and orphan messages. This plays a key role in designing uncoordinated checkpointing algorithms that require to take as less additional checkpoints as possible in order to ensure domino-free recovery. ...|$|R
40|$|Abstract. The FTMPS-project {{provides}} {{a solution to}} the need for fault-tolerance in large systems. A complete fault-tolerance approach is devel-oped and being implemented. The built-in hardware error-detection fea-tures combined with software error-detection techniques provide a high coverage of transient as well as perananent failures. Combined with the diagnosis software, the necessary information for the OSS (statistics and visualisation) and the possibly reconfigm-ation is collected. <b>Backward</b> er-ror <b>recovery</b> based on checkpointing and rollback, is implemented. ...|$|R
30|$|How can errors be recovered? The {{answer to}} this {{question}} can be either forward or <b>backward</b> error <b>recovery,</b> according to the error recovery strategy of the respective functionalities (see Section 5). The {{answer to this}} question should support the decision regarding how to execute variants. In some cases, when a forward error recovery strategy is more effective, a sequential execution is recommended. For example, when a billing system is executed in parallel, after processing redundant bills, some of them should be cancelled, since an undo operation is not applicable in such case.|$|R
