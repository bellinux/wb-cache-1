1250|488|Public
5|$|As with FreeBSD and OpenBSD, the {{developers}} of DragonFly BSD are slowly replacing K style C code with more modern, ANSI equivalents. Similar to other operating systems, DragonFly's {{version of the}} GNU Compiler Collection has an enhancement called the Stack-Smashing Protector (ProPolice) enabled by default, providing some additional protection against <b>buffer</b> <b>overflow</b> based attacks. It {{should be noted that}} , the kernel is no longer built with this protection by default.|$|E
5|$|The Debian project offers {{documentation}} and tools to harden a Debian installation both manually and automatically. Security-Enhanced Linux and AppArmor support is available but disabled by default. Debian provides an optional hardening wrapper, {{and does not}} harden all of its software by default using gcc features such as PIE and <b>buffer</b> <b>overflow</b> protection, unlike operating systems such as OpenBSD, but tries to build as many packages as possible with hardening flags.|$|E
25|$|Various DoS-causing {{exploits}} such as <b>buffer</b> <b>overflow</b> {{can cause}} server-running software to get confused {{and fill the}} disk space or consume all available memory or CPU time.|$|E
2500|$|Well-written {{and tested}} {{abstract}} data type libraries which centralize and automatically perform buffer management, including bounds checking, can reduce the occurrence and impact of <b>buffer</b> <b>overflows.</b> [...] The two main building-block data types in these languages in which <b>buffer</b> <b>overflows</b> commonly occur are strings and arrays; thus, libraries preventing <b>buffer</b> <b>overflows</b> in these data types can provide {{the vast majority of}} the necessary coverage. [...] Still, failure to use these safe libraries correctly can result in <b>buffer</b> <b>overflows</b> and other vulnerabilities; and naturally, any bug in the library itself is a potential vulnerability. [...] "Safe" [...] library implementations include [...] "The Better String Library", Vstr [...] and Erwin. The OpenBSD operating system's C library provides the strlcpy and strlcat functions, but these are more limited than full safe library implementations.|$|R
25|$|Programming {{languages}} {{commonly associated}} with <b>buffer</b> <b>overflows</b> include C and C++, which provide no built-in protection against accessing or overwriting data {{in any part of}} memory and do not automatically check that data written to an array (the built-in buffer type) is within the boundaries of that array. Bounds checking can prevent <b>buffer</b> <b>overflows,</b> but requires additional code and processing time. Modern operating systems use a variety of techniques to combat malicious <b>buffer</b> <b>overflows,</b> notably by randomizing the layout of memory, or deliberately leaving space between buffers and looking for actions that write into those areas ("canaries").|$|R
40|$|Security in {{this day}} and age is a {{necessity}} for everyone. No one can afford to be negligent any more. Personal or corporate information can very easily be acquired if the infrastructure is not secure and the days of just having up-todate antivirus software are long gone. There are various types of vulnerabilities where a number of vectors of attack are available which are constantly being exploited by attackers. Multiple layers of security are required to deter unwanted guests. This paper attempts to explain one type of vulnerability known as <b>buffer</b> <b>overflows.</b> Various articles, papers, books, etc. have been released over the years related to <b>buffer</b> <b>overflows</b> on what they are and how to deal with them. The four main chapters of this paper will explain <b>buffer</b> <b>overflows</b> in the Microsoft Windows â„¢ environment in depth. We start out with the basic foundations on understanding <b>buffer</b> <b>overflows,</b> then move on to how to exploit vulnerable software and then prevent attacks from being successful. Finally w...|$|R
25|$|In {{computer}} security and programming, a <b>buffer</b> <b>overflow,</b> or buffer overrun, is an anomaly where a program, while writing data to a buffer, overruns the buffer's boundary and overwrites adjacent memory locations.|$|E
25|$|Ars Technica {{reported}} in March 2006 an RFID <b>buffer</b> <b>overflow</b> bug that could infect airport terminal RFID databases for baggage, and also passport databases to obtain confidential {{information on the}} passport holder.|$|E
25|$|Exploiting the {{behavior}} of a <b>buffer</b> <b>overflow</b> is a well-known security exploit. On many systems, the memory layout of a program, or the system as a whole, is well defined. By sending in data designed to cause a <b>buffer</b> <b>overflow,</b> it is possible to write into areas known to hold executable code, and replace it with malicious code. Buffers are widespread in operating system (OS) code, so it is possible to make attacks that perform privilege escalation and gain unlimited access to the computer's resources. The famed Morris worm used this as one of its attack techniques.|$|E
5000|$|... <b>buffer</b> <b>overflows</b> [...] - [...] {{this is how}} the Blaster worm {{was able}} to {{propagate}} ...|$|R
25|$|Various {{techniques}} {{have been used}} to detect or prevent <b>buffer</b> <b>overflows,</b> with various tradeoffs. The most reliable way to avoid or prevent <b>buffer</b> <b>overflows</b> is to use automatic protection at the language level. This sort of protection, however, cannot be applied to legacy code, and often technical, business, or cultural constraints call for a vulnerable language. The following sections describe the choices and implementations available.|$|R
40|$|In Promela, {{communication}} buffers {{are defined}} with a fixed length, and <b>buffer</b> <b>overflows</b> {{can be handled}} in two different ways: block the send statement or lose the message. Both solutions change the semantics of the system, compared to one with unbounded channels. The question arises, if such <b>buffer</b> <b>overflows</b> can ever occur in a given system and what buffer lengths are sufficient to avoid them...|$|R
25|$|<b>Buffer</b> <b>overflow,</b> {{in which}} a program tries to store data past the end of {{allocated}} storage. This {{may or may not}} lead to an access violation or storage violation. These are known as security bugs.|$|E
25|$|Versions 4.0 through 7.3 {{contained}} a <b>buffer</b> <b>overflow</b> bug which could compromise {{the security of}} a PC using either the QuickTime Streaming Media client, or the QuickTime player itself. The bug was fixed in version 7.3.1.|$|E
25|$|The {{techniques}} to exploit a <b>buffer</b> <b>overflow</b> vulnerability vary by architecture, by operating system and by memory region. For example, exploitation on the heap (used for dynamically allocated memory), differs markedly from exploitation on the call stack.|$|E
50|$|In a {{language}} with free pointers or non-checked array writes (such as in C), {{the mixing of}} control flow data which affects the execution of code (the return addresses or the saved frame pointers) and simple program data (parameters or return values) in a call stack is a security risk, possibly exploitable through stack <b>buffer</b> <b>overflows</b> as {{the most common type}} of <b>buffer</b> <b>overflows.</b>|$|R
50|$|Various {{techniques}} {{have been used}} to detect or prevent <b>buffer</b> <b>overflows,</b> with various tradeoffs. The most reliable way to avoid or prevent <b>buffer</b> <b>overflows</b> is to use automatic protection at the language level. This sort of protection, however, cannot be applied to legacy code, and often technical, business, or cultural constraints call for a vulnerable language. The following sections describe the choices and implementations available.|$|R
5000|$|... {{to detect}} memory related errors, such as <b>buffer</b> <b>overflows</b> and use-after-free (using memory debuggers such as AddressSanitizer), ...|$|R
25|$|One way {{to attack}} a piece of {{software}} is to redirect the flow of execution of a program. A variety of control-flow integrity techniques, including stack canaries, <b>buffer</b> <b>overflow</b> protection, shadow stacks, and vtable pointer verification, are used to defend against these attacks.|$|E
25|$|A <b>buffer</b> <b>overflow</b> {{occurs when}} data written to a buffer also corrupts data values in memory {{addresses}} {{adjacent to the}} destination buffer due to insufficient bounds checking. This can occur when copying data from one buffer to another without first checking that the data fits within the destination buffer.|$|E
25|$|Since then, {{at least}} two major {{internet}} worms have exploited buffer overflows to compromise {{a large number of}} systems. In 2001, the Code Red worm exploited a <b>buffer</b> <b>overflow</b> in Microsoft's Internet Information Services (IIS) 5.0 and in 2003 the SQL Slammer worm compromised machines running Microsoft SQL Server 2000.|$|E
40|$|In {{this paper}} we discuss an {{application}} of the Simplex method in checking software safety [...] the application in automated detection of <b>buffer</b> <b>overflows</b> in C programs. This problem is important because <b>buffer</b> <b>overflows</b> are suitable targets for hackers' security attacks and sources of serious programs' misbehavior. We also describe our implementation, including a system for generating software correctness conditions and a Simplex-based theorem prover that resolves these conditions...|$|R
50|$|OpenBSD {{integrates}} several {{technologies to}} help protect the operating system from attacks such as <b>buffer</b> <b>overflows</b> or integer overflows.|$|R
5000|$|... string-manipulation routines, {{including}} [...] and , {{for lack}} of bounds checking and possible <b>buffer</b> <b>overflows</b> if the bounds aren't checked manually; ...|$|R
25|$|When this {{technique}} is possible {{the severity of the}} vulnerability increases considerably. This is because exploitation will work reliably enough to automate an attack with a virtual guarantee of success when it is run. For this reason, this is the technique most commonly used in Internet worms that exploit stack <b>buffer</b> <b>overflow</b> vulnerabilities.|$|E
25|$|Local shellcode {{is used by}} an {{attacker}} who {{has limited}} access to a machine but can exploit a vulnerability, for example a <b>buffer</b> <b>overflow,</b> in a higher-privileged process on that machine. If successfully executed, the shellcode will provide the attacker access to the machine with the same higher privileges as the targeted process.|$|E
25|$|Executable space {{protection}} is {{an approach to}} <b>buffer</b> <b>overflow</b> protection which prevents execution of code on the stack or the heap. An attacker may use buffer overflows to insert arbitrary code into {{the memory of a}} program, but with executable space protection, any attempt to execute that code will cause an exception.|$|E
5000|$|Two {{examples}} of insecure design are allowing <b>buffer</b> <b>overflows</b> and format string vulnerabilities. The following C program demonstrates these flaws: ...|$|R
40|$|In {{this paper}} we have {{discussed}} {{the application of the}} Simplex method in checking software safety - the application in automated detection of <b>buffer</b> <b>overflows</b> in C programs. This problem is important because <b>buffer</b> <b>overflows</b> are suitable targets for hackers' security attacks and sources of serious program misbehavior. We have also described our implementation, including a system for generating software correctness conditions and a Simplex based theorem prover that resolves these conditions...|$|R
2500|$|A {{technically}} inclined user may exploit stack-based <b>buffer</b> <b>overflows</b> {{to manipulate}} the program to their advantage in one of several ways: ...|$|R
25|$|QuickTime 7.5.5 {{and earlier}} {{are known to}} have a list of {{significant}} vulnerabilities that allow a remote attacker to execute arbitrary code or cause a denial of service (out-of-bounds memory access and application crash) on a targeted system. The list includes six types of <b>buffer</b> <b>overflow,</b> data conversion, signed vs unsigned integer mismatch, and uninitialized memory pointer.|$|E
25|$|While {{involved}} with the L0pht, Mudge contributed significantly to disclosure and education on information and security vulnerabilities. In addition to pioneering <b>buffer</b> <b>overflow</b> work, the security advisories he released contained early examples of flaws in the following areas: code injection, race condition, side-channel attack, exploitation of embedded systems, and cryptanalysis of commercial systems. He was the original author of the password cracking software L0phtCrack.|$|E
25|$|Randomization of {{the virtual}} memory {{addresses}} at which functions and variables can be found can make exploitation of a <b>buffer</b> <b>overflow</b> more difficult, but not impossible. It also forces the attacker to tailor the exploitation attempt to the individual system, which foils the attempts of internet worms. A similar but less effective method is to rebase processes and libraries in the virtual address space.|$|E
50|$|A guard byte {{is a part}} of a {{computer}} program's memory that helps software developers find <b>buffer</b> <b>overflows</b> while developing the program.|$|R
2500|$|The {{problem of}} <b>buffer</b> <b>overflows</b> {{is common in}} the C and C++ {{languages}} because they expose low level representational details of buffers as containers for data types. [...] <b>Buffer</b> <b>overflows</b> must thus be avoided by maintaining {{a high degree of}} correctness in code which performs buffer management. It has also long been recommended to avoid standard library functions which are not bounds checked, such as gets, scanf and strcpy. The Morris worm exploited a gets call in fingerd.|$|R
50|$|Canaries or canary {{words are}} known {{values that are}} placed between a buffer and control data on the stack to monitor <b>buffer</b> <b>overflows.</b> When the <b>buffer</b> <b>overflows,</b> the first data to be {{corrupted}} will usually be the canary, and a failed verification of the canary data is therefore an alert of an overflow, which can then be handled, for example, by invalidating the corrupted data. A canary value {{should not be confused}} with a sentinel value.|$|R
