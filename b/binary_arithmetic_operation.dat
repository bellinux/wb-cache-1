1|4361|Public
5000|$|XOR is {{also used}} to detect an {{overflow}} in the result of a signed <b>binary</b> <b>arithmetic</b> <b>operation.</b> If the leftmost retained bit of the result {{is not the same as}} the infinite number of digits to the left, then that means overflow occurred. XORing those two bits will give a [...] "1" [...] if there is an overflow.|$|E
40|$|This {{article is}} a {{continuation}} of [11] and presents the concepts of <b>binary</b> <b>arithmetic</b> <b>operations</b> for integers. There is introduced 2 's complement representation of integers and natural numbers to integers are expanded. The binary addition and subtraction for integers are defined and theorems on the relationship between binary and numerical operations presented. MML Identifier: BINARI 2...|$|R
5000|$|... for nonzero a. In {{particular}} , and moreover , making reciprocal, , a {{total function}} in this structure. The structure, however, {{is not a}} field, {{and none of the}} <b>binary</b> <b>arithmetic</b> <b>operations</b> are total, as witnessed for example by [...] being undefined despite the reciprocal being total. It has usable interpretations, however - for example, in geometry, a vertical line has infinite slope.|$|R
40|$|Common <b>binary</b> <b>arithmetic</b> <b>operations</b> such as addition/subtraction and {{multiplication}} {{suffer from}} O(n) carry propagation delay where n {{is the number}} of digits. Carry lookahead helps to improve the propagation delay to O(log n), but is bounded to a small number of digits due to the complexity of the circuit. A carry-free <b>arithmetic</b> <b>operation</b> can be achieved using a higher radix number system such as Quarternary Signed Digit (QSD). In QSD, each digit can be represented by...|$|R
40|$|It {{is shown}} that the {{exponential}} of a complex power series up to order n can be implemented via (23 / 12 +o(1)) M(n) <b>binary</b> <b>arithmetic</b> <b>operations</b> over complex field, where M(n) stands for the (smoothed) complexity of multiplication of polynomials of degree <n in FFT-model. Yet, it is shown how to raise a power series to a constant power with the complexity (27 / 8 +o(1)) M(n). Comment: 7 pages, in English; 7 pages, in Russia...|$|R
5000|$|In {{more recent}} {{computers}} such capabilities {{are almost always}} implemented in software rather than the CPU's instruction set, but BCD numeric data is still extremely common in commercial and financial applications. There are tricks for implementing packed BCD and zoned decimal add or subtract operations using short but difficult to understand sequences of word-parallel logic and <b>binary</b> <b>arithmetic</b> <b>operations.</b> For example, the following code (written in C) computes an unsigned 8-digit packed BCD add using 32-bit binary operations: ...|$|R
5000|$|A basic {{example of}} {{functional}} decomposition is expressing the four <b>binary</b> <b>arithmetic</b> <b>operations</b> of addition, subtraction, multiplication, and division {{in terms of}} the two binary operations of addition [...] and multiplication [...] and the two unary operations of additive inversion [...] and multiplicative inversion [...] Subtraction can then be realized as the composition of addition and additive inversion, [...] and division can be realized as the composition of multiplication and multiplicative inverse, [...] This simplifies the analysis of subtraction and division, and also makes it easier to axiomatize these operations in the notion of a field, as there are only two binary and two unary operations, rather than four binary operations.|$|R
40|$|Approved {{for public}} release; {{distribution}} is unlimitedThis paper presents a computer language translator {{which allows the}} IBM FORTRAN G (or higher level) user to solve directly problems in which the variables may be n-tuples and/or the FORTRAN <b>arithmetic</b> and relational <b>operations</b> may be defined by the user. The translator, called the NSFORT (for Nonstandard FORTRAN) translator, will (1) decompose all expressions {{to a series of}} <b>binary</b> <b>arithmetic</b> <b>operations,</b> relational operations, or user defined functions; (2) generate CALL statements to user supplied subprograms to perform the above operations; and (3) produce a new source program that is in every respect acceptable to the FORTRAN compiler. While using the NSFORT translator the user has virtually unrestricted use of FORTRAN. The translator's applications include n-precision arithmetic, vector and matrix operations, numerically evaluated analytic derivatives, interval arithmetic, and others. The paper describes completely the use and operation of the translator, provides examples, indicates applications, and discusses,, programming techniques. [URL] United States Marine Corp...|$|R
5000|$|When a <b>binary</b> basic <b>arithmetic</b> <b>operation</b> {{is applied}} to mixed arguments—the pair [...] and the real number —the real number is first lifted to [...] The {{derivative}} of a function [...] at the point [...] is now found by calculating [...] using the above arithmetic, which gives [...] as the result.|$|R
50|$|C {{provides}} a compound assignment operator for each <b>binary</b> <b>arithmetic</b> and bitwise <b>operation</b> (i.e. each operation which accepts two operands). Each {{of the compound}} bitwise assignment operators perform the appropriate binary operation and store the result in the left operand.|$|R
50|$|Most modern {{hardware}} implements signed Two's complement <b>binary</b> <b>arithmetic</b> operations.These <b>operations</b> {{are fully}} defined {{for the entire}} range of values for any operands they are given—since any N-bit binary number can contain 2N distinct values, and since one of them is taken up by the value 0, there are an odd number of spots left for all the non-zero positive and negative numbers.There is simply one more negative number representable than there are positive.For example, a 16-bit 2's complement value may contain numbers ranging from −32768 to +32767.|$|R
40|$|The study {{aimed to}} {{describe}} the difficulties experienced by students and analyze the external factors that cause learning difficulties in mathematics. This type of research is qualitative descriptive. The technique of ollecting data by interview and documentation. The validity of the data using triangulation techniques. Analysis of the data through the stages of data eduction, data presentation and conclusion. The {{results of the study}} indicate that the type of difficulties experienced by students in the form of 1) difficulty understanding about the inability of students to interpret the mathematical symbol on the set of chapters, 2) the difficulty of transforming the inability of students determines the set formula, 3) the difficulty in the settlement process that the students are not able to perform <b>binary</b> <b>arithmetic</b> <b>operations</b> in order to resolve the matter of the set. External factors that cause learning difficulties is 1) the school environment is a crowded classroom atmosphere and clock subjects partially underway afternoon, 2) the environmental community is that their mass media such as mobile phones, 3) the family environment is the lack of parental assistance when students learn at home...|$|R
40|$|Let F be a {{subfield}} of {{the field}} R of real numbers. Equipped with the <b>binary</b> <b>arithmetic</b> mean <b>operation,</b> each convex subset C of F^n becomes a commutative binary mode, also called idempotent commutative medial (or entropic) groupoid. Let C and C' be convex subsets of F^n. Assume that they are of the same dimension {{and at least one}} of them is bounded, or F is the field of all rational numbers. We prove that the corresponding idempotent commutative medial groupoids are isomorphic iff the affine space F^n over F has an automorphism that maps C onto C'. We also prove a more general statement for the case when C,C'⊆ F^n are considered barycentric algebras over a unital subring of F that is distinct from the ring of integers. A related result, for a subring of R instead of a subfield F, is given in rczgaroman 2. Comment: 12 pages, 3 figure...|$|R
40|$|This paper {{introduces}} a novel architecture for least latency universal adder using pipeline and parallel computing technique. The proposed architecture implemented in reconfigurable technology as arun time reconfigurable unit. The proposed 32 -bit Universal adder design and compared with previously proposed adder designs {{in terms of}} area and delay after synthesis targeting on 4 vfx 60 ff 672 - 12 Xilinxvirtex- 4 FPGA and have high hardware resource sharing up to 42 % for the <b>binary</b> and BCD <b>arithmetic</b> <b>operations.</b> Synthesis {{results show that the}} proposed design has the smallest delay (8. 2 ns) and throughputof 121. 9 MOPS (at least 20 % faster) with almost equivalent area-delay product when compared to other existing proposal...|$|R
50|$|<b>Binary</b> <b>arithmetic</b> {{and logical}} <b>operations</b> are {{performed}} as register-to-register and as memory-to-register/register-to-memory {{as a standard}} feature. If the Commercial Instruction Set option was installed, packed decimal arithmetic could be performed as memory-to-memory with some memory-to-register operations. The Scientific Instruction Set feature, if installed, provided access to four floating point registers that could be programmed for either 32-bit or 64-bit floating point operations. The Models 85 and 195 could also operate on 128-bit extended-precision floating point numbers stored in pairs of floating point registers, and software provided emulation in other models. The System/360 used an 8-bit byte, 32-bit word, 64-bit double-word, and 4-bit nibble. Machine instructions had operators with operands, which could contain register numbers or memory addresses. This complex combination of instruction options resulted {{in a variety of}} instruction lengths and formats.|$|R
40|$|AbstractDNA {{self-assembly}} is {{the most}} advanced and versatile system that has been experimentally demonstrated for programmable construction of patterned systems on the molecular scale. It has been demonstrated that the simple <b>binary</b> <b>arithmetic</b> and logical <b>operations</b> can be computed {{by the process of}} self assembly of DNA tiles. Here we report a one-dimensional algorithmic self-assembly of DNA triple-crossover molecules {{that can be used to}} execute five steps of a logical NAND and NOR operations on a string of binary bits. To achieve this, abstract tiles were translated into DNA tiles based on triple-crossover motifs. Serving as input for the computation, long single stranded DNA molecules were used to nucleate growth of tiles into algorithmic crystals. Our method shows that engineered DNA self-assembly can be treated as a bottom-up design techniques, and can be capable of designing DNA computer organization and architecture...|$|R
40|$|Preface Design Process and Technology Theory {{of logic}} design Analysis and {{synthesis}} Implementation technologies Predictable technologies Contemporary CAD of logic networks Number Systems Positional numbers Counting in a positional number system Basic <b>arithmetic</b> <b>operations</b> in various number systems <b>Binary</b> <b>arithmetic</b> Radix-complement representations Techniques for conversion of numbers in various radices Overflow Residue <b>arithmetic</b> Other <b>binary</b> codes Redundancy and reliability Graphical Data Structures Graphs in discrete devices and systems design Basic definitions...|$|R
40|$|Most {{computers}} nowadays {{support the}} IEEE 754 - 1985 standard for <b>binary</b> floating-point <b>arithmetic</b> [1], which requires that all four <b>arithmetic</b> <b>operations</b> (+, −, ×, ÷) and the square root are correctly rounded. However radix 10 is {{more suited to}} some applications, such as financial and commercial ones, an...|$|R
30|$|For the context, it is firstly {{introduced}} in image and video coding. Here, context-based adaptive <b>binary</b> <b>arithmetic</b> coding (CABAC) in H. 264 /AVC [10] {{is taken as}} an example. CABAC {{is one of the}} two entropy coding methods of the new ITU-T/ISO/IEC standard for video coding, i.e., H. 264 /AVC, and plays a very important role in the efficiency improvement of the video coding. Through combining an adaptive <b>binary</b> <b>arithmetic</b> coding technique with context modeling of the neighboring symbols in binary bit stream and macro block, a high degree of adaptation and redundancy reduction is achieved. The encoding process of CABAC consists of three elementary steps: binarization, context model selecting, and adaptive <b>binary</b> <b>arithmetic</b> encoding. The last step consists of probability estimation and <b>binary</b> <b>arithmetic</b> encoder.|$|R
5000|$|JavaScript {{supports}} the following <b>binary</b> <b>arithmetic</b> operators: ...|$|R
5000|$|Bitstream {{processing}} (Context-adaptive variable-length coding/Context-adaptive <b>binary</b> <b>arithmetic</b> coding) {{and perfect}} pixel positioning.|$|R
40|$|Abstract—Complex numbers {{play a very}} {{important}} role in various applications of electrical and computer engineering. These days, <b>arithmetic</b> <b>operations</b> dealing with these numbers rely on a “divide-and-conquer” technique wherein a complex number is broken into its real and imaginary parts and then, after representing each part in binary number system, operation is carried out on each part as if part of the real arithmetic. In an effort {{to reduce the number of}} <b>arithmetic</b> <b>operations</b> within the realm of complex <b>arithmetic,</b> <b>binary</b> number system with base (− 1 +j), called complex binary number system (CBNS), has been proposed in the literature. This number system allows a complex number to be represented as single-unit instead of two separate units as in the traditional base- 2 <b>binary</b> number system. <b>Arithmetic</b> circuits to perform addition, subtraction, multiplication, shift-left, and shift-right operations on complex numbers represented in CBNS have been previously presented in the literature. In this paper, we have presented the design procedure for a divider circuit involving CBNS. Index Terms—Arithmetic circuits, complex binary number system, complex number, division. I...|$|R
40|$|<b>Binary</b> <b>arithmetic</b> coding is, compression-wise, {{the most}} {{effective}} statistical coding method used in image and video compression. It is being used for compressing bi-level images (JBIG, JBIG 2, and MPEG- 4 shape coding) and is also being utilized (optionally) for coding of continuous-tone images (JPEG) and videos (H. 264). Despite its wide use, different arithmetic coders are incompatible {{with each other and}} application developers are faced with the difficult task of understanding and building each coder. We present a set of simple parameters {{that can be used to}} describe any <b>binary</b> <b>arithmetic</b> coder that is currently being deployed, and we also introduce a software tool for automatically generating C++/Java code for <b>binary</b> <b>arithmetic</b> coding according to the description. 1...|$|R
5000|$|Rath, Anderson, and Brainerd {{reported}} a project using an IBM 650 to teach <b>binary</b> <b>arithmetic</b> to students.|$|R
25|$|Assembly {{language}} is still taught in most computer science and electronic engineering programs. Although few programmers today regularly work with assembly {{language as a}} tool, the underlying concepts remain very important. Such fundamental topics as <b>binary</b> <b>arithmetic,</b> memory allocation, stack processing, character set encoding, interrupt processing, and compiler design {{would be hard to}} study in detail without a grasp of how a computer operates at the hardware level. Since a computer's behavior is fundamentally defined by its instruction set, the logical way to learn such concepts is to study an assembly language. Most modern computers have similar instruction sets. Therefore, studying a single assembly {{language is}} sufficient to learn: I) the basic concepts; II) to recognize situations where the use of assembly language might be appropriate; and III) to see how efficient executable code can be created from high-level languages. This is analogous to children needing to learn the basic <b>arithmetic</b> <b>operations</b> (e.g., long division), although calculators are widely used for all except the most trivial calculations.|$|R
40|$|Flap is {{a package}} to {{implement}} floating-point arithmetic with adjustable precision, in which <b>arithmetic</b> <b>operations</b> are performed on Matlab doubles but are rounded to a specified number of decimal digits after each operation. It {{is intended to}} make it easy to generate examples of the effects of rounding error for classroom use. The rounding level is controlled by a global variable that can be changed {{in the course of a}} computation. Modes for single and double precision <b>binary</b> <b>arithmetic</b> are also provided. The operations are performed on objects of class flap, which consists of an integer indicating the current rounding level for the object and a double containing its data. Most of Matlab’s commonly used operations and functions have been overloaded to work with flap objects. In addition, Flap provides functions to compute the LU, QR, and Cholesky decompositions of a flap, as well as routines for manipulating Householder transformations and plane rotations. 1...|$|R
40|$|Context-based {{adaptive}} <b>binary</b> <b>arithmetic</b> coding (CABAC) as {{a normative}} {{part of the}} new ITU-T/ISO/IEC standard H. 264 /AVC for video compression is presented. By combining an adaptive <b>binary</b> <b>arithmetic</b> coding technique with context modeling, a high degree of adaptation and redundancy reduction is achieved. The CABAC framework also includes a novel low-complexity method for <b>binary</b> <b>arithmetic</b> coding and probability estimation that is well suited for efficient hardware and software implementations. CABAC significantly outperforms the baseline entropy coding method of H. 264 /AVC for the typical area of envisaged target applications. For a set of test sequences representing typical material used in broadcast applications and for a range of acceptable video quality of about 30 to 38 dB, average bit-rate savings of 9 %- 14 % are achieved...|$|R
40|$|Abstract. We {{introduce}} the permutation group of <b>arithmetic</b> <b>operations</b> symbols {{by getting the}} permutations of all the common <b>arithmetic</b> <b>operations</b> symbols, with keeping the brackets out of ordering. We find 6 ways of doing the <b>arithmetic</b> <b>operations.</b> Therefore the output of any mathematical formulas depends on which one element of the arithmetical permutation group we work on. We find invariants by the reordering of the <b>arithmetic</b> <b>operation</b> x+y, xy. Working with the irreducible representation of the permutation arithmetic symbols group we define new arithmetic structures called arithmetic particles symbols...|$|R
5000|$|HP-16C — Computer science {{programmable}} calculator that could perform <b>binary</b> <b>arithmetic,</b> base-conversion (decimal, and binary, octal, and hexadecimal) and boolean-logic functions.|$|R
5000|$|A {{standard}} instruction set, including fixed-point <b>binary</b> <b>arithmetic</b> and logical instructions, present on all System/360 models (except the model 20, see below).|$|R
50|$|Because <b>arithmetic</b> <b>operations</b> such as addition, {{subtraction}} and multiplication {{are also}} T-functions (triangular T-functions), software-efficient word-based T-functions {{can be constructed}} by combining bitwise logic with <b>arithmetic</b> <b>operations.</b> Another important property of T-functions based on <b>arithmetic</b> <b>operations</b> is predictability of their period, which is highly attractive to cryptographers. Although triangular T-functions are naturally vulnerable to guess-and-determine attacks, well chosen bitwise transpositions between rounds can neutralize that imbalance. In software-efficient ciphers, {{it can be done}} by interleaving <b>arithmetic</b> <b>operations</b> with byte-swapping operations and to a small degree with bitwise rotation operations. However, triangular T-functions remain highly inefficient in hardware.|$|R
40|$|AbstractStandby {{redundant}} {{system is a}} powerful tool to enhance the reliability, availability, quality, and safety of operational plants. This study proposed an approximate Tω (the weakest t-norm) fuzzy Graphical Evaluation and Review Technique (GERT) simulation technology to simulate two-unit standby {{redundant system}} reliability. The approximate fuzzy <b>arithmetic</b> <b>operations</b> employ principle of interval arithmetic under the Tω <b>arithmetic</b> <b>operations.</b> Therefore, the novel fuzzy <b>arithmetic</b> <b>operations</b> may obtain fitter decision values, which have smaller fuzziness accumulating, under vague environment. In numerical examples the approximate fuzzy <b>arithmetic</b> <b>operations</b> has evidenced that it can successfully calculate results of fuzzy <b>operations</b> as interval <b>arithmetic,</b> and can more effectively reduce fuzzy spreads. In the real fuzzy repairable reliability model the performance also shows that the approximate fuzzy <b>arithmetic</b> <b>operations</b> successfully simulate/analyze the two-unit standby redundant system reliability and obtain more confident fuzzy results under vague environment...|$|R
50|$|An early {{project for}} the U.S. Air Force, BINAC {{attempted}} to make a lightweight, simple computer by using <b>binary</b> <b>arithmetic.</b> It deeply impressed the industry.|$|R
40|$|Typical {{computer}} systems perform calculations using <b>binary</b> floating point <b>arithmetic.</b> While <b>binary</b> floating-point {{has been relatively}} simple and efficient to implement in hardware, most humans are accustomed to performing arithmetic in the decimal system. Unfortunately, conversions (from decimal) to binary float and back, as well as, performing various <b>arithmetic</b> <b>operations</b> on <b>binary</b> floating-point numbers can introduce non-obvious errors and/or unacceptable behavior for some applications. For example, commercial and financial software often demand accurate decimal behaviors for calculations involving monetary values, such as billing or currency conversion...|$|R
50|$|The AN/GYK-12 has a 32-bit {{instruction}} format and operates {{on data from}} one bit to a doubleword (64 bits) in size. Only fixed-point <b>binary</b> <b>arithmetic</b> is provided.|$|R
5000|$|For <b>binary</b> <b>arithmetic,</b> or {{is faster}} than xor and takes fewer {{transistors}} to implement. However, for a multiple-level carry lookahead adder, it is simpler to use [...]|$|R
