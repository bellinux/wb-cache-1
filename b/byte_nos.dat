0|59|Public
5000|$|... command 1: get random <b>bytes,</b> <b>no</b> blocking. The second byte in {{the request}} tells EGD how many random bytes of output it should return, from 1 to 255. If EGD {{does not have}} enough entropy to {{immediately}} satisfy the request, then fewer <b>bytes,</b> or perhaps <b>no</b> <b>bytes,</b> may be returned. The first octet of the reply indicates how many additional bytes, those containing the random data, immediately follow in the reply.|$|R
50|$|This is {{a sample}} program which computes the {{factorial}} of an input integer number (ignoring the calculator's built-in factorial function). The program consumes 18 <b>bytes.</b> <b>No</b> memory registers are used.|$|R
5000|$|Shift all {{elements}} of a circular array by k <b>bytes,</b> using <b>no</b> extra memory.|$|R
5000|$|It is {{possible}} for a packet to be fragmented at one router, and for the fragments to be fragmented at another router. For example, consider a Transport layer segment with size of 4,500 <b>bytes,</b> <b>no</b> options, and IP header size of 20 bytes. So the IP packet size is 4,520 bytes. Assume that the packet travels over a link with an MTU of 2,500 bytes. Then it will become two fragments: ...|$|R
5000|$|Streaming - Data is {{read as a}} <b>byte</b> stream, <b>no</b> {{distinguishing}} {{indications are}} transmitted to signal message (segment) boundaries.|$|R
40|$|In {{this paper}} the {{classical}} limit of relativistic transport theories for spin 1 / 2 fermions is examined through a {{comparison with the}} classical kinetic theory derived from N= 1 supersymmetric classical mechanics. The conclusion {{is that in the}} classical limit spindensities, i. e. the axial-vector contribution to the relativistic Wigner-function, vanishes and dipole-densities, i. e. the spin-tensor contributions to the relativistic Wigner function, may survive. Comment: Latex 22 pages, 63628 <b>bytes.</b> <b>No</b> figure...|$|R
2500|$|A [...] Ethernet {{connection}} {{can transfer}} [...] {{bits per second}} ( [...] bytes per second ≈ , assuming an 8-bit <b>byte</b> and <b>no</b> overhead) ...|$|R
50|$|The index0 {{points are}} present {{even when they}} are {{identical}} to the index1 ones. The index0 points in audio tracks are incorrect if Nero has been asked to record all the sub-channel data (in that case the sector size is 2448 <b>bytes).</b> <b>No</b> index other than 0 or 1 has been encountered, although the chunk format allows for such cue points to be recorded; thus the number of cue blocks seems to be always 2*(#track + 1): two indices for each track, an index0 for the lead-in and an index1 for the lead-out.|$|R
50|$|The System/360 machine-code {{instructions}} are 2 <b>bytes</b> long (<b>no</b> memory operands), 4 bytes long (one operand), or 6 bytes long (two operands). Instructions are always situated on 2-byte boundaries.|$|R
40|$|In FSE 2011, Maitra and Paul {{observed}} that there exists negative {{bias in the}} first byte of the RC 4 keystream towards 0. In this paper, we give our theoretical proof of this bias. This bias immediately provide distinguisher for RC 4, and ciphertext only attack on broadcast RC 4. Additionally, we discover some new weaknesses of the keystream bytes even after the first N rounds of the PRGA, where N {{is the size of}} the RC 4 permutation, generally, N = 256. The weaknesses in turn provide us with certain state information from the keystream <b>bytes</b> <b>no</b> matter how many initial bytes are thrown away. © 2014 Springer International Publishing Switzerland. In FSE 2011, Maitra and Paul {{observed that}} there exists negative bias in the first byte of the RC 4 keystream towards 0. In this paper, we give our theoretical proof of this bias. This bias immediately provide distinguisher for RC 4, and ciphertext only attack on broadcast RC 4. Additionally, we discover some new weaknesses of the keystream bytes even after the first N rounds of the PRGA, where N is the size of the RC 4 permutation, generally, N = 256. The weaknesses in turn provide us with certain state information from the keystream <b>bytes</b> <b>no</b> matter how many initial bytes are thrown away. © 2014 Springer International Publishing Switzerland...|$|R
2500|$|Few {{data types}} in {{hardware}} (<b>no</b> <b>byte</b> string or BCD, for example) ...|$|R
40|$|This paper {{defines a}} {{functionally}} complete machine as a machine which {{is capable of}} evaluating every two place function over its data space. Necessary conditions on memory size for completeness are developed. These conditions are applied to System/ 360 as modelled by the space of bytes, the space of halfwords, and the space of words. Sufficiently large (> 64 K bytes) models of System/ 360 are shown to be complete for the space of <b>bytes.</b> <b>No</b> models of System/ 360 are complete for the spaces of halfwords or words. The inequalities developed and known examples of universal decision elements suggest structures for complete machines...|$|R
40|$|Units {{are useful}} in {{understanding}} the meaning of data about physical quantities. For example, “ 6 liters ” gives more information than “ 6. ” Other properties, such as accuracy and precision, also give useful information, {{but we do not}} discuss those here. Most units used in the physical sciences are well-standardized [1, 2, 3, 22], and there are standards for the use and spelling of unit names [2, 4], but there are few standards for the representation of units within computing systems. We present a representation which can accommodate unforeseen units, requires minimal agreement among the communicating parties, reveals the physical relationship among quantities, and requires only a few <b>bytes,</b> <b>no</b> matter how complex the unit...|$|R
5000|$|... "Computer Simulation: What It Is and How It's Done", in <b>Byte,</b> vol. 9, <b>no.</b> 3,pp. 95-102, March 1984.|$|R
40|$|The {{main concern}} {{of this paper}} is speech data {{compression}} for low-cost embedded systems such as voice-related toys or devices with interactive sound-responses. We use a PC to generate and compress 8 -bit-speech-data that has various features such as human speech, symphony and animal songs; the compressed data are then transferred to a masked-ROM. An Intel 8051 embedded chip is employed to expand the compressed speech data stored in a masked-ROM with size ranging from 1 - 8 Mega <b>Bytes.</b> <b>No</b> RAM (read/write memory) is available in the system (to reduce production cost 1. The ROM also stores the program that is responsible for expanding the compressed data. Since the compression is done off-line, we use simple vector-quantization techniques to perform a first stage lossy compression of the data; the lossy-compressed data are then treated by a second stage lossless compression. Because o...|$|R
5000|$|While S-expressions are {{typically}} encoded as text, with spaces delimiting atoms and quotation marks used to surround atoms that contain spaces, {{when using the}} canonical encoding each atom is encoded as a length-prefixed <b>byte</b> string. <b>No</b> whitespace separating adjacent elements in a list is permitted. The length of an atom is expressed as an ASCII decimal number followed by a [...] ":".|$|R
30|$|A radix- 22 {{butterfly}} loads {{their legs}} from the indexes: 0, N/ 4, N/ 2, and 3 [*]N/ 4. All this data should {{exist in the}} cache at the same time. If the L 1 D cache is 2 -way set-associative and denoting L 1 D_S the allocated cache size in <b>bytes,</b> <b>no</b> cache thrash would happen if N is {{less than or equal}} to L 1 D_S/ 8. Otherwise, cache lines for indexes (0 and N/ 2) or (N/ 4 and 3 [*] 0 / 4) will overwrite each other continuously, decreasing then the cache efficiency. A solution to this consists of applying radix- 2 FFTs for larger sizes, until the size (L 1 D_S/ 8) where radix- 22 can be used without cache thrashes. Indeed, while radix- 2 FFTs only access elements at indexes like (0 and N/ 2), no cache thrash would occur no matter how large N is; as long as the cache is 2 -way set-associative.|$|R
50|$|The EOT {{character}} in Unix {{is different from}} the Control-Z in DOS. The DOS Control-Z byte is actually sent and/or placed in files to indicate where the text ends. In contrast the Control-D causes the Unix terminal driver to signal the EOF condition, which is not a character, while the <b>byte</b> has <b>no</b> special meaning if actually read or written from a file or terminal.|$|R
50|$|Unlike HTTP, WebSocket {{provides}} full-duplex communication.Additionally, WebSocket enables {{streams of}} messages {{on top of}} TCP. TCP alone deals with streams of <b>bytes</b> with <b>no</b> inherent concept of a message. Before WebSocket, port 80 full-duplex communication was attainable using Comet channels; however, Comet implementation is nontrivial, and due to the TCP handshake and HTTP header overhead, it is inefficient for small messages. WebSocket protocol aims to solve these problems without compromising security assumptions of the web.|$|R
50|$|With <b>no</b> <b>byte</b> {{addressing}} instructions at all, code had to {{be written}} to pack and shift characters into words. The very large words, and comparatively small amount of memory, meant that programmers would frequently economize on memory by packing data into words at the bit level.|$|R
40|$|We {{describe}} a universal hash-function family, PolyR, which hashes messages of effectively arbitrary lengths in 3. 9 [...] 6. 9 cycles/byte (cpb) on a Pentium II (achieving a collision probability {{in the range}} 2 - 16 [...] 2 - 50). Unlike most proposals, PolyR actually hashes short messages faster (per byte) than long ones. At the same time, its key {{is only a few}} bytes, the output is only a few <b>bytes,</b> and <b>no</b> "preprocessing" is needed to achieve maximal effciency. Our designs have been strongly influenced by low-level considerations relevant to software speed, and experimental results are given throughout...|$|R
50|$|REDOC III {{is a more}} {{efficient}} cipher. It operates on an 80-bit block and accepts a variable-length key of up to 20,480 bits. The algorithm consists only of XORing key bytes with message <b>bytes,</b> and uses <b>no</b> permutations or substitutions. Ken Shirriff describes a differential attack on REDOC-III requiring 220 chosen plaintexts and 230 memory.|$|R
50|$|Byte Superstores Ltd was {{a retail}} venture of Specialist Computer Holdings Ltd in the United Kingdom which from 1993 sold {{primarily}} computer hardware, software and accessories in large stores on retail parks, (similar to PC World). The company {{was acquired by}} PC World in 1998 who re-branded or closed each store - leaving the <b>Byte</b> name to <b>no</b> longer exist.|$|R
50|$|A {{version of}} SLIP with header {{compression}} is called Compressed SLIP (CSLIP). The compression algorithm used in CSLIP {{is known as}} Van Jacobson TCP/IP Header Compression. CSLIP {{has no effect on}} the data payload of a packet and is independent of any compression by the serial line modem used for transmission. It reduces the Transmission Control Protocol (TCP) header from twenty bytes to seven <b>bytes.</b> CSLIP has <b>no</b> effect on User Datagram Protocol (UDP) datagrams.|$|R
50|$|While the PCI bus {{transfers}} 32 bits per data phase, the initiator transmits 4 active-low byte enable signals indicating which 8-bit bytes are to {{be considered}} significant. In particular, a write must affect only the enabled bytes in the target PCI device. They are of little importance for memory reads, but I/O reads might have side effects. The PCI standard explicitly allows a data phase with <b>no</b> <b>bytes</b> enabled, which must behave as a no-op.|$|R
40|$|Run Length Encoding(RLE) {{is one of}} {{the oldest}} {{algorithms}} for data-compression available, a method used for compression of large data into smaller and therefore more compact data. It compresses by looking at the data for repetitions of the same character in a row and storing the amount(called run) and the respective character(called run_value) as target-data. Unfortunately it only compresses within strict and special cases. Outside of these cases, it increases the data-size, even doubles the size in worst cases compared to the original, unprocessed data. In this paper, we will discuss modifications to RLE, with which we will only store the run for characters, that are actually compressible, getting rid of a lot of useless data like the runs of the characters, that are uncompressible in the first place. This will be achieved by storing the character first and the run second. Additionally we create a bit-list of 256 positions(one for every possible ASCII-character), in which we will store, if a specific (ASCII-) character is compressible(1) or not(0). Using this list, we can now say, if a character is compressible (store [the character]+[it's run]) or if it is not compressible (store [the character] only and the next character is NOT a run, but the following character instead). Using this list, we can also successfully decode the data(if the character is compressible, the next character is a run, if not compressible, the next character is a normal character). With that, we store runs only for characters, that are compressible in the first place. In fact, in the worst case scenario, the encoded data will create always just an overhead of the size of the bit-list itself. With an alphabet of 256 different characters(i. e. ASCII) it would be only a maximum of 32 <b>bytes,</b> <b>no</b> matter how big the original data was. [ [...] . ]Comment: 16 pages and algorithm-flowchart...|$|R
2500|$|While the PCI bus {{transfers}} 32 bits per data phase, the initiator transmits 4 active-low byte enable signals indicating which 8-bit bytes are to {{be considered}} significant. [...] In particular, a write must affect only the enabled bytes in the target PCI device. [...] They are of little importance for memory reads, but I/O reads might have side effects. [...] The PCI standard explicitly allows a data phase with <b>no</b> <b>bytes</b> enabled, which must behave as a no-op.|$|R
5000|$|The data-link layer {{describes}} the baseband coding {{of which the}} largest element in the structure is called a [...] "group" [...] sized 104 bits wide. Within each group is 4 blocks sized 26bits wide. Each block contains a 16bit data word and a 10 bit checkword. In {{the case of the}} FM Tuner RDA5807M IC, it displays a group in separate 16bits blocks over four i2c registers. All group is sent most significant <b>byte</b> first, with <b>no</b> gap between groups or blocks.|$|R
25|$|Over {{the years}} the {{computing}} model changed, and Unix's treatment of everything as a file or <b>byte</b> stream <b>no</b> longer was as universally applicable as it was before. Although a terminal could {{be treated as a}} file or a byte stream, which is printed to or read from, the same {{did not seem to be}} true for a graphical user interface. Networking posed another problem. Even if network communication can be compared to file access, the low-level packet-oriented architecture dealt with discrete chunks of data and not with whole files. As the capability of computers grew, Unix became increasingly cluttered with code. It is also because the modularity of the Unix kernel is extensively scalable. While kernels might have had 100,000 lines of code in the seventies and eighties, kernels of modern Unix successors like Linux have more than 13 million lines.|$|R
2500|$|Work on The Settlers III {{began in}} January 1997, {{prior to the}} release of The Settlers II: Gold Edition. Initially, Blue <b>Byte</b> had <b>no</b> {{immediate}} plans to do a third title in the series, but due to the unexpected popularity of both The Settlers and its sequel, Volker Wertich (designer and programmer of the original) and Thomas Hertzler (Blue Byte CEO and the series producer) decided to begin development. Wertich had not been involved in the making of the second game, because, as he describes it, [...] "after two years programming The Settlers, I didn't really want to see those little men for a while." [...] However, by 1997, he was ready to resume working on the series, eager to implement ideas which he felt would allow the game to compete with rival titles such as [...] and Anno 1602.|$|R
50|$|Normal {{files are}} {{progressively}} indexed. Single-block files (under 513 <b>bytes)</b> have <b>no</b> index block; the directory entry points {{directly to the}} block of file data. Files with between 2 and 256 blocks (513 bytes to 128 kB) of data have a single index block, to which the directory entry points, which contains a list of up to 256 data block addresses. Larger files have a master index block containing a list of up to 256 index block addresses. When the Apple IIgs was introduced, a new storage format was introduced for files with two forks, as was typical for IIgs system and program files; the directory entry points to an informational block that tells the computer the storage format of the two forks. These files cannot be read or written natively by ProDOS 8, though the volume itself remains compatible.|$|R
50|$|Over {{the years}} the {{computing}} model changed, and Unix's treatment of everything as a file or <b>byte</b> stream <b>no</b> longer was as universally applicable as it was before. Although a terminal could {{be treated as a}} file or a byte stream, which is printed to or read from, the same {{did not seem to be}} true for a graphical user interface. Networking posed another problem. Even if network communication can be compared to file access, the low-level packet-oriented architecture dealt with discrete chunks of data and not with whole files. As the capability of computers grew, Unix became increasingly cluttered with code. It is also because the modularity of the Unix kernel is extensively scalable. While kernels might have had 100,000 lines of code in the seventies and eighties, kernels of modern Unix successors like Linux have more than 13 million lines.|$|R
5000|$|Work on The Settlers III {{began in}} January 1997, {{prior to the}} release of the The Settlers II: Gold Edition. Initially, Blue <b>Byte</b> had <b>no</b> {{immediate}} plans to do a third title in the series, but due to the unexpected popularity of both The Settlers and its sequel, Volker Wertich (designer and programmer of the original) and Thomas Hertzler (Blue Byte CEO and the series producer) decided to begin development. Wertich had not been involved in the making of the second game, because, as he describes it, [...] "after two years programming The Settlers, I didn't really want to see those little men for a while." [...] However, by 1997, he was ready to resume working on the series, eager to implement ideas which he felt would allow the game to compete with rival titles such as Warcraft II and Anno 1602.|$|R
5000|$|<b>Byte</b> Bandit made <b>no</b> {{attempt to}} {{disguise}} itself as modern viruses, trojans, and worms do. While it naturally over-wrote the bootblock, it also hooked into the system, remaining reset-resident and causing system data corruption and system failures. The virus increments a copy counter {{every time it}} writes itself to a disk, {{which is in the}} text string [...] "Virus by Byte Bandit in 9.87. Number of copys:" [...] which also gives a date of September 1987 for the creation, as well as the assumed name of the programmer.|$|R
30|$|There were 61 out of 10, 877 Kaggle test {{records for}} which the Asm model was unable to make a prediction. The final <b>bytes</b> model had <b>no</b> such records. We {{combined}} predictions from both models by defaulting to the bytes model prediction only when no Asm file prediction was available. This approach produced a Kaggle log loss score of 0.081511944. A similar and possibly more accurate version of this ensemble could be made by generating a second Asm model using a shorter token length of 50 vs. 55 to pick up additional missing predictions. However, we leave this to future research.|$|R
2500|$|In the {{personal}} computing era, {{one source of}} consumer confusion is {{the difference in the}} way many operating systems display hard drive sizes, compared to the way hard drive manufacturers describe them. Hard drives are specified and sold using [...] "GB" [...] and [...] "TB" [...] in their decimal meaning: one billion and one trillion bytes. Many operating systems and other software, however, display hard drive and file sizes using [...] "MB", [...] "GB" [...] or other SI-looking prefixes in their binary sense, just as they do for displays of RAM capacity. For example, many such systems display a hard drive marketed as [...] "160GB" [...] as [...] "149.05GB". The earliest known presentation of hard disk drive capacity by an operating system using [...] "KB" [...] or [...] "MB" [...] in a binary sense is 1984; earlier operating systems generally presented the hard disk drive capacity as an exact number of <b>bytes,</b> with <b>no</b> prefix of any sort, for example, in the output of the MS-DOS or PCDOS CHKDSK command.|$|R
