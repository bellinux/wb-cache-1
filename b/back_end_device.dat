1|5495|Public
40|$|Abstract: This paper {{reports on}} a {{technique}} used to generate accurate HTML output from GNU Troff. GNU Troff is a typesetting package which reads plain text mixed with formatting commands and produces formatted output. It supports a number of devices and now supports the production of HTML. The paper discusses {{the design of the}} HTML device driver grohtml and modifications made to GNU Troff. The front end program troff was modi-fied to maintain a reduced state machine which is examined each time a glyph is passed to the <b>back</b> <b>end</b> <b>device</b> driver (post-grohtml). Any change in system state between the production of two glyphs results in a sequence of events being passed to the device driver. There is a direct correspondence between this technique and creating a script for a next event simulation queue. Furthermore the device driver reconstructs the system state and for-mats the HTML according to state changes caused when processing the event queue. This technique works well, as it minimises the state information passed from front end to <b>back</b> <b>end</b> <b>device</b> driver whilst still preserving the high level layout of the text. Using this technique GNU Troff effectively translates input source into another mark-up language and thus this technique could be extended to translate GNU Troff documents into any of the OpenOffice supported formats. Troff has been in use for three decades now and is still actively used by authors. Troffâ€™s biggest use, however, is to format manual pages for GNU/Linux and other UNIX like operating systems. Introducing this facility into GNU Troff provides users with the ability to translate legacy documents into HTML and in the future to a format supported by OpenOffice. Ke ywords: groff, troff, grohtml, HTML, simulation...|$|E
5|$|With {{the release}} of Windows Vista, ActiveSync was {{replaced}} with Windows Mobile Device Center. Device Center is included with Vista and Windows 7 and provides many front end enhancements, allowing a home user to sync PIM information with Microsoft Outlook 2003 and later, photos from Windows Photo Gallery, videos or music from Windows Media Player and favorites with Internet Explorer; {{without the need for}} a server <b>back</b> <b>end.</b> <b>Devices</b> at this time also included a base driver compatible with Mobile Device Center so a user can connect to a computer without a need for any configuration.|$|R
40|$|Includes bibliographical {{references}} (page 56) This project {{involves the}} design and implementation of a single-legged walking stick robot that utilizes a unique locomotion method. The robot is fully autonomous and can avoid obstacles. Forward locomotion is achieved by rotating the <b>back</b> <b>end</b> of the <b>device</b> {{up and over the}} front end. The robot consists of a long bar that connects two boxes that each house electrical and mechanical components. Wireless RF communication is used between the two boxes to coordinate their movements. As a box is lifted, position sensing is provided by an accelerometer and obstacle avoidance is provided by an infrared sensor. A programmable microcontroller manages the control of the components...|$|R
30|$|PacketCable 2.0 replaces NCS with SIP. NCS is a {{centralized}} signaling protocol to control nonintelligent legacy telephony <b>end</b> <b>devices.</b> With NCS, CMS monitors the <b>end</b> <b>device</b> status and issues the corresponding signaling to establish or terminate a session. The <b>end</b> <b>device</b> has no intelligence {{to provide the}} required call control signaling. In contrast, SIP proposes distributed signaling architecture with intelligent <b>end</b> <b>devices.</b> The <b>end</b> <b>devices</b> are able to provide call control signaling and react to the incoming requests. Consequently, the involvement of IMS components (including CMS) in session signaling is limited to AAA functions, session routing, and service triggering.|$|R
40|$|Based on {{the idea}} of the {{fabrication}} platform in the automobile industry to save cost and time of fabrication, the fabrication of other micro fluidic actuators will be reorganised to a full wafer fabrication technology line too. The equipment therefore will be the same for different fluidic devices like micro pumps, active micro valves and micro mixers. To fabricate different fluidic devices just particular design is to be done by appropriate masks and etching protocols. All different fluidic devices will be fabricated with the same front <b>end</b> and <b>back</b> <b>end</b> process on the same equipment, no special steps or equipment are necessary. The front <b>end</b> <b>device</b> fabrication for the different fluidic products is based on a 4 " wafer process integrated in a 100 class cleanroom and yet organised in a platform conception. The main process modules are oxide, nitride, doubled sided lithography, dry etching, wafer bond technologies, KOH deep etching and sputtering. Also the <b>back</b> <b>end</b> fabrication will be modular: changing the fabrication from one device to another, downtime of the different equipment is reduced to few minutes because only device specific adapters, clamps or conversion kits must be changed to fabricate different fluidic devices with the same equipment. Intermediate tests will be done on wafer level, thus time for single product endtest will be reduced. Reliability tests like temperature and vibration tests will be developed. This <b>back</b> <b>end</b> fabrication will be integrated in a laboratory (10 000 class cleanroom). High yield and reproducibility, low cost, good performance and repeatability will be the result of realizing the full wafer fabrication platform of microfluidic devices...|$|R
50|$|The {{final phase}} is the {{generation}} of the high level code in the <b>back</b> <b>end</b> of the decompiler. Just as a compiler may have several <b>back</b> <b>ends</b> for generating machine code for different architectures, a decompiler may have several <b>back</b> <b>ends</b> for generating high level code in different high level languages.|$|R
30|$|Hence, with {{elimination}} of responsibilities for <b>end</b> <b>device</b> control, supplementary {{services such as}} session forking/merging, caller ID presentation/restriction, and call forwarding may be implemented on board in CMS. Moreover, PacketCable 2.0 is able to support a variety of advanced <b>end</b> <b>devices</b> to satisfy <b>end</b> users demands for high quality experience of multimedia services.|$|R
40|$|Devices for {{generating}} streamwise vorticity in a boundary includes {{various forms of}} vortex generators. One form of a split-ramp vortex generator includes a first ramp element and a second ramp element with front <b>ends</b> and <b>back</b> <b>ends,</b> ramp surfaces extending between the front <b>ends</b> and the <b>back</b> <b>ends,</b> and vertical surfaces extending between the front <b>ends</b> and the <b>back</b> <b>ends</b> adjacent the ramp surfaces. A flow channel is between the first ramp element and the second ramp element. The <b>back</b> <b>ends</b> of the ramp elements have a height greater than a height of the front ends, and the front ends of the ramp elements have a width greater than a width of the <b>back</b> <b>ends...</b>|$|R
3000|$|The {{design of}} the MCE/WCE allows to offer an API (application {{programming}} interface) to <b>end</b> <b>devices</b> on board or at the wayside. This way, <b>end</b> <b>devices</b> can optionally subscribe to events that the Application Interface will generate to indicate the availability of e.g., high throughput or low delay with general network condition messages (e.g., [...] "no network available", [...] "low bandwidth", [...] "average bandwidth", [...] "high bandwidth"). The <b>end</b> <b>devices</b> can use this information for their internal reasoning to find a suitable moment to start a certain application (e.g., only transfer movie files for the entertainment system when high bandwidth is available).|$|R
40|$|Fr ank Doodeman A <b>back</b> <b>end</b> {{table is}} part of the Amsterdam Compiler Kit (ACK). It is used to produce the actual <b>back</b> <b>end,</b> a program that {{translates}} the intermediate lan-guage family EM to assembly language for some target machine. The table dis-cussed here can be used for two <b>back</b> <b>ends,</b> suitable for in total three machines: the MC 68000 and MC 68010 (the difference between these two is so small that one <b>back</b> <b>end</b> table can be used for either one), or for the MC 68020...|$|R
30|$|Database centric {{architectures}} {{hide the}} heterogeneity of underlying networks by only allowing access to network information using database operations. For example, the SENSEI project [27] solves the inaccessibility of low-resource <b>end</b> <b>devices</b> by collecting all data from the <b>end</b> <b>devices</b> and making it available in a centrally accessible database. Unfortunately, this approach often results in significant network overhead.|$|R
5000|$|In compilers, {{the front}} end {{translates}} a computer programming source code into an intermediate representation, and the <b>back</b> <b>end</b> works with the intermediate representation to produce code in a computer output language. The <b>back</b> <b>end</b> usually optimizes to produce code that runs faster. The front-end/back-end distinction can separate the parser section that deals with source code and the <b>back</b> <b>end</b> that generates code and optimizes. Some designs, such as GCC, offer choices between multiple front ends (parsing different source languages) or <b>back</b> <b>ends</b> (generating code for different target processors).|$|R
5000|$|The <b>back</b> <b>end</b> {{takes the}} {{optimized}} IR {{from the middle}} end. It may perform more analysis, transformations and optimizations that specific for the target CPU architecture. The <b>back</b> <b>end</b> generates the target-dependent assembly code, performing register allocation in the process. The <b>back</b> <b>end</b> performs instruction scheduling, which re-orders instructions to keep parallel execution units busy by filling delay slots. Although most algorithms for optimization are NP-hard, heuristic techniques are well-developed and currently implemented in production-quality compilers. Typically the output of a <b>back</b> <b>end</b> is machine code specialized for a particular processor and operating system.|$|R
40|$|Includes bibliographical references. This thesis {{discusses}} the University of Cape Town {{implementation of a}} table driven <b>back</b> <b>end</b> processor. The <b>back</b> <b>end</b> processor takes as input an intermediate tree representation of a high level programming language. It produces as output an object text ready for assembly. The specifications of the input tree and the output object are supplied to the <b>back</b> <b>end</b> processor via two tables. The initial motivation for this project was {{the need to provide}} a <b>back</b> <b>end</b> processor capable of taking the DIANA tree output of the University of Cape Town front end processor and producing a corresponding P-code object. The University of Cape Town <b>back</b> <b>end</b> processor is implemented using Pascal and C in a Unix V environment...|$|R
40|$|The <b>back</b> <b>end</b> of a {{compiler}} performs machine-dependent {{tasks and}} lowlevel optimisations that are laborious to implement and di#cult to debug. In addition, in languages that require run-time {{services such as}} garbage collection, the <b>back</b> <b>end</b> must interface with the run-time system to provide those services. The net result is that building a compiler <b>back</b> <b>end</b> entails a high implementation cost...|$|R
50|$|Internet Protocol as a {{communications}} protocol between the AllVid gateway and <b>end</b> <b>devices.</b>|$|R
5000|$|ANSI C12.19 is the American National Standard for Utility Industry <b>End</b> <b>Device</b> Data Tables ...|$|R
30|$|In {{order to}} {{transmit}} {{a signal from}} the NG through wireless scenario, a wireless sensor network (WSN) developed at LinkÃ¶ping University (Sweden) was used [26 â€“ 28]. The WSN {{is based on a}} ZigBee specification. The WSN consists of gateway, routers, and <b>end</b> <b>devices.</b> The gateway and routers are the mains-powered components and the <b>end</b> <b>devices</b> for sensing are battery-powered.|$|R
40|$|Abstract. The {{development}} of a wireless sensor network system for temperature and humidity monitoring is described. The system is composed of two main parts, namely an <b>end</b> <b>device</b> and a coordinator. The <b>end</b> <b>device</b> consists of an SHT 10 sensor, an XBee Pro RF module, an ATMega 8535 microcontroller, and a battery. The coordinator consists of an XBee Pro RF module and an SIM 900 GSM module. The temperature and humidity data were sent by the <b>end</b> <b>device</b> to the coordinator and they were forwarded to the web server via GPRS communication using the SIM 900 GSM module. In order to the data stored in the database can be accessed in real time via the internet, a web server is developed by using CodeIgniter (CI). It was shown that each <b>end</b> <b>device</b> can communicate very well with the coordinator. Moreover, the data are received {{in accordance with the}} timing of delivery was given...|$|R
50|$|The <b>back</b> <b>end</b> {{which is}} used to detect {{security}} issues in mobile apps is named Sherlock. The front end is known as Irene, and uses Ember as its framework. The front end development team works independent of the <b>back</b> <b>end</b> team and doesnâ€™t need the server to be online during development. The front <b>end</b> and <b>back</b> <b>end</b> deployment processes are also different from each other.|$|R
40|$|This study {{investigates the}} value {{relevance}} of nuclear decommissioning costs and <b>back</b> <b>end</b> costs (nuclear recycle costs), which are accruals related to {{nuclear power plants}} in electric utilities. We analyze the association between those accruals and stock price levels {{at the end of}} fiscal year, based on earnings capitalization model. The findings of this paper are as follows. (1) Recognizing of decommissioning costs and <b>back</b> <b>end</b> costs contribute to increase the quality of earnings of electric companies. Off-balancing regulation, which compels not to recognize some portion of <b>back</b> <b>end</b> costs, distorts the quality of earnings. (2) Decommissioning costs and <b>back</b> <b>end</b> costs, which are measured by estimating of future payments, are value relevant. However, the contents of information differ each other. The result of OLS regression shows that decommissioning costs (<b>back</b> <b>end</b> costs) are positively (negatively) associated with stock price levels. (3) Though both discretionary decommissioning costs and discretionary <b>back</b> <b>end</b> costs are value relevant, two accruals have different information contents. Moreover, the value relevance of income-increasing (negative signed) discretionary accruals is different form that of income-decreasing (positive signed) discretionary accruals. (4) We cannot observe the signaling effect of discretionary accruals reported in some prior studies. (5) As to the <b>back</b> <b>end</b> costs, although in limited case, we find the conservative behavior of estimating the future payments. In Appendix, we detect the income smoothing strategy of electric companies by discretionary estimation of decommissioning costs and <b>back</b> <b>end</b> costs. ...|$|R
5000|$|IEEE P1377 Draft Standard for Utility Industry Metering Communication Protocol Application Layer (<b>End</b> <b>Device</b> Data Tables) ...|$|R
50|$|In {{software}} engineering, {{the terms}} front <b>end</b> and <b>back</b> <b>end</b> {{refers to the}} separation of concerns between the presentation layer (front end), and the data access layer (<b>back</b> <b>end)</b> {{of a piece of}} software, or the physical infrastructure or hardware. In the client-server model, the client is usually considered the front end and the server is usually considered the <b>back</b> <b>end,</b> even when some presentation work is actually done on the server.|$|R
40|$|Although I {{have proven}} {{that the general}} problem is undecidable, I show how, for {{machines}} of practical interest, to generate the <b>back</b> <b>end</b> of a compiler. Unlike previous work on generating <b>back</b> <b>ends,</b> I generate the machinedependent components of the <b>back</b> <b>end</b> using only information that is independent of the compilerâ€™s internal data structures and intermediate form. My techniques substantially reduce the burden of retargeting the compiler: although it is still necessary to master the target machineâ€™s instruction set, {{it is not necessary}} to master the data structures and algorithms in the compilerâ€™s <b>back</b> <b>end.</b> Instead, the machine-dependent knowledge is isolated in the declarative machine descriptions. The largest machine-dependent component in a <b>back</b> <b>end</b> is the instruction selector. Previous work has shown that it is difficult to generate a highquality instruction selector. But by adopting the compiler architecture developed by Davidson and Fraser (1984), I can generate a naÃ¯ve instructio...|$|R
50|$|EMMS has {{multiple}} <b>back</b> <b>ends</b> {{to connect to}} external players so EMMS can support many different audio and video formats, while remaining clean and small itself. EMMS {{is divided into three}} parts, the player <b>back</b> <b>ends,</b> media sources (which can be a local file system or a network stream), and the core player. One of the player <b>back</b> <b>ends</b> connects to MPD. Other backends are available for mplayer and gstreamer. Additional players can be easily defined.|$|R
5000|$|Browser - A {{light-weight}} browser {{that relies}} on the System Webview, for low <b>end</b> <b>devices,</b> also known as Jelly.|$|R
50|$|In a {{redundant}} {{switched network}} {{it is possible}} for an <b>end</b> <b>device</b> to receive the same frame multiple times.|$|R
5000|$|C3300 - High <b>end</b> <b>device.</b> Targeted for use {{in company}} headquarters, datacentres and ISPs. Storage {{capacity}} of up to 2.4TB.|$|R
5000|$|QoE metrics {{are often}} {{measured}} at the <b>end</b> <b>devices</b> and can conceptually {{be seen as the}} remaining quality after the distortion introduced during the preparation of the content and the delivery through the network, until it reaches the decoder at the <b>end</b> <b>device.</b> There are several elements in the media preparation and delivery chain and some of them may introduce distortion. This causes degradation of the content, and several elements in this chain can be considered as [...] "QoE-relevant" [...] for the offered services. The causes of degradation are applicable for any multimedia service, that is, not exclusive to video or speech. Typical degradation occur at the encoding system (compression degradation), transport network, access network (e.g., packet loss or packet delay), home network (e.g. WiFi performance) and <b>end</b> <b>device</b> (e.g. decoding performance).|$|R
40|$|This paper {{presents}} a general discriminative training method {{for both the}} front end feature extractor and <b>back</b> <b>end</b> acoustic model of an automatic speech recognition system. The front <b>end</b> and <b>back</b> <b>end</b> parameters are jointly trained using the Rprop algorithm against a maximum mutual information (MMI) objective function. Results are presented on the Aurora 2 noisy English digit recognition task. It is shown that discriminative training of the front <b>end</b> or <b>back</b> <b>end</b> alone can improve accuracy, but joint training is considerably better. 1...|$|R
30|$|Low-cost <b>end</b> <b>devices</b> can be {{included}} in IP networks since IP packets can be generated and processed even without a full protocol stack.|$|R
50|$|Fortunately, {{for this}} and several reasons {{outlined}} later, DNS servers that use such sophisticated database <b>back</b> <b>ends</b> in general rarely use zone transfer as their database replication mechanism in the first place, and usually instead employ the vastly superior distributed database replication mechanisms that the <b>back</b> <b>ends</b> themselves provide.|$|R
40|$|International audienceThis paper {{presents}} architecture {{design and}} performance {{evaluation of a}} <b>back</b> <b>end</b> system used to store, index, manage and visualize water quality measurements collected by sensor networks deployed in rivers, lakes and coastal regions. The embedded communications systems in each sensor node enable ad hoc network operation to relay the measurements to the <b>back</b> <b>end</b> system in charge of managing, processing and providing data to end users and large communities through web interfaces. The {{focus is on the}} <b>back</b> <b>end</b> system architecture description and on the evaluation of its performance...|$|R
50|$|Toasters - The {{dangerous}} <b>back</b> <b>end</b> of a jet.|$|R
40|$|This {{project is}} to control an {{irrigation}} canal gate by sending control messages from a sending device to a receiving <b>end</b> <b>device,</b> which passes these messages to an electronic circuit responsible for controlling {{the movement of the}} irrigation gateThe purpose of this {{project is to}} control an irrigation canal gate by sending control messages from a sending device to a receiving <b>end</b> <b>device,</b> which passes these messages to an electronic circuit responsible for controlling the movement of the irrigation gat...|$|R
5000|$|Demo Storage - An in-memory <b>back</b> <b>end</b> for the {{persistent}} store.|$|R
