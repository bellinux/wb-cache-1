156|8328|Public
25|$|Orthogonal array {{testing is}} a <b>black</b> <b>box</b> <b>testing</b> {{technique}} {{which is a}} systematic, statistical way of software testing. It is used {{when the number of}} inputs to the system is relatively small, but too large to allow for exhaustive testing of every possible input to the systems. It is particularly effective in finding errors associated with faulty logic within computer software systems. Orthogonal arrays can be applied in user interface testing, system testing, regression testing and performance testing.|$|E
50|$|Pros and Cons of <b>black</b> <b>box</b> <b>testing</b> include: Test case {{generation}} in <b>black</b> <b>box</b> <b>testing</b> is fairly simple. Their generation is completely independent of software development {{and can be}} done in an early stage of development. As a consequence, the programmer has better knowledge of how to design the database application and uses less time for debugging. Cost for development of black box test cases is lower than development of white box test cases. The major drawback of <b>black</b> <b>box</b> <b>testing</b> is that it is unknown how much of the program is being tested. Also, certain errors cannot be detected.|$|E
5000|$|<b>Black</b> <b>box</b> <b>testing</b> {{tools such}} as Web {{application}} security scanners, vulnerability scanners and penetration testing software ...|$|E
40|$|Automated <b>black</b> <b>box</b> <b>test</b> {{generation}} {{is a useful}} tool for developers that allows them to quickly generate a large number of tests {{with a wide range of}} values tested. The current most popular tool for <b>black</b> <b>box</b> <b>test</b> generation in Java, JML, is lacking in a number of features. SPEST aims to improve upon existing tools, and provide a <b>black</b> <b>box</b> <b>test</b> generation tool that can create human readable tests from simple pre and post conditions added as comments to the Java source code...|$|R
40|$|The {{intercalated}} {{islands are}} intra-amigdaloid clusters of D 1 receptor rich GABAergic neurons, which control impulse traffic between the basolateral complex {{and the central}} nucleus of the amygdala. As dopaminergic transmission within the amygdala {{may play a role}} in anxiety, the effect of the D 1 antagonist SCH 23390 microinjected mainly close to the rostral intercalated islands in rats was studied, using the White and <b>Black</b> <b>Box</b> <b>test.</b> SCH 23390 reduced anxiety by an increase in the latency of the first entry into the black compartment and by an increase in the total time spent in the white compartment of the White and <b>Black</b> <b>Box</b> <b>test,</b> while there was no significant modification of locomotion. It is suggested that blockade of D 1 receptors in the rostral intercalated islands may reduce anxiety through a reduction of GABA-mediated dishinibition of the central amygdaloid nucleus...|$|R
40|$|Abstract. Evolutionary Testing (ET) {{has been}} shown to be very {{successful}} for testing real world applications [10]. The original ET approach focuses on searching for a high coverage of the test object by generating separate inputs for single function calls. We have identified a large set of real world application for which this approach does not perform well because only sequential calls of the tested function can reach a high structural coverage (white <b>box</b> <b>test)</b> or can check functional behavior (<b>black</b> <b>box</b> <b>tests).</b> Especially, control software which is responsible for controlling and constraining a system cannot be tested successfully with ET. Such software is characterized by storing internal data during a sequence of calls. In this paper we present the Evolutionary Sequence Testing approach for white <b>box</b> and <b>black</b> <b>box</b> <b>tests.</b> For automatic sequence testing, a fitness function for the application of ET will be introduced, which allows the optimization of input sequences that reach a high coverage of the software under test. The authors also present a new compact description for the generation of real-world input sequence...|$|R
50|$|Banking {{and large}} E-Commerce {{corporations}} {{have been the}} very early adopter customer profile for these types of tools. It is commonly held within these firms that both <b>Black</b> <b>Box</b> <b>testing</b> and White Box testing tools are needed {{in the pursuit of}} application security. Typically sited, <b>Black</b> <b>Box</b> <b>testing</b> (meaning Penetration Testing tools) are ethical hacking tools used to attack the application surface to expose vulnerabilities suspended within the source code hierarchy. Penetration testing tools are executed on the already deployed application. White Box testing (meaning Source Code Analysis tools) are used by either the application security groups or application development groups. Typically introduced into a company through the application security organization, the White Box tools complement the <b>Black</b> <b>Box</b> <b>testing</b> tools in that they give specific visibility into the specific root vulnerabilities within the source code in advance of the source code being deployed. Vulnerabilities identified with White Box testing and <b>Black</b> <b>Box</b> <b>testing</b> are typically in accordance with the OWASP taxonomy for software coding errors. White Box testing vendors have recently introduced dynamic versions of their source code analysis methods; which operates on deployed applications. Given that the White Box testing tools have dynamic versions similar to the <b>Black</b> <b>Box</b> <b>testing</b> tools, both tools can be correlated in the same software error detection paradigm ensuring full application protection to the client company.|$|E
5000|$|System Testing: In {{this stage}} the {{software}} is tested from all possible dimensions for all intended purposes and platforms. In this stage <b>Black</b> <b>box</b> <b>testing</b> technique is normally used.|$|E
50|$|The {{two types}} of {{automated}} tools associated with application vulnerability detection (application vulnerability scanners) are Penetration Testing Tools (often categorized as <b>Black</b> <b>Box</b> <b>Testing</b> Tools) and static code analysis tools (often categorized as White Box Testing Tools).|$|E
40|$|Abstract - In the Modern Age, the {{children}} are less familiar with puppets. Lack of children in recognizing the puppet is due in the beginning, the puppet was created for adults. Foreign cultural influences cause children to prefer entertainment from the outside, like a cartoon of the familiar puppets. As a result, the Indonesian people increasingly forget traditional culture to culture {{because it does not}} stand alone, one only is the art of puppetry. The proof, the art that is "valuable" is less familiar to children as a potential replacement for generations to come. Based on the above, further research will be done to create 3 -dimensional animated puppet movie Ghatotkacha. The film was made with the Indonesian leather puppet culture-based computer graphics. The methodology used to obtain specifications animated film Ghatotkacha Exemplary Good is interview, observation, and literature. Animated film done by the method of 3 - dimensional animation production pipeline: pre-production, production and post-production. Ghatotkacha animated film tested by the method alpha <b>test</b> and the <b>black</b> <b>box</b> <b>test.</b> From the making of the film, the final result Ghatotkacha animated film A Good Example. The animated film introduces the puppet culture to children. Ghatotkacha animated film was also made to appreciate the culture of Indonesian puppet. Alpha <b>testing</b> and <b>black</b> <b>box</b> <b>test</b> test carried out on the animated film Ghatotkacha. The test results showed that Ghatotkacha animated film is an animation with puppets culture of Indonesia. Ghatotkacha animated film is a cultural appreciation for the puppet to convey positive values for children aged 6 to 12 years...|$|R
40|$|Abstract <b>Black</b> <b>box</b> <b>test</b> {{generation}} needs a {{model of}} the system un-der test to describe what is to be tested. Testing criteria and test objectives define how it is to be tested. We explain howto represent a system under test via UML models. We derive test objectives from the UML models and use the objectivesand the models to generate test cases by mapping them into a problem description for an AI Planner. The planner usesthe problem description to generate a test suite that satisfies the UML-derived test objectives...|$|R
5000|$|The AST {{offers a}} series of online {{training}} courses in <b>black</b> <b>box</b> software <b>testing</b> (BBST), based on videos from Florida Institute of Technology's Center for Software Testing Education & Research (CSTER) with additional study aids and support from live instructors.|$|R
50|$|On {{a related}} note, <b>black</b> <b>box</b> <b>testing</b> in {{software}} engineering {{has a lot}} in common with reverse engineering. The tester usually has the API, but their goals are to find bugs and undocumented features by bashing the product from outside.|$|E
5000|$|In {{computer}} programming and software engineering, <b>black</b> <b>box</b> <b>testing</b> {{is used to}} check that the output of a program is as expected, given certain inputs. The term [...] "black box" [...] is used because the actual program being executed is not examined.|$|E
5000|$|Validation* Identification of {{unstable}} components/functionalities* Validation {{focused on}} Error-Handling: complementary (not concurrent!) validation regarding the one {{performed by the}} Development team (More for the Money, More for the Time)* Compliance with Software and System Requirements* <b>Black</b> <b>box</b> <b>testing</b> and White box testing techniques* Experience based techniques ...|$|E
5000|$|<b>Black</b> <b>box,</b> {{which is}} <b>testing</b> of a {{mechanism}} without knowing how it works, and merely {{focusing on the}} accuracy of output data based on a known input.|$|R
40|$|Abstract. Auto-loading {{system is}} as an {{important}} part of weapons and equipment, its work reliability determines the combat effectiveness and their own safety of weapon systems. As the core of the automatic loading system control, the control software’s reliability of automatic loading system is especially important. In introducing the importance of software testing, from the basic method of software testing starts, design methods is detailing on test and a case of <b>black</b> <b>box</b> <b>test</b> of the automatic loading system, and finally, combined with the equip software testing, software evaluation model was constructed, Results consistent with test results from platform, shooting range, altitude, cold regions, thermal zone, they are proved the software testing and evaluation are valid...|$|R
40|$|The {{contribution}} {{discusses the}} main properties {{and benefits of}} an atomic element for the formal behavioural <b>black</b> <b>box</b> <b>test</b> description. This element enables the handling of complex functional behaviour in test scenarios by its horizontal composition and the domain specific test description by its extendable vertical differentiation. The atomic element {{is derived from the}} Design by Contract TM which is a powerful concept to increase correctness and robustness of software applications. The atomic element, its composition and differentiation are a common basis for the formal test description with UML, with Petri Nets and with XML. The train’s safety-critical on-board unit of the European Train Control System (ETCS) representing a complex, real-time system is used as application example...|$|R
5000|$|Integration Testing: This {{stage is}} carried out in two modes, as a {{complete}} package or as an increment to the earlier package. Most of the time <b>black</b> <b>box</b> <b>testing</b> technique is used. However, sometimes a combination of Black and White box testing is also used in this stage.|$|E
50|$|Having {{access to}} the {{subsystem}} internals in general makes the subsystem easier to understand but also easier to hack; for example, if a programmer can examine source code, weaknesses in an algorithm are much easier to discover. That makes white box testing much more effective than <b>black</b> <b>box</b> <b>testing</b> but considerably more difficult from the sophistication needed {{on the part of}} the tester to understand the subsystem.|$|E
50|$|The {{different}} Advanced Level exams {{are more}} practical and require deeper knowledge in special areas. Test Manager deals with planning {{and control of}} the test process. Test Analyst concerns, amongst other things, reviews and <b>black</b> <b>box</b> <b>testing</b> methods. Technical Test Analyst includes component tests (also called unit test), requiring knowledge of white box testing and non-functional testing methods - this section also includes test tools. The Expert Level is still in preparation.|$|E
40|$|Abstract. To {{ensure that}} {{components}} are reusable and reliable, {{it is important}} to verify their functionality. In this paper, we present a tool for component integration testing. The components are <b>tested</b> as <b>black</b> <b>boxes.</b> The <b>test</b> tool HotAgent Test enables the tester to specify a test case in a visual way. The tool HotAgent Regression is presented to run the specified tests in regression...|$|R
40|$|In this {{document}} methods for {{answering the question}} what the actual added value of an SSL accelerator to a web server is, are analysed. These test methods should be easy to perform and should enable it to compare results of different accelerators and {{make a statement about}} their performance. The scope of this research is limited to: Open source operating systems, Apache, OpenSSL and the RSA + 3 DES cipher suite. We, two students, performed research to three testing methods. The first method is the OpenSSL’s built-in benchmark. That benchmark tests the performance of the crypto library used by Apache. Second, we tested the response time of a single SSL request in a single session. Last we used Httperf [15] to test the number of connections that the server can handle concurrently. A gray <b>box</b> <b>test</b> is a <b>black</b> <b>box</b> <b>test</b> with a design that is based on the knowledge of algorithms, internal states, architectures, or other high level descriptions of program behaviour (see [16]). Since in [16] is also stated that ”gray box testin...|$|R
40|$|Many {{organizations}} are struggling between the fast delivery of new software and quality assurance. Software testing {{play a key}} part in the quality assurance of software systems. Formal testing techniques increase software quality and, at the same time, reduce software development cycle time. This article presents a methodology for the identification and definition of <b>black</b> <b>box</b> <b>test</b> cases based on the functional requirements of a software system. The methodology is applied during the initial phases of software development. The method involves analyzing system requirements and constructing a functional description graph to organize these requirements. Introduction Until recently, many software companies {{have focused on the}} fast time to market delivery of software products rather than quality assurance. The result is inadequately tested products that have unpleasant surprises for customers (LaMonica, 1995). Testing is a central concept to the construction of quality software. The cost a [...] ...|$|R
50|$|Software can automate, assist or {{otherwise}} handle or {{help in the}} DO-178B processes. All tools used for DO-178B development {{must be part of}} the certification process. Tools generating embedded code are qualified as development tools, with the same constraints as the embedded code. Tools used to verify the code (simulators, test execution tool, coverage tools, reporting tools, etc.) must be qualified as verification tools, a much lighter process consisting in a comprehensive <b>black</b> <b>box</b> <b>testing</b> of the tool.|$|E
50|$|A {{computer}} programming contest is a competition where teams submit (computer program) solutions to judges. The teamsare given {{a set of}} problems to solve in {{a limited amount of}} time (for example 8-13 problems in 5 hours).The judges then give pass/fail judgements to the submitted solutions. Team rankings are computed based on the solutions, when the solutions were submitted and how many attempts were made to solve the problem. The judges test in a <b>Black</b> <b>box</b> <b>testing</b> where the teams {{do not have access to}} the judges' test data.|$|E
50|$|While the {{software}} is being tested, the tester learns things that together with experience and creativity generates new good tests to run. Exploratory testing is often {{thought of as a}} <b>black</b> <b>box</b> <b>testing</b> technique. Instead, those who have studied it consider it a test approach that can be applied to any test technique, at any stage in the development process. The key is not the test technique nor the item being tested or reviewed; the key is the cognitive engagement of the tester, and the tester's responsibility for managing his or her time.|$|E
40|$|Tests play a {{major role}} in validating software. In particular, the role becomes more {{important}} when considering critical software such as for space applications as is the case in the National Institute for Space Research (INPE) in Brazil. Such software uses Finite State Machines (FSM) in order to model the software specification from which test sequences are generated for a <b>black</b> <b>box</b> <b>test</b> approach. As the software for space applications is considered as a complex system with several components (usually in parallel), test designers seem to look for other alternatives instead of modeling via FSM. This paper addresses an experience in the modeling issue in using Statecharts to represent the specification of space application software from which test sequences can be generated. Moreover, it also describes a web-based tool in order to facilitate software testing, from models specified in Statecharts, in a distributed environment. Pages: 1 -...|$|R
40|$|Abstract—With the {{introduction}} of self-adaptivity in software architecture, it becomes feasible to automate tasks that are performed under changing conditions. In order to validate systems with such capabilities, the conditions have to be enforced and reactions verified. An adequate set of scenarios must be performed to assure the required quality level. In our previous work, we investigated a set of requirements for a self-adaptive system validation strategy {{as well as a}} high-level solution scheme. In this paper, we instantiate this scheme and propose a set of timed models that work together as <b>black</b> <b>box</b> <b>test</b> model for our example SAS HomeTurtle. The model can be either used for simulation or test case generation; for both approaches, a unifying infrastructure is described. We further show an example simulation run and present our implementation—the Model-driven Adaptivity Test Environment. The proposed methodology enables test experts to maintain the complex behavior of SAS and cover an adequate part of it in testing...|$|R
40|$|Emerging {{ontology}} authoring {{methods to}} add knowledge to an ontology focus on ameliorating the validation bottleneck. The verification {{of the newly}} added axiom {{is still one of}} trying and seeing what the reasoner says, because a systematic testbed for ontology authoring is missing. We sought to address this by introducing the approach of test-driven development for ontology authoring. We specify 36 generic tests, as TBox queries and TBox axioms tested through individuals, and structure their inner workings in an `open box'-way, which cover the OWL 2 DL language features. This is implemented as a Protege plugin so that one can perform a TDD <b>test</b> as a <b>black</b> <b>box</b> <b>test.</b> We evaluated the two test approaches on their performance. The TBox queries were faster, and that effect is more pronounced the larger the ontology is. We provide a general sequence of a TDD process for ontology engineering as a foundation for a TDD methodology...|$|R
50|$|Orthogonal array {{testing is}} a <b>black</b> <b>box</b> <b>testing</b> {{technique}} {{that is a}} systematic, statistical way of software testing. It is used {{when the number of}} inputs to the system is relatively small, but too large to allow for exhaustive testing of every possible input to the systems. It is particularly effective in finding errors associated with faulty logic within computer software systems. Orthogonal arrays can be applied in user interface testing, system testing, regression testing, configuration testing and performance testing.The permutations of factor levels comprising a single treatment are so chosen that their responses are uncorrelated and therefore each treatment gives a unique piece of information. The net effects of organizing the experiment in such treatments is that the same piece of information is gathered in the minimum number of experiments.|$|E
50|$|Documentation {{testing is}} part of {{non-functional}} testing of a product. It may be a type of <b>black</b> <b>box</b> <b>testing</b> that ensures that documentation about {{how to use the}} system matches with what the system does, providing proof that system changes and improvement have been documented. Documentation testing includes the plans, results, and testing of a system or system component. It includes test case specifications, test plans, test procedures, test reports, and test logs. It is about the testing of all the documents stating, defining, explaining and reporting or validating requirements, procedures followed and results. Documentation testing starts with the beginning of the very first software process to be most cost effective. Documentation testing includes checking the spelling and grammar to review any ambiguity or inconsistency between what functionality it performs and what it is supposed to do.|$|E
5000|$|The {{tendency}} is to relate equivalence partitioning to so called <b>black</b> <b>box</b> <b>testing</b> which is strictly checking a software component at its interface, without consideration of internal structures of the software. But having {{a closer look at}} the subject there are cases where it applies to grey box testing as well. Imagine an interface to a component which has a valid range between 1 and 12 like the example above. However internally the function may have a differentiation of values between 1 and 6 and the values between 7 and 12. Depending upon the input value the software internally will run through different paths to perform slightly different actions. Regarding the input and output interfaces to the component this difference will not be noticed, however in your grey-box testing you would like to make sure that both paths are examined. To achieve this it is necessary to introduce additional equivalence partitions which would not be needed for black-box testing. For this example this would be: ...|$|E
40|$|It {{has been}} {{quite a long time}} since AI {{researchers}} in the field of computer science stop talking about simulating human intelligence or trying to explain how brain works. Recently, represented by deep learning techniques, the field of machine learning is experiencing unprecedented prosperity and some applications with near human-level performance bring researchers confidence to imply that their approaches are the promising candidate for understanding the mechanism of human brain. However apart from several ancient philological criteria and some imaginary <b>black</b> <b>box</b> <b>tests</b> (Turing test, Chinese room) there is no computational level explanation, definition or criteria about intelligence or any of its components. Base on the common sense that learning ability is one critical component of intelligence and inspect from the viewpoint of mapping relations, this paper presents two laws which explains what is the "learning ability" as we familiar with and under what conditions a mapping relation can be acknowledged as "Learning Model"...|$|R
40|$|Test {{generation}} and execution are often {{hampered by the}} large state spaces of the systems involved. In automata (or transition system) based test algorithms, taking advantage of symmetry {{in the behavior of}} specification and implementation may substantially reduce the amount of tests. We present a framework for describing and exploiting symmetries in <b>black</b> <b>box</b> <b>test</b> derivation methods based on finite state machines (FSMs). An algorithm is presented that, for a given symmetry relation on the traces of an FSM, computes a subautomaton that characterizes the FSM up to symmetry. This machinery is applied to Chow's classical W-method for test derivation. Finally, we focus on symmetries defined in terms of repeating patterns. 1991 Mathematics Subject Classification: 68 M 15, 68 Q 05, 68 Q 68, 94 C 12 1991 Computing Reviews Classification System: B. 4. 5, D. 2. 5, F. 1. 1 Keywords: conformance testing, automated test generation, state space reduction, symmetry Note: The research of the first author was c [...] ...|$|R
40|$|Session 3 (full paper) International audienceA {{logic is}} devised for {{reasoning}} about iterated schemata of SMT problems. The satisfiability problem {{is shown to}} be undecidable for this logic, but we present a proof procedure that is sound, complete w. r. t. satisfiability and terminating for a precisely characterized class of problems. It is parameterized by an external procedure (used as a <b>black</b> <b>box)</b> for <b>testing</b> the satisfiability of ground instances of the schema in the considered theory (e. g. integers, reals etc.) ...|$|R
