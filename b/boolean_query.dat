107|328|Public
50|$|Thus, the {{extended}} Boolean {{model can be}} considered as a generalization of both the Boolean and vector space models; those two are special cases if suitable settings and definitions are employed. Further, research has shown effectiveness improves relative to that for <b>Boolean</b> <b>query</b> processing. Other research has shown that relevance feedback and query expansion can be integrated with extended <b>Boolean</b> <b>query</b> processing.|$|E
5000|$|Query {{rewriting}} is {{the process}} of automatically reformulating a search query to more accurately capture its intent. Query expansion adds additional query terms, such as synonyms, in order to retrieve more documents and thereby increase recall. Query relaxation removes query terms to reduce the requirements for a document to match the query, thereby also increasing recall. Other forms of query rewriting, such as automatically converting consecutive query terms into phrases and restricting query terms to specific fields, aim to increase precision. Apache Lucene search engine [...] uses query rewrite to transform complex queries to more primitive queries, such as expressions with wildcards (e.g. quer*) into a <b>boolean</b> <b>query</b> of the matching terms from the index (such as query OR queries).|$|E
50|$|The Extended Boolean {{model was}} {{described}} in a Communications of the ACM article appearing in 1983, by Gerard Salton, Edward A. Fox, and Harry Wu. The goal of the Extended Boolean model is to overcome the drawbacks of the Boolean model {{that has been used}} in information retrieval. The Boolean model doesn't consider term weights in queries, and the result set of a <b>Boolean</b> <b>query</b> is often either too small or too big. The idea of the extended model is to make use of partial matching and term weights as in the vector space model. It combines the characteristics of the Vector Space Model with the properties of Boolean algebra and ranks the similarity between queries and documents. This way a document may be somewhat relevant if it matches some of the queried terms and will be returned as a result, whereas in the Standard Boolean model it wasn't.|$|E
5000|$|Structured <b>Boolean</b> <b>queries,</b> e.g. [...] "race AND {{condition}} NOT horse" ...|$|R
50|$|FO(TC,X) is {{the set of}} <b>boolean</b> <b>queries</b> definable in FO(X) with a {{transitive}} closure (TC) operator.|$|R
40|$|In {{a variety}} of {{settings}} from relational databases to LDAP to Web applications, there is an increasing need to quickly and accurately estimate the count of tuples (LDAP entries, Web documents, etc.) matching <b>Boolean</b> substring <b>queries.</b> In providing such selectivity estimates, the correlation between different occurrences of substrings is crucial. Selectivity estimation for generalized <b>Boolean</b> <b>queries</b> has not been studied previously; our own prior work, which is discussed and extended herein, applies to the case of onedimensional <b>Boolean</b> <b>queries</b> [?]. Existing methods for the case of multidimensional conjunctive queries approximate selectivities by explicitly storing cross-counts of frequently co-occurring combinations of substrings; estimates are obtained by parsing the query into multidimensional substrings corresponding to stored cross-counts and applying probabilistic formulae. The major problem with these methods is that the number of cross-counts stored by known methods increases exponentially with the number of dimensions (a ‘‘space dimensionality explosion’’) due to the need to capture the correlation amongst the dimensions. Hence, given a limited amount of space, none of the existing methods can reliably give accurate estimates. Moreover, these methods do not generalize to <b>Boolean</b> <b>queries</b> gracefully. We present a novel approach to selectivity estimation for generalized <b>Boolean</b> substring <b>queries</b> with a focus on the two cases of (1) conjunctive multidimensional and (2) <b>Boolean</b> <b>queries.</b> Our approach does not explicitly store cross-counts...|$|R
30|$|The query {{service is}} {{implemented}} in PPNews and supports <b>Boolean</b> <b>query.</b>|$|E
40|$|Even {{though a}} <b>Boolean</b> <b>query</b> can express the {{information}} need precisely enough to select relevant documents, {{it is not}} easy to construct an appropriate <b>Boolean</b> <b>query</b> that covers all relevant documents. To utilize a <b>Boolean</b> <b>query</b> effectively, a mechanism to retrieve as many as possible relevant documents is therefore required. In accordance with this requirement, we propose a method for modifying a given <b>Boolean</b> <b>query</b> by using information from a relevant document set. The retrieval results, however, may deteriorate if some important query terms are removed by this reformulation. A further mechanism is thus required in order to use other query terms that are useful for finding more relevant documents, but are not strictly required in relevant documents. To meet this requirement, we propose a new method that combines the probabilistic IR and the Boolean IR models. We also introduce a new IR system—called appropriate <b>Boolean</b> <b>query</b> reformulation for information retrieval (ABRIR) —based on these two methods and the Okapi system. ABRIR uses both a word index and a phrase index formed from combinations of two adjacent noun words. The effectiveness of these two methods was confirmed according to the NTCIR- 4 Web test collection...|$|E
40|$|We {{analyze the}} results of several {{experimental}} runs submitted for the TREC 2007 Legal Track (also sometimes known as the Legal Discovery Track). We submitted 4 <b>boolean</b> <b>query</b> runs (the initial proposal by the defendant, the rejoinder by the plaintiff, the final negotiated query, and {{a variation of the}} final query which had proximity distances doubled). We submitted 2 vector query runs (one based on the keywords of the final negotiated query, and another based on the (natural language) request text). We submitted a blind feedback run based on the final negotiated <b>boolean</b> <b>query.</b> Finally, we submitted a fusion run of the final boolean, request text and final vector runs. We found that none of the runs had a higher mean estimated Recall@B than the original final negotiated <b>boolean</b> <b>query.</b> ...|$|E
50|$|FO(PFP,X) is {{the set of}} <b>boolean</b> <b>queries</b> definable in FO(X) {{where we}} add a partial fixed point operator.|$|R
40|$|We {{consider}} {{the problem of}} how one can estimate the support of <b>Boolean</b> <b>queries</b> given a collection of frequent itemsets. We describe an algorithm that truncates the inclusion-exclusion sum to include only the frequencies of known itemsets, give a bound for its performance on disjunctions of attributes that is smaller than the previously known bound, and show that this bound is in fact achievable. We also show how to generalize the algorithm to approximate arbitrary <b>Boolean</b> <b>queries.</b> ...|$|R
40|$|During {{the past}} decade, {{there has been}} an {{extensive}} investigation of the computational complexity of the consistent answers of <b>Boolean</b> conjunctive <b>queries</b> under primary key constraints. Much of this investigation has focused on self-join-free <b>Boolean</b> conjunctive <b>queries.</b> In this paper, we study the consistent answers of <b>Boolean</b> conjunctive <b>queries</b> involving a single binary relation, i. e., we consider arbitrary <b>Boolean</b> conjunctive <b>queries</b> on directed graphs. In the presence of a single key constraint, we show that for each such <b>Boolean</b> conjunctive <b>query,</b> either the problem of computing its consistent answers is expressible in first-order logic, or it is polynomial-time solvable, but not expressible in first-order logic...|$|R
40|$|A {{new model}} named Boolean Latent Semantic Indexing model {{based on the}} Singular Value Decomposition and <b>Boolean</b> <b>query</b> {{formulation}} is introduced. While the Singular Value Decomposition alleviates the problems of lexical matching in the traditional information retrieval model, <b>Boolean</b> <b>query</b> formulation can help users to make precise representation of their information search needs. Retrieval experiments {{on a number of}} test collections seem to show that the proposed model achieves substantial performance gains over the Latent Semantic Indexing model...|$|E
40|$|The {{relevance}} feedback process uses information derived from an initially retrieved set of documents to improve subsequent search formulations and retrieval output. In a <b>Boolean</b> <b>query</b> environment {{this implies that}} new query terms must be identified and Boolean operators must be chosen automatically to connect the various query terms. In this study, two recently proposed automatic methods for {{relevance feedback}} of Boolean queries are evaluated and conclusions are drawn concerning the use of effective feedback methods in a <b>Boolean</b> <b>query</b> environment...|$|E
40|$|We {{address the}} {{question}} "How {{much of the information}} stored in a given database can be retrieved by all Boolean queries in a given query language?". In order to answer it we develop a Kolmogorov complexity based measure of expressive power of <b>Boolean</b> <b>query</b> languages over finite structures. This turns the above informal question into a precisely defined mathematical one. This notion gives a meaningful definition of the expressive power of a <b>Boolean</b> <b>query</b> language in a single finite database. The notion of Kolmogorov expressive power of a <b>Boolean</b> <b>query</b> language L in a finite database A is defined by considering two values: the Kolmogorov complexity of the isomorphism type of A; equal to the length of the shortest description of this type, and the number of bits of this description that can be reconstructed from truth values of all queries from L in A: The closer is the second value to the first, the more expressive is the query language. After giving the definitions and provin [...] ...|$|E
40|$|This paper investigates {{automatic}} query generation from legal decisions, {{along with}} contributing a test collection {{for the evaluation}} of case law retrieval. For a sentence or paragraph within a legal decision that cites another decision, queries were automatically generated from a proportion of the terms in that sentence or paragraph. Manually generated queries were also created as a ground to empirically compare automatic methods. Automatically generated queries were found to be more effective than the average <b>Boolean</b> <b>queries</b> from experts. However, the best keyword and <b>Boolean</b> <b>queries</b> from experts significantly outperformed automatic queries...|$|R
40|$|The {{relevance}} feedback process uses information {{obtained from a}} user about a set of initially retrieved documents to improve subsequent search formulations and retrieval performance. In extended Boolean models, the {{relevance feedback}} implies not only that new query terms must be identified and re-weighted, but also that the terms must be connected with Boolean And/Or operators properly. Salton et al. proposed a relevance feedback method, called DNF (disjunctive normal form) method, for a well established extended Boolean model. However, this method mainly focuses on generating <b>Boolean</b> <b>queries</b> but does not concern about re-weighting query terms. Also, this method has some problems in generating reformulated <b>Boolean</b> <b>queries.</b> In this study, we investigate {{the problems of the}} DNF method and propose a relevance feedback method using hierarchical clustering techniques to solve those problems. We also propose a neural network model in which the term weights used in extended <b>Boolean</b> <b>queries</b> can be adjusted by the usersÕ relevance feedbacks. Ó 2005 Published by Elsevier Ltd...|$|R
5000|$|FO(LFP,X) is {{the set of}} <b>boolean</b> <b>queries</b> definable in FO(PFP,X) {{where the}} partial fixed point is limited to be monotone. That is, if the second order {{variable}} is , then [...] always implies [...]|$|R
40|$|In {{a variety}} of {{applications}} ranging from optimizing queries on alphanumeric attributes to providing approximate counts of documents containing several query terms, there is an increasing need to quickly and reliably estimate the number of strings (tuples, documents, etc.) matching a <b>Boolean</b> <b>query.</b> Boolean queries in this context consist of substring predicates composed using Boolean operators. While {{there has been some}} work in estimating the selectivity of substring queries, the more general problem of estimating the selectivity of Boolean queries over substring predicates has not been studied. Our approach is to extract selectivity estimates from relationships between the substring predicates of the <b>Boolean</b> <b>query.</b> However, storing the correlation between all possibl...|$|E
40|$|Abstract In {{this paper}} {{we present a}} {{mechanism}} for approx-imately translating <b>Boolean</b> <b>query</b> constraints across heterogeneous information sources. Achieving the best translationis challenging because sources support different constraints for formulating queries, and often these constraints cannot beprecisely translated. For instance, a query [scor...|$|E
40|$|In recent years, we have {{experienced}} {{an explosion in}} the amount of information available online. Unfortunately, tools which allow users to access this information are still quite rudimentary. Users are forced to express their information needs in <b>boolean</b> <b>query</b> languages. More, results returned are often unnecessarily redundant and poor in quality...|$|E
40|$|AbstractIn {{a variety}} of {{settings}} from relational databases to LDAP to Web applications, there is an increasing need to quickly and accurately estimate the count of tuples (LDAP entries, Web documents, etc.) matching <b>Boolean</b> substring <b>queries.</b> In providing such selectivity estimates, the correlation between different occurrences of substrings is crucial. Selectivity estimation for generalized <b>Boolean</b> <b>queries</b> has not been studied previously; our own prior work, which is discussed and extended herein, applies to the case of one-dimensional <b>Boolean</b> <b>queries</b> [CKKM 00]. Existing methods for the case of multidimensional conjunctive queries approximate selectivities by explicitly storing cross-counts of frequently co-occurring combinations of substrings; estimates are obtained by parsing the query into multidimensional substrings corresponding to stored cross-counts and applying probabilistic formulae. The major problem with these methods is that the number of cross-counts stored by known methods increases exponentially with the number of dimensions (a “space dimensionality explosion”) due to the need to capture the correlation amongst the dimensions. Hence, given a limited amount of space, none of the existing methods can reliably give accurate estimates. Moreover, these methods do not generalize to <b>Boolean</b> <b>queries</b> gracefully. We present a novel approach to selectivity estimation for generalized <b>Boolean</b> substring <b>queries</b> with a focus on the two cases of (1) conjunctive multidimensional and (2) <b>Boolean</b> <b>queries.</b> Our approach does not explicitly store cross-counts, but rather generates them on-the-fly. We employ a Monte Carlo technique called set hashing to succinctly represent the set of tuples containing a given substring as a signature vector of hash values; any combination of set hash signatures gives a cross-count when intersected. Thus, using only linear storage, a large number of cross-counts can be generated including those for complex co-occurrences of substrings. The cross-counts generated by our methods are not exact, but they are adequate for selectivity estimation. We present results from an extensive experimental evaluation of our approach on real data sets. For the case of multidimensional conjunctive queries, our approach achieves better accuracy by an order of magnitude, and scales much more gracefully to higher dimensions, than existing methods. Surprisingly, even though our approach involves generating cross-counts on-the-fly, estimation is very fast, taking 200 μs on a data set of size 6 MB. For the case of <b>Boolean</b> <b>queries,</b> our experiments also demonstrate the superiority of this approach over a straightforward independence-based approach wherein correlations are not captured...|$|R
40|$|Summary: MEDLINE {{is one of}} {{the most}} {{important}} bibliographical information sources for biologists and medical workers. Its PubMed interface supports <b>Boolean</b> <b>queries,</b> which are potentially expressive and exact. However, PubMed is also designed to support simplicity of use at the expense of query expressiveness and exactness. Many PubMed users have never tried explicit <b>Boolean</b> <b>queries.</b> We developed a Java program, PubMed Assistant, to make literature access easier in several ways. PubMed Assistant provides an interface that efficiently displays information about the citations and includes useful functions such as keyword highlighting, export to citation managers, clickable links to Google Scholar and others that are lacking in PubMed. Availability: PubMed Assistant and a detailed online manual are freely available a...|$|R
40|$|Searching for {{relevant}} documents is a laborious task involved in preparing systematic reviews of biomedical literature. Currently, complex <b>Boolean</b> <b>queries</b> are iter-atively developed, and then each document {{of the final}} query result is assessed for relevance. However, the result set sizes of these queries are hard to control, and in practice {{it is difficult to}} balance the competing desires to keep result sets to a manageable volume, and yet not exclude {{relevant documents}} from consideration. Ranking overcomes these problems by allowing the user to choose the number of documents to be inspected. However, previous work did not show significant improve-ments over the Boolean approach when ranked keyword queries based on terms in the <b>Boolean</b> <b>queries,</b> review title, research question or inclusion criteria were used. The extended Boolean retrieval model also provides ranked output, but existing complex <b>Boolean</b> <b>queries</b> can be directly used as formal description of the complex information needs occurring in this domain. In this paper we show that extended Boolean retrieval is able to find a larger quantity of relevant documents than previous approaches when comparable (or greater) numbers of documents are inspected for relevance...|$|R
40|$|Software {{tools for}} {{personal}} photo collection management are proliferating, but they usually have limited searching and browsing functions. We implemented the PhotoFinder prototype to enable non-technical users of personal photo collections to search and browse easily. PhotoFinder provides {{a set of}} visual <b>Boolean</b> <b>query</b> interfaces, coupled with dynamic query and query preview features. It gives users powerful search capabilities. Using a scatter plot thumbnail display and dragand -drop interface, PhotoFinder {{is designed to be}} easy to use for searching and browsing photos. Keywords : PhotoFinder, user interface, dynamic query, query preview, search, browsing, <b>Boolean</b> <b>query,</b> digital photo library. 1. INTRODUCTION Digital cameras, scanners and personal computers are now common. But as collections grow in size, the need to organize, search, and browse digital photos increases [1]. There are many personal photo collection management tools available either commercially or non-commercially. [...] ...|$|E
40|$|An {{uncertain}} database db {{is defined}} as a database in which distinct tuples of the same relation can agree on their primary key. A repair is obtained by selecting a maximal number of tuples without ever selecting two distinct tuples of the same relation that agree on their primary key. Obviously, the number of possible repairs can be exponential {{in the size of the}} database. Given a <b>Boolean</b> <b>query</b> q, certain (or consistent) query answering concerns the problem to decide whether q evaluates to true on every repair. In this article, we study a counting variant of consistent query answering. For a fixed <b>Boolean</b> <b>query</b> q, we define ♮CERTAINTY(q) as the following counting problem: Given an uncertain database db, how many repairs of db satisfy q? Our main result is that conjunctive queries q without self-join exhibit a complexity dichotomy: ♮CERTAINTY(q) is in P or ♮P-complete...|$|E
40|$|In {{order for}} {{automated}} information systems {{to be used}} effectively, they must be made easily accessible {{to a wide range}} of users and with short training periods. This work proposes a method of organizing documents based on the concepts of aggregation and generalization hierarchies. We propose a graphical user interface to provide a more intuitive form of <b>Boolean</b> <b>query.</b> This design is based on mapping the nodes of the aggregation hierarchy to Boolean intersection operations, mapping the nodes of the generalization hierarchy to Boolean union operations, and providing a concrete, graphical, manipulable representation of both of these node types. Finally, a working prototype interface was constructed and evaluated experimentally against a classical command-line <b>Boolean</b> <b>query</b> interface. In this formative evaluation with sixteen subjects, the graphical interface produced less than one-tenth the errors of the textual interface, on average. Significant differences in time spent specifying queri [...] ...|$|E
40|$|A {{retrospective}} method {{for the performance}} comparison of <b>Boolean</b> and best-match <b>queries</b> is introduced. The method {{is based on the}} interactive optimisation of queries by a group of test searchers using a query performance analyser. The case experiment focused on comparing the maximum effectiveness of <b>Boolean</b> exact-match <b>queries,</b> and structured and unstructured best-match queries. The experiment verified the problems in maintaining precision of <b>Boolean</b> <b>queries</b> at high recall levels. Interesting similarities were also observed between structured and unstructured best-match queries giving new light on the results of earlier studies. The case experiment showed that the proposed evaluation method yields more elaborated results in comparisons than earlier query-centred methods...|$|R
40|$|We {{propose a}} simple and {{efficient}} searchable symmetric encryption scheme based on a Bitmap index that evaluates <b>Boolean</b> <b>queries.</b> Our scheme provides a practical solution in settings where communications and computations are very constrained as it offers a suitable tradeoff between privacy and performance. ...|$|R
50|$|Searching and {{selecting}} records is also possible, {{from the}} catalogue, {{through the use}} of <b>Boolean</b> <b>queries.</b> Retrieved records are shown as a short-list of titles; clicking on any would show the full record. Selected records are printable, with any relevant images inserted in the document.|$|R
40|$|AbstractWe {{address the}} {{question}} “How {{much of the information}} stored in a given database can be retrieved by all Boolean queries in a given query language?”. In order to answer it we develop a Kolmogorov complexity based measure of expressive power of <b>Boolean</b> <b>query</b> languages over finite structures. This turns the above informal question into a precisely defined mathematical one. This notion gives a meaningful definition of the expressive power of a <b>Boolean</b> <b>query</b> language in a single finite database. The notion of Kolmogorov expressive power of a <b>Boolean</b> <b>query</b> language L in a finite database A is defined by considering two values: the Kolmogorov complexity of the isomorphism type of A, equal to the length of the shortest description of this type, and the number of bits of this description that can be reconstructed from truth values of all queries from L in A. The closer isthe second value to the first, the more expressive is the query language. After giving the definitions and proving that they are correct, we concentrate our efforts on first order logic and its powerful extensions: inflationary fixpoint logic and partial fixpoint logic. We explore some connections between the proposed Kolmogorov expressive power of Boolean queries in these languages and their standard expressive power, in particular with the definability of order. We show that, except of being of interest on its own, our notion may have important diagnostic value for database query optimization...|$|E
40|$|In {{a variety}} of {{applications}} ranging from optimizing queries on alphanumeric attributes to providing approximate counts of documents containing several query terms, there is an increasing need to quickly and reliably estimate the number of strings #tuples, documents, etc. # matching a <b>Boolean</b> <b>query.</b> Boolean queries in this context consist of substring predicates composed using Boolean operators. While {{there has been some}} work in estimating the selectivity of substring queries, the more general problem of estimating the selectivity of Boolean queries over substring predicates has not been studied. Our approach is to extract selectivity estimates from relationships between the substring predicates of the <b>Boolean</b> <b>query.</b> However, storing the correlation between all possible predicates in order to provide an exact answer to such predicates is clearly infeasible, as there is a super-exponential number of possible combinations of these predicates. Instead, our novel idea is to capture correlations in a spacee #cient but approximate manner. We employ a Monte Carlo technique called set hashing to succinctly represent the set of strings containing a given substring as a signature vector of hash values. Correlations among substring predicates can then be generated on-the-#y by operating on these signatures. We formalize our approach and propose an algorithm for estimating the selectivityofany <b>Boolean</b> <b>query</b> using the signatures of its substring predicates. We then experimentally demonstrate the superiority of our approachover a straightforward approach based on the independence assumption wherein correlations are not explicitly captured...|$|E
40|$|We {{develop a}} new method to rank the degree of {{similarity}} between Boolean expressions, contrast it with other known methods, and describe its implementation. Our method reduces time and space complexity from exponential to polynomial {{in the number of}} Boolean terms. Index Terms - <b>Boolean</b> <b>query,</b> information retrieval, ranking, resource discovery, similarity measure. 1 Introduction Most library information systems let users make Boolean queries against their database. Internet resource discovery systems, such as WAIS [1] and our Indie [2], also support Boolean queries. Frequently, users find it convenient if the retrieval system returns the answers to their queries in a ranked order. This paper develops an efficient algorithm to rank the similarity between a user's <b>Boolean</b> <b>query</b> and a set of objects, each described by a Boolean expression. Our method produces similarity rankings between zero and one. If the query and the object with which it is compared contain some identical terms, the [...] ...|$|E
40|$|Bitmap indexes are {{routinely}} used {{to speed up}} simple aggregate queries in databases. Set operations such as intersections, unions and complements can be represented as logical operations (AND, OR, NOT). However, less {{is known about the}} application of bitmap indexes to more advanced queries. We want to extend the applicability of bitmap indexes. As a starting point, we consider symmetric <b>Boolean</b> <b>queries</b> (e. g., threshold functions). For example, we might consider stores as sets of products, and ask for products that are on sale in 2 to 10 stores. Such symmetric <b>Boolean</b> <b>queries</b> generalize intersection, union, and T-occurrence queries. It may not be immediately obvious to an engineer how to use bitmap indexes for symmetric <b>Boolean</b> <b>queries.</b> Yet, maybe surprisingly, we find that the best of our bitmap-based algorithms are competitive with the state-of-the-art algorithms for important special cases (e. g., MergeOpt, MergeSkip, DivideSkip, ScanCount). Moreover, unlike the competing algorithms, the result of our computation is again a bitmap which can be further processed within a bitmap index. We review algorithmic design issues such as the aggregation of many compressed bitmaps. We conclude with a discussion on other advanced queries that bitmap indexes might be able to support efficiently. Comment: This paper uses small fonts and colours and is only intended for electronic viewin...|$|R
40|$|This paper reports {{selected}} {{findings from}} an ongoing {{series of studies}} analyzing large-scale data sets containing queries posed by Excite users, a major Internet search service. The findings presented report on: (1) queries length and frequency, (2) <b>Boolean</b> <b>queries,</b> (3) query reformulation, (4) phrase searching, (5) search term distribution, (6) relevance feedback, (7) viewing pages of results, (8) successive searching, (9) sexually-related searching, (10) image queries and (11) multi-lingual aspects. Further research is discussed...|$|R
50|$|The main {{features}} of Isearch include full text and field searching, relevance ranking, <b>Boolean</b> <b>queries,</b> {{and support for}} many document types such as HTML, mail folders, list digests, MEDLINE, BibTeX, SGML/XML, FGDC Metadata, NASA DIF, ANZLIC metadata, ISO 19115 metadata and many other resource types and document formats.|$|R
