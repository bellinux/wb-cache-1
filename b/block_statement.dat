5|97|Public
5000|$|... {{there can}} never be a {{semicolon}} directly before [...] in Pascal whereas it is mandatory in C (unless a <b>block</b> <b>statement</b> is used) ...|$|E
5000|$|The {{most common}} use {{is to allow}} {{multiple}} assignment statements without using a <b>block</b> <b>statement,</b> primarily in the initialization and the increment expressions of a for loop. This is the only idiomatic use in elementary C programming. In the following example, {{the order of the}} loop's initializers is significant:void rev(char *s, size_t len){ char *first; for (first = s, s += len; s > first; [...] ) { --s; putchar(*s); }}An alternative solution to this problem is parallel assignment, which allows multiple assignments to occur within a single statement, and also uses a comma, though with different syntax and semantics. This is used in Go in its analogous for loop.|$|E
40|$|This paper {{focuses on}} the {{construction}} of D- and Ds-optimal designs for a secondorder response surface model when the block sizes are not fixed. Overviews of the Procedure OPTEX in SAS for the construction of these designs are given. With the <b>BLOCK</b> <b>statement</b> this procedure can produce optimal designs when the block sizes are fixed but for unknown block sizes it requires additional programming to generate the optimal designs for a given number of runs and number of blocks (see Atkinson, Donev and Tobias, 2007). An example about a pastry dough experiment (Goos and Jones, 2011) is used to demonstrate how to generate designs in such situations. This research is {{supported by a grant from}} the National Research Foundation (NRF) through Competitive Support for Unrated Researchers Programme (Reference: SUR 20110629000019843 and Grant No: 80407). [URL]...|$|E
5000|$|Iteration in {{computing}} is {{the technique}} marking {{out of a}} <b>block</b> of <b>statements</b> within a computer program for a defined number of repetitions. That <b>block</b> of <b>statements</b> {{is said to be}} iterated; a computer scientist might also refer to that <b>block</b> of <b>statements</b> as an [...] "iteration".|$|R
30|$|The {{granularity}} of clones can be {{free with}} no syntactic boundaries or fixed within predefined syntactic boundaries such as method or block (Roy and Cordy [2007]). Clone granularity is fixed at different levels, such as files, classes, functions/methods, begin-end <b>blocks,</b> <b>statements</b> or sequences of source lines.|$|R
30|$|In {{structural}} testing, {{a control}} flow graph (CFG) is typically {{used to represent}} the control flow of a program. A CFG is a directed graph representing {{the order in which}} the individual statements, instructions or function calls of program are executed. In a CFG, nodes represent a <b>statement</b> or a <b>block</b> of <b>statements,</b> and edges represent the flow of control from one <b>statement</b> or <b>block</b> of <b>statements</b> to another. In the context of this paper, we define a <b>block</b> of <b>statement</b> as a set of statements of a program. After the execution of the first <b>statement</b> of the <b>block,</b> the other <b>statements</b> within the <b>block</b> are sequentially executed according to the control flow. Each block corresponds to a node in the CFG and the transfer of control from one node to another is represented by directed edges between nodes.|$|R
30|$|An {{explicit}} operation {{consists of}} a statement using a <b>block</b> <b>statement.</b> The statement may access any state variables as required, that is, for reading or writing. An implicit operation is described using an optional pre-condition, and a mandatory post-condition. In the operation given below, an aircraft sends a request to ground controller, the controller accepts request after verification of its identity and adds {{in the list of}} aircrafts having permission for taxiing. The procedure is described by an implicit operation represented by taxiwayPermission which takes aircraft identifier as input and state of the controller is updated by defining its post conditions before checking pre conditions. In the specification, external clause is introduced by keyword ext. Its purpose is to restrict access of the operation to only those components which are specified. Further, its purpose is to specify the mode of access, that is, either read or write.|$|E
40|$|Active Oberon is a {{substantial}} evolution of the programming language Oberon. It distinguishes itself by a novel object model and by its integration into the. NET language interoperability framework. The three concepts characterizing Active Oberon are: (a) active object types, (b) a single and unifying notion of abstraction called definition, and (c) a static module construct. These concepts are in fact powerful combinations of concepts: Active objects integrate active behavior with reactive message handling, definitions unify the units of usage, implementation and inheritance, and modules represent both package and static object. The rigid concept of class hierarchy has been sacrificed in Active Oberon to a more flexible concept of aggregation {{that is based on}} a generalized IMPLEMENTS relation. The relations IMPORTS and REFINES are used to specify static module dependencies and to derive new definitions from existing ones respectively. Active Oberon also features a <b>block</b> <b>statement</b> that is used to group sets of statements sharing certain processing attributes, in particular the handling of exceptions. Finally, a uses clause allows the use of namespaces within a module without qualification. This article is a report on a work in progress. We divide our presentation into three parts: (a) A short recall of the history of programming languages developed at the ETH, (b) an extensive conceptual overview of Active Oberon's object model called the Active Object System (AOS), (c) a discussion of the mapping of the AOS into the Common T!]pe S!]stem (CTS) exposed by. NET...|$|E
5000|$|Joule is a {{concurrent}} dataflow programming language, {{designed for}} building distributed applications. It is so concurrent that {{the order of}} <b>statements</b> within a <b>block</b> is irrelevant to {{the operation of the}} <b>block.</b> <b>Statements</b> are executed whenever possible, based on their inputs. Everything in Joule happens by sending messages. There is no control flow. Instead, the programmer describes the flow of data, making it a dataflow programming language.|$|R
50|$|Group <b>blocks</b> of <b>statements</b> together, with a {{capitalized}} {{name that}} describes their function {{and end with}} an EXIT.|$|R
50|$|The dynamic {{statements}} that describe the processing operations {{of a program}} are grouped into <b>blocks</b> of <b>statements</b> called procedures.|$|R
5000|$|An ON-unit is {{a single}} <b>statement</b> or <b>block</b> of <b>statements</b> written to be {{executed}} when {{one or more of}} these conditions occur: ...|$|R
5000|$|The {{event was}} {{attended}} by 600 Scouts from {{many parts of the}} United Kingdom and from Portugal. [...] The majority of the attendees were from the Baden-Powell Scouts' Association, with local members of The Scout Association choosing to mark the centenary through a display in a local town rather than attending the event. Although the Scout Association decided not to support the event, they also did not issue a <b>blocking</b> <b>statement,</b> so a number of SA members attended.|$|R
50|$|Note {{the period}} which is {{terminating}} the IF <b>statement</b> <b>block.</b>|$|R
5000|$|... and [...] mark a <b>block</b> of <b>{{statement}}s.</b> If {{more than}} one statement is {{to be controlled by}} the conditional in the example above, we can use [...] and [...] like this: ...|$|R
40|$|We {{propose a}} new {{concurrent}} model for imperative languages where concurrency occurs at a subprogram level. This model introduces a new <b>block</b> sequential <b>statement</b> {{of the form}} #(G_ 1, [...] .,G_n) where each G_i is a statement. This statement tells the machine to execute G_ 1, [...] .,G_n sequentially and atomically (, without interleaving). It therefore enhances atomicity and predictability in concurrent programming. We illustrate our idea via C^, {{an extension of the}} core concurrent C with the new <b>block</b> sequential <b>statement.</b> Comment: 3 pages. Our scheduler is quite adaptive to the requests of the processes. This makes synchronization simple...|$|R
5000|$|In Pascal {{functions}}, {{begin and}} end delimit a <b>block</b> of <b>statements</b> (proper), while C functions use [...] "{" [...] and [...] "}" [...] to delimit a <b>block</b> of <b>statements</b> optionally preceded by declarations. C (before C99) strictly defines that any declarations must occur before the statements within a particular block but allows blocks to appear within blocks, which {{is a way to}} go around this. Pascal is strict that declarations must occur before statements, but allows definitions of types and functions - not only variable declarations - to be encapsulated by function definitions to any level of depth.|$|R
5000|$|The syntax of Ezhil is broadly {{similar to}} that of BASIC: blocks of code are run in {{sequential}} order, or via functions definitions, in a common control flow structures include , and [...] The termination of function <b>block</b> and <b>statement</b> <b>blocks</b> should have the termination keyword, similar to END in BASIC. Declarations are not necessary as Ezhil is a dynamic typed language, though type conversions must be made explicitly. Ezhil has built-in types for Numbers, Strings, Logicals and Lists.|$|R
5000|$|Looping <b>statement</b> <b>blocks</b> {{begin and}} end with keywords: Do...Loop, While...End While, For...Next [...]|$|R
40|$|Abstract—Esterel is an {{imperative}} synchronous {{language for}} control-dominant reactive systems. The combination of imper-ative structures and the perfect synchrony hypothesis often result in schizophrenic statements. Previous studies explain {{the characteristics of}} schizophrenia as the instantaneous reentrance to block statements: local signal declarations and parallel statements. In practice, however, most instantly-reentered <b>block</b> <b>statements</b> do not cause any problems in Esterel compilation. In this paper, we refine schizophrenic problems in terms of signal emissions, and suggest an algorithm to detect harmful schizophrenia using reachability on control flow graphs (CFGs) in Esterel. Our algorithm performs well in analyzing practical programs. Moreover, it can be easily applied to existing compilers. I...|$|R
5000|$|<b>Block</b> <b>{{statement}}s</b> {{are similar}} to those of ALGOL: a block is started with a [...] statement and terminated with [...] As with ALGOL, statements are terminated with the semicolon (";"). When a value is computed, it is saved until the next statement terminator [...] - [...] which means that a value can be computed, assigned to a variable, and carried forward to the next statement, if desired. Alternatively, an open parenthesis may be used to begin a block, with the close parenthesis used to close the block. When parentheses are included in an expression, the standard precedence rules are used, in which parenthesized expressions are computed first, ...|$|R
40|$|Abstract. This project aims {{to improve}} the metaprogramming and {{verification}} capabilities of the GNU Compiler Collection. It consists of a plugin infrastructure that exposes two compile-time mechanisms. The first of these is a mechanism by which one may perform arbitrary computations over types {{within the context of}} the C++ template metaprogramming infrastructure. The second of these exposes selected portions of the control flow graph and basic <b>block</b> <b>statements</b> of Low GIMPLE, with additional support infrastructure that allows for data-flow analysis of the resultant structure. The plugins themselves are written in Haskell, reflecting the functional nature of both C++ template metaprogramming and standard data-flow analysis. We demonstrate the effectiveness of our technique using specific case studies in the field of session types. Key words: C++, Metaprogramming, Program Analysi...|$|R
50|$|Local {{activities}} express intrinsic object dynamics. A typical {{context is}} a <b>block</b> of <b>statements</b> representing the “launch logic” {{for a set}} of mutually independent activities, with the assumption {{that the end of the}} block acts as a barrier that cannot be passed before all activities have terminated.|$|R
50|$|It is permissible, {{and often}} necessary, to use values {{from other parts}} of the program outside of the {{bracketed}} <b>block</b> of <b>statements</b> in order to perform the desired function. In the example above, the line of code is using the value of i as it increments.|$|R
5000|$|The {{answer is}} that we add a special statement, called a Φ (Phi) function, to the {{beginning}} of the last <b>block.</b> This <b>statement</b> will generate a new definition of y, y3, by [...] "choosing" [...] either y1 or y2, depending on which arrow control arrived from: ...|$|R
5000|$|There is no unified way of {{defining}} <b>blocks</b> of <b>statements.</b> Instead, certain keywords, such as [...] "If … Then" [...] or [...] "Sub" [...] are interpreted as starters of sub-blocks of code and have matching termination keywords such as [...] "End If" [...] or [...] "End Sub".|$|R
40|$|Abstract. We {{present an}} {{algorithm}} for attacking the state explosion problem in analyzing multithreaded programs. Our approach employs partial-order reduction and static virtual coarsening. It uses information on shared variables to generate and interleave <b>blocks</b> of <b>statements.</b> Our algorithm performs polynomially {{as long as}} the number of shared variables is constant. ...|$|R
40|$|Structural view To {{understand}} a software component with this view, the user model need represent user's {{knowledge of the}} computer language's syntax. Typically, the component is expressed as an abstract syntax tree. The vocabularies used in this view are based on syntactic grammar (data structure etc.) For example, the structural description for the software component stack will be either a linked list or an array. The retrieval mechanism is strongly related to the syntactic pattern recognition (Gonzalez & Thomason 1978). Structural decomposition is typically using parser to make a transition from source code to basic structural representation <b>blocks</b> (<b>statements,</b> procedures etc.) We propose a multiple-view user modeling to {{provide a basis for}} enabling the user to choose the most appropriate user model to be used in a specific software reuse process. The possibility of integrating with several different user view models can further increase user conceptualization capabilities. This appr [...] ...|$|R
50|$|The {{consistent}} {{treatment of}} <b>blocks</b> as <b>statements</b> (for {{the purpose of}} indentation) is a very distinctive feature of the GNU C code formatting style; as is the mandatory space before parentheses. All code formatted in the GNU style has the property that each closing brace, bracket or parenthesis appears {{to the right of}} its corresponding opening delimiter, or in the same column.|$|R
50|$|Some {{versions}} of Fortran, {{such as those}} on the IBM System/360 and successor mainframes, {{do not support the}} PROGRAM statement. Many compilers from other software manufacturers will allow a fortran program to be compiled without a PROGRAM statement. In these cases, whatever module that has any non-comment statement where no SUBROUTINE, FUNCTION or <b>BLOCK</b> DATA <b>statement</b> occurs, is considered to be the Main program.|$|R
50|$|C/C++test {{includes}} {{options for}} line coverage, meaning has the line been executed, <b>block</b> coverage, <b>statement</b> coverage, path coverage, decision coverage, branch coverage, and simple condition coverage. It also supports modified condition/decision coverage or MCDC because projects that require safe reliable software such as aircraft and cars, tend to required {{this form of}} coverage as it's {{believed to be a}} better measure of whether or the code has been thoroughly exercised.|$|R
40|$|The {{detection}} of parallelism {{is based on}} the dependence analysis of the program. One of the key problems is to partition the program into independent subtasks in the presence of control statements (MIMD). In this paper the nonstructured control statements are converted into structured ones. In this way, a large <b>block</b> of <b>statements</b> is obtained, and the control dependences of the program are easily converted into manageable parallel tasks...|$|R
5000|$|The {{following}} {{contains an}} Obligation <b>block.</b> Obligations are <b>statements</b> {{that can be}} returned along with a decision to enrich the decision flow. In this example, the PEP must log that access was granted. [...] Permit [...] http://www.axiomatics.com/automatic-unique-id/18a9eae9-c92b-4087-b2ac-c5a33d7ff477 ...|$|R
40|$|Access to thesis {{permanently}} {{restricted to}} Ball State community only. Access to abstract permanently restricted to Ball State community only. Department of Computer ScienceLiterature review [...] Benefits {{of the study}} [...] Related work [...] Limitations of current tools [...] Sequence and usage matrices [...] Distance metrics [...] Distance between clones with different usage distances [...] Calculation steps [...] Clone type identification [...] Experiment [...] Identification of clones [...] Future research [...] <b>Block</b> and <b>statement</b> types. Thesis (M. S. ...|$|R
40|$|In {{this paper}} how a pure denotative (nonprocedural) {{language}} {{based on the}} lambda calculus can be provided with purely denotative analogs of the various constructs - such as while loops, <b>blocks,</b> case <b>statements</b> and the like - of conventional imperative structured programming languages. They can be simulated quite adequately using only two simple tools: phrases, which are compound expressions not unlike blocks, and pronouns, special variables not unlike keywords between which certain relationships are 'understood' to hold...|$|R
5000|$|A {{sequence}} of statements becomes a group when {{preceded by a}} [...] statement and followed by an [...] statement. Groups may include nested groups and begin <b>blocks.</b> The [...] <b>statement</b> specifies a group or a single statement as the [...] part and the [...] part (see the sample program). The group is the unit of iteration. The begin block (...) may contain declarations for names and internal procedures local to the block. A procedure starts with a [...] statement and is terminated syntactically by an [...] statement. The body of a procedure is a {{sequence of}} <b>blocks,</b> groups, and <b>statements</b> and contains declarations for names and procedures local to the procedure or [...] to the procedure.|$|R
