139|404|Public
25|$|The control {{instructions}} {{consist of}} conditional and unconditional branches, and jumps. The conditional and unconditional branch instructions use the <b>branch</b> <b>instruction</b> format, while the jump instructions use the memory instruction format.|$|E
25|$|The Monroe Epic {{programmable}} calculator {{came on the}} market in 1967. A large, printing, desk-top unit, with an attached floor-standing logic tower, it could be programmed to perform many computer-like functions. However, the only <b>branch</b> <b>instruction</b> was an implied unconditional branch (GOTO) {{at the end of the}} operation stack, returning the program to its starting instruction. Thus, it was not possible to include any conditional branch (IF-THEN-ELSE) logic. During this era, the absence of the conditional branch was sometimes used to distinguish a {{programmable calculator}} from a computer.|$|E
25|$|Branch {{instructions}} have a 6-bit opcode field, a 5-bit Ra {{field and}} a 21-bit displacement field. The Ra field specifies a register {{to be tested}} by a conditional <b>branch</b> <b>instruction,</b> and if the condition is met, the program counter is updated by adding {{the contents of the}} displacement field with the program counter. The displacement field contains a signed integer and if the value of the integer is positive, if the branch is taken then the program counter is incremented. If the value of the integer is negative, then program counter is decremented if the branch is taken. The range of a branch thus is ±1 Mi instructions, or ±4 MiB. The Alpha Architecture was designed with a large range as part of the architecture's forward-looking goal.|$|E
5000|$|... #Subtitle level 2: Performance {{problems}} with <b>branch</b> <b>instructions</b> ...|$|R
2500|$|Complete set of vector-level {{compare and}} <b>branch</b> <b>instructions</b> with no {{condition}} flag ...|$|R
50|$|Addressing modes for load/store and <b>branch</b> <b>instructions</b> were as follows. All {{displacements}} were sign-extended.|$|R
2500|$|CCS (count, compare, and skip): A complex {{conditional}} <b>branch</b> <b>instruction.</b> The A register {{was loaded}} with data retrieved from the address specified by the instruction. (Because the AGC uses ones' complement notation, there are two representations of zero. When all bits are set to zero, this is called plus zero. If all bits are set to one, this is called minus zero.) The diminished absolute value (DABS) of the data was then computed and stored in the A register. If the number was greater than zero, the DABS decrements the value by 1; if the number was negative, it is complemented before the decrement is applied—this is the absolute value. Diminished means [...] "decremented but not below zero". Therefore, when the AGC performs the DABS function, positive numbers will head toward plus zero, and so will negative numbers but first revealing their negativity via the four-way skip below. The final step in CCS is a four-way skip, depending upon the data in register A before the DABS. If register A was greater than 0, CCS skips to the first instruction immediately after CCS. If register A contained plus zero, CCS skips to the second instruction after CCS. Less than zero causes a skip to the third instruction after CCS, and minus zero skips to the fourth instruction after CCS. The {{primary purpose of the}} count was to allow an ordinary loop, controlled by a positive counter, to end in a CCS and a TC {{to the beginning of the}} loop, equivalent to an IBM 360's BCT. The absolute value function was deemed important enough to be built into this instruction; when used for only this purpose, the sequence after the CCS was TC *+2, TC *+2, AD ONE. A curious side effect was the creation and use of CCS-holes when the value being tested was known to be never positive, which occurred more often than one might suppose. That left two whole words unoccupied, and a special committee was responsible for assigning data constants to these holes.|$|E
5000|$|In {{computer}} architecture, {{a branch}} target predictor {{is the part}} of a processor that predicts the target of a taken conditional branch or an unconditional <b>branch</b> <b>instruction</b> before the target of the <b>branch</b> <b>instruction</b> is computed by the execution unit of the processor.|$|E
5000|$|... {{identify}} a particular instruction {{as a target}} for a <b>BRANCH</b> <b>instruction.</b>|$|E
5000|$|Multi-way <b>branch</b> <b>instructions</b> improve <b>branch</b> {{prediction}} {{by combining}} many alternative branches into one bundle.|$|R
5000|$|... 32-bit fixed-size {{instructions}} (all {{instructions are}} 32 bits, including jump, call and <b>branch</b> <b>instructions.)</b> ...|$|R
25|$|Though the {{predicate}} {{takes up}} {{four of the}} 32bits in an instruction code, and thus cuts down significantly on the encoding bits available for displacements in memory access <b>instructions,</b> it avoids <b>branch</b> <b>instructions</b> when generating code for small if statements. Apart from eliminating the <b>branch</b> <b>instructions</b> themselves, this preserves the fetch/decode/execute pipeline {{at the cost of}} only one cycle per skipped instruction.|$|R
50|$|Most Branch {{instructions}} take conditional effect {{based on}} the state of the condition codes in the PSW. A <b>Branch</b> <b>instruction</b> was typically preceded by a two-operand CMP (compare) or BIT (bit test) or a one-operand TST (test) instruction. Arithmetic and logic instructions also set the condition codes. In contrast to Intel processors in the x86 architecture, MOV instructions set them too, so a <b>Branch</b> <b>instruction</b> could be used to branch depending on whether the value moved was zero or negative.|$|E
5000|$|... {{where the}} CB is the {{conditional}} <b>branch</b> <b>instruction</b> or [...] "combination card' {{used to make}} the control flow jump, in this case backwards by 11 cards.|$|E
50|$|Memory {{dependence}} prediction for {{loads and}} stores {{is analogous to}} branch prediction for conditional branch instructions. In branch prediction, the branch predictor predicts which way the branch will resolve before it is known. The processor can then speculatively fetch and execute instructions {{down one of the}} paths of the branch. Later, when the <b>branch</b> <b>instruction</b> executes, it can be determined if the <b>branch</b> <b>instruction</b> was correctly predicted. If not, this is a branch misprediction, and a pipeline flush is necessary to throw away instructions that were speculatively fetched and executed.|$|E
50|$|The 1802 has {{a single}} bit, {{programmable}} and testable output port (Q), and four input pins which are directly tested by <b>branch</b> <b>instructions</b> (EF1-EF4).|$|R
50|$|An {{alternative}} to conditional <b>branch</b> <b>instructions</b> is predication. Predication is an architectural feature that enables instructions to be conditionally executed instead of modifying the control flow.|$|R
40|$|Recent superscalar {{processors}} highly {{depend on}} ecient branch prediction to exploit instruction level parallelism. Many strategies to improve branch prediction accuracy have been proposed, {{the most successful}} ones can adapt predictions dynamically based on the outcomes of previous branches. In this paper we present a dierent strategy, that is partially nonadaptive. We will show that patterns in the outcomes of individual <b>branch</b> <b>instructions</b> {{are more important than}} the global pattern of consecutive <b>branch</b> <b>instructions</b> and we will show that some patterns in the outcomes of <b>branch</b> <b>instructions</b> are much more frequent than other patterns. We will propose a classication of patterns in outcomes of individual <b>branch</b> <b>instructions,</b> based on their frequentness and how well they can be predicted by Two Level Adaptive Branch Predictors. We will analyze six traces of benchmark applications with respect to the occurrence of these patterns. We will present a mechanism (HW, Hard Wired) that dynamically discriminates between instructions based on this categorization. This mechanism can predict trivial and loop patterns almost perfectly with a hard wired lookup table. We will discuss the usage of HW as a prediction strategy in its own and its usage as a prestage to other branch prediction strategies. is hard, especially the future. " Winston Churchill Chapter...|$|R
5000|$|Instructions {{were fixed}} length (12 decimal digits), {{consisting}} of a 2-digit [...] "op code", a 5-digit [...] "P Address" [...] (usually the destination address), and a 5-digit [...] "Q Address" [...] (usually the source address or the source immediate value). Some instructions, such as the B (<b>branch)</b> <b>instruction,</b> only used the P Address, and later smart assemblers included a [...] "B7" [...] instruction that generated a 7-digit <b>branch</b> <b>instruction</b> (op code, P address, and one extra digit because the next instruction had to start on an even-numbered digit).|$|E
50|$|When {{a branch}} is not taken, the CPU's program counter is unchanged. Therefore, the next {{instruction}} executed is the instruction after the <b>branch</b> <b>instruction.</b> Therefore, {{the flow of}} control is unchanged.|$|E
50|$|The control {{instructions}} {{consist of}} conditional and unconditional branches, and jumps. The conditional and unconditional branch instructions use the <b>branch</b> <b>instruction</b> format, while the jump instructions use the memory instruction format.|$|E
50|$|In microprocessors, branch {{prediction}} permits avoidance of pipeline emptying at <b>branch</b> <b>instructions.</b> In engineering, possible failure modes are predicted and avoided by correcting the mechanism causing the failure.|$|R
5000|$|Elimination of {{unnecessary}} <b>branch</b> <b>instructions</b> {{can make the}} execution of necessary branches, {{such as those that}} make up loops, faster by lessening the load on branch prediction mechanisms.|$|R
50|$|In most processors, {{the zero}} flag is mainly used in {{conditional}} <b>branch</b> <b>instructions,</b> which alter control flow on previous instruction results, {{but there are}} often other uses as well.|$|R
50|$|The {{technique}} sees common usage {{in software}} exploits, {{where it is}} used to direct program execution when a <b>branch</b> <b>instruction</b> target is not known precisely. Other notable applications include defensive programming strategies such as EMC-aware programming.|$|E
50|$|Static {{prediction}} is the simplest branch prediction technique {{because it does}} not rely on information about the dynamic history of code executing. Instead it predicts the outcome of a branch based solely on the <b>branch</b> <b>instruction.</b>|$|E
50|$|When a <b>branch</b> <b>instruction</b> is involved, the {{location}} of the following delay slot instruction in the pipeline may be called a branch delay slot. Branch delay slots are found mainly in DSP architectures and older RISC architectures. MIPS, PA-RISC, ETRAX CRIS, SuperH, and SPARC are RISC architectures that each have a single branch delay slot; PowerPC, ARM, Alpha, and RISC-V do not have any. DSP architectures that each have a single branch delay slot include the VS DSP, µPD77230 and TMS320C3x. The SHARC DSP and MIPS-X use a double branch delay slot; such a processor will execute a pair of instructions following a <b>branch</b> <b>instruction</b> before the branch takes effect.|$|E
5000|$|Indirect branching, {{which allows}} the {{contents}} of a memory register to be used as the target of a <b>branching</b> <b>instruction</b> (GTO or XEQ) is omitted from the HP 35s.|$|R
50|$|The {{instruction}} set {{does not contain}} conditional <b>branch</b> <b>instructions.</b> Instead, it contains conditional skip instructions which cause the following instruction to be ignored. A conditional skip followed by an unconditional branch performs a conditional <b>branch.</b> The skip <b>instructions</b> test any bit of any register. The ALU status register is one possibility.|$|R
50|$|The SHARC {{processor}} has {{built-in support}} for loop control. Up to 6 levels may be used, avoiding {{the need for}} normal <b>branching</b> <b>instructions</b> and the normal bookkeeping related to loop exit.|$|R
50|$|Flushing the {{pipeline}} {{occurs when a}} <b>branch</b> <b>instruction</b> jumps to a new memory location, invalidating all prior stages in {{the pipeline}}. These prior stages are cleared, allowing the pipeline to continue at the new instruction indicated by the branch.|$|E
50|$|A {{branch is}} an {{instruction}} {{in a computer}} program that can cause a computer to begin executing a different instruction sequence and thus deviate from its default behavior of executing instructions in order. Branch (or branching, branched) may also refer to the act of switching execution to a different instruction sequence {{as a result of}} executing a <b>branch</b> <b>instruction.</b> A <b>branch</b> <b>instruction</b> can be either an unconditional branch, which always results in branching, or a conditional branch, {{which may or may not}} cause branching, depending on some condition. Branch instructions are used to implement control flow in program loops and conditionals (i.e., executing a particular sequence of instructions only if certain conditions are satisfied).|$|E
50|$|Mechanically, a <b>branch</b> <b>instruction</b> {{can change}} the program counter of a CPU. The program counter is the memory address of the next instruction. Therefore, a branch can cause the CPU to begin {{fetching}} its instructions from a different sequence of memory cells.|$|E
5000|$|Machine level <b>branch</b> <b>instructions</b> are {{sometimes}} called jump instructions. Machine level jump instructions typically have unconditional and conditional forms where the latter {{may be taken}} or not taken depending on some condition.|$|R
50|$|The machine {{instructions}} can {{be grouped}} into six categories: accumulator <b>instructions,</b> <b>branch</b> <b>instructions,</b> memory reference instructions, address register instructions, scratchpad register instruction, miscellaneous instructions (interrupt, input, output, indirect scratchpad register, load, and store).|$|R
40|$|Increasing system {{complexity}} of SOC applications {{leads to an}} increased need of powerful embedded DSP processors. To fulfill the required computational bandwidth, state-of-the-art DSP processors allow executing several instructions in parallel and for reaching higher clock frequencies they {{increase the number of}} pipeline stages. However, deeply pipelined processors have drawbacks in the execution of branch instructions: branch delays. In average not more than two branch delay slots can be used, additional ones keep unused and decrease the overall system performance. Instead of compensating the drawback of branch delays (e. g. branch prediction circuits) it is possible {{to reduce the number of}} branch delays by reducing the number of <b>branch</b> <b>instructions.</b> Predicated execution (also guarded execution or conditional execution) can be used for implementing if-then-else constructs without using <b>branch</b> <b>instructions.</b> The drawback of traditional predicated execution is decreased code density. This paper introduces selective predicated execution based on FSEL which allows reducing the number of <b>branch</b> <b>instructions</b> without decreasing code density. Selective predicated execution based on FSEL is part of a project for a configurable DSP core. 1...|$|R
