10|1208|Public
5000|$|Any Boolean algebra, {{with the}} monoid {{multiplication}} • {{taken to be}} conjunction and both residuals taken to be material implication x→y. Of the remaining 15 binary Boolean operations that might be considered in place of conjunction for the monoid multiplication, only five meet the monotonicity requirement, namely 0, 1, x, y, and x∨y. Setting y = z = 0 in the residuation axiom y ≤ x\z ⇔ x•y ≤ z, we have 0 ≤ x\0 ⇔ x•0 ≤ 0, which is falsified by taking x = 1 when x•y = 1, x, or x∨y. The dual argument for z/y rules out x•y = y. This just leaves x•y = 0 (a constant binary operation independent of x and y), which satisfies almost all the axioms when the residuals are both taken to be the constant operation x/y = x\y = 1. The axiom it fails is x•I = x = I•x, {{for want of a}} suitable value for I. Hence conjunction is the only <b>binary</b> <b>Boolean</b> <b>operation</b> making the monoid multiplication that of a residuated Boolean algebra.|$|E
40|$|In {{this paper}} we study the state {{complexity}} of catenation combined with symmetric difference. First, an upper bound is computed using some combinatoric tools. Then, this bound {{is shown to}} be tight by giving a witness for it. Moreover, we relate this work with the study of state complexity for two other combinations: catenation with union and catenation with intersection. And we extract a unified approach which allows to obtain the state complexity of any combination involving catenation and a <b>binary</b> <b>boolean</b> <b>operation...</b>|$|E
40|$|It is {{well known}} that quantum finite automata (QFA) cannot {{recognize}} all regular languages. However nobody knows what languages can be recognized by a QFA. We examine some necessary and some sufficient conditions for a (regular) language to be recognizable by a QFA. For a subclass of regular languages we get a condition which is necessary and sufficient. Also, we prove that the class of languages recognizable by a QFA is not closed under union, even not under any <b>binary</b> <b>Boolean</b> <b>operation</b> where both arguments are significant...|$|E
25|$|Given two operands, {{each with}} two {{possible}} values, there are 22 = 4 possible combinations of inputs. Because each output can have two possible values, {{there are a}} total of 24 = 16 possible <b>binary</b> <b>Boolean</b> <b>operations.</b>|$|R
40|$|The {{generalized}} winding number function measures insideness for arbitrary oriented triangle meshes. Exploiting this, I similarly generalize <b>binary</b> <b>boolean</b> <b>operations</b> {{to act on}} such meshes. The resulting {{operations for}} union, intersection, difference, etc. avoid volumetric discretization or pre-processing. Comment: 1 page, 1 figur...|$|R
40|$|The paper {{discusses}} {{the potential of}} the usage of Extended <b>Boolean</b> <b>operations</b> for personalized information delivery on the Internet based on semantic vector representation models. The final goal is the design of an e-commerce portal tracking user's clickstream activity and purchases history in order to offer them personalized information. The emphasis is put on the introduction of dynamic composite user profile constructed by means of extended <b>Boolean</b> <b>operations.</b> The basic <b>binary</b> <b>Boolean</b> <b>operations</b> such as OR, AND and NOT (AND-NOT) and their combinations have been introduced and implemented in variety of ways...|$|R
40|$|It {{is an open}} {{problem to}} {{characterize}} the class of languages recognized by quantum finite automata (QFA). We examine some necessary and some sufficient conditions for a (regular) language to be recognizable by a QFA. For a subclass of regular languages we get a condition which is necessary and sufficient. Also, we prove that the class of languages recognizable by a QFA is not closed under union or any other <b>binary</b> <b>Boolean</b> <b>operation</b> where both arguments are significant. Comment: 18 pages, 16 figures, extends quant-ph/ 000100...|$|E
40|$|International audienceI {{study the}} state {{complexity}} of binary operations on regular languages over different alphabets. It {{is well known}} that if $$L'_m$$ and $$L_n$$ are languages restricted to be over the same alphabet, with m and n quotients, respectively, the state complexity of any <b>binary</b> <b>boolean</b> <b>operation</b> on $$L'_m$$ and $$L_n$$ is mn, and that of the product (concatenation) is $$(m- 1) 2 ^n + 2 ^{n- 1 }$$. In contrast to this, I show that if $$L'_m$$ and $$L_n$$ are over their own different alphabets, the state complexity of union and symmetric difference is $$mn+m+n+ 1 $$, that of intersection is $$mn+ 1 $$, that of difference is $$mn+m+ 1 $$, and that of the product is $$m 2 ^n+ 2 ^{n- 1 }$$...|$|E
40|$|I {{study the}} state {{complexity}} of binary operations on regular languages over different alphabets. It {{is well known}} that if $L'_m$ and $L_n$ are languages restricted to be over the same alphabet, with $m$ and $n$ quotients, respectively, the state complexity of any <b>binary</b> <b>boolean</b> <b>operation</b> on $L'_m$ and $L_n$ is $mn$, and that of the product (concatenation) is $(m- 1) 2 ^n + 2 ^{n- 1 }$. In contrast to this, I show that if $L'_m$ and $L_n$ are over their own different alphabets, the state complexity of union and symmetric difference is $mn+m+n+ 1 $, that of intersection is $mn$, that of difference is $mn+m$, and that of the product is $m 2 ^n+ 2 ^{n- 1 }$. Comment: 13 pages, 6 figures. An earlier version is to appear in the proceedings of DCFS 2016. Two errors are corrected in the present arXiv versio...|$|E
40|$|AbstractConsider the Boolean {{functions}} and(n) =⋀i= 1 n xi nor(n) =⋀i= 1 n ¬ xi and the equivalence Eq(n) =and (n) ∨nor(n). Let L (F) be {{the smallest}} number of arbitrary <b>binary</b> <b>Boolean</b> <b>operations</b> {{that are used}} in any Boolean computation for F. We prove L(Eq(n)) = 2 n − 3, L (and(n), nor(n)) = 2 n− 2. There exist many structurally different optimal computations for Eq (n) ...|$|R
40|$|AbstractLet fn:{ 0, 1 } 2 ⌜lgn⌝+ 1 +n→{ 0, 1 } be the Boolean {{function}} fn(a,b,q,z 1 …,zn) =q⋁j= 1 n zj(a=j∨b=j) ∨ ⊕j= 1 n zj(a=j∨b=j) where a→a is any surjective map B⌜lgn⌝→{ 1, 2, …,n}. We prove C(fn) ⩾ 3 n− 2 where C(fn) is {{the minimal}} {{size of a}} Boolean network which computes fn over the base of all 16 <b>binary</b> <b>Boolean</b> <b>operations.</b> This lower bound corresponds to an upper bound of 3 n provided that we count only those gates that depend on some variable zj...|$|R
40|$|A right {{ideal is}} a {{language}} L over an alphabet A that satisfies L = LA*. We {{show that there}} exists a stream (sequence) (R_n : n > 3) of regular right ideal languages, where R_n has n left quotients and is most complex under the following measures of complexity: the state complexities of the left quotients, the number of atoms (intersections of complemented and uncomplemented left quotients), the state complexities of the atoms, {{the size of the}} syntactic semigroup, the state complexities of the operations of reversal, star, and product, and the state complexities of all <b>binary</b> <b>boolean</b> <b>operations.</b> In that sense, this stream of right ideals is a universal witness. Comment: 19 pages, 4 figures, 1 tabl...|$|R
40|$|The {{quotient}} {{complexity of}} a regular language L {{is the number of}} left quotients of L, which {{is the same as the}} state complexity of L. Suppose that L and L' are binary regular languages with quotient complexities m and n, and that the transition semigroups of the minimal deterministic automata accepting L and L' are the symmetric groups S_m and S_n of degrees m and n, respectively. Denote by o any <b>binary</b> <b>boolean</b> <b>operation</b> that is not a constant and not a function of one argument only. For m,n >= 2 with (m,n) not in (2, 2),(3, 4),(4, 3),(4, 4) we prove that the quotient complexity of LoL' is mn if and only either (a) m is not equal to n or (b) m=n and the bases (ordered pairs of generators) of S_m and S_n are not conjugate. For (m,n) ∈(2, 2),(3, 4),(4, 3),(4, 4) we give examples to show that this need not hold. In proving these results we generalize the notion of uniform minimality to direct products of automata. We also establish a non-trivial connection between complexity of boolean operations and group theory...|$|E
40|$|Abstract. The {{quotient}} {{complexity of}} a regular language L is the num-ber of left quotients of L, {{which is the same}} as the state complexity of L. Suppose that L and L ′ are binary regular languages with quotient complexities m and n, and that the subgroups of permutations in the transition semigroups of the minimal deterministic automata accepting L and L ′ are the symmetric groups Sm and Sn of degrees m and n, respectively. Denote by ◦ any <b>binary</b> <b>boolean</b> <b>operation</b> that is not a constant and not a function of one argument only. For m,n ≥ 2 with (m,n) ∈ {(2, 2), (3, 4), (4, 3), (4, 4) } we prove that the quotient complex-ity of L ◦ L ′ is mn if and only either (a) m = n or (b) m = n and the bases (ordered pairs of generators) of Sm and Sn are not conjugate. For (m,n) ∈ {(2, 2), (3, 4), (4, 3), (4, 4) } we give examples to show that this need not hold. In proving these results we generalize the notion of uniform minimality to direct products of automata. We also establish a non-trivial connection between complexity of boolean operations and group theory...|$|E
40|$|This is an Accepted Manuscript of {{an article}} {{published}} by Institut für Informatik in Journal of Automata, Languages and Combinatorics on 2017 - 08 - 27, available online: [URL] study the state complexity of binary operations on regular languages over diﬀerent alphabets. It is known that if L′m and Ln are languages of state complexities m and n, respectively, and restricted to the same alphabet, the state complexity of any <b>binary</b> <b>boolean</b> <b>operation</b> on L′m and Ln is mn, and that of product (concatenation) is m 2 n − 2 n− 1. In contrast to this, we show that if L′m and Ln are over diﬀerent alphabets, the state complexity of union and symmetric diﬀerence is (m + 1) (n + 1), that of diﬀerence is mn + m, that of intersection is mn, and that of product is m 2 n + 2 n− 1. We also study unrestricted complexity of binary operations in the classes of regular right, left, and two-sided ideals, and derive tight upper bounds. The bounds for product of the unrestricted cases (with the bounds for the restricted cases in parentheses) are as follows: right ideals m + 2 n− 2 + 2 n− 1 + 1 (m + 2 n− 2); left ideals mn + m + n (m + n − 1); two-sided ideals m+ 2 n (m+n− 1). The state complexities of boolean operations on all three types of ideals {{are the same as}} those of arbitrary regular languages, whereas {{that is not the case}} if the alphabets of the arguments are the same. Finally, we update the known results about most complex regular, right-ideal, left-ideal, and two-sided-ideal languages to include the unrestricted cases. Natural Sciences and Engineering Research Council of Canada grant No. OGP 000087...|$|E
2500|$|More {{generally}} one may complement any of {{the eight}} subsets of the three ports of either an AND or OR gate. The resulting sixteen possibilities give rise to only eight <b>Boolean</b> <b>operations,</b> namely those with an odd number of 1's in their truth table. There are eight such because the [...] "odd-bit-out" [...] can be either 0 or 1 and can go in any of four positions in the truth table. There being sixteen <b>binary</b> <b>Boolean</b> <b>operations,</b> this must leave eight operations with an even number of 1's in their truth tables. Two of these are the constants 0 and 1 (as binary operations that ignore both their inputs); four are the operations that depend nontrivially on exactly one of their two inputs, namely x, y, ¬x, and ¬y; and the remaining two are x⊕y (XOR) and its complement x≡y.|$|R
40|$|The final {{publication}} {{is available}} at Springer via [URL] right ideal is a language L over an alphabet Sigma that satisfies the equation L = L Sigma*. We show that there exists a sequence (Rn vertical bar n >= 3) of regular right-ideal languages, where R-n has n left quotients and is most complex among regular right ideals under the following measures of complexity: the state complexities of the left quotients, the number of atoms (intersections of complemented and uncomplemented left quotients), the state complexities of the atoms, {{the size of the}} syntactic semigroup, the state complexities of reversal, star, product, and all <b>binary</b> <b>boolean</b> <b>operations</b> that depend on both arguments. Thus (Rn vertical bar n >= 3) is a universal witness reaching the upper bounds for these measures. Natural Sciences and Engineering Research Council of Canada [OGP 0000871...|$|R
40|$|A minimal {{deterministic}} {{finite automaton}} (DFA) is uniformly minimal if it always remains minimal {{when the final}} state set {{is replaced by a}} non-empty proper subset of the state set. We prove that a permutation DFA is uniformly minimal if and only if its transition monoid is a primitive group. We use this to study <b>boolean</b> <b>operations</b> on group languages, which are recognized by direct products of permutation DFAs. A direct product cannot be uniformly minimal, except in the trivial case where one of the DFAs in the product is a one-state DFA. However, non-trivial direct products can satisfy a weaker condition we call uniform boolean minimality, where only final state sets used to recognize <b>boolean</b> <b>operations</b> are considered. We give sufficient conditions for a direct product of two DFAs to be uniformly boolean minimal, which in turn gives sufficient conditions for pairs of group languages to have maximal state complexity under all <b>binary</b> <b>boolean</b> <b>operations</b> ("maximal <b>boolean</b> complexity"). In the case of permutation DFAs with one final state, we give necessary and sufficient conditions for pairs of group languages to have maximal boolean complexity. Our results demonstrate a connection between primitive groups and automata with strong minimality properties. Comment: 45 pages, 5 figures. The remark on page 15 has been updated to acknowledge an overlooked referenc...|$|R
40|$|We {{study the}} state {{complexity}} of binary operations on regular languages over different alphabets. It {{is known that}} if $L'_m$ and $L_n$ are languages of state complexities $m$ and $n$, respectively, and restricted to the same alphabet, the state complexity of any <b>binary</b> <b>boolean</b> <b>operation</b> on $L'_m$ and $L_n$ is $mn$, and that of product (concatenation) is $m 2 ^n - 2 ^{n- 1 }$. In contrast to this, we show that if $L'_m$ and $L_n$ are over different alphabets, the state complexity of union and symmetric difference is $(m+ 1) (n+ 1) $, that of difference is $mn+m$, that of intersection is $mn$, and that of product is $m 2 ^n+ 2 ^{n- 1 }$. We also study unrestricted complexity of binary operations in the classes of regular right, left, and two-sided ideals, and derive tight upper bounds. The bounds for product of the unrestricted cases (with the bounds for the restricted cases in parentheses) are as follows: right ideals $m+ 2 ^{n- 2 }+ 2 ^{n- 1 }$ ($m+ 2 ^{n- 2 }$); left ideals $mn+m+n$ ($m+n- 1 $); two-sided ideals $m+ 2 n$ ($m+n- 1 $). The state complexities of boolean operations on all three types of ideals {{are the same as}} those of arbitrary regular languages, whereas {{that is not the case}} if the alphabets of the arguments are the same. Finally, we update the known results about most complex regular, right-ideal, left-ideal, and two-sided-ideal languages to include the unrestricted cases. Comment: 30 pages, 15 figures. This paper is a revised and expanded version of the DCFS 2016 conference paper, also posted previously as arXiv: 1602. 01387 v 3. The expanded version has appeared in J. Autom. Lang. Comb. 22 (1 - 3), 29 - 59, 2017, the issue of selected papers from DCFS 2016. This version corrects the proof of distinguishability of states in the difference operation on p. 12 in arXiv: 1609. 04439 v...|$|E
40|$|A right ideal (left ideal, two-sided ideal) is a {{non-empty}} language L over an alphabet Σ {{such that}} L=LΣ^* (L=Σ^*L, L=Σ^*LΣ^*). Let k= 3 for right ideals, 4 for left ideals and 5 for two-sided ideals. We {{show that there}} exist sequences (L_n | n > k) of right, left, and two-sided regular ideals, where L_n has quotient complexity (state complexity) n, such that L_n is most complex in its class under the following measures of complexity: {{the size of the}} syntactic semigroup, the quotient complexities of the left quotients of L_n, the number of atoms (intersections of complemented and uncomplemented left quotients), the quotient complexities of the atoms, and the quotient complexities of reversal, star, product (concatenation), and all <b>binary</b> <b>boolean</b> <b>operations.</b> In that sense, these ideals are "most complex" languages in their classes, or "universal witnesses" to the complexity of the various operations. Comment: 25 pages, 11 figures. To appear in Discrete Mathematics and Theoretical Computer Science. arXiv admin note: text overlap with arXiv: 1311. 444...|$|R
40|$|This paper {{presents}} the multi-objective evolutionary optimization of three-dimensional geometry represented via constructive solid geometry (CSG), a <b>binary</b> tree of <b>boolean</b> <b>operations</b> of solid primitives. NSGA-II is extended for binary tree chromosomes with customized crossover and mutation operators tailored for {{the evolution of}} CSG trees and applied for two-objective shape optimization of indoor modular space truss joints. The results show success in generating a variety of shapes over the Pareto front. A selection of Pareto-optimal shapes are manufactured using a solid freeform fabrication process...|$|R
40|$|The novel {{devices are}} {{expected}} to shift the paradigm of a logic operation by their own nature, replacing the conventional devices. In this study, {{the nature of our}} fabricated magnetic tunnel junction (MTJ) that responds to the two external inputs, magnetic field and voltage bias, demonstrated seven basic logic operations. The seven operations were obtained by the electric-field-assisted switching characteristics, where the surface magnetoelectric effect occurs due to a sufficiently thin free layer. The MTJ was transformed as a universal logic gate combined with three supplementary circuits: A multiplexer (MUX), a Wheatstone bridge, and a comparator. With these circuits, the universal logic gates demonstrated 16 <b>binary</b> <b>Boolean</b> logic <b>operations</b> in one logic stage. A possible further approach is parallel computations through a complimentary of MUX and comparator, capable of driving multiple logic gates. A reconfigurable property can also be realized when different logic operations are produced from different level of voltages applying to the same configuration of the logic gate. (C) 2015 AIP Publishing LLC. The authors wish to acknowledge support from the national research funding of Korea (NRF- 2012 M 3 A 7 B 403519). We also thank IC design education center of Korea Advanced Institute of Science and Technology for supporting the computer-aided design tools for this work...|$|R
5000|$|<b>Boolean</b> <b>operations</b> on polygons: Various <b>Boolean</b> <b>operations</b> on {{the sets}} of points defined by {{polygonal}} regions.|$|R
25|$|The n-ary <b>Boolean</b> <b>operations</b> {{themselves}} {{constitute a}} power set algebra 2W, namely when W {{is taken to}} be the set of 2n valuations of the n inputs. In terms of the naming system of operations n'f'i where i in binary is a column of a truth table, the columns can be combined with <b>Boolean</b> <b>operations</b> of any arity to produce other columns present in the table. That is, we can apply any <b>Boolean</b> <b>operation</b> of arity m to m <b>Boolean</b> <b>operations</b> of arity n to yield a <b>Boolean</b> <b>operation</b> of arity n, for any m and n.|$|R
5000|$|... #Caption: <b>Binary</b> <b>boolean</b> {{expression}} tree {{equivalent to}} ((true [...] false) [...] false) [...] (true [...] false)) ...|$|R
5000|$|... #Caption: One {{approach}} is to use n LFSRs in parallel, their outputs combined using an n-input <b>binary</b> <b>Boolean</b> function (F).|$|R
40|$|<b>Boolean</b> <b>operations</b> and feature-based {{modeling}} {{are closely}} linked domains. For example, several, sometimes many <b>Boolean</b> <b>operations</b> are involved during a feature instantiation or modification. So Boolean combinations are tools used "inside" feature-based modeling {{and it is}} interesting to study the way to make these operations faster or less numerous by using {{the fact that they are}} applying to features. This is the first issue this paper deals with. Symmetrically, Boolean operators may be used to combine two feature-based objects. This occurs, for example, when a genetic algorithm is used to semi-automatically generate the shape of a product from requirements. The second part of the paper tackles the <b>Boolean</b> <b>operation</b> optimization in this specific context. This includes improving <b>Boolean</b> <b>operations</b> performances and incrementally maintaining the feature-based model of the object resulting from a <b>Boolean</b> <b>operation...</b>|$|R
40|$|Abstract. A complex {{structure}} can {{be constructed}} by <b>Boolean</b> <b>operations</b> of geometric primitives such as cube, sphere, cylinder, and so on. However, <b>Boolean</b> <b>operations</b> cannot represent the structure in form of mathematical function. In this paper, we propose a new shape representation method that combines the <b>Boolean</b> <b>operations</b> with the KS function. Applications show that 2 D and 3 D engineering parts can be described by a single implicit KS function...|$|R
50|$|Modern {{implementations}} for <b>Boolean</b> <b>operations</b> on polygons {{tend to use}} plane sweep algorithms (or Sweep line algorithms). A list {{of papers}} using plane sweep algorithms for <b>Boolean</b> <b>operations</b> on polygons {{can be found in}} References below.|$|R
40|$|This thesis {{deals with}} general polygon <b>boolean</b> <b>operation</b> algorithms. <b>Boolean</b> <b>operations</b> are e. g. intersection, union or difference. A general polygon can be e. g. a selfinterecting polygon with inner hole. Clipping of polygons against a {{rectangular}} window {{is probably the}} most familiar <b>boolean</b> <b>operation</b> on polygons. At first, basic definitions are listed. Then the principles of a selected set of <b>boolean</b> <b>operation</b> algorithms are reviewed. Finally, a complex comparison of the algorithms is undertaken. Performance as well as the ability to handle degenerate cases are tested. The output of this thesis is an overall evaluation of algorithm properties and a dynamic library that contains the implementation of all of the tested algorithms...|$|R
5000|$|<b>Boolean</b> <b>operations</b> on polygons are {{a set of}} <b>Boolean</b> <b>operations</b> (AND, OR, NOT, XOR, ...) {{operating}} on one or more sets of polygons in computer graphics. These sets of operations are widely used in computer graphics, CAD, and in EDA (in integrated circuit physical design and verification software).|$|R
5000|$|... #Subtitle level 2: Language {{equations}} with <b>Boolean</b> <b>operations</b> ...|$|R
40|$|Each Web {{search engine}} {{provides}} query language through {{which it can}} communicate with its users and retrieve corresponding results to user queries. Supporting <b>Boolean</b> <b>operations</b> is a major characteristic of the query language. In this paper, we propose a novel, fully automatic, query probing based approach to identify what <b>Boolean</b> <b>operations</b> that are supported by a search engines and their corresponding syntaxes. Experiments show high effectiveness and efficiency. Along with this, we also provide a Web application called SE-BOSS (Search Engine <b>Boolean</b> <b>Operation</b> Scanning System) for interested users...|$|R
40|$|Abstract. <b>Boolean</b> <b>operation</b> {{is the key}} {{technology}} for modeling the bone scaffold. This paper proposes a <b>Boolean</b> <b>operation</b> algorithm based on triangle mesh model. It firstly voxelizes the mesh models based on project vector and octree, and classifies the vertices into inside, outside and surface type according to the position relationship between the vertex and the other mesh model’s voxel. Then the triangles can be easily classified based on the vertices class. Finally the Boolean model can be composed by the corresponding triangles of the <b>Boolean</b> <b>operation.</b> In order to obtain the intersection features well, it detects the intersection lines and gets the intersection polygons further, and then triangulates the polygon using the ear clipping method. This <b>Boolean</b> <b>operation</b> algorithm {{has been applied to}} the bone scaffold modeling and got good performance...|$|R
5000|$|... the <b>Boolean</b> <b>operations</b> of (<b>binary)</b> intersection, union, and complement, ...|$|R
2500|$|Given the Boolean domain B={0,1}, a set F of Boolean {{functions}} ƒi:Bni→B is functionally complete if {{the clone}} on B {{generated by the}} basic functions ƒi contains all functions ƒ:Bn→B, for all strictly positive integers [...] In other words, the set is functionally complete if every Boolean function that takes at least one variable can be {{expressed in terms of}} the functions ƒi. Since every Boolean function of at least one variable can be expressed in terms of <b>binary</b> <b>Boolean</b> functions, F is functionally complete if and only if every <b>binary</b> <b>Boolean</b> function can be expressed in terms of the functions in F.|$|R
