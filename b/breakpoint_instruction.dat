2|17|Public
5000|$|The TMS9900 has an uncommon, {{and rarely}} used, {{instruction}} called [...] "X" [...] (eXecute). This instruction {{is used to}} execute another instruction at an address pointed to by a register without changing program flow, i.e. execution continues at the address following the X instruction. This instruction {{can be used for}} debugging (as a <b>breakpoint</b> <b>instruction)</b> and for creating indexed-opcode tables as used in byte-code interpreters.|$|E
50|$|Debug mode is also entered asynchronously by the debug module {{triggering}} a watchpoint or breakpoint, or by issuing a BKPT (<b>breakpoint)</b> <b>instruction</b> from the software being debugged. When {{it is not}} being used for instruction tracing, the ETM can also trigger entry to debug mode; it supports complex triggers sensitive to state and history, {{as well as the}} simple address comparisons exposed by the debug module. Asynchronous transitions to debug mode are detected by polling the DSCR register. This is how single stepping is implemented: HALT the core, set a temporary breakpoint at the next instruction or next high-level statement, RESTART, poll DSCR until you detect asynchronous entry to debug state, remove that temporary breakpoint, repeat.|$|E
5000|$|Breakpoints ... Programs halt when a {{specified}} event, a breakpoint, has occurred. The event {{can be specified}} as a code execution address, or as a data access (read or write) to an address with {{a specified}} value. Nexus breakpoints can be set at any address, including flash or ROM memory; CPUs may also provide special <b>breakpoint</b> <b>instructions.</b>|$|R
50|$|Many {{processors}} include hardware {{support for}} <b>breakpoints</b> (typically <b>instruction</b> and data <b>breakpoints).</b> As an example, the x86 instruction set architecture provides hardware support for breakpoints with its x86 debug registers. Such hardware may include limitations, for example not allowing <b>breakpoints</b> on <b>instructions</b> located in branch delay slots. This kind of limitation is {{imposed by the}} microarchitecture of the processor and varies from processor to processor.|$|R
50|$|Breakpoints {{are most}} {{commonly}} used to interrupt a running program immediately before the execution of a programmer-specified instruction. This {{is often referred to}} as an <b>instruction</b> <b>breakpoint.</b>|$|R
50|$|In-system {{programming}} allows {{an external}} hardware debugger to reprogram a system under test (for example, adding or removing <b>instruction</b> <b>breakpoints).</b> Many systems with such ISP support also have other hardware debug support.|$|R
40|$|Using debuggers is {{a common}} mean for {{identifying}} and analyzing malware (such as viruses, worms, spyware, rootkits, etc.). However, debuggers can be detected by malware via observing {{of the behavior of}} operating system, changes in code (such as <b>breakpoint</b> <b>instructions)</b> and non-standard behavior of the CPU, making the analysis of the malware can be hard and tedious. In this thesis we are implementing a basic debugger based on the QEMU emulator that hides its presence from the debugged application. This is accomplished by using the QEMU as virtual machine and adding context awareness to the already existing primitive debugger. The context awareness is implemented using an embedded Python scripting engine. Such setup gives us a flexible way of implementing support for various operating systems. In this thesis, we have developed two examples. One example is for the RTEMS operating system, which serves as easy to understand reference implementation. Second example is for the Linux operating system, to show the abilities of the undetectable debugger in a more real scenario...|$|R
5000|$|Without {{hardware}} support (and in multitasking environments), debuggers have {{to implement}} breakpoints in software. For <b>instruction</b> <b>breakpoints,</b> {{this is a}} comparatively simple task of replacing the instruction {{at the location of}} the breakpoint by either: ...|$|R
50|$|As {{multiprocessing}} {{became more}} commonplace, such techniques would have limited practicality, since many independent processes would be stopped simultaneously. This {{led to the}} development of proprietary software from several independent vendors that provided similar features but deliberately restricted <b>breakpoints</b> and <b>instruction</b> stepping to particular application programs in particular address spaces and threads. The program state (as applicable to the chosen application/thread) was saved for examination at each step and restored before resumption, giving the impression of a single user environment. This is normally sufficient for diagnosing problems at the application layer.|$|R
50|$|The INT 3 {{instruction}} is defined {{for use by}} debuggers to temporarily replace an instruction in a running program in order to set a <b>breakpoint.</b> Other INT <b>instructions</b> are encoded using two bytes. This makes them unsuitable for use in patching instructions (which can be one byte long); see SIGTRAP.|$|R
5000|$|Machine breakpointsEarly {{mainframe}} computers, {{such as the}} IBM/360, had console switches/dials {{that allowed}} <b>breakpoints</b> at specific <b>instruction</b> storage addresses and provided [...] "single cycle" [...] operation, permitting the contents of registers and memory to be observed directly on console lights. The advent of multitasking limited {{the use of this}} option since the entire machine was halted.|$|R
2500|$|The ARMv7 {{architecture}} defines basic debug {{facilities at}} an architectural level. These include <b>breakpoints,</b> watchpoints and <b>instruction</b> execution in a [...] "Debug Mode"; similar facilities were also available with EmbeddedICE. Both [...] "halt mode" [...] and [...] "monitor" [...] mode debugging are supported. The actual transport mechanism used {{to access the}} debug facilities is not architecturally specified, but implementations generally include JTAG support.|$|R
50|$|The {{goal of a}} pipelined {{architecture}} is to complete an instruction every clock cycle. To maintain this rate, the pipeline must be full of instructions at all times. The branch delay slot is {{a side effect of}} {{pipelined architecture}}s due to the branch hazard, i.e. the fact that the branch would not be resolved until the instruction has worked its way through the pipeline. A simple design would insert stalls into the pipeline after a branch instruction until the new branch target address is computed and loaded into the program counter. Each cycle where a stall is inserted is considered one branch delay slot. A more sophisticated design would execute program instructions which are not dependent on the result of the branch instruction. This optimization can be performed in software at compile time by moving instructions into branch delay slots in the in-memory instruction stream, if the hardware supports this. Another side effect is that special handling is needed when managing <b>breakpoints</b> on <b>instructions</b> as well as stepping while debugging within branch delay slot.|$|R
50|$|XAP6 is a 32-bit {{processor}} and {{was launched in}} 2013. It has {{the same type of}} load-store architecture as the XAP4 and XAP5, but has 32-bit registers and 32-bit buses for Data and Address. The XAP6a implementation has a three-stage instruction pipeline. Like all the XAP processors, the XAP6 has been optimised for low-cost, low-energy and easy verification. XAP6 is tailored for small low-energy ASICs and minimises processor hardware size (the XAP6 core uses 30,000-gates). The XAP6 registers (all 32-bit) are; 8 General Purpose, Program Counter, Vector Pointer, Global Pointer, FLAGS, INFO, BRKE, 4 <b>Breakpoint.</b> The XAP6 <b>instructions</b> are 16, 32 and 48-bit. The XAP6 compile chain is based on GNU GCC and Binutils.|$|R
40|$|Richard Uhlig, David Nagle, Trevor Mudge & Stuart Sechrest Department of Electrical Engineering and Computer Science University of Michigan e-mail: uhlig@eecs. umich. edu, bassoon@eecs. umich. edu This work is {{supported}} by Defense Advanced Research Projects Agency under DARPA/ARO Contract Number DAAL 03 - 90 -C- 0028 and a National Science Foundation Graduate Fellowship. needed, traps can be set or cleared using page valid bits, or by installing and removing page-table entries in a software -managed TLB [1]. For cache simulation, where cache-line granularity is needed, <b>instruction</b> <b>breakpoints,</b> data breakpoints, or memory parity traps can be set [2]. Two essential features of this approach enable Tapeworm to overcome the limitations of trace-driven simulation. First, because Tapeworm processes only the infrequent case of misses, it is much faster than comparable tracedriven simulators, which consider all memory references. Second, because Tapeworm resides in the kernel of a running operating [...] ...|$|R
50|$|In 2005, further project {{requirements}} saw a new 16-bit processor, the XAP4, {{designed to}} supersede the XAP2 {{taking into account}} the experience gained on XAP3 and the evolving requirements of ASIC designs. XAP4 is a very small, 12,000-gate, Von Neumann bus, 16-bit processor core capable of addressing a total of 64 kBytes of memory for programs, data and peripherals. It offers high code density combined with good performance in the region of 50 Dhrystone MIPS when clocked at 80 MHz.XAP4 was designed for use in modern ASIC or microcontroller applications capable of processing real-world data captured by an Analog to digital converter (ADC) or similar sources. The processor's 16-bit integer word supports the precision of most ADCs without carrying the overhead of a 32-bit processor. XAP4 also offers a migration path from 8-bit processors, such as 8051, in applications that need increased performance and program size, but cannot justify the cost and overhead of a 32-bit processor. The XAP4 registers (all 16-bit) are; 8 General Purpose, Program Counter, Vector Pointer, FLAGS, INFO, BRKE, 2 <b>Breakpoint.</b> The XAP4 <b>instructions</b> are 16 and 32-bit. The XAP4 compile chain is based on GNU GCC and Binutils.|$|R
50|$|Development of an {{extended}} version of this architecture commenced in 2006 and resulted in the XAP5, which was announced in July 2008. XAP5 is a 16-bit processor with a 24-bit address bus making it capable of running programs from memory up to 16 MBytes. XAP4 and XAP5 are both implemented with a two-stage instruction pipeline, which maximises their performance when clocked at low frequencies. This is tailored {{to the requirements of}} small, low-energy ASICs as it minimises processor hardware size (the XAP5 core uses 18,000-gates), and it fits designs that are clocked relatively slowly to reduce an ASIC's dynamic power consumption and run programs direct from Flash or OTP memory that has a slow access time. Typical clock speeds for XAP5 are in the range of 16 to 100 MHz on a 0.13 process. XAP5 has particular design features making it suitable for executing programs from Flash including a Vector Pointer and an Address Translation Window, which combine to allow in-place execution of programs and relocation of programs regardless of where they are stored in physical memory. The XAP4 registers (16 and 24-bit) are; 8 General Purpose, Program Counter, Vector Pointer, FLAGS, INFO, BRKE, 4 <b>Breakpoint.</b> The XAP5 <b>instructions</b> are 16, 32 and 48-bit. The XAP5 compile chain is based on GNU GCC and Binutils.|$|R
40|$|International audienceThis paper {{presents}} {{the challenges of}} implementing a bare-metal hypervisor without using hardware virtualization features. This choice is dictated by two reasons:(i) some processor do not include virtualization instructions,(ii) in the context formal verification, the proof relies on good behavior of the hardware. Thus eliminating hardware features will let us have a more precise proof. Implementing virtualization features in hardware is a complex work: the instruction set remains large, and despite of the documentation, some behaviors are not obvious, if not undefined. Moreover, doing this in software forces us to freeze the guest to perform work, decreasing performances. We implemented a software hypervisor that has the particularity to run the guest systems in privilege mode. Before that, the hypervisor dynamically analyze the guest code and runs it after setting <b>breakpoints</b> on sensitive <b>instructions.</b> To perform the analysis, we extracted the whole ARM and Thumb instruction set to identify sensitives instructions, which has to be handled by the hypervisor. In order to preserve acceptable performances, we only track code running on privileged mode. Thus, guest kernel run {{at the same level}} of privileges as the hypervisor. We evaluated the performances of our approach using micro-benchmarks and macro-benchmarks to evaluate the impact of the process on a piece of code and on a whole system. The results show that, when running a guest that performs pre-emptive scheduling and running its tasks in user mode, our hypervisor performs with a reasonable overhead: from 0. 3 % to 15 % overhead on several synthetic benchmarks. We finally provide several ideas for further optimization and a direction for future work...|$|R

