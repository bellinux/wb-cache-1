147|301|Public
5000|$|Back in the O.S.V.R.: Medium, Messages and Mysticism: <b>Binding</b> <b>Time</b> With the Ghost in the Machine https://www.youtube.com/watch?v=3S41TX8-1Nw: Created for Book Expo America, 2014 {{created for}} and {{screened}} {{as part of}} [...] "The Media IS the Message: Multi-Media and the Future of Publishing" [...] (with Ralph Rivera, BBC Future Media), for BookExpo America 2014, and the 72nd Annual New York State CommunicationAssociation Conference and the 62nd Alfred Korzybski Memorial Lecture and Symposium for the Institute of General Semantics, in New York, 2014 ...|$|E
5000|$|Like {{other members}} of the Rad51/RecA family, Dmc1 stabilizes strand {{exchange}} intermediates (Rad1/RecA-stretched DNA, or RS-DNA) in stretched triplets similar to B form DNA. Each molecule of the protein binds a triplet of nucleotides, and the strength of that binding, as assessed by the change in Gibbs free energy, can be assessed by the length of time that a labelled dsDNA probe with a short homologous sequence remains bound to a DNA containing a short region of homology to it. A study of this type has shown that a mismatch in any of the three positions {{at the end of a}} stretch of homology will not increase the length of time that the probe remains bound, and in Rad51 or RecA constructs an internal mismatch will cause a similar reduction in <b>binding</b> <b>time.</b> All of the enzymes are capable of [...] "stepping over" [...] a mismatch and continuing to bind the probe more firmly if a longer region of homology exists. However, with Dmc1 a triplet with a single internal (but not terminal) mismatch will contribute to the stability of probe binding to a similar extent as one without a mismatch. In this way, Dmc1 is specially suited to its role as a meiosis-specific recombinase, as this activity permits it more effectively to catalyze recombination between sequences that are not perfectly matched.|$|E
40|$|<b>Binding</b> <b>time</b> {{analysis}} {{has proved to}} be a valuable pre-analysis for partial evaluation. Until now (almost) all <b>binding</b> <b>time</b> analyses have been monovariant, such that <b>binding</b> <b>time</b> analysis could assign only one <b>binding</b> <b>time</b> description to each function definition. This means that if a function f(x) is called once with dynamic data, no reductions on x can be performed in the body of f even when f is called with static data. There is currently great interest in polyvariant <b>binding</b> <b>time</b> analysis. Gengler and Rytz [Gengler & Rytz 1992 a, Gengler & Rytz 1992 b] use a kind of repeated abstract interpretation which is very slow. Consel [Consel 1992] avoids repeating the analysis by collapsing closure and <b>binding</b> <b>time</b> analysis and letting control flow information depend on <b>binding</b> <b>time</b> values. Both approaches copy (functions resp. <b>binding</b> <b>time</b> descriptions) in the “needed ” number of variants. Recently type inference has attracted much attention as a program analysis framework. This framework has been very successful in <b>binding</b> <b>time</b> analysis an...|$|E
40|$|Polyvariant {{expansion}} is a binding-time-improving transformation for offline partial evaluation. We show {{how to achieve}} it automatically for a higher-order functional language using the interpretive approach. We have designed and implemented an interpreter that statically propagates <b>binding</b> <b>times.</b> When specialized {{with respect to a}} source program, it performs polyvariant expansion. Extending the interpreter to an online specializer allows us to generate a binding-time-polyvariant compiler generator. Maintaining the <b>binding</b> <b>times</b> affords an abstract interpretation equivalent to a constraint-based binding-time analysis...|$|R
50|$|Several object <b>binding</b> <b>times</b> {{exist in}} object {{oriented}} systems. Java, for example, has late binding leading to more loosely coupled systems (at least for deployment).|$|R
30|$|There are no <b>binding</b> {{construction}} <b>time</b> constraints.|$|R
40|$|Abstract <b>Binding</b> <b>time</b> {{analysis}} {{has proved to}} be a valuable pre-analysis for partial evaluation. Until now (almost) all <b>binding</b> <b>time</b> analyses have been monovariant, such that <b>binding</b> <b>time</b> analysis could assign only one <b>binding</b> <b>time</b> description to each function definition. This means that if a function f (x) is called once with dynamic data, no reductions on x can be performed in the body of f even when f is called with static data...|$|E
40|$|Abstract. <b>Binding</b> <b>time</b> {{analysis}} {{is an important}} part of off-line partial evaluation, annotating expressions as being safely evaluable from known data or possibly depending on unknown data. Most binding-time analy-ses have been monovariant, allowing only one binding-time description for each function. The idea of polyvariance is to allow multiple <b>binding</b> <b>time</b> descriptions of each function, by duplicating the function [6, 2] or by associating a set of <b>binding</b> <b>time</b> descriptions to each function [3]. Instead we present an inference based <b>binding</b> <b>time</b> analysis polymorphic in <b>binding</b> <b>time</b> values. This polymorphism captures a very powerful no-tion of polyvariance limited only by the (standard) types of the language. Polymorphism gives a much simpler definition than the known polyvari-ant schemes allowing us to reason formally about the system and prove it correct. This paper is based on work in [14]. ...|$|E
40|$|Given a {{description}} of the parameters in a program that will be known at partial evaluation time, a <b>binding</b> <b>time</b> analysis must determine which parts of the program are dependent solely on these known parts (and therefore also known at partial evaluation time). In this paper a <b>binding</b> <b>time</b> analysis for the simply typed lambda calculus is presented. The analysis takes the form of an abstract interpretation and uses a novel formalisation of the problem of <b>binding</b> <b>time</b> analysis, based on the use of partial equivalence relations. A simple proof of correctness is achieved by the use of logical relations. 1 Introduction Given {{a description}} of the parameters in a program that will be known at partial evaluation time, a <b>binding</b> <b>time</b> analysis must determine which parts of the program are dependent solely on these known parts (and therefore also known at partial evaluation time). A <b>binding</b> <b>time</b> analysis performed prior to the partial evaluation process can have several practical benefits (see [ [...] ...|$|E
40|$|Our results formalize {{and confirm}} a {{folklore}} theorem about traditional bindingtime analysis, namely that CPS {{has a positive}} effect on <b>binding</b> <b>times.</b> What may be more surprising is that the benefit does not arise from a standard refinement of program analysis, as, for instance, duplicating continuations...|$|R
40|$|The aim of binding-time {{analysis}} {{is to determine}} when variables, expressions, statements, etc. in a program can be evaluated by classifying these into static (compile-time) and dyamic (run-time). Explicit separation of <b>binding</b> <b>times</b> {{has turned out to}} be crucial for successful self-application of partial evaluators, and apparently, it is also an important stepping-stone for profitable specialization of imperative languages with pointers and dynamic memory allocation. In this paper we present an automatic binding-time analysis for a substantial subset of the C language. The paper has two parts. In the first part, the semantic issues of binding-time separation is discussed with emphasis on pointers and classification of these. This leads to the introduction of a two-level C language where <b>binding</b> <b>times</b> are explicit in the syntax. Finally, well-annotatedness rules are given which excludes non-consistently annotated programs. In the second part, an automatic binding-time analysis based on c [...] ...|$|R
40|$|We {{present a}} novel {{technique}} for offine partial evaluation of functional languages with an ML-style typing discipline. Our program specialization method comprises a polymorphic binding-time analysis with polymorphic recursion. Based {{on the region}} calculus of Tofte and Talpin, we develop a binding-time analysis as a constraint analysis on top of region inference. Our insight is to regard <b>binding</b> <b>times</b> as properties of regions...|$|R
3000|$|... et values {{exhibited}} {{a tendency to}} increase {{as a function of}} an increased antibody <b>binding</b> <b>time,</b> reaching a plateau after 8  h. Thus, 8  h was used as the optimal <b>binding</b> <b>time</b> for anti-E. coli to obtain maximal electrochemical signals from the sensor.|$|E
40|$|<b>Binding</b> <b>time</b> {{analysis}} aims at {{determining which}} identifiers can be bound to their values at compile time. This <b>binding</b> <b>time</b> information {{is of utmost}} importance when performing partial evaluation or constant folding on programs. Existing <b>binding</b> <b>time</b> analyses are global in that they require complete program texts and descriptions of which of their inputs are available at compile time. As a consequence, such analyses cannot be used in programming languages that support modules or separate compilation. Libraries have to be analyzed every time they are used in some program. This is particularly limiting when considering programming in-the-large; any modification of an application results in the reprocessing of all the modules. This paper presents a new static analysis for higher-order typed functional languages that relies on a type and e#ect system to obtain polyvariant and separate <b>binding</b> <b>time</b> information. By allowing function types to be parametrized over the binding times of their arg [...] ...|$|E
40|$|Conformational {{fluctuations}} {{are believed}} {{to play an important}} role in the process by which transcription factor proteins locate and bind their target site on the genome of a bacterium. Using a simple model, we show that the <b>binding</b> <b>time</b> can be minimized, under selective pressure, by adjusting the spectrum of conformational states so that the fraction of time spent in more mobile conformations is matched with the target recognition rate. The associated optimal <b>binding</b> <b>time</b> is then within an order of magnitude of the limiting <b>binding</b> <b>time</b> imposed by thermodynamics, corresponding to an idealized protein with instant target recognition. Numerical estimates suggest that typical bacteria operate in this regime of optimized conformational fluctuations...|$|E
40|$|We {{show that}} a non-duplicating CPS {{transformation}} {{has no effect on}} control-flow analysis and that it has a positive effect on binding-time analysis: a monovariant control-flow analysis yields equivalent results on a direct-style program and on its CPS counterpart, and a monovariant binding-time analysis yields more precise results on a CPS program than on its direct-style counterpart. Our proof technique amounts to constructing the continuation-passing style (CPS) counterpart of flow information and of <b>binding</b> <b>times.</b> Our results confirm a folklore theorem about binding-time analysis, namely that CPS has a positive effect on <b>binding</b> <b>times.</b> What may be more surprising is that this benefit holds even if contexts or continuations are not duplicated. The present study is symptomatic of an unsettling property of program analyses: their quality is unpredictably vulnerable to syntactic accidents in source programs, i. e., to the way these programs are written. More reliable program analyses require {{a better understanding of the}} effect of syntactic change...|$|R
40|$|Distributed {{shared memory}} (DSM) {{architectures}} try to bind recently referenced data to memory local to a node {{with the assumption}} that the data will be referenced again in the near future. However, patterns of reference at the local memory may not be as highly localized as at the processor cache. In general, the higher the cache hit rate, the lower the local memory hit rate. Also, unlike in traditional caches, replaced data from the local memory can have the side effect of affecting locality of data in a remote memory. Thus, utilizing locality of reference at the local memory seems to be arduous in DSM architectures due to higher overhead for dynamic binding and weaker locality of reference. This thesis considers three <b>binding</b> <b>times</b> for new data at the local memory: page fault time, node miss time, and cache miss time. In DSM architectures, different <b>binding</b> <b>times</b> are associated with different ways of arranging data, which cause different overheads under the same patterns of reference. [...] ...|$|R
5000|$|Wark {{described}} {{the process of}} culture by which [...] "the jolt of new experiences becomes naturalised into habit" [...] or second nature and describes the information society as not being new but something that changes through culture the balance between space <b>binding</b> and <b>time</b> <b>binding</b> media.|$|R
40|$|Abstract—Feature {{selection}} {{is the process}} of determining features that should be included in a product to satisfy the requirements for the various stakeholders. Feature <b>binding</b> <b>time</b> refers to the time at which variable features are selected for a product and their implementations are bound into the product. A feature may have different binding times for different prod-ucts. In this paper, we present an aspect-oriented approach to supporting flexible feature <b>binding</b> <b>time.</b> Index Terms—component; formatting; style; styling; I...|$|E
40|$|AbstractTranscription factor (TF) {{proteins}} rapidly locate unique target {{sites on}} long genomic DNA molecules—and bind to them—during gene regulation. The search mechanism {{is known to}} involve a combination of three-dimensional diffusion through {{the bulk of the}} cell and one-dimensional sliding diffusion along the DNA. It is believed that the surprisingly high target binding rates of TF proteins relies on conformational fluctuations of the protein between a mobile state that is insensitive to the DNA sequence and an immobile state that is sequence-sensitive. Since TFs are not able to consume free energy during their search to obtain DNA sequence information, the Second Law of Thermodynamics must impose a strict limit on the efficiency of passive search mechanisms. In this article, we use a simple model for the protein conformational fluctuations to obtain the shortest <b>binding</b> <b>time</b> consistent with thermodynamics. The <b>binding</b> <b>time</b> is minimized if the spectrum of conformational fluctuations that take place during the search is impedance-matched to the large-scale conformational change that takes place at the target site. For parameter values appropriate for bacterial TF, this minimum <b>binding</b> <b>time</b> is within an order-of-magnitude of a limiting <b>binding</b> <b>time</b> corresponding to an idealized protein with instant target recognition. Numerical estimates suggest that typical bacteria operate in this regime of optimized conformational fluctuations...|$|E
40|$|Partial {{evaluation}} of an applied lambda calculus was done {{some years ago}} in the lambda-mix project. When moving to pure lambda calculus, some issues need to be considered, most importantly how we represent programs in pure lambda calculus. We start by presenting a compact representation schema for -terms and show how this leads to an exceedingly small and elegant self-interpreter. Partial evaluation is discussed, and it is shown that partial evaluation in the most general sense is uncomputable. There are several ways of restricting partial evaluation. We choose one of these, which requires explicit <b>binding</b> <b>time</b> information. <b>Binding</b> <b>time</b> annotations are discussed, and the representation schema is extended to include annotations. A partial evaluator is then constructed {{as an extension of the}} self-interpreter, and self-application is performed to produce possibly the smallest non-trivial compiler generator in the literature. It is shown that <b>binding</b> <b>time</b> analysis can be done by modifying [...] ...|$|E
40|$|Scalable {{software}} composition by reusing software assets {{is one of}} {{the major}} challenges in software engineering since many years. The goal of software product line engineering is to provide a systematic approach for reuse for a set of similar programs, called a software product line (SPL). The programs of an SPL can be distinguished in terms of features, which describe commonalities and differences between the programs. This allows SPL engineers to describe a program by listing its features. There are several SPL development techniques that support composition of assets to derive a tailor-made program according to a selection of required features. A main difference between existing techniques is their support for different feature <b>binding</b> <b>times,</b> i. e., the time at which a feature is included in a program. We can distinguish between static and dynamic binding. While static binding occurs before runtime (e. g., at compile-time), dynamic binding occurs during program start or in a running program. Both <b>binding</b> <b>times</b> have benefits and drawbacks. Static binding is used to generat...|$|R
50|$|Ius scriptum was {{contrasted with}} ius non scriptum, {{the body of}} common laws that arose from {{customary}} practice and had become <b>binding</b> over <b>time.</b>|$|R
40|$|We look at {{the problem}} of signal {{transduction}} by extracellular agonist binding to a receptor protein at the membrane (sensor) via binding of G-proteins (effectors) to a highly integrative target molecule, such as the second messenger cAMP (target). We explore the effects of <b>binding</b> <b>times,</b> effector assignment and effector pool size on {{the shape of the}} output signal under different input scenarios. We conclude that low rates of information transfer may sometimes coincide with a high probability or efficiency of plasticity induction. Comment: 4 pages, submitted to IEEE Biocomputin...|$|R
40|$|Program specializers {{improve the}} speed of {{programs}} by performing some of the programs ' reductions at specialization time rather than at runtime. This specialization process can be time-consuming; one common technique for improving {{the speed of}} the specialization of a particular program is to specialize the specializer itself on that program, creating a custom specializer, or program generator, for that particular program. Much research has been devoted to the problem of generating e cient program generators, which do not perform reductions at program generation time which could instead have been performed when the program generator was constructed. The conventional wisdom holds that only o ine program specializers, which use <b>binding</b> <b>time</b> annotations, can be specialized into such e cient program generators. This paper argues {{that this is not the}} case, and demonstrates that the specialization of a nontrivial online program specializer similar to the original MIX &quot; can indeed yield an e cient program generator. The key to our argument is that, while the use of <b>binding</b> <b>time</b> information at program generator generation time is necessary for the construction of an e cient custom specializer, the use of explicit <b>binding</b> <b>time</b> approximation techniques is not. This allows us to distinguish the problem at hand (i. e., the use of <b>binding</b> <b>time</b> information during program generator generation) from particular solutions to that proble...|$|E
40|$|Companies are {{adopting}} the Software Product Line (SPL) development paradigm to obtain {{significant improvements in}} time to market, maintenance cost, productivity, and quality of products. SPL encompasses a family of software-intensive systems developed from reusable assets. By reusing such assets, {{it is possible to}} construct a large number of different products applying various compositions. There is a variety of widely used techniques to develop SPLs, such as aspect-oriented programming (AOP), feature-oriented programming (FOP), and conditional compilation. These techniques differ in the type of composition to create a product within the SPL static or dynamically. In this context, it is important to define when certain features should be activated in the product due to specific client requirements and different application scenarios. Thereby, the <b>binding</b> <b>time</b> of a feature is the time that one decides to activate or deactivate the feature from a product. In general, static and dynamic binding times are considered. For example, products for devices with constrained resources may use static <b>binding</b> <b>time</b> instead of dynamic due to the performance overhead introduced by the latter. For devices without constrained resources, the <b>binding</b> <b>time</b> can be flexible, features can be activated or deactivated statically or users may do it on demand (dynamically). To provide flexible <b>binding</b> <b>time</b> for features, researchers proposed an AOP idiom based on AspectJ and design patterns named Edicts. The idea consists of supporting <b>binding</b> <b>time</b> flexibility of features in a modular and convenient way. However, we observe modularity problems in the Edicts idiom. Although we usually use aspects to tackle crosscutting concerns common in classes, such a problem now appears within the own aspects. Indeed, several studies indicate that these concerns hurt software modularity. This way, we observe that Edicts clones, scatters, and tangles code throughout its implementation, which may lead to time consuming tasks, such as maintaining duplicated code. This way, we develop three idioms and implement them to provide flexible <b>binding</b> <b>time</b> for features of four different applications. In addition, we evaluate Edicts and the three idioms quantitatively by means of metrics with respect to code tangling, scattering, cloning, size, and also try to guarantee that our idioms do not change feature code behavior among the different implementations. FACEPE, CNPq, INE...|$|E
40|$|The {{speed and}} {{reliability}} of neuronal reactions are important factors for proper functioning of the nervous system. To understand how organisms use protein molecules to carry out very fast biological actions, we quantified single-molecule reaction time and its variability in synaptic transmission. From the synaptic delay of crayfish neuromuscular synapses {{the time for a}} few Ca 2 + ions to bind with their sensors in evoked neurotransmitter release was estimated. In standard crayfish saline at room temperature, the average Ca 2 + <b>binding</b> <b>time</b> was 0. 12 ms for the first evoked quanta. At elevated extracellular Ca 2 + concentrations this <b>binding</b> <b>time</b> reached a limit due to saturation of Ca 2 + influx. Analysis of the synaptic delay variance at various Ca 2 + concentrations revealed that the variability of the Ca 2 +-sensor <b>binding</b> <b>time</b> is the major source of the temporal variability of synaptic transmission, and that the Ca 2 +-independent molecular reactions after Ca 2 + influx were less stochastic. The results provide insights into how organisms maximize reaction speed and reliability...|$|E
40|$|Opportunities for {{specialization}} abound during program execution. Dynamic specialization exploits run-time {{values that}} are not available at compile time, yielding code that is often superior to statically optimal code. This paper surveys {{the design of the}} FABIUS compiler, which achieves dynamic speculation with low overhead through the use of generating extensions that create native residual code. One novel aspect of dynamically specialized code yields values {{that can be used in}} successive rounds of specialization. We demonstrate that decoupling <b>binding</b> <b>times</b> at procedure call boundaries allows multi-stage specialization to be expressed in a two-level language...|$|R
40|$|International audienceMany key {{cellular}} {{processes are}} controlled by the association of DNA-binding proteins (DBPs) to specific sites. The kinetics of the search process leading to the binding of DBPs to their target locus are largely determined by transient interactions with non- cognate DNA. Using single-molecule microscopy, we studied the dynamics and non- specific binding to DNA of the Lac repressor (LacI) in the environment of mammalian nuclei. We measured {{the distribution of the}} LacI–DNA <b>binding</b> <b>times</b> at non-cognate sites and determined the mean residence time to be s 1 D 1 ⁄ 4 182 ms. This non-specific interaction time, measured {{in the context of an}} exogenous system such as that of human U 2 OS cells, is remarkably different compared to that reported for the LacI in its native environment in E. coli (< 5 ms). Such a striking difference (more than 30 fold) suggests that the genome, its organization, and the nuclear environment of mammalian cells play important roles on the dynamics of DBPs and their non-specific DNA interactions. Furthermore, we found that the distribution of off-target <b>binding</b> <b>times</b> follows a power law, similar to what was reported for TetR in U 2 OS cells. We argue that a possible molecular origin of such a power law distribution of residence times is the large variability of non-cognate sequences found in the mammalian nucleus by the diffusing DBPs...|$|R
40|$|Visualization {{can help}} both implementors and users of partial evaluators to {{understand}} (1) where reductions are applied {{in a given}} source program, (2) what residual code is produced by these reductions, (3) how these transformation decisions are made, and (4) how these transformations affect the code generated by subsequent passes of a compiler. We have identified the following as important characteristics of visualization tools designed to help answer these questions. —The source and residual programs are displayed side-by-side and correlated so that a user can see the residual code produced for a given source expression or the source code that produced a given residual-program expression. —If the partial evaluator {{is part of a}} larger compilation system, the output of each subsequent compiler pass can be displayed as well, and correlated with the source and residual code so that the effects of partial evaluation on subsequent compiler passes can be seen. —Residual code and code from subsequent compiler passes, if any, can be displayed in the concrete syntax of the full source language, regardless of the intermediate representations used by the partial evaluator or compiler. This may require decompilation of intermediate code or unexpansion of macro-expanded code. —The display of information can be constrained to particular frames of reference. In particular, if the binding-time analysis is polyvariant, it is possible to view call sites for which a given expression is assigned different <b>binding</b> <b>times</b> or to display <b>binding</b> <b>times</b> relative to particular call contexts...|$|R
40|$|AbstractWe {{study the}} {{kinetics}} of the biomolecular binding {{process at the}} interface using energy landscape theory. The global kinetic connectivity case is considered for a downhill funneled energy landscape. By solving the kinetic master equation, the kinetic time for binding is obtained and shown to have a U-shape curve-dependence on the temperature. The kinetic minimum of the <b>binding</b> <b>time</b> monotonically decreases when {{the ratio of the}} underlying energy gap between native state and average non-native states versus the roughness or the fluctuations of the landscape increases. At intermediate temperatures, fluctuations measured by the higher moments of the <b>binding</b> <b>time</b> lead to non-Poissonian, non-exponential kinetics. At both high and very low temperatures, the kinetics is nearly Poissonian and exponential...|$|E
40|$|The {{views and}} {{conclusions}} contained {{in this document}} {{are those of the}} authors and should not be interpreted as representing the official policies, either expressed or implied, of the Defense Advanced Several developments in programming language design and software engineering lead to a reexamination of the role of binding times in programming language implementation. We can alleviate problems associated with these developments by using event-driven processing to determine translation binding times. Our ultimate goal is to clarify the effects of different designs on binding times and to reduce <b>binding</b> <b>time</b> concerns in the language design process. Determining the <b>binding</b> <b>time</b> of a translation action involves two concerns: the ordering of the action's execution relative to other actions and the translation phase in which the execution occurs (e. g. compiletime, link-time, or run-time). Some issues that affect these concerns include: how to handle forward references, language designs that require dynamic interpretation, the role of link-time in languages that allow separate compilation, and how to achieve elasticity. Elasticity occurs when similar translation actions may be executed at very different binding times, typically in different translation phases. In particular, the <b>binding</b> <b>time</b> of each translation action i...|$|E
40|$|AbstractAutoprojection, or self-applicable partial evaluation, {{has been}} {{implemented}} for first order functional languages {{for some years}} now. This paper describes an approach to treat a higher order subset of the Scheme language. The system has been implemented as an extension to the existing autoprojector Similix [6, 7] that treats a first order Scheme subset. To our knowledge, our system is the first fully automatic and implemented autoprojector for a higher order language. We describe a new automatic <b>binding</b> <b>time</b> analysis for higher order programs. The analysis requires no type information. It {{is based on a}} closure analysis [34], which for any application point finds the set of lambda abstractions that can possibly be applied at that point. The <b>binding</b> <b>time</b> analysis has the interesting property that no structured <b>binding</b> <b>time</b> values are needed. Since our language is higher order, interpreters written in a higher order style can be partially evaluated. To exemplify this, we present and partially evaluate four versions of an interpreter for a lambda calculus language: one written in direct style, one written in continuation passing style, one implementing call-by-name reduction, and one implementing call-by-need reduction. The three latter interpreters are heavily based on higher order functions. To our knowledge, {{this is the first time}} autoprojection has been used to generate compilers from so sophisticated interpreters. This paper is a modified and slightly extended version of [2]...|$|E
40|$|We {{present a}} model of how {{transcription}} factors scan DNA to find their specific binding sites. Following the classical work of Winter et al. (1981), our model assumes two modes of transcription factor dynamics. Adjacent moves, where the proteins make a single step movement to one side, or short walks where the transcription factors slide along the DNA several binding sites at a time. The {{purpose of this article}} is twofold. Firstly, we discuss how such a system can be efficiently modeled computationally. Secondly, we analyse how the mean first <b>binding</b> <b>times</b> of transcription factors to their specific time depends on key parameters of the system...|$|R
40|$|The leukemia-associated {{fusion protein}} MN 1 -TEL {{combines}} the transcription-activating domains of MN 1 with the DNA-binding {{domain of the}} transcriptional repressor TEL. Quantitative photobleaching experiments revealed that ~ 20 % of GFP-tagged MN 1 and TEL is transiently immobilised, likely due to indirect or direct DNA binding, since transcription inhibition abolished immobilisation. Interestingly, ~ 50 % of the MN 1 -TEL fusion protein was immobile with much longer <b>binding</b> <b>times</b> than unfused MN 1 and TEL. MN 1 -TEL immobilisation was not observed when the TEL DNA-binding domain was disrupted, suggesting that MN 1 -TEL stably occupies TEL recognition sequences, preventing binding of factors required for proper transcription regulation, which may contribute to leukemogenesis...|$|R
5000|$|Ius non scriptum is Latin for [...] "unwritten law". It {{contrasts}} with the ius scriptum ("written law") by way of their sources (e.g. a legislature, court judgments, or custom). The ius non scriptum was the body of common laws that arose from customary practice. It had become <b>binding</b> over <b>time.</b>|$|R
