250|535|Public
25|$|Although this {{definition}} {{is sufficient to}} describe what a <b>burst</b> <b>error</b> is, {{the majority of the}} tools developed for <b>burst</b> <b>error</b> correction rely on cyclic codes. This motivates our next definition.|$|E
25|$|C's Ware's EVE <b>Burst</b> <b>Error</b> (1995) {{allowed the}} player to switch between both protagonists {{at any time}} during the game. EVE <b>Burst</b> <b>Error</b> often {{requires}} the player to have both protagonists co-operate with each other at various points during the game, with choices in one scenario affecting the other.|$|E
25|$|Interleaving is used {{to convert}} {{convolutional}} codes from random error correctors to <b>burst</b> <b>error</b> correctors. The basic idea behind the use of interleaved codes is to jumble symbols at the receiver. This leads to randomization of bursts of received errors which are closely located and we can then apply the analysis for random channel. Thus, the main function performed by the interleaver at transmitter is to alter the input symbol sequence. At the receiver, the deinterleaver will alter the received sequence to get back the original unaltered sequence at the transmitter.|$|E
40|$|The paper {{presents}} {{lower and}} upper bounds {{on the number}} of parity-check digits required for a linear code that is capable of detecting repeated low-density <b>burst</b> <b>errors</b> of length $b$ (fixed) with weight w or less $(w leq b) $. A bound for codes which can correct and simultaneously detect such <b>burst</b> <b>errors</b> has also been derived. An illustration has been provided for the code detecting 2 -repeated <b>burst</b> <b>errors</b> of length 3 (fixed) with weight 2 or less over GF(2) ...|$|R
40|$|Abstract — Multimedia data {{transmission}} over wireless networks is challenging due lower bandwidth, delay composition, air interface and occurrence of <b>burst</b> <b>errors.</b> Packet loss caused by <b>burst</b> <b>errors</b> seriously limits the maximum achievable throughput of wireless networks. <b>Burst</b> <b>errors</b> {{are critical for}} Quality of Service (QoS) in terms of error detection, correction and retransmission of erroneous packets. Codecs {{for most of the}} multimedia traffic like voice, video transmissions are usually designed to conceal single <b>error</b> but not <b>burst</b> of packet <b>error.</b> To tailor efficient transmission schemes, it is essential to design a wireless error model and develop techniques that can provide insight into the behaviour of wireless transmissions...|$|R
3000|$|... {{will contain}} {{erroneous}} decisions, which will propagate through the DFE and will cause <b>burst</b> <b>errors.</b> If an interleaver {{is not used}} then the Log-MAP decoding algorithm {{will not be able}} to correct these long <b>burst</b> <b>errors.</b> However, when the correct decisions on the symbols are fed back in the iterative mode, the estimate [...]...|$|R
2500|$|Theorem (<b>Burst</b> <b>error</b> {{correction}} ability). The <b>burst</b> <b>error</b> correction {{ability of}} any [...] code satisfies ...|$|E
2500|$|Theorem. If the <b>burst</b> <b>error</b> {{correcting}} {{ability of}} some code is [...] then the <b>burst</b> <b>error</b> correcting ability of its -way interleave is ...|$|E
2500|$|Cyclic codes {{can detect}} all bursts of length up to [...] We will see {{later that the}} <b>burst</b> <b>error</b> {{detection}} ability of any [...] code is bounded from above by [...] Cyclic codes are considered optimal for <b>burst</b> <b>error</b> detection since they meet this upper bound: ...|$|E
5000|$|In {{an analog}} channel model, the {{transmitted}} message is modelled as an analog signal. The {{model can be}} a linear or non-linear, time-continuous or time-discrete (sampled), memoryless or dynamic (resulting in <b>burst</b> <b>errors),</b> time-invariant or time-variant (also resulting in <b>burst</b> <b>errors),</b> baseband, passband (RF signal model), real-valued or complex-valued signal model. The model may reflect the following channel impairments: ...|$|R
40|$|Abstract — An {{efficient}} error protection {{scheme is}} proposed for video delivery over lossy channels. Flexible Macroblock Ordering {{is used to}} generate spatial descriptions that are sent over disjoint paths. Additionally, descriptions are partitioned to allow unequal <b>error</b> protection against <b>burst</b> <b>errors.</b> Experimental results show that a significant quality gain can be achieved (up to 3 dB) {{in the presence of}} <b>burst</b> <b>errors.</b> I...|$|R
2500|$|Many codes {{have been}} {{designed}} to correct random errors. [...] Sometimes, however, channels may introduce errors which are localized in a short interval. Such errors occur in a <b>burst</b> (called <b>burst</b> <b>errors)</b> because they occur in many consecutive bits. Examples of <b>burst</b> <b>errors</b> can be found extensively in storage mediums. These errors may be due to physical damage such as scratch on a disc or a stroke of lightning in case of wireless channels. They are not independent; they tend to be spatially concentrated. If one bit has an error, {{it is likely that the}} adjacent bits could also be corrupted. The methods used to correct random errors are inefficient to correct <b>burst</b> <b>errors.</b>|$|R
2500|$|This contradicts [...] Thus, the <b>burst</b> <b>error</b> {{descriptions}} are identical.|$|E
2500|$|Theorem (Rieger bound). If [...] is the <b>burst</b> <b>error</b> {{correcting}} {{ability of}} an [...] linear block code, then [...]|$|E
2500|$|Theorem (<b>Burst</b> <b>error</b> {{codeword}} classification). Let [...] be {{a linear}} -burst-error-correcting code. Then no nonzero burst of length [...] {{can be a}} codeword.|$|E
50|$|Reed-Solomon {{codes are}} {{specifically}} useful in combating mixtures of random and <b>burst</b> <b>errors.</b> CIRC corrects <b>error</b> <b>bursts</b> up to 3,500 bits in sequence (2.4 mm in length as seen on CD surface) and compensates for <b>error</b> <b>bursts</b> up to 12,000 bits (8.5 mm) {{that may be}} caused by minor scratches.|$|R
50|$|Reed-Solomon coding is very {{widely used}} in mass storage systems to correctthe <b>burst</b> <b>errors</b> {{associated}} with media defects.|$|R
30|$|Nature of the error: If the {{prediction}} algorithm mispredicts occupancy for short time intervals (say {{for a minute}} or so), we term {{the prediction}} errors as point errors, otherwise we call them <b>burst</b> <b>errors.</b> For a particular error percentage, an erroneous occupancy string can have point <b>errors,</b> <b>burst</b> <b>errors,</b> or a mix of both; resulting in different values of energy consumption and occupants’ discomfort for the same error percentage.|$|R
2500|$|While cyclic {{codes in}} general are {{powerful}} tools for detecting burst errors, we now consider a family of binary cyclic codes named Fire Codes, which possess good single <b>burst</b> <b>error</b> correction capabilities. By single burst, say of length , we mean that all errors that a received codeword possess lie within a fixed span of [...] digits.|$|E
2500|$|Certain {{families}} of codes, such as Reed–Solomon, operate on alphabet sizes larger than binary. This property awards such codes powerful <b>burst</b> <b>error</b> correction capabilities. Consider a code operating on [...] Each {{symbol of the}} alphabet can be represented by [...] bits. If [...] is an [...] Reed–Solomon code over , {{we can think of}} [...] as an [...] code over [...]|$|E
2500|$|An error vector [...] {{is called}} a cyclic <b>burst</b> <b>error</b> of length [...] if its nonzero {{components}} are confined to [...] cyclically consecutive components. For example, the previously considered error vector , is a cyclic burst of length , since we consider the error starting at position [...] and ending at position [...] Notice the indices are -based, that is, the first element is at position [...]|$|E
40|$|In this paper, a {{new class}} of error-correcting linear block codes using symbols from GF(2 m) is presented. These codes are not cyclic codes, but posses instead a unique {{algebraic}} structure. It is shown that they are instantaneously decodable with a modest amount of hardware consisting almost entirely of mod 2 adders for correcting <b>burst</b> <b>errors.</b> Furthermore, their efficiency compares favorably with the Varsharmov-Gilbert bound for both random errors over GF(2 m) and <b>burst</b> <b>errors</b> over GF(2) ...|$|R
2500|$|All <b>burst</b> <b>errors</b> {{of length}} [...] will be {{detected}} by any polynomial of degree [...] or greater {{which has a}} non-zero [...] term.|$|R
30|$|Interleavers {{allow for}} the {{temporal}} separation of adjacent coded symbols during transmission, so that when <b>burst</b> <b>errors</b> occur {{in response to a}} loss of signal power during fading, the resulting errors in an <b>error</b> <b>burst</b> will be distributed throughout the data block after deinterleaving. This leads to performance gains in the receiver, as the equalizer and the decoder are able to infer information and correct single errors more accurately, as opposed to correcting consecutive, or <b>burst</b> <b>errors.</b> Therefore, interleavers are employed in a wireless communication system where the transmitted signal is subject to multipath and fading [2].|$|R
2500|$|For example, {{the burst}} {{description}} of the error pattern [...] is [...] Notice that such description is not unique, because [...] describes the same <b>burst</b> <b>error.</b> In general, {{if the number of}} nonzero components in [...] is , then [...] will have [...] different burst descriptions each starting at a different nonzero entry of [...] To remedy the issues that arise by the ambiguity of burst descriptions with the theorem below, however before doing so we need a definition first.|$|E
2500|$|The reason such {{codes are}} {{powerful}} for <b>burst</b> <b>error</b> correction {{is that each}} symbol is represented by [...] bits, and in general, it is irrelevant {{how many of those}} [...] bits are erroneous; whether a single bit, or all of the [...] bits contain errors, from a decoding perspective it is still a single symbol error. In other words, since burst errors tend to occur in clusters, there is a strong possibility of several binary errors contributing to a single symbol error.|$|E
2500|$|It {{is often}} useful {{to have a}} compact {{definition}} of a <b>burst</b> <b>error,</b> that encompasses not only its length, but also the pattern, and location of such error. [...] We define a burst description to be a tuple [...] where [...] is {{the pattern of the}} error (that is the string of symbols beginning with the first nonzero entry in the error pattern, and ending with the last nonzero symbol), and [...] is the location, on the codeword, where the burst can be found.|$|E
50|$|Viterbi decoders tend {{to produce}} <b>errors</b> in short <b>bursts.</b> Correcting these <b>burst</b> <b>errors</b> {{is a job}} best done by short or {{simplified}} Reed-Solomon codes.|$|R
2500|$|Theorem (Distinct Cosets). A {{linear code}} [...] is an -burst-error-correcting code {{if all the}} <b>burst</b> <b>errors</b> of length [...] lie in {{distinct}} cosets of [...]|$|R
25|$|The {{process is}} subject to both <b>burst</b> <b>errors</b> and random <b>errors.</b> <b>Burst</b> <b>errors</b> include those due to disc {{material}} (defects of aluminum reflecting film, poor reflective index of transparent disc material), disc production (faults during disc forming and disc cutting etc.), disc handling (scratches – generally thin, radial and orthogonal to direction of recording) and variations in play-back mechanism. Random errors include those due to jitter of reconstructed signal wave and interference in signal. CIRC (Cross-Interleaved Reed–Solomon code) {{is the basis for}} error detection and correction in the CD process. It corrects <b>error</b> <b>bursts</b> up to 3,500 bits in sequence (2.4nbsp&mm in length as seen on CD surface) and compensates for <b>error</b> <b>bursts</b> up to 12,000 bits (8.5nbsp&mm) that may be caused by minor scratches.|$|R
2500|$|By {{the upper}} bound on <b>burst</b> <b>error</b> {{detection}} (...) , we know that a cyclic code can not detect all bursts of length [...] However cyclic codes can indeed detect most bursts of length [...] The reason is that detection fails only when the burst is divisible by [...] Over binary alphabets, there exist [...] bursts of length [...] Out of those, only [...] are divisible by [...] Therefore, the detection failure probability is very small (...) assuming a uniform distribution over all bursts of length [...]|$|E
2500|$|The above proof {{suggests}} a simple algorithm for <b>burst</b> <b>error</b> detection/correction in cyclic codes: given a transmitted word (i.e. a polynomial of degree [...] ), compute {{the remainder of}} this word when divided by [...] If the remainder is zero (i.e. if the word is divisible by [...] ), then it is a valid codeword. Otherwise, report an error. To correct this error, subtract this remainder from the transmitted word. The subtraction result is going to be divisible by [...] (i.e. {{it is going to be}} a valid codeword).|$|E
2500|$|With {{the theory}} {{presented}} in the above section, let us consider {{the construction of a}} [...] -burst error correcting Fire Code. Remember that to construct a Fire Code, we need an irreducible polynomial [...] , an integer [...] , representing the <b>burst</b> <b>error</b> correction capability of our code, and we need to satisfy the property that [...] is not divisible by the period of [...] With these requirements in mind, consider the irreducible polynomial [...] , and let [...] Since [...] is a primitive polynomial, its period is [...] We confirm that [...] is not divisible by [...] Thus, ...|$|E
25|$|Without error {{correcting}} codes, {{digital audio}} {{would not be}} technically feasible. The Reed–Solomon codes can correct a corrupted symbol with a single bit error just as easily as it can correct a symbol with all bits wrong. This makes the RS codes particularly suitable for correcting <b>burst</b> <b>errors.</b> By far, the most common application of RS codes is in compact discs. In addition to basic error correction provided by RS codes, protection against <b>burst</b> <b>errors</b> due to scratches on the disc is provided by a cross interleaver.|$|R
3000|$|The {{second type}} are <b>burst</b> <b>errors</b> or sensor malfunctions. We model them by {{choosing}} a burst length τ and a burst start t, {{according to a}} distribution ν [...]...|$|R
40|$|Resynchronizing variable-length codes (RVLCs) {{for large}} alphabets are {{designed}} by first creating resynchronizing Huffman codes and then adding an extended synchronizing codeword, and the RVLCs {{are applied to}} both JPEG and wavelet-based image compression. The RVLCs demonstrate the desired resynchronization properties, both at a symbol level and structurally so that decoded data can be correctly placed within an image following errors. The encoded images, when subject to both structural and statistical error detection and concealment, can tolerate BERs of up to and are very tolerant of <b>burst</b> <b>errors.</b> The RVLC-JPEG images have negligible overhead at visually lossless bit rates, while the RVLC-wavelet overhead can be adjusted based on the desired tolerance to <b>burst</b> <b>errors</b> and typically ranges from 7 - 18 %. The tolerance to both bit and <b>burst</b> <b>errors</b> demonstrates that images coded with such RVLCs can be transmitted over imperfect channels suffering bit errors or packet losses without channel co [...] ...|$|R
