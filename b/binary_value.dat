232|746|Public
5|$|Rule 90 is an {{elementary}} cellular automaton. That {{means that it}} consists of a one-dimensional array of cells, each of which holds a single <b>binary</b> <b>value,</b> either 0 or 1. An assignment of values {{to all of the}} cells is called a configuration. The automaton is given an initial configuration, and then progresses through other configurations in a sequence of discrete time steps. At each step, all cells are updated simultaneously. A pre-specified rule determines the new value of each cell as a function of its previous value and of the values in its two neighboring cells. All cells obey the same rule, which may be given either as a formula or as a rule table that specifies the new value for each possible combination of neighboring values.|$|E
25|$|To convert from a base-10 integer to its base-2 (binary) equivalent, {{the number}} is divided by two. The {{remainder}} is the least-significant bit. The quotient is again divided by two; its remainder becomes the next least significant bit. This process repeats until a quotient of one is reached. The sequence of remainders (including the final quotient of one) forms the <b>binary</b> <b>value,</b> as each remainder must be either zero or one when dividing by two. For example, (357)10 is expressed as (101100101)2.|$|E
25|$|We {{can assume}} that as we write text left to right, we are {{increasing}} the 'address' on paper, as a processor would write bytes with increasing memory addresses − as in the adjacent table. On paper, the hex value 0a0b0c0d (written 168496141 in usual decimal notation) is big-endian style since we write the most significant digit first and the rest follow in decreasing significance. Mapping this number as a <b>binary</b> <b>value</b> to a sequence of 4 bytes in memory in big-endian style also writes the bytes {{from left to right}} in decreasing significance: 0Ah at +0, 0Bh at +1, 0Ch at +2, 0Dh at +3.|$|E
3000|$|... on and P_i,j^k {{display the}} same {{performances}} like the active UEs’ existences with their on–off <b>binary</b> <b>values.</b> Thus, {{it is clear}} that the <b>binary</b> <b>values</b> of τ, P_i,j^k are of the same distribution performances just like UEs. □ [...]...|$|R
5000|$|... #Subtitle level 2: Mapping multi-byte <b>binary</b> <b>values</b> {{to memory}} ...|$|R
50|$|Many {{variants}} of BCD encode the characters '0' through '9' as the corresponding <b>binary</b> <b>values.</b>|$|R
25|$|The 80-bit {{floating}} point format has a range (including subnormals) from approximately 3.65104951 to 1.18104932. Although log10(264)≅19.266, this format is usually described as giving approximately eighteen significant digits of precision. The use of decimal {{when talking about}} binary is unfortunate because most decimal fractions are recurring sequences in binary just as 2/3 is in decimal. Thus, a value such as 10.15 is represented in binary as equivalent to 10.1499996185 etc. in decimal for REAL*4 but 10.15000000000000035527etc. in REAL*8: interconversion will involve approximation except for those few decimal fractions that represent an exact <b>binary</b> <b>value,</b> such as 0.625. For REAL*10, the decimal string is 10.1499999999999999996530553etc. The last 9 digit is the eighteenth fractional digit and thus the twentieth significant digit of the string. Bounds on conversion between decimal and binary for the 80-bit format can be given as follows: if a decimal string with at most 18 significant digits is correctly rounded to an 80-bit IEEE 754 binary {{floating point}} value (as on input) then converted {{back to the same}} number of significant decimal digits (as for output), then the final string will exactly match the original; while, conversely, if an 80-bit IEEE 754 binary floating point value is correctly converted and (nearest) rounded to a decimal string with at least 21 significant decimal digits then converted back to binary format it will exactly match the original. These approximations are particularly troublesome when specifying the best value for constants in formulae to high precision, as might be calculated via arbitrary precision arithmetic.|$|E
500|$|A {{state of}} the Rule 184 {{automaton}} consists of a one-dimensional array of cells, each containing a <b>binary</b> <b>value</b> (0 or 1). In each step of its evolution, the Rule 184 automaton applies the following rule {{to each of the}} cells in the array, simultaneously for all cells, to determine the new {{state of the}} cell: ...|$|E
500|$|In dynamic RAM (DRAM), each bit of {{stored data}} {{occupies}} a separate memory cell that is electrically implemented with one capacitor and one transistor. [...] The charge state of a capacitor (charged or discharged) is what determines whether a DRAM cell stores [...] "1" [...] or [...] "0" [...] as a <b>binary</b> <b>value.</b> [...] Huge numbers of DRAM memory cells are packed into integrated circuits, together with some additional logic that organizes the cells {{for the purposes}} of reading, writing and refreshing the data.|$|E
50|$|If using <b>binary</b> <b>values</b> {{for true}} (1) and false (0), then {{exclusive}} or works exactly like addition modulo 2.|$|R
50|$|If using <b>binary</b> <b>values</b> {{for true}} (1) and false (0), then logical {{conjunction}} works exactly like normal arithmetic multiplication.|$|R
3000|$|Segregate the {{resultant}} <b>binary</b> <b>values</b> {{into two groups}} each with four bits. Interchange {{the position of the}} two groups [...]...|$|R
500|$|In {{the case}} of automata with binary-valued states (zero or one), {{there are only two}} {{possible}} permutations on the states (the identity permutation and the permutation that swaps the two states), which may themselves be represented as the exclusive or of a state with a <b>binary</b> <b>value.</b> In this way, any conventional two-valued cellular automaton may be converted to a second-order cellular automaton rule by using the conventional automaton's transition function on the states at time , and then computing the exclusive or of these states with the states at time [...] to determine the states at time [...] However, the behavior of the reversible cellular automaton determined in this way may not bear any resemblance to the behavior of the cellular automaton from which it was defined.|$|E
500|$|The {{simplest}} possible cellular automata have a one-dimensional {{array of}} cells, {{each of which}} can hold a <b>binary</b> <b>value</b> (either 0 or 1), with each cell having a neighborhood consisting only of it and its two nearest cells on either side; these are called the elementary cellular automata. [...] If the update rule for such an automaton causes each cell to always remain in the same state, then the automaton is reversible: the previous state of all cells can be recovered from their current states, because for each cell the previous and current states are the same. Similarly, if the update rule causes every cell to change its state from 0 to 1 and vice versa, or if it causes a cell to copy the state from a fixed neighboring cell, or if it causes it to copy a state and then reverse its value, it is necessarily reversible. [...] call these types of reversible cellular automata, {{in which the state}} of each cell depends only on the previous state of one neighboring cell, [...] "trivial". Despite its simplicity, the update rule that causes each cell to copy the state of a neighboring cell is important in the theory of symbolic dynamics, where it is known as the shift map.|$|E
2500|$|... 100101 (= 37) and the {{remainder}} is the <b>binary</b> <b>value</b> of any counters ...|$|E
50|$|MAPPER's data {{is stored}} as a {{character}} representation, rather than, say, <b>binary</b> <b>values.</b> Even numeric fields are stored as text.|$|R
2500|$|Tabulation hashing {{in greater}} generality, for {{arbitrary}} <b>binary</b> <b>values,</b> was later rediscovered by [...] and studied {{in more detail}} by [...]|$|R
5000|$|Several languages, {{including}} Java, C#, Scala, Python, Ruby, and OCaml, {{can represent}} <b>binary</b> <b>values</b> by prefixing a number with 0B or 0b.|$|R
2500|$|Given {{a set of}} all {{possible}} -bit values, we can assign the lower (by the <b>binary</b> <b>value)</b> half to be the integers from 0 to [...] inclusive and the upper half to be [...] to −1 inclusive. [...] The upper half (again, by the <b>binary</b> <b>value)</b> {{can be used to}} represent negative integers from [...] to −1 because, under addition modulo [...] they behave the same way as those negative integers. [...] That is to say that because [...] any value in the set [...] can be used in place of.|$|E
2500|$|On a little-endian system, the bytes {{are written}} {{from left to}} right in {{increasing}} significance, starting with the one's byte: 0Dh at +0, 0Ch at +1, 0Bh at +2, 0Ah at +3. Writing a 32-bit <b>binary</b> <b>value</b> to a memory location on a little-endian system and outputting the memory location (with growing addresses {{from left to right}}) shows that the order is reversed (byte-swapped) compared to usual big-endian notation. This is the way a hexdump is displayed: because the dumping program is unable to know what kind of data it is dumping, the only orientation it can observe is monotonically increasing addresses. The human reader, however, who knows {{that he or she is}} reading a hexdump of a little-endian system and who knows what kind of data he or she is reading, reads the byte sequence 0Dh,0Ch,0Bh,0Ah as the 32-bit <b>binary</b> <b>value</b> 168496141, or 0x0a0b0c0d in hexadecimal notation. (Of course, this is not the same as the number 0D0C0B0Ah = 0x0d0c0b0a = 218893066.) ...|$|E
5000|$|... 2) Generate the {{corresponding}} <b>binary</b> <b>value</b> of it (<b>binary</b> <b>value</b> should be 8 digits e.g. for decimal 32 binary number should be 00100000) ...|$|E
50|$|Hexadecimal to octal {{conversion}} proceeds {{by first}} converting the hexadecimal digits to 4-bit <b>binary</b> <b>values,</b> then regrouping the binary bits into 3-bit octal digits.|$|R
5000|$|<b>Binary</b> <b>values</b> {{are stored}} in big endian format, e.g. the value 1 is X'0001' for a 16-bit value, and X'00000001' for a 32-bit value.|$|R
40|$|We have {{developed}} a simple optimization procedure for assigning <b>binary</b> <b>values</b> to amino acids. The <b>binary</b> <b>values</b> are determined by a maximization {{of the degree of}} pattern conservation in groups of closely related protein sequences. The maximization is carried out at fixed composition. For compositions approximately corresponding to an equipartition of the residues, the optimal encoding is found to be strongly correlated with hydrophobicity. The stability of the procedure is demonstrated. Our calculations are based upon sequences in the SWISS-PROT database...|$|R
50|$|The prefix {{holds the}} <b>binary</b> <b>value</b> 11111111 for any {{multicast}} address.|$|E
5000|$|... #Caption: Decomposition of the quad-dotted IPv4 address {{representation}} to its <b>binary</b> <b>value</b> ...|$|E
5000|$|... #Caption: Decomposition of an IPv4 address from dot-decimal {{notation}} to its <b>binary</b> <b>value.</b>|$|E
5000|$|Data {{acquisition}} using {{signal processing}} theory (sampling and quantizing) for assigning <b>binary</b> <b>values</b> from continuous analog or other digital sources to the discrete cell partitions; ...|$|R
5000|$|... {{where each}} {{position}} in the string may {{take one of the}} two <b>binary</b> <b>values</b> [...] The action of the shift operator on this string is ...|$|R
5000|$|... #Caption: A binary clock {{might use}} LEDs to express <b>binary</b> <b>values.</b> In this clock, each column of LEDs shows a binary-coded decimal numeral of the {{traditional}} sexagesimal time.|$|R
5000|$|... #Caption: Decomposition of an IPv6 address from {{hexadecimal}} representation to its <b>binary</b> <b>value.</b>|$|E
5000|$|... 16-bit sub-prefix: {{generated}} by interpreting the sub-prefix as a <b>binary</b> <b>value,</b> e.g. B’0001010001111000’ ...|$|E
5000|$|The {{original}} <b>binary</b> <b>value</b> will {{be preserved}} by converting to decimal {{and back again}} using: ...|$|E
40|$|We {{develop a}} simple {{optimization}} procedure for assigning <b>binary</b> <b>values</b> to the amino acids. The <b>binary</b> <b>values</b> {{are determined by}} a maximization {{of the degree of}} pattern conservation in groups of closely related protein sequences. The maximization is carried out at fixed composition. For compositions approximately corresponding to an equipartition of the residues, the optimal encoding is found to be strongly correlated with hydrophobicity. The stability of the procedure is demonstrated. Our calculations are based upon sequences in the SWISS-PROT database. Comment: 9 pages, 4 Postscript figures. References and figure adde...|$|R
5000|$|In {{the above}} quote, the encoded value of Man is TWFu. Encoded in ASCII, the {{characters}} M, a, and n are stored as the bytes , , and , {{which are the}} 8-bit <b>binary</b> <b>values</b> , , and [...] These three values are joined together into a 24-bit string, producing [...] Groups of 6 bits (6 bits have a maximum of 26 = 64 different <b>binary</b> <b>values)</b> are converted into individual numbers {{from left to right}} (in this case, there are four numbers in a 24-bit string), which are then converted into their corresponding Base64 character values.|$|R
30|$|In {{this stage}} the {{software}} separates value sequences of down-hole parameters and converts the data {{back to their}} original <b>binary</b> <b>values,</b> from which the real physical values can be easily acquired.|$|R
