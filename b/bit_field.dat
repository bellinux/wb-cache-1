59|147|Public
25|$|This is an 8 <b>bit</b> <b>field</b> of flags, which {{indicates}} the type of page that follows.|$|E
25|$|Chunk {{types are}} given a four-letter case {{sensitive}} ASCII type/name; compare FourCC. The case of the different letters in the name (bit 5 of the numeric value of the character) is a <b>bit</b> <b>field</b> that provides the decoder with some information {{on the nature of}} chunks it does not recognize.|$|E
500|$|... {{showed that}} in some cases the multiplications or table lookups {{required}} by some integer sorting algorithms could be replaced by customized operations that would be more easily implemented in hardware but that are not typically available on general-purpose computers. [...] improved on this by showing how to replace these special operations by the <b>bit</b> <b>field</b> manipulation instructions already available on Pentium processors.|$|E
50|$|The {{members of}} <b>bit</b> <b>fields</b> {{do not have}} addresses, and as such cannot be used with the address-of (&) unary {{operator}}. The sizeof operator may not be applied to <b>bit</b> <b>fields.</b>|$|R
5000|$|A multi-tagged frame {{not only}} has {{multiple}} VLAN IDs, but has multiple VLAN header <b>bit</b> <b>fields.</b>|$|R
5000|$|Register map description, which {{describes}} various device registers and <b>bit</b> <b>fields</b> from the device data sheet.|$|R
2500|$|The color type is {{specified}} as an 8-bit value however {{only the}} low 3 bits are used and, even then, only the five combinations listed above are permitted. [...] So {{long as the}} color type is valid it {{can be considered as}} a <b>bit</b> <b>field</b> as summarized in the adjacent table: ...|$|E
50|$|C also {{provides}} a special type of structure member known as a <b>bit</b> <b>field,</b> which is an integer with an explicitly specified number of bits. A <b>bit</b> <b>field</b> is declared as a structure member of type int, signed int, unsigned int, or _Bool, following the member name by a colon (:) {{and the number of}} bits it should occupy. The total number of bits in a single <b>bit</b> <b>field</b> must not exceed the total number of bits in its declared type.|$|E
50|$|The {{meaning of}} the {{individual}} bits within the field {{is determined by the}} programmer; for example, the first bit in a <b>bit</b> <b>field</b> (located at the field's base address) is sometimes used to determine the state of a particular attribute associated with the <b>bit</b> <b>field.</b>|$|E
50|$|<b>Bit</b> <b>fields</b> are {{not allowed}} in a union. It is {{applicable}} only for the classes defined using the keyword struct or class.|$|R
5000|$|Header Data (32 <b>bits)</b> <b>field,</b> {{which in}} this case (ICMP echo request and replies), will be {{composed}} of identifier (16 bits) and sequence number (16 bits).|$|R
50|$|In {{vertical}} microcode, each microinstruction {{is significantly}} encoded that is, the <b>bit</b> <b>fields</b> generally pass through intermediate combinatory logic that, in turn, generates the actual control and sequencing signals for internal CPU elements (ALU, registers, etc.). This {{is in contrast}} with horizontal microcode, in which the <b>bit</b> <b>fields</b> themselves either directly produce the control and sequencing signals or are only minimally encoded. Consequently, vertical microcode requires smaller instruction lengths and less storage, but requires more time to decode, resulting in a slower CPU clock.|$|R
50|$|A <b>bit</b> <b>field</b> is a data {{structure}} used in computer programming. It {{consists of a}} number of adjacent computer memory locations which have been allocated to hold a sequence of bits, stored so that any single bit or group of bits within the set can be addressed. A <b>bit</b> <b>field</b> is most commonly used to represent integral types of known, fixed bit-width.|$|E
50|$|A mask is {{data that}} is used for bitwise operations, {{particularly}} in a <b>bit</b> <b>field.</b>|$|E
50|$|This is an 8 <b>bit</b> <b>field</b> of flags, which {{indicates}} the type of page that follows.|$|E
40|$|We {{describe}} {{low power}} instruction encoding techniques for low-power instruction fetches. Instruction fields of a binary program are re-encoded {{so that the}} number of bits switched from the neighboring fields of consecutive instructions is minimized. The low-power encoding techniques are applied into the opcode, register <b>fields,</b> and unused <b>bit</b> <b>fields</b> of an instruction format. Experimental results based on software simulations show that the switching activity is reduced up to 62. 1 %, 14. 8 %, and 4. 2 % in the opcode, register <b>fields,</b> and unused <b>bit</b> <b>fields,</b> respectively, over that of original binary program...|$|R
5000|$|... an {{enumeration}} type and a “flags” type, both corresponding to C’s [...] type, but differing {{in that the}} latter is only used for <b>bit</b> <b>fields</b> ( [...] and [...] ); ...|$|R
5000|$|The {{overload}} frame {{contains the}} two <b>bit</b> <b>fields</b> Overload Flag and Overload Delimiter. There {{are two kinds}} of overload conditions that can lead to the transmission of an overload flag: ...|$|R
50|$|APS can be also {{signaled}} digitally, in the CGMS-A <b>bit</b> <b>field</b> sent in {{the vertical}} blanking interval.|$|E
50|$|Bit (boolean value), <b>bit</b> <b>field</b> (group {{of up to}} 32 bits) and {{bit string}} (up to 4Gb in length).|$|E
5000|$|A 3 <b>bit</b> <b>field</b> {{which says}} if the {{datagram}} {{is a part}} of a fragmented data frame or not.|$|E
50|$|This {{scheme is}} {{designed}} {{in order to}} densely encode the common cases found in many programming patterns: access to small stack frames, a small set of globals and constants, structures, and arrays. Access to <b>bit</b> <b>fields</b> that have an odd length is facilitated by means of sign and zero extend instructions.|$|R
50|$|As {{an example}} of a deletion, as of version 10.23 Dynamic C does not support block scope {{variables}} or <b>bit</b> <b>fields.</b> The development toolchain does not include a separate preprocessor and linker, which may complicate the process of porting existing programs to the compiler. As of version 10.64 block scope for variables is supported.|$|R
50|$|McGonigle’s juggling act seen in {{the film}} affords a rare {{opportunity}} to observe Fields's own juggling talent - his famous vaudeville specialty - as he juggles airborne balls and cigar boxes. In this <b>bit,</b> <b>Fields</b> looks relatively fit and slim, in contrast to the plumper look that became part of his trademark in later years.|$|R
5000|$|Larger {{multiply}} (32×32 -> 64 bits) {{and divide}} (64÷32 -> 32 bits quotient and 32 bits remainder) instructions, and <b>bit</b> <b>field</b> manipulations ...|$|E
5000|$|Full bit-vector: A <b>bit</b> <b>field</b> {{for each}} {{processor}} at the directory node are maintained. The storage overhead scales {{with the number}} of processors.|$|E
5000|$|The [...] {{field is}} a <b>bit</b> <b>field.</b> It {{combines}} the file access modes and also indicates any special file type. There are many macros {{to work with}} the different mode flags and file types.|$|E
50|$|Some smaller {{instruction}} classes {{include the}} shift/rotate instructions and the procedure call instructions. Particularly notable are the stack instructions PUSH and POP, {{and the corresponding}} stack call instructions PUSHJ and POPJ. The byte instructions use a special format of indirect word to extract and store arbitrary-sized <b>bit</b> <b>fields,</b> possibly advancing a pointer to the next unit.|$|R
2500|$|The first byte is a <b>bit</b> encoded <b>field</b> {{indicating}} which EGT sensors are supported: ...|$|R
40|$|A 64 -bit {{processor}} must necessarily implement substantial parallelism in {{the movement}} and processing of data. Data movement is inherently parallel at the bit level, and many operations implemented in the integer unit exhibit bit-level parallelism. A microvector is an array of small data items or <b>bit</b> <b>fields</b> packed into a single word. Scalar operations performed on a microvector {{can be used to}} implement vector parallelism on its constituent fields. In this paper we present libuvec, a library for computing with data which is packed into <b>bit</b> <b>fields.</b> We present experimental results showing excellent performance, up to 30 times the speed of scalar arithmetic in certain applications. 1 Introduction The current generation of microprocessor architectures all have a word length of 64 bits, meaning that both instruction and data are processed 64 bits at a time: DEC Alpha, IBM/Motorola/Apple Power PC, and Intel Pentium. The increase in word length has accompanied an increase in the complexity of [...] ...|$|R
5000|$|For some {{computer}} applications, binary formats were used, {{where each}} hole represented a single binary digit (or [...] "bit"), every column (or row) {{is treated as}} a simple <b>bit</b> <b>field,</b> and every combination of holes is permitted.|$|E
5000|$|The [...] {{operator}} {{can be used}} to set bits in a <b>bit</b> <b>field</b> to 1, by -ing {{the field}} with a constant field with the relevant bits set to 1. For example, [...] will force the final bit to 1 while leaving other bits unchanged.|$|E
50|$|As {{a special}} {{exception}} to the usual C syntax rules, it is implementation-defined whether a <b>bit</b> <b>field</b> declared as type int, without specifying signed or unsigned, is signed or unsigned. Thus, it is recommended to explicitly specify signed or unsigned on all structure members for portability.|$|E
50|$|A <b>field</b> <b>bit,</b> which denotes {{whether the}} command sent {{is in the}} lower field (logic 1 = 0 to 63 decimal) or the upper field (logic 0 = 64 to 127 decimal). The <b>field</b> <b>bit</b> was added later by Philips when it was {{realized}} that 64 commands per device were insufficient. Previously, the <b>field</b> <b>bit</b> was combined with the start bit. Many devices still use this original system.|$|R
50|$|<b>Bits</b> within <b>fields</b> are {{numbered}} from bit 0 as the least-significant bit; each field is transmitted {{most significant bit}} first.|$|R
5000|$|The PDP-10 {{architecture}} is {{almost identical to}} the earlier PDP-6 architecture, sharing the same 36-bit word length and slightly extending the instruction set (but with improved hardware implementation). Some aspects of the instruction set are unusual, most notably the [...] "byte" [...] instructions, which operated on <b>bit</b> <b>fields</b> of any size from 1 to 36 bits inclusive according to the general definition of a byte as a contiguous sequence of a fixed number of bits.|$|R
