40|9|Public
5|$|Another {{method of}} {{constructing}} hash functions with both high quality and practical speed is tabulation hashing. In this method, the hash value for a key {{is computed by}} using each byte of the key as an index into a table of random numbers (with a different table for each byte position). The numbers from those table cells are then combined by a <b>bitwise</b> <b>exclusive</b> or operation. Hash functions constructed this way are only 3-independent. Nevertheless, linear probing using these hash functions takes constant expected time per operation. Both tabulation hashing and standard methods for generating 5-independent hash functions are limited to keys that have a fixed number of bits. To handle strings or other types of variable-length keys, {{it is possible to}} compose a simpler universal hashing technique that maps the keys to intermediate values and a higher quality (5-independent or tabulation) hash function that maps the intermediate values to hash table indices.|$|E
25|$|However, {{the values}} from this table may be {{combined}} by a more complicated function than <b>bitwise</b> <b>exclusive</b> or.|$|E
25|$|The first {{instance}} of tabulation hashing is Zobrist hashing, {{a method for}} hashing positions in abstract board games such as chess named after Albert Lindsey Zobrist, who published it in 1970. In this method, a random bitstring is generated for each game feature such as {{a combination of a}} chess piece and a square of the chessboard. Then, to hash any game position, the bitstrings for the features of that position are combined by a <b>bitwise</b> <b>exclusive</b> or. The resulting hash value can then be used as an index into a transposition table. Because each move typically changes {{only a small number of}} game features, the Zobrist value of the position after a move can be updated quickly from the value of the position before the move, without needing to loop over all of the features of the position.|$|E
5000|$|<b>Bitwise</b> XOR (<b>exclusive</b> OR) (denoted {{with a blue}} circled plus [...] ).|$|R
5000|$|Cover-coding is a {{technique}} for obscuring the data that is transmitted over an insecure link, to reduce the risks of snooping. An example of cover-coding {{would be for the}} sender to perform a <b>bitwise</b> XOR (<b>exclusive</b> OR) of the original data with a password or random number which is known to both sender and receiver. The resulting cover-coded data is then transmitted from sender to the receiver, who uncovers the original data by performing a further <b>bitwise</b> XOR (<b>exclusive</b> OR) operation on the received data using the same password or random number.|$|R
5000|$|The <b>bitwise</b> XOR (<b>exclusive</b> or) {{performs}} a logical XOR function, which {{is equivalent to}} adding two bits and discarding the carry. The result is zero only when we have two zeroes or two ones. [...] XOR {{can be used to}} toggle the bits between 1 and 0. Thus i = i ^ 1 when used in a loop toggles its values between 1 and 0.|$|R
2500|$|Encode {{the secret}} as an {{arbitrary}} length binary number s. Give to each player i (except one) a random number pi {{with the same}} length as s. Give to the last player the result of (s XOR p1 XOR p2 XOR ... XOR p'n−1) where XOR is <b>bitwise</b> <b>exclusive</b> or. The secret is the bitwise XOR of all the players' numbers (p).|$|E
2500|$|There are {{arithmetic}} {{operations on}} ordinals {{by virtue of}} the one-to-one correspondence between ordinals and nimbers. [...] Three common operations on nimbers are nimber addition, nimber multiplication, and minimum excludance (mex). [...] Nimber addition is a generalization of the <b>bitwise</b> <b>exclusive</b> or operation on natural numbers. [...] The [...] of a set of ordinals is the smallest ordinal not present in the set.|$|E
2500|$|For as many {{iterations}} as are needed, the PRGA modifies {{the state}} and outputs a byte of the keystream. [...] In each iteration, the PRGA increments , looks up the th element of , , and adds that to , exchanges the values of [...] and , and then uses the sum [...] as an index to fetch a third element of , (the keystream value [...] below) which is <b>bitwise</b> <b>exclusive</b> OR'ed (XOR'ed) with the next byte of the message to produce the next byte of either ciphertext or plaintext. [...] Each element of S is swapped with another element at least once every 256 iterations.|$|E
25|$|The {{key idea}} of {{tabulation}} hashing is {{to view a}} key as a vector of t r-bit numbers, use a lookup table filled with random values to compute a hash value {{for each of the}} r-bit numbers representing a given key, and combine these values with the <b>bitwise</b> binary <b>exclusive</b> or operation. The choice of r should be made {{in such a way that}} this table is not too large; e.g., so that it fits into the computer's cache memory.|$|R
5000|$|... == Structure == Internally, the cipher uses <b>bitwise</b> {{addition}} ⊕ (<b>exclusive</b> OR), 32-bit addition mod 232 ⊞, and constant-distance rotation operations (<<<) on {{an internal}} state of sixteen 32-bit words. Using only add-rotate-xor operations avoids {{the possibility of}} timing attacks in software implementations. The basic Salsa20 round primitive [...] is b ⊕= (a ⊞ c) <<< k; ...|$|R
50|$|Let p {{denote the}} number of bits in a key to be hashed, and q denote {{the number of}} bits desired in an output hash function. Choose another number r, {{less than or equal}} to p; this choice is arbitrary, and {{controls}} the tradeoff between time and memory usage of the hashing method: smaller values of r use less memory but cause the hash function to be slower. Compute t by rounding p/r up to the next larger integer; this gives the number of r-bit blocks needed to represent a key. For instance, if r = 8, then an r-bit number is a byte, and t is the number of bytes per key.The key idea of tabulation hashing is to view a key as a vector of t r-bit numbers, use a lookup table filled with random values to compute a hash value for each of the r-bit numbers representing a given key, and combine these values with the <b>bitwise</b> binary <b>exclusive</b> or operation. The choice of r should be made in such a way that this table is not too large; e.g., so that it fits into the computer's cache memory.|$|R
5000|$|Computes {{the random}} value x = TDEAk(s ⊕ t), where ⊕ denotes <b>bitwise</b> <b>exclusive</b> or.|$|E
5000|$|As noted above, since {{exclusive}} disjunction {{is identical}} to addition modulo 2, the <b>bitwise</b> <b>exclusive</b> disjunction of two n-bit strings {{is identical to}} the standard vector of addition in the vector space [...]|$|E
50|$|Here highbit(S) {{denotes the}} most {{significant}} bit of S; the '*' operator denotes unsigned integer multiplication with lost overflow; '^' is the <b>bitwise</b> <b>exclusive</b> or operation applied to words; and P is a suitable fixed word.|$|E
5000|$|CDMA is a {{spread-spectrum}} multiple-access technique. A spread-spectrum technique spreads the bandwidth of {{the data}} uniformly for the same transmitted power. A spreading code is a pseudo-random code that has a narrow ambiguity function, unlike other narrow pulse codes. In CDMA a locally generated code runs {{at a much higher}} rate than the data to be transmitted. Data for transmission is combined by <b>bitwise</b> XOR (<b>exclusive</b> OR) with the faster code. The figure shows how a spread-spectrum signal is generated. The data signal with pulse duration of [...] (symbol period) is XORed with the code signal with pulse duration of [...] (chip period). (Note: bandwidth is proportional to , where [...] = bit time.) Therefore, the bandwidth {{of the data}} signal is [...] and the bandwidth of the spread spectrum signal is [...] Since [...] is much smaller than , the bandwidth of the spread-spectrum signal is much larger than the bandwidth of the original signal. The ratio [...] is called the spreading factor or processing gain and determines to a certain extent the upper limit {{of the total number of}} users supported simultaneously by a base station.|$|R
40|$|This thesis {{investigates the}} {{hardware}} implementation and {{statistical analysis of}} new stream ciphers, Phelix and Salsa 20. Both are candidates for the eSTREAM project, a project highlighting the state of stream cipher design and analysis. [...] From a physical technology perspective, hardware implementation methodology consists of Application Specific Integrated Circuit (ASIC) design and Field Programmable Gate Array (FPGA) design. When high performance is required, an ASIC is typically chosen as the implementation platform. However, FPGA platforms have become increasingly popular due to their flexibility and a diminishing performance tradeoff as compared with ASIC technology. Following this trend we have developed two versions of Salsa 20, one for deployment on an ASIC, the other for an FPGA. The cipher Phelix is studied for application to ASIC environment. [...] Implementing a cipher requires detailed knowledge of the cryptographic algorithm itself, particularly the underlying arithmetic. In the case of Phelix and Salsa 20, {{both of which are}} composed of several simple operations: 32 -bit addition, <b>bitwise</b> addition (<b>exclusive</b> or) and rotation, the most important operation is the 32 -bit addition, for which we have investigated multiple structures for the adders and compared them in both speed and area. Different adder architectures are chosen for different designs, and the basic criteria is the concern of speed or area the overall implementation consumes. [...] Two structures for Phelix have been implemented, one is a high speed design and the other one is aimed at compactness. The simulation results shows that it consumes about 12, 000 two-input NAND gates in the compact design and achieves more than one Gbps throughput in the high speed design. The speed of the compact design is 260 Mbps and the area of the high speed design is 64, 200 two-input NAND gates. Up to four different structures are investigated for Salsa 20 as extra considerations are given to the utilization of FPGA. The proposed VLSI implementations achieve a data throughput up to 4. 8 Gbps, and a compact FPGA design uses 194 slices and 4 memory blocks in a Xilinx device. The proposed designs in the thesis serve mainly as a quick evaluation of their hardware performance; hence, further architectural optimizations are certainly possible. [...] Security analysis is an important concern in cipher designs. Thus, we have applied certain statistical tests, which are publicly available in the NIST (National Institute of Standards and Technology) test suite to test various sequences produced by using the Phelix and Salsa 20 algorithms. Since the test suite has not considered the relationship between key, IV, internal state and the keystream, we also applied six novel tests to examine the ciphers. Two strategies are employed to interpret the test results: the examination of the proportion of sequences that pass a statistical test and the distribution of P-values to check for uniformity. NIST gives the definition of P-value: the probability that a perfect random number generator would have produced a sequence less random than the sequence that was tested. The experimental results show that both Salsa 20 and Phelix have passed the tests in NIST, considering that P-value less than 0. 01 indicate a possible weakness. An easily understood deviation is observed in the correlation test for the last internal state (the state after 9 double rounds) and the keystream in Salsa 20. However, how this could be exploited in an attack is an open question...|$|R
40|$|Thesis (M. Eng.) [...] Memorial University of Newfoundland, 2008. Engineering and Applied ScienceIncludes bibliographical {{references}} (leaves 97 - 102) This thesis {{investigates the}} hardware implementation and {{statistical analysis of}} new stream ciphers, Phelix and Salsa 20. Both are candidates for the eSTREAM project, a project highlighting the state of stream cipher design and analysis. [...] From a physical technology perspective, hardware implementation methodology consists of Application Specific Integrated Circuit (ASIC) design and Field Programmable Gate Array (FPGA) design. When high performance is required, an ASIC is typically chosen as the implementation platform. However, FPGA platforms have become increasingly popular due to their flexibility and a diminishing performance tradeoff as compared with ASIC technology. Following this trend we have developed two versions of Salsa 20, one for deployment on an ASIC, the other for an FPGA. The cipher Phelix is studied for application to ASIC environment. [...] Implementing a cipher requires detailed knowledge of the cryptographic algorithm itself, particularly the underlying arithmetic. In the case of Phelix and Salsa 20, {{both of which are}} composed of several simple operations: 32 -bit addition, <b>bitwise</b> addition (<b>exclusive</b> or) and rotation, the most important operation is the 32 -bit addition, for which we have investigated multiple structures for the adders and compared them in both speed and area. Different adder architectures are chosen for different designs, and the basic criteria is the concern of speed or area the overall implementation consumes. [...] Two structures for Phelix have been implemented, one is a high speed design and the other one is aimed at compactness. The simulation results shows that it consumes about 12, 000 two-input NAND gates in the compact design and achieves more than one Gbps throughput in the high speed design. The speed of the compact design is 260 Mbps and the area of the high speed design is 64, 200 two-input NAND gates. Up to four different structures are investigated for Salsa 20 as extra considerations are given to the utilization of FPGA. The proposed VLSI implementations achieve a data throughput up to 4. 8 Gbps, and a compact FPGA design uses 194 slices and 4 memory blocks in a Xilinx device. The proposed designs in the thesis serve mainly as a quick evaluation of their hardware performance; hence, further architectural optimizations are certainly possible. [...] Security analysis is an important concern in cipher designs. Thus, we have applied certain statistical tests, which are publicly available in the NIST (National Institute of Standards and Technology) test suite to test various sequences produced by using the Phelix and Salsa 20 algorithms. Since the test suite has not considered the relationship between key, IV, internal state and the keystream, we also applied six novel tests to examine the ciphers. Two strategies are employed to interpret the test results: the examination of the proportion of sequences that pass a statistical test and the distribution of P-values to check for uniformity. NIST gives the definition of P-value: the probability that a perfect random number generator would have produced a sequence less random than the sequence that was tested. The experimental results show that both Salsa 20 and Phelix have passed the tests in NIST, considering that P-value less than 0. 01 indicate a possible weakness. An easily understood deviation is observed in the correlation test for the last internal state (the state after 9 double rounds) and the keystream in Salsa 20. However, how this could be exploited in an attack is an open question...|$|R
5000|$|... (Similarly, a {{universal}} family can be XOR universal if , the value [...] is uniformly distributed in [...] where [...] is the <b>bitwise</b> <b>exclusive</b> or operation. This is only possible if [...] {{is a power}} of two.) ...|$|E
5000|$|The set of evil numbers (numbers [...] with [...] ) forms a {{subspace}} of the nonnegative integers under nim-addition (<b>bitwise</b> <b>exclusive</b> or). For {{the game}} of Kayles, evil nim-values occur for few (finitely many) positions in the game, with all remaining positions having odious nim-values.|$|E
5000|$|... where [...] denotes {{concatenation}} of bit vectors (with upper bits on the left), [...] the <b>bitwise</b> <b>exclusive</b> or (XOR), [...] {{means the}} upper [...] bits of , and [...] means the lower [...] bits of [...] The twist transformation A {{is defined in}} rational normal form as: ...|$|E
50|$|Modern {{variants}} {{of the running}} key cipher often replace the traditional tabula recta with <b>bitwise</b> <b>exclusive</b> or, operate on whole bytes rather than alphabetic letters, and derive their running keys from large files. Apart from possibly greater entropy density of the files, and the ease of automation, there is little practical difference between such variants and traditional methods.|$|E
5000|$|Encode {{the secret}} as an {{arbitrary}} length binary number s. Give to each player i (except one) a random number pi {{with the same}} length as s. Give to the last player the result of (s XOR p1 XOR p2 XOR ... XOR pn-1) where XOR is <b>bitwise</b> <b>exclusive</b> or. The secret is the bitwise XOR of all the players' numbers (p).|$|E
5000|$|The two colors {{may also}} be {{combined}} in more complex ways, e.g. by computing their <b>bitwise</b> <b>exclusive</b> or. This technique is known as inverting color or color inversion, and is often used in graphical user interfaces for highlighting, rubber-band drawing, and other volatile painting - since re-painting the same shapes with the same color will restore the original pixel values.|$|E
5000|$|There are {{arithmetic}} {{operations on}} ordinals {{by virtue of}} the one-to-one correspondence between ordinals and nimbers. Three common operations on nimbers are nimber addition, nimber multiplication, and minimum excludance (mex). Nimber addition is a generalization of the <b>bitwise</b> <b>exclusive</b> or operation on natural numbers. The [...] of a set of ordinals is the smallest ordinal not present in the set.|$|E
5000|$|IDEA {{operates}} on 64-bit blocks using a 128-bit key, {{and consists of}} a series of eight identical transformations (a round) and an output transformation (the half-round). The processes for encryption and decryption are similar. IDEA derives much of its security by interleaving operations from different groups [...] - [...] modular addition and multiplication, and <b>bitwise</b> <b>exclusive</b> or (XOR) [...] - [...] which are algebraically [...] "incompatible" [...] in some sense.|$|E
5000|$|The cube-{{connected}} {{cycles of}} order n (denoted CCCn) {{can be defined}} as a graph formed from a set of n2n nodes, indexed by pairs of numbers (x, y) where 0 ≤ x < 2n and 0 ≤ y < n. Each such node is connected to three neighbors: (x, (y + 1) mod n), (x, (y &minus; 1) mod n), and (x ⊕ 2y, y), where [...] "⊕" [...] denotes the <b>bitwise</b> <b>exclusive</b> or operation on binary numbers.|$|E
5000|$|IDEA {{operates}} on 64-bit blocks using a 128-bit key {{and consists of}} a series of 8 identical transformations (a round, see the illustration) and an output transformation (the half-round). The processes for encryption and decryption are similar. IDEA derives much of its security by interleaving operations from different groups [...] - [...] modular addition and multiplication, and <b>bitwise</b> <b>eXclusive</b> OR (XOR) [...] - [...] which are algebraically [...] "incompatible" [...] in some sense. In more detail, these operators, which all deal with 16-bit quantities, are: ...|$|E
5000|$|For finite ordinals, the nim-sum {{is easily}} {{evaluated}} {{on a computer}} by taking the <b>bitwise</b> <b>exclusive</b> or (XOR, denoted by [...] ) of the corresponding numbers. For example, the nim-sum of 7 and 14 can be found by writing 7 as 111 and 14 as 1110; the ones place adds to 1; the twos place adds to 2, which we replace with 0; the fours place adds to 2, which we replace with 0; the eights place adds to 1. So the nim-sum is written in binary as 1001, or in decimal as 9.|$|E
5000|$|For as many {{iterations}} as are needed, the PRGA modifies {{the state}} and outputs a byte of the keystream. In each iteration, the PRGA increments , looks up the th element of , , and adds that to , exchanges the values of [...] and , and then uses the sum [...] as an index to fetch a third element of , (the keystream value [...] below) which is <b>bitwise</b> <b>exclusive</b> OR'ed (XOR'ed) with the next byte of the message to produce the next byte of either ciphertext or plaintext. Each element of S is swapped with another element at least once every 256 iterations.|$|E
5000|$|The {{following}} C function will {{compute the}} Hamming distance of two integers (considered as binary values, that is, as sequences of bits). The running {{time of this}} procedure {{is proportional to the}} Hamming distance rather than to the number of bits in the inputs. It computes the <b>bitwise</b> <b>exclusive</b> or of the two inputs, and then finds the Hamming weight of the result (the number of nonzero bits) using an algorithm of [...] that repeatedly finds and clears the lowest-order nonzero bit. Some compilers support the __builtin_popcount function which can calculate this using specialized processor hardware where available.|$|E
50|$|Tabulation hashing is a {{technique}} for mapping keys to hash values by partitioning each key into bytes, using each byte as the index into a table of random numbers (with a different table for each byte position), and combining {{the results of these}} table lookups by a <b>bitwise</b> <b>exclusive</b> or operation. Thus, it requires more randomness in its initialization than the polynomial method, but avoids possibly-slow multiplication operations. It is 3-independent but not 4-independent. Variations of tabulation hashing can achieve higher degrees of independence by performing table lookups based on overlapping combinations of bits from the input key, or by applying simple tabulation hashing iteratively.|$|E
5000|$|Hashing by cyclic {{polynomial}} - {{sometimes called}} Buzhash - is also simple, {{but it has}} the benefit of avoiding multiplications, using barrel shifts instead. It {{is a form of}} tabulation hashing: it presumes that there is some hash function [...] from characters to integers in the interval [...] This hash function might be simply an array or a hash table mapping characters to random integers. Let the function [...] be a cyclic binary rotation (or circular shift): it rotates the bits by 1 to the left, pushing the latest bit in the first position. E.g., [...] Let [...] be the <b>bitwise</b> <b>exclusive</b> or. The hash values are defined as ...|$|E
50|$|This method {{leads to}} a fast method for {{computing}} the Thue-Morse sequence: start with t0 = 0, and then, for each n, find the highest-order bit in the binary representation of n {{that is different from}} the same bit in the representation of n &minus; 1. (This bit can be isolated by letting x be the <b>bitwise</b> <b>exclusive</b> or of n and n &minus; 1, shifting x right by one bit, and computing the exclusive or of this shifted value with x.) If this bit is at an even index, tn differs from tn &minus; 1, and otherwise it is the same as tn &minus; 1. The resulting algorithm takes constant time to generate each sequence element, using only a logarithmic number of bits (constant number of words) of memory.|$|E
50|$|The first {{instance}} of tabulation hashing is Zobrist hashing, {{a method for}} hashing positions in abstract board games such as chess named after Albert Lindsey Zobrist, who published it in 1970. In this method, a random bitstring is generated for each game feature such as {{a combination of a}} chess piece and a square of the chessboard. Then, to hash any game position, the bitstrings for the features of that position are combined by a <b>bitwise</b> <b>exclusive</b> or. The resulting hash value can then be used as an index into a transposition table. Because each move typically changes {{only a small number of}} game features, the Zobrist value of the position after a move can be updated quickly from the value of the position before the move, without needing to loop over all of the features of the position.|$|E
50|$|Simple {{tabulation}} {{is limited}} to keys of a fixed length, because a different table of random values needs to be initialized for each position of a block in the keys. studies variations of tabulation hashing suitable for variable-length keys such as character strings. The general type of hashing scheme studied by Lemire uses a single table T indexed by {{the value of a}} block, regardless of its position within the key.However, the values from this table may be combined by a more complicated function than <b>bitwise</b> <b>exclusive</b> or.Lemire shows that no scheme of this type can be 3-independent. Nevertheless, he shows that it is still possible to achieve 2-independence. In particular, a tabulation scheme that interprets the values Txi (where xi is, as before, the ith block of the input) as the coefficients of a polynomial over a finite field and then takes the remainder of the resulting polynomial modulo another polynomial, gives a 2-independent hash function.|$|E
