31|118|Public
50|$|The {{reformulation}} of a <b>best-first</b> <b>algorithm</b> as {{a sequence}} of depth-first calls prompted the formulation of a class of null-window alpha-beta algorithms, of which MTD-f is the best known example.|$|E
50|$|Another search {{algorithm}} called SSS* can theoretically {{result in}} fewer nodes searched. However, its original formulation has practical issues (in particular, it {{relies heavily on}} an OPEN list for storage) and nowadays most chess engines still use a form of NegaScout in their search. Most chess engines use a transposition table in which the relevant part of the search tree is stored. This part of the tree has {{the same size as}} SSS*'s OPEN list would have. A reformulation called MT-SSS* allowed it to be implemented as a series of null window calls to Alpha-Beta (or NegaScout) that use a transposition table, and direct comparisons using game playing programs could be made. It did not outperform NegaScout in practice. Yet another search algorithm, which does tend to do better than NegaScout in practice, is the <b>best-first</b> <b>algorithm</b> called MTD-f, although neither algorithm dominates the other. There are trees in which NegaScout searches fewer nodes than SSS* or MTD-f and vice versa.|$|E
40|$|Abstract. In many {{scientific}} areas {{there is}} a frequent need to extract a common pattern from multiple data. In most cases, however, an approximate but low cost solution is preferred to a high cost exact match. To establish a fast search engine an efficient heuristic method should be implemented. Our investigation {{is devoted to the}} approximate nearest neighbor search (ANN) for unordered labeled trees. The proposed modified <b>best-first</b> <b>algorithm</b> provides a O((Nq+N b) ·M + K·N q·N b/M) cost function with simple implementation details. According to our test results, realized with smaller trees where the brute-force algorithm could be tested, the yielded results are a good approximation of the global optimum values. Based on the results of the tests, the execution cost for the base <b>best-first</b> <b>algorithm</b> is about one order of magnitude larger than the cost for the porposed modified best-first approximation method...|$|E
5000|$|The A* search {{algorithm}} {{is an example}} of best-first search, as is B*. <b>Best-first</b> <b>algorithms</b> are often used for path finding in combinatorial search. (Neither A* nor B* is a greedy best-first search as they incorporate the distance from start in addition to estimated distances to the goal.) ...|$|R
40|$|Search {{algorithms}} {{are often}} categorized by their node expansion strategy. One option is the depth-first strategy, a simple backtracking strategy that traverses the search {{space in the}} order in which successor nodes are generated. An alternative is the best-first strategy, which was designed to make it possible to use domain-specific heuristic information. By exploring promising parts of the search space first, <b>best-first</b> <b>algorithms</b> are usually more efficient than depth-first algorithms...|$|R
40|$|In the {{presence}} of non-admissible heuristics, A * and other <b>best-first</b> <b>algorithms</b> can be converted into anytime optimal algorithms over OR graphs, by simply continuing the search after the first solution is found. The same trick, however, does not work for <b>best-first</b> <b>algorithms</b> over AND/OR graphs, that {{must be able to}} expand leaf nodes of the explicit graph that are not necessarily part of the best partial solution. Anytime optimal variants of AO * must thus address an exploration-exploitation tradeoff: they cannot just ”exploit”, they must keep exploring as well. In this work, we develop one such variant of AO * and apply it to finite-horizon MDPs. This Anytime AO * algorithm eventually delivers an optimal policy while using non-admissible random heuristics that can be sampled, as when the heuristic is the cost of a base policy that can be sampled with rollouts. We then test Anytime AO * for action selection over large infinite-horizon MDPs that cannot be solved with existing off-line heuristic search and dynamic programming algorithms, and compare it with UCT...|$|R
40|$|Irrelevance-based partial MAPs {{are useful}} {{constructs}} for domain-independent explanation using belief networks. We {{look at two}} definitions for such partial MAPs, and prove important properties that are useful in designing algorithms for computing them effectively. We make use of these properties in modifying our standard MAP <b>best-first</b> <b>algorithm,</b> so as to handle irrelevance-based partial MAPs. Comment: Appears in Proceedings of the Seventh Conference on Uncertainty in Artificial Intelligence (UAI 1991...|$|E
40|$|Fourier-based {{learning}} algorithms rely {{on being}} able to efficiently find the large coefficients of a function’s spectral representation. In this paper, we introduce and analyze techniques for finding large coefficients. We show how a previously introduced search technique can be generalized from the Boolean case to the real-valued case, and we apply it in branch-and-bound and beam search algorithms that have significant advantages over the <b>best-first</b> <b>algorithm</b> in which the technique was originally introduced. ...|$|E
40|$|The {{approach}} {{is based on}} a graph search algorithm. A relational data structure is used to represent a truss structure. There are four types of entities: units, faces, edges, and vertices. There are contain/contained relationships for every pair of entity types, as well as in-contact relationships between faces. A <b>best-first</b> <b>algorithm</b> constitutes the core of the planner. The cost function in the current implementation corresponds to a combination of the rigidity of the intermediate structures and the total distance to be traversed by the agent executing the assembly tasks...|$|E
25|$|What sets A* {{apart from}} a greedy <b>best-first</b> search <b>algorithm</b> is that it takes the cost/distance already traveled, , into account.|$|R
40|$|Dynamic Programming (DP) is an {{important}} class of algorithms widely used {{in many areas of}} speech and language processing. Recently there have been a series of work trying to formalize many instances of DP algorithms under algebraic and graph-theoretic frameworks. This tutorial surveys two such frameworks, namely semirings and directed hypergraphs, and draws connections between them. We formalize two particular types of DP algorithms under each of these frameworks: the Viterbi-style topological algorithms and the Dijkstra-style <b>best-first</b> <b>algorithms.</b> Wherever relevant, we also discuss typical applications of these algorithms in Natural Language Processing. ...|$|R
40|$|Depth-first search schemes {{are known}} to be more {{cost-effective}} for solving graphical models tasks than Best-First Search schemes. In this paper we show however that anytime <b>Best-First</b> <b>algorithms</b> recently developed for path-finding problems, can fare well when applied to graphical models. Specifically, we augment best-first schemes designed for graphical models with such anytime capabilities and demonstrate their potential when compared against one of the most competitive depth-first branch and bound scheme. Though Best-First search using weighted heuristics is successfully used in many domains, the crucial question of weight parameter choice has not been systematically studied and presents an interesting machine learning problem. 1...|$|R
40|$|AbstractWe {{evaluate}} current explanation schemes. These {{are either}} insufficiently general, or suffer from other serious drawbacks. A domain-independent explanation theory, based on ignoring irrelevant variables in a probabilistic setting, is proposed. Independence-based maximum aposteriori probability (IB-MAP) explanations, {{an instance of}} irrelevance-based explanation, has several interesting properties, which provide for simple algorithms for computing such explanations. A <b>best-first</b> <b>algorithm</b> that generates IB-MAP explanations is presented, and evaluated empirically. The algorithm shows reasonable performance for up to medium-size problems {{on a set of}} randomly generated belief networks. An alternate algorithm, based on linear systems of inequalities, is discussed...|$|E
40|$|AbstractThis paper {{describes}} FMS {{scheduling problem}} based on Petri net {{with the goal}} of minimizing makespan. A hybrid heuristic search approach for the scheduling is presented, which combine dynamic search window with <b>best-first</b> <b>algorithm</b> and backtracking search., In addition redundant markings can be eliminated to reduce the searched state space. We use the proposed method to search for an optimal schedule of an example with varied lot sizes for each job type considered. Comparison with previous work is given to show the proposed approach can generate an optimal solution, but with much less search time and memory space. This hybrid algorithm can be deal with large systems...|$|E
40|$|The goal of {{this project}} was to explore the {{possibility}} of relatively inexperienced programmers making their own pathfinding classes, or even a generic pathfinding library. As a practical part of the project, the group uncovered the information needed to create a pathfinding library fit for a 2 D map. The obvious choice of algorithm was the A*, a <b>best-first</b> <b>algorithm,</b> which searches a grid for the best path between two points. A pathfinding library was programmed in Java, its code described and evaluated in this report, and finally, a set of recommendations is put forward to the inexperienced programmer based on the observations and experiences of this project report’s author...|$|E
40|$|Abstract—Implementation of a <b>best-first</b> {{detection}} <b>algorithm</b> for multiple-input multiple-output (MIMO) systems requires {{large amounts}} of memory especially in large systems with high-order modulation. In this letter, we propose modified <b>best-first</b> detection <b>algorithms</b> in which the order of nodes is determined by both the original cost and the estimated future cost associated with each node, as inspired by an improved shortest path algorithm (A ∗ algorithm). The modified algorithms maintain the detection optimality, reduce the memory requirement and sorting com-plexity, and achieve improved detection performance in memory-constrained scenarios. Index Terms—Maximum likelihood (ML) decoding, multiple-input multiple-output (MIMO) systems, tree-search detection, Dijkstra’s algorithm, A ∗ algorithm, memory efficiency. I...|$|R
40|$|The paper {{focuses on}} finding the m best {{solutions}} to combinatorial optimization problems using Best-First or Branchand-Bound search. Specifically, we present m-A*, extending the well-known A * to the m-best task, and prove that all its desirable properties, including soundness, completeness and optimal efficiency, are maintained. Since <b>Best-First</b> <b>algorithms</b> have memory problems, we also extend the memoryefficient Depth-First Branch-and-Bound to the m-best task. We extend both algorithms to optimization tasks over graphical models (e. g., Weighted CSP and MPE in Bayesian networks), provide complexity analysis and an empirical evaluation. Our experiments with 5 variants of Best-First and Branch-and-Bound confirm that Best-First is largely superior when memory is available, but Branch-and-Bound is more robust, while both styles of search benefit greatly when the heuristic evaluation function has increased accuracy. ...|$|R
40|$|This paper {{introduces}} {{a new paradigm}} for minimax game-tree search algo- rithms. MT is a memory-enhanced version of Pearls Test procedure. By changing the way MT is called, a number of <b>best-first</b> game-tree search <b>algorithms</b> can be simply and elegantly constructed (including SSS*). Most of the assessments of minimax search algorithms {{have been based on}} simulations. However, these simulations generally do not address two of the key ingredients of high performance game-playing programs: iterative deepening and memory usage. This paper presents experimental data from three game-playing programs (checkers, Othello and chess), covering the range from low to high branching factor. The improved move ordering due to iterative deepening and memory usage results in significantly different results from those portrayed in the literature. Whereas some simulations show Alpha-Beta expanding almost 100 % more leaf nodes than other algorithms [12], our results showed variations of less than 20 %. One new instance of our framework (MTD-f) out-performs our best alpha- beta searcher (aspiration NegaScout) on leaf nodes, total nodes and execution time. To our knowledge, these are the first reported results that compare both depth-first and <b>best-first</b> <b>algorithms</b> given the same amount of memoryComment: Novag Award 1994 - 1995 Best Computer Chess publicatio...|$|R
40|$|Abstract – In this paper, {{the problem}} of path {{planning}} for robot manipulators with six de-grees of freedom in an on-line provided three-dimensional environment is investigated. As a basic approach, the <b>best-first</b> <b>algorithm</b> is used to search in the implicit descrete configuration space. Collisions are detected in the Cartesian workspace by hierarchical distance computation based on the given CAD model. The basic ap-proach is extended by three simple mechanisms and results in a heuristic hierarchical search. This is done by adjusting the stepsize of the search to {{the distance between the}} robot and the obstacles. As a first step, we show encouraging experimental results with two degrees of free-dom for five typical benchmark problems. I...|$|E
40|$|Top-k spatial-textual queries have {{received}} significant {{attention in the}} research community. Several techniques to efficiently process this class of queries are now widely used {{in a variety of}} applications. However, the problem of how best to process multiple queries efficiently is not well understood. Applications relying on processing continuous streams of queries, and offline pre-processing of other queries could benefit from solutions to this problem. In this work, we study practical solutions to efficiently process a set of top-k spatial-textual queries. We propose an efficient <b>best-first</b> <b>algorithm</b> for the batch processing of top-k spatial-textual queries that promotes shared processing and reduced I/O in each query batch. By grouping similar queries and processing them simultaneously, we are able to demonstrate significant performance gains using publicly available datasets...|$|E
40|$|Similarity searching often reduces {{to finding}} the k nearest neighbors to a query object. Finding the k nearest neighbors is {{achieved}} by applying either a depth-first or a <b>best-first</b> <b>algorithm</b> to the search hierarchy containing the data. These algorithms are generally applicable to any index based on hierarchical clustering. The {{idea is that the}} data is partitioned into clusters which are aggregated to form other clusters, with the total aggregation being represented as a tree. These algorithms have traditionally used a lower bound corresponding to the minimum distance at which a nearest neighbor can be found (termed MINDIST) to prune the search process by avoiding the processing of some of the clusters as well as individual objects when they can be shown to be farther from the query object q than all of the current k nearest neighbors of q. An alternative pruning technique that uses an upper bound corresponding to the maximum possible distance at which a nearest neighbor is guaranteed to be found (termed MAXNEARESTDIST) is described. The MAXNEARESTDIST upper bound is adapted to enable its use for finding the k nearest neighbors instead of just the nearest neighbor (i. e., k = 1) as in its previous uses. Both the depth-first and best-first k-nearest neighbor algorithms are modified to use MAXNEARESTDIST, which is shown to enhance both algorithms by overcoming their shortcomings. In particular, for the depthfirst algorithm, the number of clusters in the search hierarchy that must be examined is not increased thereby potentially lowering its execution time, while for the <b>best-first</b> <b>algorithm,</b> the number of clusters in the search hierarchy that must be retained in the priority queue used to control the ordering of processing of the clusters is also not increased, thereby potentially lowering its storage requirements. Index Terms — k-nearest neighbors; similarity searching; metric spaces; depth-first nearest neighbor finding; best-first nearest neighbor finding I...|$|E
40|$|When {{exploring}} a game {{over a large}} strategy space, {{it may not be}} feasible or cost-effective to evaluate the payoff of every relevant strategy profile. For example, evaluating each payoff of an empirically defined game may require Monte Carlo simulation or other costly computation. Analyzing such games poses a search problem, with the goal of identifying and confirming pure-strategy equilibrium profiles by evaluating payoffs of candidates and potential deviations from those candidates. Sureka & Wurman (2005) studied this problem and proposed a search method based on best-response dynamics. We introduce a family of <b>best-first</b> <b>algorithms,</b> which prioritize unconfirmed profiles by their known bound away from equilibrium and select the profile with the current minimum. We compare algorithms by measuring the fraction of profile space explored to confirm equilibria, as well as the search effort required to confirm approximate equilibria, on several game classes. Our best-first approach compares similarly to the existing best-response algorithms when searching for exact equilibria, and favorably when searching for approximate equilibria...|$|R
40|$|We empirically examine {{several ways}} of {{exploiting}} the information of multiple heuristics in a satisficing <b>best-first</b> search <b>algorithm,</b> comparing their performance {{in terms of}} coverage, plan quality, speed, and search guidance. Our results indicate that using multiple heuristics for satisficing search is indeed useful. Among the combination methods we consider, the best results are obtained by the alternation method of the “Fast Diagonally Downward ” planner. runtim...|$|R
40|$|Existing {{algorithms}} {{for generating}} referential descriptions to sets of objects have serious deficits: while incremental approaches may produce ambiguous and redundant expressions, exhaustive searches are computationally expensive. Mediating between these extreme control regimes, we propose a <b>best-first</b> searching <b>algorithm</b> for uniquely identifying sets of objects. We incorporate linguistically motivated preferences and several techniques {{to cut down}} the search space. Preliminary results show {{the effectiveness of the}} new algorithm...|$|R
40|$|International audienceWe aim at {{planning}} multi-contact {{sequences of}} stances and postures for humanoid robots. The output sequence defines the contact transitions that allow our robot to realize {{different kind of}} tasks, ranging from biped locomotion to dexterous manipulation. The central component of the planning framework is a <b>best-first</b> <b>algorithm</b> that performs {{a search of the}} contacts to be added or removed at each step, following an input collision-free guide path, and making calls to an optimization-based inverse kinematics solver under static equilibrium constraints. The planner can handle systems made of multiple robots and/or manipulated objects through a centralized multi-agent approach, opening the way for multi-robot collaborative locomotion and manipulation planning. Results are presented in virtual environments, with discussion on execution on the real robot HRP- 2 in an example situation...|$|E
40|$|Specific-subject {{oriented}} {{information collection}} {{is one of}} the key technologies of vertical search engines, which directly affects the speed and relevance of search results. The topic information collection algorithm is widely used for its accuracy. The Hidden Markov Model (HMM) is used to learn and judge the relevance between the Uniform Resource Locator (URL) and the topic information. The Rocchio method is used to construct the prototype vectors relevant to the topic information, and the HMM is used to learn the preferred browsing paths. The concept maps including the semantics of the webpage are constructed and the web's link structures can be decided. The validity of the algorithm is proved by the experiment at last. Comparing with the <b>Best-First</b> <b>algorithm,</b> this algorithm can get more information pages and has higher precision ratio...|$|E
40|$|The {{best known}} control {{algorithm}} for symbolic model matching in computer vision is the Interpretation Tree search algorithm, popularized and extended by Grimson, Lozano-Perez, Huttenlocher and others. This algorithm {{has a high}} computational complexity when applied to matching problems {{with large numbers of}} features. This paper examines eleven variations of this algorithm in a search for improved performance, and concludes that a <b>best-first</b> <b>algorithm</b> has greatly reduced theoretical complexity and runs much faster than the standard algorithm. KEYWORDS: model-based vision, model matching, object recognition, search 1 Introduction The most well-known control algorithm for symbolic model matching in computer vision is the Interpretation Tree (IT) search algorithm, as used by Grimson and LozanoPerez [12]. The algorithm searches a tree of potential model-to-data correspondences, such that each node in the tree represents one correspondence and the path of nodes from the current node [...] ...|$|E
40|$|AbstractThis paper {{proposes a}} new search {{algorithm}}, denoted PN∗, for AND/OR tree search. The algorithm {{is based on}} proof-number (PN) search, a <b>best-first</b> search <b>algorithm,</b> proposed by Allis et al. [Artificial Intelligence 66 (1) (1994) 91 – 124], and on Korf's RBFS algorithm [Artificial Intelligence 62 (1) (1993) 41 – 78]. PN∗ combines several existing ideas. It transforms a <b>best-first</b> PN-search <b>algorithm</b> into an iterative-deepening depth-first approach. Moreover, it is enhanced by methods such as recursive iterative deepening, dynamic evaluation, efficient successor ordering, and pruning by dependency relations. The resulting algorithm {{turns out to be}} highly efficient as witnessed by the experimental results. The PN∗ algorithm is implemented in a tsume-shogi (Japanese-chess mating-problem) program, and evaluated by testing it on 295  notoriously difficult tsume-shogi problems (one problem has a depth of search of over 1500  plies). The experimental results are compared with those of other programs. The PN∗ program shows by far the best results, solving all problems but one. Needless to say, it outperforms the best human tsume-shogi problem solvers by far...|$|R
40|$|Artificial Intelligence Lab, Department of MIS, University of ArizonaSpiders are the {{software}} agents that search engines use to collect content for their databases. We investigated algorithms {{to improve the}} performance of vertical search engine spiders. The investigation addressed three approaches: a breadth-first graph-traversal algorithm with no heuristics to refine the search process, a <b>best-first</b> traversal <b>algorithm</b> that used a hyperlink-analysis heuristic, and a spreading-activation algorithm based on modeling the Web as a neural network...|$|R
40|$|AbstractBest-first search {{algorithms}} usually amalgamate identical nodes for optimization reasons, meanwhile {{transforming the}} search tree into a search graph. However, identical nodes may represent different search states, e. g., {{due to a}} difference of history. So, in a search graph a node's value may be dependent on the path leading to it. This implies that different paths may result in different values. Therefore, {{it is difficult to}} determine the value of any node unambiguously. The problem is known as the graph–history-interaction (GHI) problem. This paper provides a solution for best-first search. First, we give a precise formulation of the problem. Then, for best-first search and for other searches, we review earlier proposals to overcome the problem. Next, our solution is given in detail. Here we introduce the notion of twin nodes, enabling a distinction of nodes according to their history. The implementation, called base-twin algorithm (BTA), is performed for pn search, a <b>best-first</b> search <b>algorithm.</b> It is generally applicable to other <b>best-first</b> search <b>algorithms.</b> Experimental results in the field of computer chess confirm the claim that the GHI problem has been solved for best-first search...|$|R
40|$|Search {{algorithms}} {{are often}} categorized by their node expansion strategy. One option is the depth-first strategy, a simple backtracking strategy that traverses the search {{space in the}} order in which successor nodes are generated. An alternative is the best-first strategy, which was designed to make it possible to use domain-specific heuristic information. By exploring promising parts of the search space first, best-first algorithms are usually more efficient than depth-first algorithms. In programs that play minimax games such as chess and checkers, the efficiency of the search is of crucial importance. Given the success of best-first algorithms in other domains, one would expect them to be used for minimax games too. However, all high-performance game-playing programs are based on a depth-first algorithm. This study takes a closer look at a depth-first algorithm, Alpha-Beta, and a <b>best-first</b> <b>algorithm,</b> SSS*. The prevailing opinion on these algorithms is that SSS* offers the potential [...] ...|$|E
40|$|Abstract — A new {{algorithm}} is proposed for removing large objects from digital images. The challenge is {{to fill in the}} hole that is left behind in a visually plausible way. This has been addressed by two classes of algorithms one is the “inpainting algorithms ” for filling in small image gaps, and second is the “super resolution ” techniques ” for creating one enhanced resolution image. This paper presents a novel and efficient algorithm that combines the advantages of these two approaches. We first note that exemplar-based texture synthesis contains the essential process required to replicate both texture and structure; the success of structure propagation, however, is highly dependent on the order in which the filling proceeds. We propose a <b>best-first</b> <b>algorithm</b> in which the confidence in the synthesized pixel values is propagated {{in a manner similar to}} the propagation of information in inpainting. Index Terms — exemplar-based inpainting framework, non parametric patch sampling. I...|$|E
40|$|Introduction In his seminal paper "As We May Think" [1], Vannevar Bush {{suggested}} a future machine called a "memex". In doing so, he introduced {{the world to}} the concept of linked documents and of the trail - a sequence of linked pages. The concept of trails is well established in the hypertext community and many systems have been built which support their construction [2]. Previous work has described a navigation engine for automatically constructing trails as a means of assisting users browsing Web sites [4]. This navigation engine was further used to provide search and navigation facilities for Javadoc program documentation. If JavaDoc-style program documention, which is derived from source code, can be indexed, it seems logical that the source code itself can be indexed. We have developed a new tool called AutoCode based upon the navigation engine design. AutoCode provides full-text indexing of the java source code and uses a probabilistic <b>best-first</b> <b>algorithm</b> to identify trails...|$|E
40|$|Since <b>best-first</b> search <b>algorithms</b> such as A* require {{large amounts}} of memory, they {{sometimes}} cannot run to completion, even on problem instances of moderate size. This problem {{has led to the}} development of limited-memory search algorithms, of which the best known is IDA* [9, 10]. This paper presents the following results about IDA* and related algorithms: ffl The analysis of asymptotic optimality for IDA* in [10] is incorrect. There are trees satisfying the asymptotic optimality conditions given in [10] for which IDA* is not asymptotically optimal. ffl To correct the above problem, we state and prove necessary and sufficient conditions for asymptotic optimality of IDA* on trees. On trees not satisfying our conditions, we show that no <b>best-first</b> limited-memory search <b>algorithm</b> can be asymptotically optimal. ffl On graphs, IDA* can perform quite poorly. In particular, there are graphs on which IDA* does ΩΓ/ 2 N) node expansions where N is the number of nodes expanded by A*. [...] ...|$|R
40|$|This paper reports our ongoing {{research}} on unsupervised language learning via compression within the MDL paradigm. It formulates an empirical information-theoretical measure, description length gain, {{for evaluating the}} goodness of guessing a sequence of words (or character) as a phrase (or a word), which can be calculated easily following classic information theory. The paper also presents a <b>best-first</b> learning <b>algorithm</b> based on this measure. Experiments on phrase and lexical learning from POS tag and character sequence, respectively, show promising results...|$|R
40|$|The {{problem of}} {{effectively}} combining multiple heuristic estimators {{has been studied}} extensively {{in the context of}} optimal planning, but not in the context of satisficing planning. To narrow this gap, we empirically examine several ways of exploiting the information of multiple heuristics in a satisficing <b>best-first</b> search <b>algorithm,</b> comparing their performance in terms of coverage, plan quality and runtime. Our empirical results indicate that using multiple heuristics for satisficing search is indeed useful and that the best results are not obtained by the most obvious combination methods...|$|R
