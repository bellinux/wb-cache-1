15|7|Public
25|$|Channels {{differ in}} the number and type of {{concurrent}} I/O operations they support. In IBM terminology, a multiplexer channel supports a number of concurrent interleaved slow-speed operations, each transferring one byte from a device at a time. A selector channel supports one high-speed operation, transferring a block of data at a time. A <b>block</b> <b>multiplexer</b> supportes a number of concurrent high-speed operations.|$|E
5000|$|... {{support for}} the <b>block</b> <b>multiplexer</b> channel {{introduced}} in the System/360 Model 85.|$|E
5000|$|A <b>block</b> <b>multiplexer</b> {{channel is}} capable of {{concurrently}} running multiple channel programs, but only {{one at a time}} can be active. The control unit can request suspension {{at the end of a}} channel command and can later request resumption. This is intended for devices in which there is a mechanical delay after completion of data transfer, e.g., for seeks on moving-head DASD. The <b>block</b> <b>multiplexer</b> channel was a late addition to the System/360 architecture; early machines had only byte multiplexer channels and selector channels. The <b>block</b> <b>multiplexer</b> channel was an optional feature only on the models 85 and 195. The block multiplexor channel was also available on the later System/370 computers.|$|E
40|$|International Telemetering Conference Proceedings / October 29 -November 02, 1990 / Riviera Hotel and Convention Center, Las Vegas, NevadaTelemetry systems {{today are}} {{required}} to receive a variety of modulation formats. Typically, to change the format required changing the demodulator unit or large switching systems. Using some common digital building <b>blocks</b> and <b>multiplexers,</b> the user can change demodulation mode by pressing a button. This paper describes a system that demodulates PM, FM, BPSK, QPSK and DSB AM...|$|R
50|$|Some other multi-bit adder {{architectures}} {{break the}} adder into blocks. It {{is possible to}} vary the length of these blocks based on the propagation delay of the circuits to optimize computation time. These block based adders include the carry-skip (or carry-bypass) adder which will determine P and G values for each block rather than each bit, and the carry select adder which pre-generates the sum and carry values for either possible carry input (0 or 1) to the <b>block,</b> using <b>multiplexers</b> to select the appropriate result when the carry bit is known.|$|R
40|$|This paper {{describes}} the Amorphous FPGA, an innovative architecture attempting to optimally allocate logic and rout-ing resource on per-mapping basis. Designed for high per-formance, routability, and ease-of-use, it supports variable-granularity logic <b>blocks,</b> dedicated wide <b>multiplexers,</b> and variable-length bypassing interconnects with a symmetrical structure. Due to its many unconventional architectural fea-tures, the amorphous FPGA requires several major modi-cations {{to be made}} in the standard VPR placement/routing CAD ow, which include a new placement algorithm and a modi ed delay-based routing procedure. It is shown that, on average, an FPGA with the amorphous architecture can achieve a 1. 35 times improvement in logic density, 9 % im-provement in average net delay, and 4 % improvement in the critical-path delay for the largest 20 MCNC benchmark cir-cuits over an island-style baseline...|$|R
50|$|<b>Block</b> <b>multiplexer</b> {{channels}} {{could operate}} as a selector channel to allow compatible attachment of legacy subsystems.|$|E
50|$|The 2835 storage Control {{connects to}} one or two <b>block</b> <b>multiplexer</b> {{channels}} and attaches one or two 2305 Fixed Head storage Modules.|$|E
5000|$|The <b>block</b> <b>multiplexer</b> channel, {{previously}} {{available only}} on the 360/85 and 360/195, was a standard part of the architecture. For compatibility it could operate as a selector channel.|$|E
40|$|Switches in {{interconnection}} {{networks for}} highly parallel shared memory computer systems may be implemented with different internal buffer structures. For a 2 × 2 synchronous switch, {{previous studies have}} often assumed a switch composed of two queues, one at each output, {{each of which has}} unbounded size and may accept two inputs every clock cycle. Hardware implementations may actually use simpler queue designs and will have bounded size. Two additional models for a 2 × 2 switch using queues that may accept only one input at a time are analyzed. The first uses four queues, one for each input/output pair. The second uses two queues, one at each input. In each case, a <b>multiplexer</b> <b>blocks</b> one queue if two queues desire the same output, making these models more difficult to analyze than the previous model. Maximum bandwidth, expected queue length, expected waiting time, and queue length distribution are presented for both models, with unbounded queue size and with queue size equal to 1. Keywords [...] ...|$|R
40|$|My {{dissertation}} {{consists in}} a feseability {{study for the}} realization of a SOC for hearing aids. The {{state of the art}} of the chips for those prosthesis consists in DSP-based architecures which have the main advantages of providing acceptable performances, being flexible toward innovations and programmable. The last advantage allows to progeam the hearing aids according to the user's needs. Firt of all, a state of the art analysis has been executed, which confirms these facts. After that, a requirements analysis has been executed, underlining both the functional requirements (necessity of compressing the input signal, reducing the environmental noise, etc.) and the project requirements (low-power oriented - desing, low - latency design architecture,etc.). After that, a simulation of the DSP algorithms have been performed using Simulink - Matlab, in order to understand what solutions lead to best results, allowing to start a preliminary desing of several subsystem of the chip. A preliminary architecture of several blocks has been implemented: the input interface, the output interface, harwdare accelerators for the studied algorithms, audio datapath. The preliminary architectures have been simulated and their performances in term of latency, distortion, etc. have been extracted. It constituted a real first phase of design of the single subsytems which allowed to extimate the complexity of the chips in term of logical - arithmetic <b>blocks</b> (adders, multipliers, <b>multiplexers)</b> and offers an interesting starting point for the real desing phase. The study has provided two outputs: a preliminary datasheet of the system and a development plan of the project...|$|R
40|$|Generic {{structures}} {{have been}} conceived for <b>multiplexer</b> <b>blocks</b> {{to be implemented}} in field-programmable gate arrays (FPGAs) based on four-gate field-effect transistors (G(sup 4) FETs). This concept is {{a contribution to the}} continuing development of digital logic circuits based on G 4 FETs and serves as a further demonstration that logic circuits based on G(sup 4) FETs could be more efficient (in the sense that they could contain fewer transistors), relative to functionally equivalent logic circuits based on conventional transistors. Results in this line of development at earlier stages were summarized in two previous NASA Tech Briefs articles: "G(sup 4) FETs as Universal and Programmable Logic Gates" (NPO- 41698), Vol. 31, No. 7 (July 2007), page 44, and "Efficient G 4 FET-Based Logic Circuits" (NPO- 44407), Vol. 32, No. 1 (January 2008), page 38. As described in the first-mentioned previous article, a G 4 FET can be made to function as a three-input NOT-majority gate, which {{has been shown to be}} a universal and programmable logic gate. The universality and programmability could be exploited to design logic circuits containing fewer components than are required for conventional transistor-based circuits performing the same logic functions. The second-mentioned previous article reported results of a comparative study of NOT-majority-gate (G(sup 4) FET) -based logic-circuit designs and equivalent NOR- and NAND-gate-based designs utilizing conventional transistors. [NOT gates (inverters) were also included, as needed, in both the G(sup 4) FET- and the NOR- and NAND-based designs. ] In most of the cases studied, fewer logic gates (and, hence, fewer transistors), were required in the G(sup 4) FET-based designs. There are two popular categories of FPGA block structures or architectures: one based on multiplexers, the other based on lookup tables. In standard multiplexer- based architectures, the basic building block is a tree-like configuration of multiplexers, with possibly a few additional logic gates such as ANDs or ORs. Interconnections are realized by means of programmable switches that may connect the input terminals of a block to output terminals of other blocks, may bridge together some of the inputs, or may connect some of the input terminals to signal sources representing constant logical levels 0 or 1. The left part of the figure depicts a four-to-one G(sup 4) FET-based multiplexer tree; the right part of the figure depicts a functionally equivalent four-to-one multiplexer based on conventional transistors. The G(sup 4) FET version would contains 54 transistors; the conventional version contains 70 transistors...|$|R
50|$|The 3830-2 {{connects to}} one, two or four <b>block</b> <b>multiplexer</b> {{channels}} and can attach {{any combination of}} up to four A-units, i.e., any combination of 3333s, 3340-A2s, or 3350-A2/A2Fs up {{to a maximum of}} 32 physical drives (up to 6 additional drives attached to each A-unit).|$|E
5000|$|A {{selector}} channel {{has only a}} single subchannel, and hence is only capable of executing one channel command at a time. It is normally used to attach fast devices that are not capable of exploiting a <b>block</b> <b>multiplexer</b> channel to suspend the connection, such as magnetic tape drives.|$|E
50|$|Channels {{differ in}} the number and type of {{concurrent}} I/O operations they support. In IBM terminology, a multiplexer channel supports a number of concurrent interleaved slow-speed operations, each transferring one byte from a device at a time. A selector channel supports one high-speed operation, transferring a block of data at a time. A <b>block</b> <b>multiplexer</b> supportes a number of concurrent high-speed operations.|$|E
5000|$|XCS {{inspired}} {{the development of}} a whole new generation of LCS algorithms and applications. In 1995, Congdon was the first to apply LCS to real-world epidemiological investigations of disease [...] followed closely by Holmes who developed the BOOLE++, EpiCS, and later EpiXCS for epidemiological classification. These early works inspired later interest in applying LCS algorithms to complex and large-scale data mining tasks epitomized by bioinformatics applications. In 1998, Stolzmann introduced anticipatory classifier systems (ACS) which included rules in the form of 'condition-action-effect, rather than the classic 'condition-action' representation. [...] ACS was designed to predict the perceptual consequences of an action in all possible situations in an environment. In other words, the system evolves a model that specifies not only what to do in a given situation, but also provides information of what will happen after a specific action will be executed. This family of LCS algorithms is best suited to multi-step problems, planning, speeding up learning, or disambiguating perceptual aliasing (i.e. where the same observation is obtained in distinct states but requires different actions). Butz later pursued this anticipatory family of LCS developing a number of improvements to the original method. [...] In 2002, Wilson introduced XCSF, adding a computed action in order to perform function approximation. [...] In 2003, Bernado-Mansilla introduced a sUpervised Classifier System (UCS), which specialized the XCS algorithm to the task of supervised learning, single-step problems, and forming a best action set. UCS removed the reinforcement learning strategy in favor of a simple, accuracy-based rule fitness as well as the explore/exploit learning phases, characteristic of many reinforcement learners. Bull introduced a simple accuracy-based LCS (YCS) and a simple strength-based LCS Minimal Classifier System (MCS) in order to develop a better theoretical understanding of the LCS framework. Bacardit introduced GAssist and BioHEL, Pittsburgh-style LCSs designed for data mining and scalability to large datasets in bioinformatics applications. In 2008, Drugowitsch published the book titled [...] "Design and Analysis of Learning Classifier Systems" [...] including some theoretical examination of LCS algorithms. [...] Butz introduced the first rule online learning visualization within a GUI for XCSF (see the image {{at the top of this}} page). Urbanowicz extended the UCS framework and introduced ExSTraCS, explicitly designed for supervised learning in noisy problem domains (e.g. epidemiology and bioinformatics). [...] ExSTraCS integrated (1) expert knowledge to drive covering and genetic algorithm towards important features in the data, (2) a form of long-term memory referred to as attribute tracking, allowing for more efficient learning and the characterization of heterogeneous data patterns, and (3) a flexible rule representation similar to Bacardit's mixed discrete-continuous attribute list representation. [...] Both Bacardit and Urbanowicz explored statistical and visualization strategies to interpret LCS rules and perform knowledge discovery for data mining. [...] Browne and Iqbal explored the concept of reusing building blocks in the form of code fragments and were the first to solve the 135-bit mulitplexer benchmark problem by first learning useful building <b>blocks</b> from simpler <b>multiplexer</b> problems. ExSTraCS 2.0 was later introduced to improve Michigan-style LCS scalability, successfully solving the 135-bit multiplexer benchmark problem for the first time directly. [...] The n-bit multiplexer problem is highly epistatic and heterogeneous, making it a very challenging machine learning task.|$|R
50|$|IBM {{introduced}} {{a new type of}} I/O channel on the Model 85 and Model 195: the 2880 <b>block</b> <b>multiplexer</b> channel. The channel allowed a device to suspend a channel program, pending the completion of an I/O operation and thus to free the channel for use by another device. These channels could support either standard 1.5 MB/second connections or, with the 2-byte interface feature, 3 MB/second; the later used one tag cable and two bus cables.|$|E
50|$|Symmetrix arrays, EMC's {{flagship}} product at that time, began shipping in 1990 as a storage array connected to an IBM mainframe via the <b>block</b> <b>multiplexer</b> channel. Newer generations of Symmetrix brought additional host connection protocols which include ESCON, SCSI, Fibre Channel-based storage area networks (SANs), FICON and iSCSI. The Symmetrix product was initially popular within {{the airline industry}} and with companies that were willing to deviate {{from the safety of}} IBM's 3390 disk subsystem and take a risk with the unproven Symmetrix array. This product is the main reason for the rapid growth of EMC in the 1990s, both in size and value, from a company valued {{hundreds of millions of dollars}} to a multi-billion company. Moshe Yanai managed the Symmetrix development from the product's inception in 1987 until shortly before leaving EMC in 2001, and his Symmetrix development team grew from several people to thousands.|$|E
50|$|The 1100/80 {{introduced}} a high speed cache memory - the SIU or Storage Interface Unit. The SIU was logically and physically positioned between the CAU(s)/IOU(s) and the Main Memory units. The {{first version of}} the 1100/80 system could be expanded {{to a maximum of}} two CAUs, and two IOUs. A later version was expandable to four CAUs and four IOUs. The CAU was capable of executing both 36-bit 1100 series instructions, and 30-bit 490 series instructions. The IOU, or Input/Output Unit was modular in design and could be configured with different Channel Modules to support varying I/O requirements. The Word Channel Module included four 1100 Series (parallel) Word Channels. <b>Block</b> <b>Multiplexer</b> and Byte Channel Modules allowed direct connection of high speed disk/tape systems, and low speed printers, etc. respectively. The Control/Maintenance Panel was now on the SIU, and provided a minimum of indicator/buttons since the system incorporated a mini-computer, based on the BC/7 (business computer) as a maintenance processor. This was used to load microcode, and for diagnostic purposes. The CAU, IOU, and SIU units were implemented using emitter-coupled logic (ECL) on high density multi-layer PC boards. The ECL circuitry utilized DC voltages of +0 and -2 volts, with the CAU requiring four 50 amp -2 volt power supplies. Power was 400 Hz, to reduce large scale DC power supplies.|$|E
40|$|International Telemetering Conference Proceedings / October 30 -November 02, 1989 / Town & Country Hotel & Convention Center, San Diego, CaliforniaIn {{order to}} support the higher {{telemetry}} rates and novel telemtry data structures anticipated in the 90 's, high performance, readily adapted telemetry processing systems will be required. In this paper, an advanced multiprocessor front end utilizing an open architecture based on Multibus II is described. The system employs primarily COTS hardware and software products, in addition to custom microprocessor-based frame synchronizer and <b>block</b> <b>multiplexer</b> channel interface boards. The system is designed to facilitate a modular, parallel approach to processing of incoming telemetry streams, and suppports connectivity options, including standard network interfaces to workstations, {{as well as the}} channel interface to host systems...|$|E
40|$|Today TCP/IP is {{the most}} {{commonly}} used network protocol suite in the area of research and development. Taking into account this evolution the KFA Jülich installed the IBM TCP/IP software on the IBM ES 9000 / 620 with VM and MVS operating system and connected the mainframe to the local Internet as soon as appropriate products were available. Starting with an IBM- 8232 communication controller, and followed by an IBM 3172 model 1 the communication throughput to the IBM mainframe was extended. Installing the IBM 3172 model 2 should be a further step to high bandwidth. The announcement of new features of the IBM RISC/System 6000, particularly <b>block</b> <b>multiplexer</b> channel adapter to VM systems and FDDI single ring adapter, led to the questions regarding price/performance relationship of the RISC/System 6000 solution in comparison to an IBM 3172 model 2 and later on to an IBM 3172 model 3 communication controller solution. This report presents the results of some test series regarding the RISC/System 6000 / 32 H as an FDDI station and its operation as a BMPX to FDDI gateway. It further concludes with experiences in using two IBM RISC/System 6000 / 350 as BMPX to FDDI gateways for VM and MVS in a production environment. The experiences will be set into relation to the currently known performance of a connection via an IBM 3172 model 2 and IBM 3172 model 3...|$|E
40|$|Carry Select Adder {{is one of}} {{the fastest}} adders used in many data-processing {{processors}} to perform fast arithmetic functions. Carry select adder(CSLA) is used to increase the speed of a parallel adder that expands area in favour of speed. CSLA is used in many computational systems to alleviate the problem of carry propagation delay by independently generating multiple carriers and then select a carry to generate the sum. The problem raised in CSLA is not area efficient because it uses multiple pairs of Ripple carry adders (RCA) to generate the partial sum and carry which are selected by the multiplexer. Square Root CSLA is constructed by equalising the delay through two carry chains and the <b>block</b> <b>multiplexer</b> signal from previous stage. This is an extension of linear CSLA which improves the delay time greatly. By using SQRT CSLA, the time can be improved, as the time waiting for carry bit is used to calculate an extra input bit in each stage. The main disadvantage in the SQRT CSLA is duplication of adders is done. By this duplication the size of the adder is bigger and takes more space than standard ripple adder. This disadvantage is overcome by using Binary to Excess- 1 convertor for RCA with cin= 1 to optimise the area and delay. This modified design will reduce area and power as compared with regular SQRT CSLA with only a slight increase in delay. Based on this modification 8, 16, 32, 64, 128 -b SQRT CSLA architecture and simulation will be developed and compare with regular SQRT CSL...|$|E

