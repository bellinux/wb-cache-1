36|8|Public
2500|$|Soon after {{promulgation}} of the PCI specification, it {{was discovered}} that lengthy transactions by some devices, due to slow acknowledgments, long data bursts, or some combination, could cause <b>buffer</b> <b>underrun</b> or overrun in other devices. [...] Recommendations on the timing of individual phases in Revision 2.0 were made mandatory in revision 2.1: ...|$|E
5000|$|<b>Buffer</b> <b>underrun</b> protection: When a <b>buffer</b> <b>underrun</b> occurs, {{the drive}} suspends writing. The drive memorizes the end writing point and timing, and {{immediately}} resumes writing from that exact point when sufficient data is {{filled in the}} buffer memory.|$|E
5000|$|Various {{recorders}} minimize or {{cope with}} <b>buffer</b> <b>underrun</b> {{in the following}} ways: ...|$|E
50|$|<b>Buffer</b> <b>underruns</b> {{are often}} the result of {{transitory}} issues involving the connection which is being buffered: either a connection between two processes, with others competing for CPU time, or a physical link, with devices competing for bandwidth.|$|R
5000|$|Professionally encoded videos average a bitrate of 4-5 Mbit/s with {{a maximum}} of 7-8 Mbit/s in high-action scenes. Encoding at less than the max bitrate (like this) is {{typically}} done to allow greater compatibility among players, and to help prevent <b>buffer</b> <b>underruns</b> {{in the case of}} dirty or scratched discs ...|$|R
50|$|In {{the late}} 1990s, <b>buffer</b> <b>underruns</b> became {{a very common}} problem as {{high-speed}} CD recorders {{began to appear in}} home and office computers, which—for a variety of reasons—often could not muster the I/O performance to keep the data stream to the recorder steadily fed. The recorder, should it run short, would be forced to halt the recording process, leaving a truncated track that usually renders the disc useless.|$|R
50|$|DVD+R, DVD+RW and the {{recordable}} Blu-ray formats are {{immune from}} <b>buffer</b> <b>underrun</b> as these discs contain technology {{that allows the}} recorder's write mechanism to precisely locate {{the end of the}} recorded track and to seamlessly carry on from where it left off. Many disc authoring utilities 'grey out' the <b>buffer</b> <b>underrun</b> protection option when these discs are being written.|$|E
50|$|SafeBurn is a {{proprietary}} technology for <b>buffer</b> <b>underrun</b> protection developed by Yamaha Corporation.|$|E
50|$|BURN-Proof (Buffer Underrun-Proof) is a {{proprietary}} technology for <b>buffer</b> <b>underrun</b> protection developed by Sanyo.|$|E
40|$|Video {{streaming}} is in {{high demand}} by mobile users, as recent studies indicate. In cellular networks, however, the unreliable wireless channel leads to two major problems. Poor channel states degrade video quality and interrupt the playback when a user cannot sufficiently fill its local playout buffer: <b>buffer</b> <b>underruns</b> occur. In contrast to that, good channel conditions cause common greedy buffering schemes to pile up very long buffers. Such over-buffering wastes expensive wireless channel capacity. To keep buffering in balance, we employ a novel approach. Assuming that we can predict data rates, we plan the quality and download time of the video segments ahead. This anticipatory scheduling avoids <b>buffer</b> <b>underruns</b> by downloading {{a large number of}} segments before a channel outage occurs, without wasting wireless capacity by excessive buffering. We formalize this approach as an optimization problem and derive practical heuristics for segmented video streaming protocols (e. g., HLS or MPEG DASH). Simulation results and testbed measurements show that our solution essentially eliminates playback interruptions without significantly decreasing video quality...|$|R
40|$|Abstract—HTTP {{adaptive}} {{video streaming}} {{has become the}} de facto standard for media data delivery in the Internet. Mobile users are increasingly accessing video streaming services while traveling in fast-moving vehicles (e. g., public transport). The inherent high-speed mobility in these scenarios escalates bandwidth uncertainty and seriously degrades the performance of HTTP adaptive video streaming. This paper proposes a location window based geo-intelligent adaptive streaming algorithm, which adapts to the geo-spatial bandwidth variations experienced by a fast-moving user by adjusting {{the quality of the}} next chunk based on the estimated bandwidth at the next X locations of the mobile user. In order to realize geo-intelligence, we introduce a neural network model for accurately creating bandwidth maps that store location-specific bandwidth knowledge. By incorporating both these contributions in conjunction with real-world mobile broadband bandwidth traces from a metropolitan area, we present a systematic study to explore the effects of varying the size of the location window on the user-perceived Quality of Experience (QoE). The evaluation results demonstrate that an optimum location window can be identified, which can almost entirely eliminate playout <b>buffer</b> <b>underruns,</b> thus leading to a smooth and high-quality streaming experience. I...|$|R
40|$|With the {{widespread}} deployment of high-data rate mobile networks and {{the ubiquity of}} mobile devices such as tablets and smartphones, {{it is no surprise}} that video streaming has emerged as the fastest growing mobile application. HTTP adaptive video streaming technology has become the de facto standard for media data delivery. In particular, mobile users are increasing accessing video streaming services while traveling in fast-moving vehicles (e. g., public transport). While travelling at vehicular speed, a mobile user changes his geographic location at a fast rate. Since wireless link quality is sensitive to location along a route, rapid location change introduces frequent variation in link quality, which ultimately results increased instability for the mobile bandwidth. Hence, the inherent high-speed mobility in these scenarios escalates bandwidth uncertainty and seriously degrades the performance of HTTP adaptive video streaming. This thesis proposes a location window based geo-intelligent adaptive streaming algorithm, which adapts to the geo-spatial bandwidth variations experienced by a fast-moving user by adjusting the quality of the next chunk based on the estimated bandwidth at the next X locations of the mobile user. In order to realise geo-intelligence, this research introduces a neural network model for accurately creating bandwidth maps that store location-specific bandwidth knowledge. By incorporating both these contributions in conjunction with real-world mobile broadband bandwidth traces collected from a metropolitan area (i. e. Sydney), we present a systematic study to explore the effects of varying the size of the lo- cation window on the user-perceived Quality of Experience (QoE). Through comprehensive trace-driven simulations, our evaluation results demonstrate that an optimum location window can be identified, which can almost entirely eliminate playout <b>buffer</b> <b>underruns,</b> thus leading to a smooth and high-quality streaming experience...|$|R
5000|$|Power Burn is a {{proprietary}} technology for <b>buffer</b> <b>underrun</b> protection, developed by Sony. Features: ...|$|E
5000|$|Some {{recorders}} are, in fact, {{able to stop}} {{writing in}} the middle of a session, and resume writing whenever the buffer is refilled. Recorders with such <b>buffer</b> <b>underrun</b> protection handle the interruption with an extremely small gap in the recorded track on the disc. [...] Since the techniques for protecting against <b>buffer</b> <b>underrun</b> are proprietary and vendor-specific, technical details vary.|$|E
50|$|In {{terms of}} {{concurrent}} programming, a <b>buffer</b> <b>underrun</b> {{can be considered}} a form of resource starvation.|$|E
40|$|FyLasso Antivulnerability is a {{software}} utility, developed for Windows XP and Windows Server 2003, which protects from 0 -days, worms and malicious hackers. FyLasso uses a periodically updated Attack Vectors Database to search your computer for potential software vulnerabilities. Every potential vulnerability found is protected from exploitation using FyLasso’s Proactive Real-time Defense System (PRDS). The {{purpose of this}} paper is to provide a technical explanation of FyLasso and PRDS. 1 1 What is the problem being solved? The software running on todays computer systems contain bugs. These software bugs are errors during programming or design of an application [2]. Some types of bugs, called software vulnerabilities, are exploited by worms and malicious hackers. Software vulnerabilities allow arbitrary code execution to occur resulting in the primary reason why computers are insecure. The following sections explain how FyLasso Antivulnerability (FyLasso) detects potential software vulnerabilities and prevents arbitrary code execution from occuring thus protecting computers from attack. 2 The Attack Vectors Database FyLasso organizes software bugs into attack vectors. Each attack vector contains a unique set of adjacent assembly instructions, consisting of a variety of <b>buffer</b> overruns, <b>buffer</b> <b>underruns</b> and integer overflows. One of the most commonly attacked bug used to penetrate into computer systems is the buffer overflow [7, 10]. Listing 1 contains three examples of common buffer overflow attack vectors. Listing 1 : Example Buffer Overflow Attack Vectors 004030 DC mov ch, byte [eax] 004030 DE mov byte [ebx], ch 004030 E 0 i n c eax 004030 E 1 i n c ebx 004030 E 2 t e s t ch, ch 004030 E 4 jnz 004030 DC 004012 F 0 rep movsd 004012 F 2 mov ecx, eax 004012 F 4 and ecx, 3 004012 F 7 rep movsb 00400087 mov dl, byte [eax] 00400089 mov byte [ecx+eax], dl 0040008 C i n c eax 0040008 D t e s t dl, d...|$|R
5000|$|The buffer in {{an audio}} {{controller}} is a ring <b>buffer.</b> If an <b>underrun</b> occurs and the audio controller is not stopped, it will either keep repeating the sound {{contained in the}} buffer, which may hold {{a quarter of a}} second, or replace by silence depending on the implementation. Such effect is commonly referred to as [...] "machinegun" [...] or Max Headroom stuttering effect. This happens if the operating system hangs during audio playback. An error handling routine (e.g. blue screen of death) may eventually stop the audio controller.|$|R
50|$|A <b>buffer</b> <b>underrun</b> {{occurs during}} {{recording}} if {{the supply of}} data to the recorder is interrupted before the write is complete. Software typically moves the {{data to be recorded}} into a buffer; underrun occurs if the recorder processes data in the buffer faster than the software reloads it. Historically, <b>buffer</b> <b>underrun</b> was often caused by writing data obtained from a slow device, or by slowness of the recording software, from a slow processor or a processor executing other tasks concurrently.|$|E
50|$|They {{were also}} {{popular in the}} early ages of CD burning; early CD writers ruined the disk when a <b>buffer</b> <b>underrun</b> occurred, which could happen during the hard drive's {{automatic}} calibration.|$|E
50|$|Recording {{software}} maintains larger buffers {{than when}} CD recorders were first introduced. Some recorders maintain their own buffer memory {{independently of the}} computer. This additional buffering ensures that momentary pauses in the supply of data do not cause <b>buffer</b> <b>underrun.</b>|$|E
50|$|The terms <b>buffer</b> <b>underrun</b> and buffer {{underflow}} {{are also used}} to mean buffer underwrite, a condition similar to buffer overflow, but where the program is tricked into writing {{before the beginning of}} the buffer, overriding potential data there, like permission bits.|$|E
50|$|A runt {{frame is}} an Ethernet frame {{that is less}} than the IEEE 802.3's minimum length of 64 octets. Runt frames are most {{commonly}} caused by collisions; other possible causes are a malfunctioning network card, <b>buffer</b> <b>underrun,</b> duplex mismatch or software issues.|$|E
5000|$|Flow control: The rate of data {{transmission}} between two nodes must sometimes be managed {{to prevent a}} fast sender from transmitting more data than can be supported by the receiving data buffer, causing a buffer overrun. This {{can also be used}} to improve efficiency by reducing <b>buffer</b> <b>underrun.</b>|$|E
5000|$|Soon after {{promulgation}} of the PCI specification, it {{was discovered}} that lengthy transactions by some devices, due to slow acknowledgments, long data bursts, or some combination, could cause <b>buffer</b> <b>underrun</b> or overrun in other devices. Recommendations on the timing of individual phases in Revision 2.0 were made mandatory in revision 2.1: ...|$|E
50|$|<b>Buffer</b> <b>underrun</b> is {{minimized}} by {{a strategy}} {{in which the}} recorder burns a packet rather than an entire session or an entire disc. When using rewritable media (CD-RW, DVD-RW, DVD-RAM), the UDF file system organizes the disc into packets that are written individually. The packets are referenced by a single, updated address table.|$|E
50|$|If the framebuffer of the {{graphics}} controller is not updated, {{the picture of}} the computer screen will appear to hang until the buffer receives new data. Many video player programs (e.g. MPlayer) feature the ability to drop frames if the system is overloaded, intentionally allowing a <b>buffer</b> <b>underrun</b> to keep up the tempo.|$|E
5000|$|... growisofs has a {{built-in}} dd, which is the low-level process for sending data to the writer. This uses two buffers, the Ring Buffer (the growisofs program's software buffer) and the Unit Buffer (the drive's internal hardware buffer), and to prevent <b>buffer</b> <b>underrun,</b> these buffers must be kept filled. This is monitored and displayed in the status line as the RBU ("Ring Buffer Utilisation") and UBU ("Unit Buffer Utilisation").|$|E
50|$|Laser {{printing}} {{differs from}} other printing technologies in that each page is always rendered {{in a single}} continuous process without any pausing in the middle, while other technologies like inkjet can pause every few lines. To avoid a <b>buffer</b> <b>underrun</b> (where the laser reaches a point on the page before it has the dots to draw there), a laser printer typically needs enough raster memory to hold the bitmap image of an entire page.|$|E
50|$|Windows Vista {{binaries}} include intrinsic {{support for}} detection of stack-overflow. When a stack overflow in Windows Vista binaries is detected, {{the process is}} killed so that it cannot be used {{to carry on the}} exploit. Also Windows Vista binaries place buffers higher in memory and non buffers, like pointers and supplied parameters, in lower memory area. So to actually exploit, a <b>buffer</b> <b>underrun</b> is needed to gain access to those locations. However, buffer underruns are much less common than buffer overruns.|$|E
50|$|While drives {{are burning}} DVD+R, DVD+RW and all Blu-ray formats, {{they do not}} require any such error {{correcting}} recovery as the recorder is able to place the new data exactly {{on the end of}} the suspended write effectively producing a continuous track (this is what the DVD+ technology achieved). Although later interfaces were able to stream data at the required speed, many drives now write in a 'zoned constant linear velocity'. This means that the drive has to temporarily suspend the write operation while it changes speed and then recommence it once the new speed is attained. This is handled in the same manner as a <b>buffer</b> <b>underrun.</b>|$|E
50|$|In computing, <b>buffer</b> <b>underrun</b> or buffer {{underflow}} {{is a state}} occurring when a buffer used to communicate between two devices or processes is fed with data at a lower speed than the data is being read from it. (The term is distinct from buffer overflow, a condition where a portion of memory {{being used as a}} buffer has a fixed size but is filled with more than that amount of data.) This requires the program or device reading from the buffer to pause its processing while the buffer refills. This can cause undesired and sometimes serious side effects because the data being buffered is generally not suited to stop-start access of this kind.|$|E
50|$|Buffer underruns {{can cause}} serious {{problems}} during CD/DVD burning, because once {{the writing is}} started, it cannot stop and resume flawlessly; thus the pause needed by the underrun can cause the data on the disc to become invalid. Since the buffer is generally being filled from a relatively slow source, such as a hard disk or another CD/DVD, a heavy CPU or memory load from other concurrent tasks can easily exhaust the capacity of a small buffer. Therefore, a technique called <b>buffer</b> <b>underrun</b> protection was implemented by various individual CD/DVD writer vendors, under various trademarks, such as Plextor BurnProof, Nero UltraBuffer, Yamaha SafeBurn, JustLink, and Seamless Link. With this technique, the laser is indeed able to stop writing for any {{amount of time and}} resume when the buffer is full again. The gap between successive writes is extremely small.|$|E
50|$|Windows XP {{includes}} {{technology from}} Roxio which {{allows users to}} directly burn files to a compact disc through Windows Explorer. Previously, end users had to install CD burning software. In Windows XP, CD and DVD-RAM (FAT32 only for DVD-RAM) burning has been directly integrated into the Windows interface. Data discs are created using the Joliet and ISO 9660 file systems and audio CDs using the Redbook standard. To prevent <b>buffer</b> <b>underrun</b> errors, Windows XP premasters a complete image of files to be burnt and then streams it to the disc burner. Users can burn files to a CD {{in the same way}} they write files to a floppy disk or to the hard drive via standard copy-paste or drag and drop methods. The burning functionality is also exposed as an API called the Image Mastering API. Windows XP's CD burning support does not do disk-to-disk copying or disk images, although the API can be used programmatically to do these tasks. Creation of audio CDs is integrated into Windows Media Player. Audio CDs are burnt using track-at-once mode. CD-RW discs can be quick erased.|$|E
5000|$|The {{simplest}} {{guard against}} such problems {{is to increase}} the size of the buffer—if an incoming data stream needs to be read at 1 bit per second, a buffer of 10 bits would allow the connection to be blocked for up to 10 seconds before failing, whereas one of 60 bits would allow a blockage of up to a minute. However, this requires more memory to be available to the process or device, which can be expensive. It assumes that the buffer starts full—requiring a potentially significant pause before the reading process begins—and that it will always remain full unless the connection is currently blocked. If the data does not, on average, arrive faster than it is needed, any blockages on the connection will be cumulative; [...] "dropping" [...] one bit every minute on a hypothetical connection with a 60-bit buffer would lead to a <b>buffer</b> <b>underrun</b> if the connection remained active for an hour. In real-time applications, a large buffer size also increases the latency between input and output, which is undesirable in low-latency applications such as video conferencing.|$|E
50|$|In {{the early}} 1920s, George O. Squier was granted patents {{for a system}} for the {{transmission}} and distribution of signals over electrical lines which was the technical basis for what later became Muzak, a technology streaming continuous music to commercial customers {{without the use of}} radio. Attempts to display media on computers date back to the earliest days of computing in the mid-20th century. However, little progress was made for several decades, primarily due to the high cost and limited capabilities of computer hardware. From the late 1980s through the 1990s, consumer-grade personal computers became powerful enough to display various media. The primary technical issues related to streaming were: having enough CPU power and bus bandwidth to support the required data rates and creating low-latency interrupt paths in the operating system to prevent <b>buffer</b> <b>underrun</b> and thus enable skip-free streaming of the content. However, computer networks were still limited in the mid-1990s, and audio and video media were usually delivered over non-streaming channels, such as by downloading a digital file from a remote server and then saving it to a local drive on the end user's computer or storing it as a digital file and playing it back from CD-ROMs.|$|E
40|$|In {{this work}} {{we present a}} quality driven {{approach}} to DASH (Dynamic Adaptive Streaming over HTTP) for segment selection in varying network conditions. Current adaption algorithms focus largely on regulating data rates using network layer parameters by selecting the level of quality on offer that can eliminate <b>buffer</b> <b>underrun</b> without considering picture fidelity. In reality, viewers may accept a level of <b>buffer</b> <b>underrun</b> {{in order to achieve}} an improved level of picture fidelity. In this case, the conventional DASH algorithms can cause extreme degradation of the picture fidelity when attempting to eliminate <b>buffer</b> <b>underrun</b> with scarce bandwidth availability. Our work is concerned with a quality-aware rate adaption scheme that maximizes the client's quality of experience in terms of both continuity and fidelity (picture quality). Results show that the scheme proposed can maintain a high level of quality for streaming services, especially at low packet loss rates. It is also shown that by eliminating <b>buffer</b> <b>underrun</b> completely, the PSNR that reflects the picture quality of the video is greatly reduced. Our scheme offers the offset between continuity-based quality and resolution-based quality, which can be used to set threshold values for the level of quality desired by clients with different quality requirements...|$|E
