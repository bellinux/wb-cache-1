11|58|Public
5000|$|Block mode: FTP {{breaks the}} data into several blocks (<b>block</b> <b>header,</b> byte count, and data field) and then passes {{it on to}} TCP.|$|E
50|$|If service_number is 7, {{then the}} extended_service_number is added and {{used instead of}} the service_number. If block_size is 0, the service_number must be zero as well with no block_data present. This {{is known as a}} Null Service <b>Block</b> <b>Header,</b> which is used for padding the packet, when no {{captions}} are sent.|$|E
50|$|As for Huffman coding, {{modifying the}} {{probability}} distribution of tANS is relatively costly, hence it is mainly used in static situations, usually with some Lempel-Ziv scheme (e.g. ZSTD, LZFSE). In this case, the file {{is divided into}} blocks - {{for each of them}} symbol frequencies are independently counted, then after approximation (quantization) written in the <b>block</b> <b>header</b> and used as static probability distribution for tANS.|$|E
30|$|Group all {{predicted}} <b>block</b> <b>headers</b> in one header sub-bitstream.|$|R
40|$|Photograph (engineering {{notebook}} photoprint) of Los Angeles Street Railway in Pico Street {{just west}} of Westlake Boulevard, Los Angeles. "T" rail and granite <b>block</b> <b>headers.</b> Also visible are: billboards, automobiles, buildings, businesses, utility poles and lines, some trees, sidewalks, street lights. No legible signs...|$|R
50|$|The ZPAQ {{standard}} {{does not}} specify a compression algorithm. Rather, it specifies a format for representing the decompression algorithm in the <b>block</b> <b>headers.</b> Decompression algorithms {{are written in}} a language called ZPAQL and stored as a byte code which can either be interpreted or converted directly to 32 or 64 bit x86 code and executed. A ZPAQL program has 3 parts.|$|R
50|$|Most {{compressible}} {{data will}} end up being encoded using method , the dynamic Huffman encoding, which produces an optimised Huffman tree customised for each block of data individually. Instructions to generate the necessary Huffman tree immediately follow the <b>block</b> <b>header.</b> The static Huffman option is used for short messages, where the fixed saving gained by omitting the tree outweighs the percentage compression loss due to using a non-optimal (thus, not technically Huffman) code.|$|E
50|$|If {{the latest}} {{transaction}} in a coin is buried under enough blocks, the spent transactions {{before it can}} be discarded to save disk space. To facilitate this without breaking the block's hash, transactions are hashed in a Merkle Tree, with only the root included in the block's hash. Old blocks can then be compacted by stubbing off branches of the tree. The interior hashes {{do not need to be}} stored. A <b>block</b> <b>header</b> with no transactions would be about 80 bytes. If Vic Coin assume blocks are generated every 10 minutes, 80 bytes* 6* 24* 365 =4.2MB per year. With computer systems typically selling with 2GB of RAM as of 2008, and Moore's Law predicting current growth of 1.2 GB per year, storages should not be a problem even if the block headers must be kept in a memory.|$|E
50|$|The {{streaming}} archive {{format is}} designed to be extracted in a single pass. An archive is divided into a sequence of blocks that can be decompressed independently in parallel. Blocks are divided into segments that must be decompressed sequentially in order. Each <b>block</b> <b>header</b> contains a description of the decompression algorithm. Each segment has a header containing an optional file name and an optional comment for meta-data such as size, date, and attributes, and an optional trailing SHA-1 checksum of the original data for integrity checking. If the file name is omitted, it is assumed to be a continuation of the last named file, which may be in the previous block. Thus, inserting, removing, or reordering the blocks in a streaming archive has the effect of performing the same operations on the data that the blocks represent.|$|E
5000|$|SOAP header block: A SOAP header {{can contain}} {{more than one}} of these blocks, each being a {{discrete}} computational <b>block</b> within the <b>header.</b> In general, the SOAP role information is used to target nodes on the path. A <b>header</b> <b>block</b> is said to be targeted at a SOAP node if the SOAP role for the <b>header</b> <b>block</b> is the name of a role in which the SOAP node operates. (ex: A SOAP <b>header</b> <b>block</b> with role attribute as ultimateReceiver is targeted only at the destination node which has this role. A header with a role attribute as next is targeted at each intermediary as well as the destination node.) ...|$|R
2500|$|Any {{block size}} could be {{specified}} {{up to the}} maximum track length. [...] Since the <b>block</b> <b>headers</b> occupied space, the usable capacity of the drive was dependent on the block size. [...] Blocks ("records" [...] in IBM's terminology) of 88, 96, 880 and 960 were often used because they related to the fixed block size of 80- and 96-character punch cards. The drive capacity was usually stated under conditions of full track record blocking. For example, the 100-megabyte 3336 disk pack only achieved that capacity with a full track block size of 13,030 bytes.|$|R
50|$|Files are {{composed}} of a file <b>header</b> <b>block,</b> which contains information about the file (size, last access time, data block pointers, etc.), and the data blocks, which contain the actual data. The file <b>header</b> <b>block</b> contains up to BSIZE/4-56 data block pointers (which amounts to 72 entries with the usual 512 byte blocks). If a file is larger than that, file extension blocks will be allocated to hold the data block pointers. File extension blocks are organised in a linked list, which starts in the file <b>header</b> <b>block</b> ('extension' field).|$|R
50|$|In {{the book}} Programmers at Work, C. Wayne Ratliff {{discussed}} using the style below. The style begins much like 1TBS {{but then the}} closing brace lines up with the indent of the nested block. Ratliff was the original programmer behind the popular dBase-II and -III fourth-generation programming languages. He indicated that it was originally documented in material from Digital Research Inc. This style has sometimes been termed banner style, possibly for the resemblance to a banner hanging from a pole. In this style, which is to Whitesmiths as K&R is to Allman, the closing control is indented as the last item in the list (and thus properly loses salience). The style can make visual scanning easier for some, since the headers of any block are the only thing exdented at that level (the theory being that the closing control of the prior block interferes with the visual flow of the next <b>block</b> <b>header</b> in the K&R and Allman styles).|$|E
30|$|When {{the user}} {{is using the}} DRMChain platform, he/she firstly needs to {{register}} as user-level account, then he/she can commit his/her artwork, and the DRMChain will create the raw artwork and its corresponding blockchain data, which includes block data (<b>block</b> <b>header)</b> and the block transaction (block body).|$|E
30|$|Some pioneer {{work has}} been done to improve the {{efficiency}} of blockchain. Zyskind et al. (2015) proposed a lightweight blockchain architecture to protect personal data. They improved the efficiency of blockchain by using off-chain data storage and heavy processing. Only references to data and lightweight processing tasks were handled in the blockchain. Paul et al. (2014) proposed a new scheme that could lead to an energy-efficient Bitcoin. The authors modified added some extra bytes to the present <b>block</b> <b>header</b> to utilize the timestamp more effectively.|$|E
50|$|As {{noted in}} Nakamoto's whitepaper, it is {{possible}} to verify bitcoin payments without running a full network node (simplified payment verification, SPV). A user only needs a copy of the <b>block</b> <b>headers</b> of the longest chain, which are available by querying network nodes until it is apparent that the longest chain has been obtained. Then, get the Merkle branch linking the transaction to its block. Linking the transaction to a place in the chain demonstrates that a network node has accepted it, and blocks added after it further establish the confirmation.|$|R
2500|$|Data {{is stored}} {{on a hard}} drive {{in a series of}} logical blocks. [...] Each block is delimited by markers {{identifying}} its start and end, error detecting and correcting information, and space between blocks to allow for minor timing variations. [...] These blocks often contained 512 bytes of usable data, but other sizes have been used. [...] As drive density increased, an initiative known as Advanced Format extended the block size to 4096 bytes of usable data, with a resulting significant reduction in the amount of disk space used for <b>block</b> <b>headers,</b> error checking data, and spacing.|$|R
5000|$|In the 1960s most {{disk drives}} used IBM's {{variable}} block length format (called Count Key Data or [...] "CKD").Any block size could be specified {{up to the}} maximum track length. Since the <b>block</b> <b>headers</b> occupied space, the usable capacity of the drive was dependent on the block size. Blocks ("records" [...] in IBM's terminology) of 88, 96, 880 and 960 were often used because they related to the fixed block size of 80- and 96-character punch cards. The drive capacity was usually stated under conditions of full track record blocking. For example, the 100-megabyte 3336 disk pack only achieved that capacity with a full track block size of 13,030 bytes.|$|R
30|$|Distributed Ledger Technology (DLT) {{has gained}} a lot of {{interest}} recently. Going back to Satoshi Nakamotos Blockchain implementation Bitcoin (Nakamoto 2009), DLT combines peer-to-peer networks, cryptography and game theory to provide a distributed and immutable transaction storage. Bitcoin was designed as a currency system in which signed transactions are stored by combining a number of transactions in a so-called block. The transactions are stored in structure called merkle tree (Merkle 1987) that supports the integrity of the contained data and provides an efficient way to check the validity of the contained data. Each block is secured using an additional hash function that is created for the data of the <b>block</b> <b>header,</b> which includes the root of the merkle tree, and must fulfill certain characteristics. Each <b>block</b> <b>header</b> has a reference to the hash value of the previous block. This ensures both the chronological order and the data integrity of the entire database. So-called miners are searching for the hash value of a new block. This search is associated with the provision of a certain amount of resources, at least in permissionless environments. Once found, the users agree whether the transactions and the block hash and therefore the blocks are valid or not (the so-called consensus). If the block is valid it is attached to the chain and the successful miner receives a reward. This list of chained blocks is public and can be verified by all peers. With this concept, blockchains solve the problem of distributed consensus (described e.g. in Lamport (1998)).|$|E
40|$|Blockchain {{systems are}} {{designed}} to produce blocks at a constant average rate. The most popular systems currently employ a Proof of Work (PoW) algorithm {{as a means of}} creating these blocks. Bitcoin produces, on average, one block every 10 minutes. An unfortunate limitation of all deployed PoW blockchain systems is that the time between blocks has high variance. For example, 5 % of the time, Bitcoin's inter-block time is at least 40 minutes. This variance impedes the consistent flow of validated transactions through the system. We propose an alternative process for PoW-based block discovery that results in an inter-block time with significantly lower variance. Our algorithm, called Bobtail, generalizes the current algorithm by comparing the mean of the k lowest order statistics to a target. We show that the variance of inter-block times decreases as k increases. If our approach were applied to Bitcoin, about 80 % of blocks would be found within 7 to 12 minutes, and nearly every block would be found within 5 to 18 minutes; the average inter-block time would remain at 10 minutes. Further, we show that low-variance mining significantly thwarts doublespend and selfish mining attacks. For Bitcoin and Ethereum currently (k= 1), an attacker with 40 % of the mining power will succeed with 30 % probability when the merchant sets up an embargo of 8 blocks; however, when k>= 20, the probability of success falls to less than 1 %. Similarly, for Bitcoin and Ethereum currently, a selfish miner with 40 % of the mining power will claim about 66 % of blocks; however, when k>= 5, the same miner will find that selfish mining is less successful than honest mining. The cost of our approach is a larger <b>block</b> <b>header...</b>|$|E
40|$|Document image {{segmentation}} {{plays an important}} role in classification of journals, magazines, newspaper, etc., It is a process of splitting the document into distinct regions. Document layout analysis is a key process of identifying and categorizing the regions of interest in the scanned image of a text document. A reading system requires the segmentation of text zones from non-textual ones and the arrangement in their correct reading order. Detection and labelling of text zones play different logical roles inside the document such as titles, captions, footnotes, etc. This research work proposes a new approach to segment the document and classify the journals based on the <b>header</b> <b>block.</b> Documents are collected from different journals and used as input image. The image is segmented into <b>blocks</b> like heading, <b>header,</b> author name and footer using Particle Swarm optimization algorithm and features are extracted from <b>header</b> <b>block</b> using Gray Level Co-occurrences Matrix. Extreme Learning Machine has been used for classification based on the <b>header</b> <b>blocks</b> and obtained 82. 3 % accuracy...|$|R
5000|$|SOAP header : A {{collection}} {{of one or}} more <b>header</b> <b>blocks</b> targeted at each SOAP receiver.|$|R
40|$|The FIASCO system {{implements}} a machine-learning {{approach for}} the automatic removal of boilerplate (navigation bars, link lists, page headers and footers, etc.) from Web pages {{in order to}} make them available as a clean and useful corpus for linguistic purposes. The system parses an HTML document into a DOM tree representation and identifies a set of disjoint subtrees that correspond to text <b>blocks,</b> <b>headers</b> or list items. Each block is then represented as a vector of linguistic, structural and visual features. A support vector machine classifier is used to distinguish between “clean ” and “dirty ” blocks. Dirty blocks are removed from the HTML tree before it is passed to the Lynx browser for conversion into plain text. The SVM classifier was trained and evaluated on a manually cleaned dataset of 158 English Web pages, the FIASCO gold standard...|$|R
5000|$|SOAP body : Contains {{the body}} of the message {{intended}} for the SOAP receiver. The interpretation and processing of SOAP body is defined by <b>header</b> <b>blocks.</b>|$|R
5000|$|In the <b>header</b> <b>block,</b> {{the target}} name is {{replaced}} by the wildcard symbol [...] "*" [...] for broadcast messages.This {{is the case for}} tigger and status messages.|$|R
5000|$|Ultimate SOAP receiver: The {{destination}} receiver of the SOAP message. This node {{is responsible}} for processing the message body and any <b>header</b> <b>blocks</b> targeted at it [...]|$|R
5000|$|Header Contents $00-01: T/S {{reference}} to root directory block of this partition ($01/$24). 02: DOS Type ("H") 04-15: Disk label, $A0 padded 16-17: Disk ID 19-1A: DOS Version ("1H") 20-21: T/S {{reference to}} present directory <b>header</b> <b>block</b> 22-23: T/S reference to parent directory <b>header</b> <b>block</b> (set to $00/$00 when {{at the top}} of the directory) 24-25: T/S reference to dir entry in previous directory (set to $00/$00 when {{at the top of}} the directory) 26: Index to parent directory entry ($00 at the top) AB-AC: GEOS border sector AD-BC: GEOS format string (GEOS format Vx.x) ...|$|R
50|$|DIP <b>header</b> <b>blocks</b> on {{to which}} {{discrete}} components could be soldered were used where groups of components {{needed to be}} easily removed, for configuration changes, optional features or calibration.|$|R
30|$|Each {{image data}} will be stored in a file in the Flexible Image Transport System (FITS) format, which is {{composed}} of an image data <b>block</b> and a <b>header</b> <b>block.</b> The data block contains radiances or brightness temperatures for all pixels, which were converted from raw counts based on a calibration table. The <b>header</b> <b>block</b> contains ancillary information such {{as the time of}} the exposure, the filter selection, the instrument status, the geometry of observation, and the orbital information. In addition to these FITS image files, we will prepare an additional FITS file for each image, which contains the latitudes, the longitudes, the incident angles, the emission angles, the phase angles, the azimuth angles between the incident and emission rays, and the local solar times for all points where the line of sights for the camera pixels intersect with reference altitude surfaces of the Venusian atmosphere. These level- 2 products will be archived in the Planetary Data System (PDS) or a system similar to PDS.|$|R
50|$|ISO 7200, titled Technical product {{documentation}} - Data {{fields in}} title <b>blocks</b> and document <b>headers,</b> {{is an international}} technical standard defined by ISO which describes title block formats {{to be used in}} technical drawings.|$|R
50|$|The {{journaling}} format {{consists of}} a sequence of transactions, or updates. An update contains 4 types of blocks: a transaction <b>header</b> <b>block,</b> a sequence of data blocks, a corresponding sequence of fragment tables, and a sequence of index <b>blocks.</b> A transaction <b>header</b> <b>block</b> contains the transaction date and a pointer skipping over the data blocks to allow the archive index to be read quickly. The data blocks contain a sequence of file fragments compressed together. The fragment tables give the size and SHA-1 hash of each fragment. The index blocks contain a list of edits to the global archive index. An edit is either a file update or a file deletion. An update includes a file name, last modified date, attributes, {{and a list of}} fragment pointers into the current and previous transactions. Fragments may be shared by more than one file. A deletion does not remove any data from the archive, but rather indicates that the file is not to be extracted unless the archive is rolled back to an earlier date.|$|R
5000|$|SOAP intermediary: All the nodes {{in between}} the SOAP {{originator}} and the intended SOAP destination. It processes the SOAP <b>header</b> <b>blocks</b> targeted at it and acts to forward a SOAP message towards an ultimate SOAP receiver.|$|R
50|$|It is {{possible}} to implement out-of-band data transmission using a physically separate channel, but most commonly out-of-band data is a feature provided by a transmission protocol using the same channel as normal data. A typical protocol might divide the {{data to be transmitted}} into blocks, which each <b>block</b> having a <b>header</b> word that identifies the type of data being sent, and a count of the data bytes or words to be sent in the <b>block.</b> The <b>header</b> will identify the data as being in-band or out-of-band, along with other identification and routing information. At the receiving end, the protocol looks at the header and routes the data to the normal reception endpoint if it is in-band, and to a separate mechanism if it is out-of-band. Depending on the implementation, there may be some mechanism for notifying or interrupting the receiving application when out-of-band data has arrived.|$|R
25|$|The pixels {{within each}} line are not interlaced, but {{presented}} consecutively {{from left to}} right. As with non-interlaced images, there is no break between the data for one line and {{the data for the}} next. The indicator that an image is interlaced is a bit set in the image's <b>header</b> <b>block.</b>|$|R
50|$|Settlements can be {{verified}} easily without running a full network node. A user only {{needs to keep}} {{a copy of the}} <b>block</b> <b>headers</b> of the longest proof-of-work chain, which he can obtain by querying network nodes until he is convinced he has the longest chain, and obtain the Merkle branch linking the transaction to the block it is time stamped in. He cannot check the transaction for himself, but by linking it to a place in the chain, he can see that a network node has accepted it, and blocks added after it further confirm the network has accept edit. Therefore, the verification is reliable as long as honest master nodes control the network, although it is more vulnerable if the network is over powered by an attacker. While network master nodes can verify transactions for themselves, the simplified method can be fooled by an attacker's fabricated transactions {{for as long as the}} attacker can continue to overpower the network. One strategy to protect against this would be to accept alerts from network master nodes when detect an invalid block, prompting the user's software to download the full block and alerted transactions to confirm the inconsistency. Businesses that receive frequent payments will probably still want to run the own nodes for more independent privacy, security and quicker verification.|$|R
50|$|If {{the file}} data {{is small enough}} to fit inside a tree node, it is instead pulled in-tree and stored inline in the extent data item. Each tree node is stored in its own tree block—a single {{uncompressed}} <b>block</b> with a <b>header.</b> The tree <b>block</b> is regarded as a free-standing, single-block extent.|$|R
