1|116|Public
5000|$|Development of the single-chip {{microprocessor}} was {{an enormous}} catalyst to the popularization of cheap, easy to use, and truly personal computers. The Altair 8800, introduced in a Popular Electronics magazine article in the January 1975 issue, at the time set a new low price point for a computer, bringing computer ownership to an admittedly select market in the 1970s. This {{was followed by the}} IMSAI 8080 computer, with similar abilities and limitations. The Altair and IMSAI were essentially scaled-down minicomputers and were incomplete: to connect a keyboard or teleprinter to them required heavy, expensive [...] "peripherals". These machines both featured a front panel with switches and lights, which communicated with the operator in binary. To program the machine after switching it on the <b>bootstrap</b> <b>loader</b> <b>program</b> had to be entered, without error, in binary, then a paper tape containing a BASIC interpreter loaded from a paper-tape reader. Keying the loader required setting a bank of eight switches up or down and pressing the [...] "load" [...] button, once for each byte of the program, which was typically hundreds of bytes long. The computer could run BASIC programs once the interpreter had been loaded.|$|E
50|$|The small {{program that}} starts this {{sequence}} {{is known as}} a <b>bootstrap</b> <b>loader,</b> <b>bootstrap</b> or boot <b>loader.</b> This small <b>program's</b> only job is to load other data and programs which are then executed from RAM. Often, multiple-stage boot loaders are used, during which several programs of increasing complexity load one after the other in a process of chain loading.|$|R
50|$|The {{operator}} then {{removed the}} bootstrap tape, snapped {{in the tape}} containing the regular loader, carefully arranging it so it wouldn't jam, and pressed a few more buttons to start up the bootstrap program. Once the regular loader was in, the computer was ready to read in a program tape. The regular loader read a more compact format tape than the <b>bootstrap</b> <b>loader.</b> Each block began with a starting address so the tape could be rewound and retried if an error occurred. If any mistakes {{were made in the}} process, or if the program crashed and damaged the <b>loader</b> <b>program,</b> the process had to be restarted from the beginning.|$|R
5000|$|... 0x0C00-0x0FFF : 1024 bytes of <b>bootstrap</b> <b>loader</b> ROM (flash parts only).|$|R
50|$|These {{techniques}} could {{generally be}} easily circumvented since the code {{to read the}} bad sectors was usually in the <b>bootstrap</b> <b>loader</b> on the disk itself, so by reverse engineering and rewriting the <b>bootstrap</b> <b>loader,</b> it would not look for the bad sectors, and the comparison for a known bit pattern {{would have to be}} encoded there, too.|$|R
40|$|The MSP 430 <b>bootstrap</b> <b>loader</b> (BSL) enables {{users to}} {{communicate}} with embedded memory in the MSP 430 microcontroller during the prototyping phase, final production, and in service. Both the programmable memory (flash memory) and the data memory (RAM) can be modified as required. The commonly used UART protocol with RS 232 interfacing is supported, allowing flexible use of both hardware and software. To use the <b>bootstrap</b> <b>loader,</b> a specific BSL entry sequence has {{to be applied to}} specific device pins. An added sequence of commands initiates the desired function. A boot loading session can be exited by continuing operation at a defined user program address, or by the reset condition. Access to the MSP 430 memory via the <b>bootstrap</b> <b>loader</b> is protected against misuse by a...|$|R
50|$|A RAM {{image is}} a {{sequence}} of machine code instructions and associated data kept permanently in the non-volatile ROM memory of an embedded system, which is copied into volatile RAM by a <b>bootstrap</b> <b>loader.</b> Typically the RAM image is loaded into RAM when the system is switched on, and it contains a second-level <b>bootstrap</b> <b>loader</b> and basic hardware drivers, enabling the unit to function as desired, or else more sophisticated software to be loaded into the system.|$|R
50|$|In {{the case}} of a computer, the POST {{routines}} are part of a device's pre-boot sequence; if they complete successfully, the <b>bootstrap</b> <b>loader</b> code is invoked to load an operating system.|$|R
40|$|The <b>bootstrap</b> <b>loader</b> (sometimes {{called the}} bootloader) of the MSP 430 {{derivatives}} with flash memory allows {{access to their}} embedded memories during prototyping, production, and in the field. It is possible to download or modify code in flash memory (electrically-erasable and programmable memory) or to store calibration data or other system-relevant data in flash memory or in RAM. This application note describes simple and low-cost hardware and software solutions to access the <b>bootstrap</b> <b>loader</b> functions of the MSP 430 flash devices via the serial port (RS- 232) of a personal computer (PC). The description provided and the C-source code o...|$|R
5|$|The default <b>bootstrap</b> <b>loader</b> is GNU GRUB version 2, {{though the}} package name is simply grub, while version 1 was renamed to grub-legacy. This {{conflicts}} with e.g. Fedora, where grub version 2 is named grub2.|$|R
40|$|<b>Bootstrap</b> <b>loader</b> and mode-control {{options for}} Adage Graphics Computer System Significantly simplify {{operations}} procedures. Normal load and control functions are performed {{quickly and easily}} from control console. Operating characteristics of revised system include greatly increased speed, convenience, and reliability...|$|R
50|$|The <b>bootstrap</b> <b>loader</b> {{takes the}} {{control over the}} booting process and loads NTLDR.Ntdetect.com is invoked by NTLDR, and returns the {{information}} it gathers to NTLDR when finished, {{so that it can}} then be passed on to ntoskrnl.exe, the Windows NT kernel.|$|R
50|$|The MBR {{is loaded}} at memory {{location}} 0000hex:7C00hex {{and with the}} following CPU registers set up when the prior <b>bootstrap</b> <b>loader</b> (normally the IPL in the BIOS) passes execution to it by jumping to 0000hex:7C00hex in the CPU's real mode.|$|R
50|$|The VBR {{is loaded}} at memory {{location}} 0000h:7C00h {{and with the}} following CPU registers set up when the prior <b>bootstrap</b> <b>loader</b> (that is, typically the BIOS or MBR, but possibly another boot loader) passes execution to it by jumping to 0000h:7C00h in the CPU's real mode.|$|R
5000|$|Booting. Early {{microcomputers}} {{often used}} self-modifying code in their bootloaders. Since the bootloader was keyed in via the front panel at every power-on, {{it did not}} matter if the bootloader modified itself. However, even today many <b>bootstrap</b> <b>loaders</b> are self-relocating, and a few are even self-modifying.|$|R
50|$|As {{initially}} {{introduced the}} Level 6 {{consisted of three}} models: the 6/06, the 6/34, and the 6/36. The CPU featured a real-time clock, a ROM <b>bootstrap</b> <b>loader</b> and 64 interrupt levels. The architecture provided a variety of addressing modes and 18 programmer-visible registers. Rack-mount and tabletop versions were available.|$|R
5000|$|The CPU had a microprocessor, {{which was}} {{defined in the}} manual as a {{portmanteau}} of [...] "microcode processor" [...] - {{not to be confused}} with the then nascent microprocessor. The CPU additionally contained instructions, operator communication, <b>bootstrap</b> <b>loaders,</b> and hardware test programs, that were implemented in a 1K read-only memory.|$|R
50|$|In general, {{there are}} two types of class loader: <b>bootstrap</b> class <b>loader</b> and user defined class loader.|$|R
50|$|There was a {{hierarchy}} of device drivers: those ending in Z were for Fortran, such as DISKZ, while assembler programmers might use DISK0, and DISK1 was even faster at reading multiple disk sectors. But DISKZ started its sector addressing with the first available unused sector, while the others started with sector zero of the disk, making it easy for a Fortran programmer dabbling in assembler to inadvertently overwrite the <b>bootstrap</b> <b>loader.</b>|$|R
5000|$|The DMA {{controller}} {{also provides}} a special [...] "load mode", which allows loading of memory while the CLEAR and WAIT inputs of the processor are active. This allows a program to be loaded {{without the need for}} a ROM-based <b>bootstrap</b> <b>loader.</b> This was used by the COSMAC Elf microcomputer and its successors to load a program from toggle switches or a hexadecimal keypad with no required software and minimal hardware.|$|R
40|$|Application Note This {{document}} {{describes the}} Altera Â® PROFINET reference design bootstrap process. Use this process when you require custom {{modifications to the}} Altera PROFINET reference design. 1 A complete <b>bootstrap</b> <b>loader</b> is included with the Altera PROFINET reference design. Overview Figure 1 shows the control blocks and interfaces in the PROFINET reference design, including the components that are instantiated as soft logic on the FPGA and the components that are located off the FPGA...|$|R
5000|$|A user would {{normally}} use the [...] "(L)oad" [...] command to load a <b>bootstrap</b> <b>loader</b> (i.e., for CP/M) from a floppy or the fixed disk. One could also access a [...] "(T)ypewriter" [...] mode for direct interface with the serial printer port and basic typing on screen. [...] "(H)ost terminal" [...] {{would allow the}} 820-II to interface as a terminal via either of the serial ports, as specified, at up to 19.2 kbit/s.|$|R
5000|$|The <b>bootstrap</b> <b>loader</b> on PC-compatible {{computers}} (MBR or boot sector) {{is located}} at track zero, the first sector on a disk. The ROM BIOS will load this sector into memory at address :, and typically check for a signature [...] "" [...] at offset [...] If the sector is {{not considered to be}} valid, the ROM BIOS will try the next physical disk in the row, otherwise it will jump to the load address with certain registers set up.|$|R
5000|$|In the BASIC {{programming}} language, [...] is used {{to start}} program execution from direct mode, or to start a overlay <b>program</b> from a <b>loader</b> <b>program.</b>|$|R
25|$|While {{many other}} vendors have {{continued}} to utilize a single-sector setup (logical sector 0 only) for the <b>bootstrap</b> <b>loader,</b> Microsoft's boot sector code has grown to span over logical sectors 0 and 2 since the introduction of FAT32, with logical sector 0 depending on sub-routines in logical sector 2. The Backup Boot Sector area consists of three logical sectors 6, 7, and 8 as well. In some cases, Microsoft also uses sector 12 of the reserved sectors area for an extended boot loader.|$|R
5000|$|As {{time went}} on and BASIC was no longer shipped on all PCs, this {{interrupt}} would simply display an error message indicating that no bootable volume was found (famously, [...] "No ROM BASIC", or more explanatory messages in later BIOS versions); in other BIOS versions it would prompt the user to insert a bootable volume and press a key, and then after the user pressed a key it would loop back to the <b>bootstrap</b> <b>loader</b> (INT 19h) to try booting again.|$|R
5000|$|While {{many other}} vendors have {{continued}} to utilize a single-sector setup (logical sector 0 only) for the <b>bootstrap</b> <b>loader,</b> Microsoft's boot sector code has grown to span over logical sectors 0 and 2 since the introduction of FAT32, with logical sector 0 depending on sub-routines in logical sector 2. The Backup Boot Sector area consists of three logical sectors 6, 7, and 8 as well. In some cases, Microsoft also uses sector 12 of the reserved sectors area for an extended boot loader.|$|R
50|$|Since {{the screen}} {{address on the}} C64 and C128 was relocatable, the screen address could be {{detected}} and used by the <b>loader</b> <b>program</b> when BLoading these split files.|$|R
50|$|The Poly-88 ROM {{contained}} a boot <b>loader</b> <b>program,</b> capable of reading programs from the cassette tape interface. Available programs included games, utilities, a BASIC interpreter, and an 8080 assembler.|$|R
50|$|When powered on, the Apple III {{runs through}} system diagnostics, then read block number one (zero-indexed) from the {{built-in}} diskette drive into memory and executes it. SOS-formatted diskettes place a <b>loader</b> <b>program</b> in block one. That <b>loader</b> <b>program</b> searches for, loads, and executes a file named SOS.KERNEL, which is the kernel and API of the operating system. The kernel in turn searches for and loads a file named SOS.INTERP (the interpreter, or program, to run) and SOS.DRIVER, the set of device drivers to use. Once all files are loaded, control is passed to the SOS.INTERP program.|$|R
50|$|The term boot {{comes from}} the idea of lifting oneself by one's own bootstraps: the {{computer}} contains a tiny <b>program</b> (<b>bootstrap</b> <b>loader)</b> which will load and run a program found on a boot device. This program may itself be a small program designed to load a larger and more capable program, i.e., the full operating system. To enable booting without the requirement either for a mass storage device or to write to the boot medium, it is usual for the boot program to use some system RAM as a RAM disk for temporary file storage.|$|R
50|$|Every Java {{virtual machine}} {{implementation}} {{must have a}} <b>bootstrap</b> class <b>loader,</b> capable of loading trusted classes. The Java virtual machine specification doesn't specify how a class loader should locate classes.|$|R
50|$|Due to the {{incompatibility}} between 40- and 80-track drives, much {{software was}} distributed on combined 40/80-track disks. These work by writing {{the same data}} in pairs of consecutive tracks in 80-track format, and including a small <b>loader</b> <b>program</b> on track 1 (which {{is in the same}} physical position in either format). The <b>loader</b> <b>program</b> detects which type of drive is in use, and loads the main software program straight from disk bypassing the DFS, double-stepping for 80-track drives and single-stepping for 40-track. This effectively achieves downgraded capacity to 100 KB from either disk format, but enabled distributed software to be effectively compatible with either drive.|$|R
50|$|Minicomputers, {{starting}} with the Digital Equipment Corporation (DEC) PDP-5 and PDP-8 (1965) simplified design by using the CPU to assist input and output operations. This saved cost but made booting more complicated than pressing a single button. Minicomputers typically had some way to toggle in short programs by manipulating an array of switches on the front panel. Since the early minicomputers used magnetic core memory, which did not lose its information when power was off, these <b>bootstrap</b> <b>loaders</b> would remain in place unless they were erased. Erasure sometimes happened accidentally when a program bug caused a loop that overwrote all of memory.|$|R
50|$|It is modular in construction, {{with the}} {{operating}} system generation based on a relocating, linking, <b>loader</b> <b>program.</b> This makes the incorporation of different hardware driver modules quite easy, particularly for bus-oriented machines, such as the IEEE-696 (S-100) bus which was commonly used for TurboDOS systems.|$|R
5000|$|The Windows Registry is {{structured}} into hives. Each hive {{is kept in}} a separate file (in the directory [...] {{of the system and}} boot partition). When a Windows system boots, the <b>bootstrap</b> <b>loader</b> (the same that loads the kernel and other boot files, such as boot drivers, from the boot partition) loads the SYSTEM file into memory. A great deal of crucial information is kept in the SYSTEM hive, including information about what drivers to use with what devices, what software to run initially, and many parameters governing the operation of the system. The conventions for the arrangement of configuration information are poorly defined.|$|R
