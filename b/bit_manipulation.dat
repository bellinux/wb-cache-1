104|37|Public
2500|$|C++ {{provides}} more than 35 operators, covering basic arithmetic, <b>bit</b> <b>manipulation,</b> indirection, comparisons, logical operations and others. Almost all operators can be overloaded for user-defined types, {{with a few}} notable exceptions such as member access (. and [...]*) {{as well as the}} conditional operator. The rich set of overloadable operators is central to making user-defined types in C++ seem like built-in types.|$|E
5000|$|<b>Bit</b> <b>Manipulation</b> Instruction Sets <b>bit</b> <b>manipulation</b> {{extensions}} for the x86 instruction set.|$|E
5000|$|MMX, SSE, SSE2, SSE3, SSSE3, SSE4a, SSE4.1, SSE4.2, AMD64, AMD-V, AES, AVX, AVX1.1, XOP, FMA3, FMA4, CVT16, F16C, BMI (<b>Bit</b> <b>Manipulation</b> instructions), ABM (Advanced <b>Bit</b> <b>Manipulation),</b> TBM (Trailing <b>Bit</b> <b>Manipulation</b> instructions), Turbo Core 3.0, NX bit ...|$|E
5000|$|PMP syntax is {{very close}} to the non-OOP syntax of Turbo Pascal or Delphi, with some {{extensions}} to support some target processor features (<b>bit</b> <b>manipulations</b> ...).|$|R
40|$|This paper {{describes}} {{one such}} language, called Rivl (pronounced "Rival"). In Rivl, video operations are expressed {{independent of the}} internal representation of video data. Just {{as it is the}} responsibility of traditional languages to map a floating-point operation onto the underlying <b>bit</b> <b>manipulations,</b> it is Rivl's responsibility to map image and video clip operations onto the underlying pixel and frame manipulations...|$|R
5000|$|Larger {{multiply}} (32×32 -> 64 bits) {{and divide}} (64÷32 -> 32 bits quotient and 32 bits remainder) instructions, and <b>bit</b> field <b>manipulations</b> ...|$|R
50|$|Bit {{twiddling}} and {{bit bashing}} {{are often used}} interchangeably with <b>bit</b> <b>manipulation,</b> but sometimes exclusively refer to clever or non-obvious ways or uses of <b>bit</b> <b>manipulation,</b> or tedious or challenging low-level device control data manipulation tasks.|$|E
50|$|<b>Bit</b> <b>manipulation</b> is {{the act of}} algorithmically {{manipulating}} bits {{or other}} pieces of data shorter than a word. Computer programming tasks that require <b>bit</b> <b>manipulation</b> include low-level device control, error detection and correction algorithms, data compression, encryption algorithms, and optimization. For most other tasks, modern programming languages allow the programmer to work directly with abstractions instead of bits that represent those abstractions. Source code that does <b>bit</b> <b>manipulation</b> makes use of the bitwise operations: AND, OR, XOR, NOT, and bit shifts.|$|E
50|$|C {{provides}} six operators for <b>bit</b> <b>manipulation.</b>|$|E
2500|$|The 6309 is Hitachi's CMOS {{version of}} the Motorola 6809 microprocessor. While in [...] "Emulation Mode" [...] it is fully {{compatible}} with the 6809. To the 6809 specifications it adds higher clock rates, enhanced features, new instructions, and additional registers. Most new instructions were added to support the additional registers, as well as up to 32-bit math, hardware division, <b>bit</b> <b>manipulations,</b> and block transfers. The 6309 is generally 30% faster in native mode than the 6809.|$|R
40|$|A {{diagrammatic}} {{valence bond}} method based on Rumer-Pauling rules for configuration interaction calculations is described. The advantages {{of this method}} are that it is simple and flexible {{and is expected to}} be computationally efficient as the basis functions can be coded as increasing integers. Evaluation of Hamiltonian matrix elements involves simple <b>bit</b> <b>manipulations</b> and binary searches. The basis, being represented pictorially, should also help in utilizing spatial symmetries for further block-diagonalizing the Hamiltonian matrix. The eigenfunctions of the Hamiltonian {{can also be used to}} compute matrix elements between different electronic states...|$|R
40|$|This paper {{presents}} a fast algorithm for generating Hilbert address for hardware implementation with low storage requirement. This work avoids {{the use of}} recursive functions as compared with Quinqueton's work, and eliminates complicated <b>bit</b> <b>manipulations</b> as proposed by Butz, and does not use any look-up-tables as implemented by Kamata. Each address can be obtained in one clock cycle by one-to-one mapping using a simple incremental counter and cascading of multiplexers. The merit of our method is that it achieves very high speed when computing the Hilbert address which requires little memory storage...|$|R
50|$|<b>Bit</b> <b>Manipulation</b> Instructions Sets (BMI sets) are {{extensions}} to the x86 {{instruction set}} architecture for microprocessors from Intel and AMD. The {{purpose of these}} instruction sets {{is to improve the}} speed of <b>bit</b> <b>manipulation.</b> All the instructions in these sets are non-SIMD and operate only on general-purpose registers.|$|E
50|$|There {{exists a}} class of {{universal}} computers with one instruction based on <b>bit</b> <b>manipulation</b> such as bit copying or bit inversion. Since their memory model {{is the same as}} the memory structure used in real computers, those <b>bit</b> <b>manipulation</b> machines are equivalent to real computers rather than to Turing machines.|$|E
50|$|AMD {{calls this}} pair of {{instructions}} Advanced <b>Bit</b> <b>Manipulation</b> (ABM).|$|E
40|$|This paper {{describes}} a prototype plug-in card for PC compatible computers built to manipulate multiresolution images through relationships defined in pyramids. The prototype {{is based on}} a Quadtree storage scheme that allows images to be organized as a regular decomposed picture. The decomposed images are physically stored in different memory modules in order to take advantage of data flow operations. The image representation developed is well-suited to access the localization of nodes linked in pyramid algorithms, because hierarchical relationships are defined by simple <b>bit</b> <b>manipulations</b> that can be implemented on hardware...|$|R
5000|$|A <b>bit</b> of {{algebraic}} <b>manipulation</b> {{shows that}} the expected values ...|$|R
40|$|Abstract — Since the {{invention}} of FPGAs, the increase in their size and performance has allowed designers to use FPGAs for more complex designs. FPGAs are generally good at <b>bit</b> <b>manipulations</b> and fixed point arithmetics but has a harder time coping with floating point arithmetics. In this paper we describe methods used to construct high performance floating point components in a Virtex- 4. We have constructed a floating point adder/subtracter and multiplier which we then used to construct a complex radix- 2 butterfly. Our adder/subtracter can operate at a frequency of 361 MHz in a Virtex- 4 SX 35 (speed grade- 12). I...|$|R
5000|$|... #Subtitle level 2: <b>Bit</b> <b>manipulation</b> in the C {{programming}} language ...|$|E
5000|$|<b>Bit</b> <b>Manipulation</b> Instruction Sets for Intel and AMD x86-based {{processors}} ...|$|E
5000|$|Intel BCD opcodes (also {{used for}} {{advanced}} <b>bit</b> <b>manipulation</b> techniques) ...|$|E
30|$|One-dimensional (1 D) set {{partitioning}} in hierarchical trees (SPIHT) technique {{based on}} zerotree wavelet coding {{has been presented}} in a low-memory compression study [18]. However, 1 D SPIHT memory access counts are too high {{during the process of}} repetitively arranging key data in <b>bit</b> <b>manipulations</b> after wavelet transform for transmission, resulting in excessive power consumption. Several studies have been conducted to reduce memory accesses and improve compression ratio of 1 D SPIHT [19 – 22], including line-based backward coding of wavelet trees (L-BCWT) [23, 24] and zero memory set partitioned embedded block (ZM-SPECK) [25]. However, energy efficiency of systems after adopting these modified SPIHT methods needs to be further improved to satisfy energy requirements of low-power IoT devices.|$|R
40|$|In {{the area}} of fault attacks, lasers are a common method to inject faults into an {{integrated}} circuit. Against the background of decreasing structure sizes in ICs, it is of interest which fault model can be met with {{state of the art}} equipment. We investigate laser-based fault injections into the SRAM-cells of block RAMs of two different FPGAs with 90 nm and 45 nm feature size respectively. Our results show that individual <b>bit</b> <b>manipulations</b> are feasible for both, the 90 nm chip and the 45 nm chip, but with limitations for the latter. To the best of our knowledge, we are the first to investigate laser fault injections into 45 nm technology nodes. We provide detailed insights of our laser equipment and the parameters of our setup to give a comparison base for further research...|$|R
2500|$|<b>Bit</b> {{test and}} <b>manipulation</b> in memory: BSET (to 1), BCLR (to 0), BCHG (invert bit) and BTST (set the zero bit if tested bit is 0) ...|$|R
5000|$|<b>Bit</b> <b>manipulation</b> {{intrinsic}} functions, {{based on}} similar functions included in Industrial Real-Time Fortran (ANSI/ISA S61.1 (1976)) ...|$|E
5000|$|Platform and CPU Information: Platform Detection, CPU Feature Detection, Byte Order and Byte Swapping, <b>Bit</b> <b>Manipulation</b> ...|$|E
50|$|It has complex {{instructions}} such as <b>bit</b> <b>manipulation,</b> saving/restoring and push/pop {{of several}} registers with single command.|$|E
30|$|Choi et al. [25] {{proposed}} a robust lossless digital watermarking {{scheme based on}} a generalized integer transform in spatial domain. In the proposed method, data bits are hidden into the cover media by a reversible generalized integer transform with <b>bit</b> plane <b>manipulation.</b> With the reversible transform, data can be hidden in the cover media, and the stego media can be restored to its original form after extraction of the hidden data. In embedding procedure, adaptive <b>bit</b> plane <b>manipulation</b> is applied to increase robustness of the algorithm while keeps good visual quality. To further increase the robustness of the algorithm, watermark bits are repeatedly embedded and majority voting is used to decode the hidden information in extraction procedure. Furthermore, a threshold is introduced in the algorithm, which helps in choosing regions that would result lower variance for embedding, as regions with lower variance are more robust against JPEG compression.|$|R
500|$|... {{showed that}} in some cases the multiplications or table lookups {{required}} by some integer sorting algorithms could be replaced by customized operations that would be more easily implemented in hardware but that are not typically available on general-purpose computers. [...] improved on this by showing how to replace these special operations by the <b>bit</b> field <b>manipulation</b> instructions already available on Pentium processors.|$|R
50|$|The new {{instructions}} {{included some}} minor improvements and extensions to the supervisor state, several instructions for software management of a multiprocessing system (which were removed in the 68060), {{some support for}} high-level languages which did not get used much (and was removed from future 680x0 processors), bigger multiply (32×32→64 bits) and divide (64÷32→32 bits quotient and 32 bits remainder) instructions, and <b>bit</b> field <b>manipulations.</b>|$|R
50|$|There are {{two sets}} {{published}} by Intel: BMI (here {{referred to as}} BMI1) and BMI2; they were both introduced with the Haswell microarchitecture. Another two sets were published by AMD: ABM (Advanced <b>Bit</b> <b>Manipulation,</b> {{which is also a}} subset of SSE4a implemented by Intel as part of SSE4.2 and BMI1), and TBM (Trailing <b>Bit</b> <b>Manipulation,</b> an extension introduced with Piledriver-based processors as an extension to BMI1, but dropped again in Zen based processors).|$|E
5000|$|AMD's Barcelona {{architecture}} {{introduced the}} [...] (advanced <b>bit</b> <b>manipulation)</b> ISA introducing the [...] instruction {{as part of}} the SSE4a extensions in 2007.|$|E
50|$|The IRTF {{standard}} {{evolved from}} a series of workshops held at Purdue University in the early 1970s. The Fortran committee created a proposal which was approved and published by the Instrument Society of America (ISA) as ISA Standard S61.1 (1972). The paper defined library calls for controlling the state of concurrently activated programs, process I/O, and <b>bit</b> <b>manipulation.</b> A second supplementary paper, ISA S61.2 (1973) was published a year later. This paper defined additional calls for random unformatted files, and <b>bit</b> <b>manipulation.</b>|$|E
2500|$|In Fig. 3-3a, {{segments}} OA and OK represent equal spacetime intervals. Time dilation {{is represented}} by the ratio OB/OK. The invariant hyperbola has the equation [...] where k=OK, and the red line representing the world line of a particle in motion has the equation w=x/'=xc/v. A <b>bit</b> of algebraic <b>manipulation</b> yields ...|$|R
5000|$|In Fig. 3-3a, {{segments}} OA and OK represent equal spacetime intervals. Time dilation {{is represented}} by the ratio OB/OK. The invariant hyperbola has the equation [...] where k = OK, and the red line representing the world line of a particle in motion has the equation w = x/&beta; = xc/v. A <b>bit</b> of algebraic <b>manipulation</b> yields ...|$|R
40|$|The {{worst-case}} {{model for}} algorithm design {{does not always}} reflect the real world: inputs may have additional structure to be exploited, and sometimes data can be imprecise or become available only gradually. To better understand these situations, we examine several scenarios where additional information can affect the design and analysis of geometric algorithms. First, we consider hereditary convex hulls: given a three-dimensional convex polytope and a two-coloring of its vertices, we can find the individual monochromatic polytopes in linear expected time. This can be generalized in many ways, eg, to more than two colors, and to the offline-problem where we wish to preprocess a polytope so that any large enough subpolytope can be found quickly. Our techniques {{can also be used}} to give a simple analysis of the self-improving algorithm for planar Delaunay triangulations by Clarkson and Seshadhri [58]. Next, we assume that the point coordinates have a bounded number of bits, and that we can do standard <b>bit</b> <b>manipulations</b> in constant time. Then Delaunay triangulations can be found in expected time O(n √ log log n). Our result is based on a new connection between quadtrees and Delaunay triangulations, which also lets us generalize a recent result by Löffler and Snoeyink about Delaunay triangulations for imprecise points [110]. Finally, we consider randomized incremental constructions when the input permutation is generated by a bounded-degree Markov chain, and show that the resulting running time is almost optimal for chains with a constant eigenvalue gap...|$|R
