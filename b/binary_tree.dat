2557|3189|Public
5|$|This {{is in fact}} true of {{the binary}} {{expansions}} of many rational numbers, where {{the values of the}} numbers are equal but the corresponding <b>binary</b> <b>tree</b> paths are different. For example, 0.10111...2=0.11000...2, which are both equal to , but the first representation corresponds to the <b>binary</b> <b>tree</b> path LRLRLLL... while the second corresponds to the different path LRLLRRR....|$|E
5|$|Alternatively, a {{hierarchical}} clustering may be {{represented as a}} <b>binary</b> <b>tree</b> with the points at its leaves; the clusters of the clustering are the sets of points in subtrees descending from each node of the tree.|$|E
5|$|A {{binary search}} tree is a <b>binary</b> <b>tree</b> data {{structure}} that works {{based on the principle}} of binary search. The records of the tree are arranged in sorted order, and each record in the tree can be searched using an algorithm similar to binary search, taking on average logarithmic time. Insertion and deletion also require on average logarithmic time in {{binary search tree}}s. This can faster than the linear time insertion and deletion of sorted arrays, and binary trees retain the ability to perform all the operations possible on a sorted array, including range and approximate queries.|$|E
40|$|Enumeration is an {{important}} aspect for combinatorial properties of <b>binary</b> <b>trees.</b> Traditional solutions for enumerating <b>binary</b> <b>trees</b> are expressed by algorithms {{and most of them}} are recursive. In this paper, we give our solutions by iterative formulas for enumerating <b>binary</b> <b>trees.</b> Iterative algorithms can be obtained easily based on the iterative formulas for enumerating <b>binary</b> <b>trees,</b> and the iterative algorithms can be guaranteed to be correct...|$|R
5000|$|Unrooted <b>binary</b> <b>trees</b> {{have also}} been called free <b>binary</b> <b>trees,</b> cubic trees, ternary trees and unrooted ternary trees,. However, the [...] "free binary tree" [...] name has also been applied to unrooted trees that may have degree-two nodes and to rooted <b>binary</b> <b>trees</b> with unordered children, and the [...] "ternary tree" [...] name is more {{frequently}} used to mean a rooted tree with three children per node.|$|R
25|$|The {{ability to}} {{represent}} <b>binary</b> <b>trees</b> as strings of symbols and parentheses implies that <b>binary</b> <b>trees</b> can represent {{the elements of}} a free magma on a singleton set.|$|R
25|$|From a {{graph theory}} perspective, binary (and K-ary) trees as defined here are {{actually}} arborescences. A <b>binary</b> <b>tree</b> may thus be also called a bifurcating arborescence—a term which appears in some very old programming books, before the modern computer science terminology prevailed. It {{is also possible}} to interpret a <b>binary</b> <b>tree</b> as an undirected, rather than a directed graph, in which case a <b>binary</b> <b>tree</b> is an ordered, rooted tree. Some authors use rooted <b>binary</b> <b>tree</b> instead of <b>binary</b> <b>tree</b> to emphasize {{the fact that the}} tree is rooted, but as defined above, a <b>binary</b> <b>tree</b> is always rooted. A <b>binary</b> <b>tree</b> is a special case of an ordered K-ary tree, where k is 2.|$|E
25|$|An unrooted <b>binary</b> <b>tree</b> is a {{connected}} {{undirected graph}} with no cycles {{in which each}} non-leaf node has exactly three neighbors. A branch-decomposition may be represented by an unrooted <b>binary</b> <b>tree</b> T, together with a bijection between the leaves of T and {{the edges of the}} given graph G=(V,E).|$|E
25|$|The dyadic {{intervals}} consequently have {{a structure}} that reflects that of an infinite <b>binary</b> <b>tree.</b>|$|E
40|$|Dynamic memory {{management}} {{has been an}} active research area {{for the last four}} decades. The primary goals of any {{memory management}} technique are the speed of allocation & delloaction; and efficient storage utilization. In this paper, we introduce two new memory allocation techniques: Address Ordered <b>Binary</b> <b>Trees</b> (ABT) and Segregated <b>Binary</b> <b>Trees</b> (SBT). Our empirical results show how Address Ordered and Segregated <b>Binary</b> <b>Trees</b> can outperform other mechanisms with respect to storage utilization. In addition, the Segregated <b>Binary</b> <b>Trees</b> compare favorably with Segregated Free List approaches in terms of execution time...|$|R
40|$|In this work, we {{deal with}} the {{unification}} of unrestricted (i. e. inifiable and non-unifiable) pais of <b>binary</b> <b>trees</b> with uniform probability distribution. The following results are obtained: Almost all pairs of <b>binary</b> <b>trees</b> are not unifiable. When considering unrestricted pairs of <b>binary</b> <b>trees,</b> drawn from a uniform distribution, the average time to process unification is constant. Postprint (published version...|$|R
40|$|We {{present a}} simple {{mechanism}} for quickly rendering computer images of botanical trees based on random <b>binary</b> <b>trees</b> {{commonly found in}} computer science. That is, we visualize abstract <b>binary</b> <b>trees</b> as botanical ones. We generate random <b>binary</b> <b>trees</b> by splitting based upon the beta distribution, and obtain the standard <b>binary</b> search <b>trees</b> as a special case. We draw them in PostScript to resemble actual botanical trees found in nature. Through flexible parameterization and extensive randomization, we can produce a rich collection of images...|$|R
25|$|Constructing a {{separator}} hierarchy directly, by traversing the <b>binary</b> <b>tree</b> {{top down}} and applying a linear-time planar separator algorithm {{to each of}} the induced subgraphs associated with each node of the <b>binary</b> <b>tree,</b> would take a total of O(nnbsp&lognbsp&n) time. However, it is possible to construct an entire separator hierarchy in linear time, by using the Lipton–Tarjan breadth-first layering approach and by using appropriate data structures to perform each partition step in sublinear time.|$|E
25|$|In {{computer}} science and probability theory, a random <b>binary</b> <b>tree</b> is a <b>binary</b> <b>tree</b> selected at random from some probability distribution on binary trees. Two different distributions are commonly used: binary trees formed by inserting nodes {{one at a}} time according to a random permutation, and binary trees chosen from a uniform discrete distribution in which all distinct trees are equally likely. It is also possible to form other distributions, for instance by repeated splitting. Adding and removing nodes directly in a random <b>binary</b> <b>tree</b> will in general disrupt its random structure, but the treap and related randomized binary search tree data structures use the principle of binary trees formed from a random permutation in order to maintain a balanced binary search tree dynamically as nodes are inserted and deleted.|$|E
25|$|For any {{non-empty}} <b>binary</b> <b>tree</b> with n0 {{leaf nodes}} and n2 nodes of degree 2, n0 = n2 + 1.|$|E
25|$|Nodes can be {{inserted}} into <b>binary</b> <b>trees</b> in between two other nodes or added after a leaf node. In <b>binary</b> <b>trees,</b> a node that is inserted is specified {{as to which}} child it is.|$|R
40|$|We {{show that}} the set of {{balanced}} <b>binary</b> <b>trees</b> is closed by interval in the Tamari lattice. We establish that the intervals [T, T'] where T and T' are balanced <b>binary</b> <b>trees</b> are isomorphic as posets to a hypercube. We introduce synchronous grammars that allow to generate tree-like structures and obtain fixed-point functional equations to enumerate these. We also introduce imbalance tree patterns and {{show that the}}y can be used to describe some sets of balanced <b>binary</b> <b>trees</b> that play a particular role in the Tamari lattice. Finally, we investigate other families of <b>binary</b> <b>trees</b> that are also closed by interval in the Tamari lattice. Comment: 38 page...|$|R
40|$|Mathematics of Operations Research, 9, pp. 43 - 65. A {{widely used}} class of <b>binary</b> <b>trees</b> is studied {{in order to}} provide {{information}} useful in evaluating algorithms based on this storage structure. A closed form counting formula for the number of <b>binary</b> <b>trees</b> with n nodes and height k is developed and restated as a recursion more useful computationally. A generating function for the number of nodes given height is developed and used to find the asymptotic distribution of <b>binary</b> <b>trees.</b> An asymptotic probab ility distribution for height given the number of nodes is derived based on equally likely <b>binary</b> <b>trees.</b> This is compared with a similar result for general trees...|$|R
25|$|A graph {{formed by}} taking two (full) binary trees, adding a vertex, and adding an edge {{directed}} {{from the new}} vertex {{to the root of}} each <b>binary</b> <b>tree.</b>|$|E
25|$|A {{balanced}} <b>binary</b> <b>tree</b> has {{the minimum}} possible maximum height (a.k.a. depth) for the leaf nodes, because {{for any given}} number of leaf nodes, the leaf nodes are placed at the greatest height possible.|$|E
25|$|In a <b>binary</b> <b>tree,</b> a node {{with two}} {{children}} cannot be deleted unambiguously. However, in certain binary trees (including binary search trees) these nodes can be deleted, though with a rearrangement of the tree structure.|$|E
40|$|International audienceWe {{show that}} the set of {{balanced}} <b>binary</b> <b>trees</b> is closed by interval in the Tamari lattice. We establish that the intervals [T, T] where T and T are balanced <b>binary</b> <b>trees</b> are isomorphic as posets to a hypercube. We introduce synchronous grammars that allow to generate tree-like structures and obtain fixed-point functional equations to enumerate these. We also introduce imbalance tree patterns and {{show that the}}y can be used to describe some sets of balanced <b>binary</b> <b>trees</b> that play a particular role in the Tamari lattice. Finally, we investigate other families of <b>binary</b> <b>trees</b> that are also closed by interval in the Tamari lattice...|$|R
40|$|This {{paper is}} a brief {{mathematical}} excursion which starts from quantum electrodynamics and leads to the Möbius function of the Tamari lattice of planar <b>binary</b> <b>trees,</b> {{within the framework of}} groups of tree-expanded series. First we recall Brouder’s expansion of the photon and the electron Green’s functions on planar <b>binary</b> <b>trees,</b> before and after the renormalization. Then we recall the structure of Connes and Kreimer’s Hopf algebra of renormalization in the context of planar <b>binary</b> <b>trees,</b> and of their dual group of tree-expanded series. Finally we show that the Möbius function of the Tamari posets of planar <b>binary</b> <b>trees</b> gives rise to a particular series in this group...|$|R
5000|$|... use unordered <b>binary</b> <b>trees,</b> and {{the fact}} that the Wedderburn-Etherington numbers are {{significantly}} smaller than the numbers that count ordered <b>binary</b> <b>trees,</b> to significantly reduce the number of terms in a series representation of the solution to certain differential equations.|$|R
25|$|The maximum {{possible}} {{number of}} null links (i.e., absent {{children of the}} nodes) in a complete <b>binary</b> <b>tree</b> of n nodes is (n+1), where only 1 node exists in bottom-most level to the far left.|$|E
25|$|Heaps are {{commonly}} implemented with an array. Any <b>binary</b> <b>tree</b> {{can be stored}} in an array, but because a binary heap is always a complete <b>binary</b> <b>tree,</b> it can be stored compactly. No space is required for pointers; instead, the parent and children of each node can be found by arithmetic on array indices. These properties make this heap implementation a simple example of an implicit data structure or Ahnentafel list. Details depend on the root position, which in turn may depend on constraints of a programming language used for implementation, or programmer preference. Specifically, sometimes the root is placed at index 1, in order to simplify arithmetic.|$|E
25|$|This {{method of}} storing binary trees wastes a fair bit of memory, as the {{pointers}} will be null (or {{point to the}} sentinel) {{more than half the}} time; a more conservative representation alternative is threaded <b>binary</b> <b>tree.</b>|$|E
40|$|The {{analysis}} of an algorithm by Koda and Ruskey for listing ideals {{in a forest}} poset leads to a study of random <b>binary</b> <b>trees</b> and their limits as infinite random <b>binary</b> <b>trees.</b> The corresponding finite and infinite random forests are studied too. The infinite random <b>binary</b> <b>trees</b> and forests studied here have exactly one infinite path; they can be defined using suitable size-biazed Galton [...] Watson processs. Limit theorems are proved using {{a version of the}} contraction method...|$|R
40|$|One of {{the most}} widely known topological index is the Wiener index. The Wiener Index Conjecture states that all {{positive}} integer numbers except a finite set are the Wiener indices of some trees. We explore the Wiener indices of the <b>binary</b> <b>trees.</b> We present efficient algorithms for generating the Wiener indices of the <b>binary</b> <b>trees.</b> Based on experiments we strengthen the conjecture for the class of the <b>binary</b> <b>trees.</b> Key-Words: Molecular graphs, topological indices, Wiener index. ...|$|R
40|$|Abstract. The {{analysis}} of an algorithm by Koda and Ruskey for listing ideals {{in a forest}} poset leads to a study of random <b>binary</b> <b>trees</b> and their limits as infinite random <b>binary</b> <b>trees.</b> The corresponding finite and infinite random forests are studied too. The infinite random <b>binary</b> <b>trees</b> and forests studied here have exactly one infinite path; they can be defined using suitable size-biazed Galton–Watson processs. Limit theorems are proved using {{a version of the}} contraction method. 1...|$|R
25|$|A binary heap is a heap data {{structure}} {{that takes the}} form of a <b>binary</b> <b>tree.</b> Binary heaps are a common way of implementing priority queues. The binary heap was introduced by J. W. J. Williams in 1964, as a {{data structure}} for heapsort.|$|E
25|$|In a {{complete}} <b>binary</b> <b>tree,</b> a node's breadth-index (i − (2d − 1)) {{can be used}} as traversal instructions from the root. Reading bitwise from left to right, starting at bit d − 1, where d is the node's distance from the root (d = ⌊log2(i+1)⌋) and the node in question is not the root itself (d > 0). When the breadth-index is masked at bit d − 1, the bit values 0 and 1 mean to step either left or right, respectively. The process continues by successively checking the next bit to the right until there are no more. The rightmost bit indicates the final traversal from the desired node's parent to the node itself. There is a time-space trade-off between iterating {{a complete}} <b>binary</b> <b>tree</b> this way versus each node having pointer/s to its sibling/s.|$|E
25|$|A <b>binary</b> <b>tree</b> {{can be seen}} as a type of {{linked list}} where the {{elements}} are themselves linked lists of the same nature. The result is that each node may include a reference to the first node of one or two other linked lists, which, together with their contents, form the subtrees below that node.|$|E
40|$|In {{contrast}} to traditional integer sequences for {{the representation of}} <b>binary</b> <b>trees,</b> a kind of character sequence (words) is presented for <b>binary</b> <b>trees</b> based on a grammar GBT and for full <b>binary</b> <b>trees</b> based on a grammar GFBT. The properties of words derived from GBT (GFBT) are discussed in depth, including necessary and suf&quot;cient conditions for a word, pre&quot;x and suf&quot;x of &(GBT) (&(GFBT)) and algorithms are given and analysed for the enumeration of words of &(GBT) (&(GFBT)) lexicographically and in other ways. By modifying an algorithm for the enumeration of words in &(GBT), an algorithm is obtained to enumerate <b>binary</b> <b>trees</b> with a computer representation in an average time of O(1) per tree. The problem with non-isomorphi...|$|R
40|$|Planar <b>binary</b> <b>trees</b> {{appear as}} main {{ingredient}} {{of a new}} homology theory related to dialgebras, c. f. [L]. Here we investigate the simplicial properties of the set of these trees, which are independent of the dialgebra context though they {{are reflected in the}} dialgebra homology. The set of planar <b>binary</b> <b>trees</b> is endowed with a natural (almost) simplicial structure which gives rise to a chain complex. Our main idea consists in decomposing the set of trees into classes, by exploiting the orientation of their leaves. This decomposition yields a chain bicomplex whose total chain complex is that of <b>binary</b> <b>trees.</b> Our main theorem concerns a further decomposition of this bicomplex. Each vertical complex is the direct sum of subcomplexes which are in bijection with the planar <b>binary</b> <b>trees.</b> This decomposition is used in the computation of dialgebra homology as a derived functor, c. f. [F 2]. Introduction The planar <b>binary</b> <b>trees</b> have been widely studied for their combinatorial properties, which rela [...] ...|$|R
40|$|International audienceThe {{construction}} of a theory for <b>binary</b> <b>trees</b> is presented, based on the systematic exploration of the properties necessary for the proof-based synthesis and certification of sorting algorithms for <b>binary</b> <b>trees.</b> The process is computer supported, being realised {{in the frame of}} the Theorema system, with some additional proofs in Coq required for algorithm certification. The result of the exploration consists in 11 definitions, 3 axioms, and more than 200 properties. Also, more than 5 algorithms for sorting <b>binary</b> <b>trees</b> are generated...|$|R
