118|705|Public
5000|$|Leaves {{are labeled}} with [...] (true), [...] (false), or a <b>Boolean</b> <b>variable.</b>|$|E
50|$|Consider a {{variable}} A and a <b>boolean</b> <b>variable</b> S. A is only accessed when S is marked true. Thus, S is a semaphore for A.|$|E
5000|$|Rows are the clauses in the 2-SAT {{formula and}} literals {{corresponding}} to the same <b>boolean</b> <b>variable</b> are arranged in columns, with negation indicated by parentheses. For example, the real variables x11, x21 and x41 correspond to the same <b>boolean</b> <b>variable</b> (q1) or its negation, and are called replicas.It is convenient to associate the values 1 and -1 with TRUE and FALSE rather than the traditional 1 and 0. With this convention, the compatibility between the replicas {{takes the form of}} the following linear equations: ...|$|E
5000|$|For example, {{given the}} {{function}} f1 (...) for the <b>boolean</b> <b>variables</b> p and q, and f2 (...) for the <b>boolean</b> <b>variables</b> q and r, {{both with the}} range in R, the pointwise product of f1 (...) and f2 (...) {{is shown in the}} next table: ...|$|R
40|$|An {{important}} issue in analog circuit design {{is the problem}} of digital to analog conversion, namely, the encoding of <b>Boolean</b> <b>variables</b> into a single analog value which contains enough information to reconstruct the values of the <b>Boolean</b> <b>variables.</b> Wegener (1996) proved that [3 n- 1 / 2] 2 -input arithmetic gates are necessary and sufficient for implementing the encoding function of n <b>Boolean</b> <b>variables.</b> However, the proof of the upper bound is not constructive. We present an explicit construction of a digital to analog encoder that is optimal in the number of 2 -input arithmetic gates...|$|R
5000|$|... where u, v, w {{respectively}} {{denote the}} <b>Boolean</b> <b>variables</b> (A<120&deg;), (B<120&deg;), (C<120&deg;).|$|R
5000|$|... where [...] and [...] are {{declared}} local to each iteration. The following gives {{a program}} for the N-queens problem, which uses a <b>Boolean</b> <b>variable</b> for each square on the board.|$|E
50|$|It {{is easy to}} {{see that}} a credal set over a <b>Boolean</b> <b>variable</b> cannot have more than two vertices, while no bounds can be {{provided}} for credal sets over variables with three or more values.|$|E
5000|$|PriorityAn {{administratively}} assigned precedence hint {{used by the}} BMC to help {{select a}} grandmaster for the PTP domain. IEEE 1588-2002 used a single <b>boolean</b> <b>variable</b> to indicate precedence. IEEE 1588-2008 features two 8-bit priority fields.|$|E
25|$|In May 1966, Böhm and Jacopini {{published}} an article in Communications of the ACM which showed that any program with gotos could {{be transformed into a}} goto-free form involving only choice (IF THEN ELSE) and loops (WHILE condition DO xxx), possibly with duplicated code and/or the addition of <b>Boolean</b> <b>variables</b> (true/false flags). Later authors showed that choice can be replaced by loops (and yet more <b>Boolean</b> <b>variables).</b>|$|R
40|$|A {{simple way}} to {{represent}} a Boolean function f which {{is assumed to be}} a mapping from the space { 0, 1 } n {- 1, 1 } with the exponent n representing the total number of <b>Boolean</b> <b>variables</b> in the function is through the usage of the disjunctive normal form (DNF), in which a conjunction of disjunctions of <b>Boolean</b> literals (<b>Boolean</b> <b>variables</b> an...|$|R
50|$|In May 1966, Böhm and Jacopini {{published}} an article in Communications of the ACM which showed that any program with gotos could {{be transformed into a}} goto-free form involving only choice (IF THEN ELSE) and loops (WHILE condition DO xxx), possibly with duplicated code and/or the addition of <b>Boolean</b> <b>variables</b> (true/false flags). Later authors showed that choice can be replaced by loops (and yet more <b>Boolean</b> <b>variables).</b>|$|R
50|$|The {{domain of}} a <b>boolean</b> <b>variable</b> X is the set {true, false}. However neither {{true or false}} is a {{solution}} to the above equation. So it must be wrong to assert the existence of X, and it is falsehood to name the expression ¬X as X.|$|E
5000|$|A <b>boolean</b> <b>variable</b> {{makes the}} effect more clear. Its values {{can be either}} [...] "true" [...] or [...] "false", while a nullable boolean may also contain a {{representation}} for [...] "undecided". However, the interpretation or treatment of a logical operation involving such a variable depends on the language.|$|E
50|$|Type errors (such as {{an attempt}} to apply the ++ {{increment}} operator to a <b>boolean</b> <b>variable</b> in Java) and undeclared variable errors are sometimes considered to be syntax errors when they are detected at compile-time. However, it is common to classify such errors as (static) semantic errors instead.|$|E
25|$|An {{instance}} of the Boolean satisfiability problem is a Boolean expression that combines <b>Boolean</b> <b>variables</b> using <b>Boolean</b> operators.|$|R
40|$|For {{arbitrary}} {{undirected graph}} $G$, we are designing SATISFIABILITY problem (SAT) for HCP, using tools of Boolean algebra only. The obtained SAT be the logic formulation of conditions for Hamiltonian cycle existence, and use $m$ <b>Boolean</b> <b>variables,</b> where $m$ {{is the number}} of graph edges. This Boolean expression is true if and only if an initial graph is Hamiltonian. That is, each satisfying assignment of the <b>Boolean</b> <b>variables</b> determines a Hamiltonian cycle of $G$, and each Hamiltonian cycle of $G$ corresponds to a satisfying assignment of the <b>Boolean</b> <b>variables.</b> In common case, the obtained Boolean expression may has an exponential length (the number of Boolean literals). Comment: 7 pages, 1 figures. It has sent to 6 th Twente Workshop on Graphs and Combinatorial Optimizatio...|$|R
5000|$|... or, using {{a common}} notation:where A,B,C are <b>Boolean</b> <b>variables,</b> , , , and [...] are literals, and [...] and [...] are clauses.|$|R
50|$|Listed {{are some}} of the {{possible}} sub-expressions that can be created for various logic gates. In an operation expression, C acts as an output; in a CNF sub-expression, C acts as a new <b>Boolean</b> <b>variable.</b> For each operation, the CNF sub-expression is true if and only if C adheres to the contract of the Boolean operation for all possible input values.|$|E
5000|$|Secondly, a {{decision}} tree algorithm, the ID3 algorithm {{is applied to}} the 16 locations in order to achieve the maximum information gain. Let Kp be a <b>boolean</b> <b>variable</b> which indicates whether p is a corner, then the entropy of Kp is used to measure the information of p being a corner. For a set of pixels Q, the total entropy of KQ (not normalized) is: ...|$|E
50|$|An atomic term is {{an upper}} case Latin letter, I and S excepted, {{followed}} by a numerical superscript called its degree, or by concatenated lower case variables, collectively known as an argument list. The degree of a term conveys the same information {{as the number of}} variables following a predicate letter. An atomic term of degree 0 denotes a <b>Boolean</b> <b>variable</b> or a truth value. The degree of I is invariably 2 and so is not indicated.|$|E
25|$|Following are two {{different}} notations describing the same function in unsimplified Boolean algebra, using the <b>Boolean</b> <b>variables</b> , , , , and their inverses.|$|R
3000|$|... 1 We must {{note that}} in the final step of problem resolution, a_k,r^(j) are {{converted}} to <b>boolean</b> <b>variables</b> (Eq. (27)) [...]...|$|R
2500|$|Boolean network, {{a certain}} network {{consisting}} {{of a set of}} <b>Boolean</b> <b>variables</b> whose state is determined by other variables in the network ...|$|R
5000|$|The {{semantics}} of {{a feature}} {{model is the}} set of feature configurations that the feature model permits. The most common approach is to use mathematical logic to capture the semantics of a feature diagram. Each feature corresponds to a <b>boolean</b> <b>variable</b> and the semantics is captured as a propositional formula. The satisfying valuations of this formula correspond to the feature configurations permitted by the feature diagram.For instance, if [...] is a mandatory sub-feature of , the formula will contain the constraint [...]|$|E
50|$|A Boolean {{function}} {{is a function}} that takes as input n Boolean variables (that is, values that can be either false or true, or equivalently binary values that can be either 0 or 1), and produces as output another <b>Boolean</b> <b>variable.</b> It is monotonic if, for every combination of inputs, switching one of the inputs from false to true can only cause the output to switch from false to true and not from true to false. The Dedekind number M(n) {{is the number of}} different monotonic Boolean functions on n variables.|$|E
5000|$|In {{computer}} science, a <b>Boolean</b> <b>variable</b> is {{a variable}} that takes values in some Boolean domain. Some programming languages feature reserved words or symbols for {{the elements of}} the Boolean domain, for example [...] and [...] However, many programming languages do not have a Boolean datatype in the strict sense. In C or BASIC, for example, falsity is represented by the number 0 and truth is represented by the number 1 or −1, and all variables that can take these values can also take any other numerical values.|$|E
40|$|We prove a {{complexity}} classification theorem that classifies all counting {{constraint satisfaction}} problems (#CSP) over <b>Boolean</b> <b>variables</b> into exactly three categories: (1) Polynomial-time tractable; (2) #P-hard for general instances, but solvable in polynomial-time over planar graphs; and (3) #P-hard over planar graphs. The classification {{applies to all}} sets of local, not necessarily symmetric, constraint functions on <b>Boolean</b> <b>variables</b> that take complex values. It is shown that Valiant's holographic algorithm with matchgates is a universal strategy for all problems in category (2). Comment: 94 page...|$|R
40|$|In {{this work}} we propose to {{implement}} supervisory control by embedding {{control in the}} plant Finite State Machine (FSM). Supervisory control is introduced by extending the plant with <b>boolean</b> <b>variables,</b> guard formulas and updating functions. <b>Boolean</b> <b>variables</b> are used to encode the supervisor's states. Event observation is captured {{by a set of}} boolean functions that update the values of <b>boolean</b> <b>variables,</b> and control is introduced by guarding events with boolean formulas. The resulting Extended Finite State Machine (EFSM) implements the supervisory control map {{in the sense that the}} languages closed and marked by the EFSM are equal to those of the supervised system. After studying embedded supervisory control under partial observation, centralized and decentralized control architectures are analyzed. It is shown that the coobservability condition remains necessary and sufficient for the existence of decentralized supervisors. An application of our approach in the synthesis of communication protocols is presented...|$|R
40|$|We {{consider}} semidefinite relaxations of a quadratic {{optimization problem}} with polynomial constraints. This {{is an extension}} of quadratic problems with <b>boolean</b> <b>variables.</b> Such combinatorial problems can in general not be solved in polynomial time. Semidefinite relaxations has been proposed as a promising technique to give provable good bounds on certain boolean quadratic problems in polynomial time. We formulate the extensions from <b>boolean</b> <b>variables</b> to quaternary variables using (i) a polynomial relaxation or (ii) by using standard semidefinite relaxations of a linear transformation of <b>boolean</b> <b>variables.</b> We analytically compare the two different approaches of relaxation. The relaxations can all be expressed as semidefinite programs, which can be solved efficiently using e. g. interior point methods. Applications of our results include maximum likelihood estimation in communication systems, which we explore in simulations in order to compare the quality of the different relaxations with optimal solutions. 1...|$|R
50|$|A {{specific}} image feature, {{defined in}} terms of a specific structure in the image data, can often be represented in different ways. For example, an edge can be represented as a <b>boolean</b> <b>variable</b> in each image point that describes whether an edge is present at that point. Alternatively, we can instead use a representation which provides a certainty measure instead of a boolean statement of the edge's existence and combine this with information about the orientation of the edge. Similarly, the color of a specific region can either be represented in terms of the average color (three scalars) or a color histogram (three functions).|$|E
5000|$|A Boolean {{function}} can {{be represented}} as a rooted, directed, acyclic graph, which consists of several decision nodes and terminal nodes. There {{are two types of}} terminal nodes called 0-terminal and 1-terminal. Each decision node [...] is labeled by <b>Boolean</b> <b>variable</b> [...] and has two child nodes called low child and high child. The edge from node [...] to a low (or high) child represents an assignment of [...] to 0 (resp. 1).Such a BDD is called 'ordered' if different variables appear in the same order on all paths from the root. A BDD is said to be 'reduced' if the following two rules have been applied to its graph: ...|$|E
50|$|Combinatorial {{explosion}} {{can occur}} in computing environments in a way analogous to communications and multi-dimensional space. Imagine a simple system with only one variable, a boolean called A. The system has two possible states, A = true or A = false. Adding another <b>boolean</b> <b>variable</b> B will give the system four possible states, A = true and B = true, A = true and B = false, A = false and B = true, A = false and B = false. A system with n booleans has 2n possible states, while a system of n variables each with Z allowed values (rather than just the 2 (true and false) of booleans) will have Zn possible states.|$|E
3000|$|... [Rescaling] A {{last step}} {{involves}} {{the transformation of}} the estimated inner and outer weights and outer loadings into the metric of the <b>Boolean</b> <b>variables</b> (i.e., the metric of interpretation).|$|R
5000|$|The boolean satisfiability problem, {{where we}} want to know whether or not a certain formula in propositional logic with <b>boolean</b> <b>{{variables}}</b> is true for some value of the variables ...|$|R
40|$|An {{important}} issue in analog circuit design {{is the problem}} of digital to analog conversion, namely, the encoding of <b>Boolean</b> <b>variables</b> into a single analog value which contains enough information to reconstruct the values of the <b>Boolean</b> <b>variables.</b> A natural question is: What is the complexity of implementing the digital to analog encoding function? That question was recently answered in [5], where matching lower and upper bounds {{on the size of the}} circuit for the encoding function were proven. In particular, it was proven that Σ 3 nΓ 1 2 Υ 2 -input arithmetic gates are necessary and sufficient for implementing the encoding function of n <b>Boolean</b> <b>variables.</b> However, the proof of the upper bound is not constructive. In this paper, we present an explicit construction of a digital to analog encoder that is optimal in the number of 2 -input arithmetic gates. In addition, we present an efficient analog to digital decoding algorithm. Namely, given the encoded analog value, our d [...] ...|$|R
