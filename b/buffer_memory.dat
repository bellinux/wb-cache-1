248|656|Public
25|$|More {{sophisticated}} receivers use a <b>buffer</b> <b>memory</b> {{to store}} {{some or all}} of the teletext pages as they are broadcast, allowing instant display from the buffer.|$|E
2500|$|Hardware {{designers}} later developed EEPROMs {{with the}} erasure region broken up into smaller [...] "fields" [...] {{that could be}} erased individually without affecting the others. Altering {{the contents of a}} particular memory location involved copying the entire field into an off-chip <b>buffer</b> <b>memory,</b> erasing the field, modifying the data as required in the buffer, and re-writing it into the same field. This required considerable computer support, and PC-based EEPROM flash memory systems often carried their own dedicated microprocessor system. Flash drives are more or less a miniaturized version of this.|$|E
5000|$|PAVP Lite: Reserves <b>buffer</b> <b>memory</b> for {{encryption}} of {{compressed video}} data.|$|E
50|$|Registered <b>Memory</b> (<b>Buffered</b> <b>Memory)</b> <b>Buffered</b> <b>memory</b> is {{an older}} term for {{registered}} <b>memory.</b> <b>Buffered</b> {{refers to an}} electronic buffer placed between the memory and the memory controller. In general registered RAM won't fit in a slot for unregistered RAM, however it will with SDRAM.|$|R
5000|$|IBM POWER9 SU {{scale-up}} version, {{optimized for}} four sockets or more, for large NUMA machines {{with up to}} 230 GB/s bandwidth to <b>buffered</b> <b>memory</b> ...|$|R
50|$|Moreover, some {{methods for}} {{delivering}} Quality of Service (QOS) using packet metering algorithms may intentionally hold back packets {{to meet the}} quality specifications in the transmission. This is achieved by using <b>buffer</b> <b>memories.</b>|$|R
50|$|In Mailbox mode, the {{controllers}} {{on either}} side can place a message into the converter's <b>buffer</b> <b>memory,</b> {{for the other side}} to retrieve from that memory.|$|E
50|$|More {{sophisticated}} systems use a <b>buffer</b> <b>memory</b> {{to store}} {{some or all}} of the teletext pages as they are broadcast, allowing instant display from the buffer.|$|E
50|$|DAT+ and DAT- signals will be {{activated}} {{as soon as}} data {{is placed in the}} internal data <b>buffer</b> <b>memory.</b> DAT- goes positive and then activates the BSEL lines 3.5ms after the DAT lines are activated. The bus speed in DOLLx8 network is managed by the CLK signal and are currently set to 36kHz, which represents 14 milliseconds between each clock pulse. The bus clock is controlled by a positive BSEL- signal (BSEL + goes then simultaneously negative or low) and remains high {{as long as there is}} data in the data <b>buffer</b> <b>memory.</b> When data communication is completed and DAT receives HEX 0D 0A (CRLF) from the data <b>buffer</b> <b>memory,</b> the BSEL+ signal goes high again while BSEL signal goes low, which results in that the CLK signal ceases. The DOLLx8 system is then passively in standby or hibernation mode with minimal power consumption that leads to zero electromagnetic interference (EMI) in the network.|$|E
40|$|Abstract—Decoding of Turbo Codes {{requires}} <b>buffer</b> <b>memories</b> {{to store}} the received values and the extrinsic information that is exchanged between the constituent decoders. In this paper, the effect of unreliable <b>buffer</b> <b>memories</b> on the decoding performance is analyzed. The buffer is modeled as a discrete memoryless channel, which introduces spatially independent and uniform bit errors on the binary representation of the stored values. This leads to a strong performance degradation if a conventional Turbo decoding algorithm is employed. It is however shown that suitable modification of quantizer, index assignment, and of the transition metrics of the MAP algorithm can effectively compensate for these errors. I...|$|R
30|$|The main {{function}} of the Timer A ISR is to fill up a <b>memory</b> <b>buffer</b> (packet[]) with samples from the sensors. The variable ptr is employed {{to keep track of}} how many samples have been stored in the <b>memory</b> <b>buffer</b> so far. When the <b>memory</b> <b>buffer</b> is filled (ptr = PACKET_LEN), its contents are passed to the radio transceiver and a DATA packet is transmitted. Figure 11 b shows the <b>memory</b> <b>buffer</b> being filled with readings from the ADC (strain data). To transmit acceleration data, the <b>memory</b> <b>buffer</b> should be filled with readings from the accelerometer.|$|R
25|$|Registered or <b>buffered</b> <b>memory,</b> which {{improves}} {{signal integrity}} (and hence potentially clock rates and physical slot capacity) by electrically buffering the signals with a register, {{at a cost}} of an extra clock of increased latency. Those modules are identified by an additional R in their designation, for example PC3-6400R.|$|R
5000|$|The {{waveform}} amplitude {{values are}} stored in a <b>buffer</b> <b>memory,</b> which is stored in a phase generator. When addressed, the retrieved value is {{used as the basis}} of the synthesized sound.|$|E
5000|$|Buffer {{underrun}} protection: When {{a buffer}} underrun occurs, the drive suspends writing. The drive memorizes the end writing point and timing, and immediately resumes writing from that exact point when sufficient data is {{filled in the}} <b>buffer</b> <b>memory.</b>|$|E
50|$|Recording {{software}} maintains larger buffers {{than when}} CD recorders were first introduced. Some recorders maintain their own <b>buffer</b> <b>memory</b> {{independently of the}} computer. This additional buffering ensures that momentary pauses in the supply of data do not cause buffer underrun.|$|E
30|$|We {{find that}} {{hardware}} instruction tracing simplifies the isolation enforcement as it records tracing data securely and efficiently. For example, Intel PT can be configured by the kernel driver {{to save the}} trace into a <b>memory</b> <b>buffer</b> which is inaccessible from the traced application. Thus the application is incapable of corrupting the trace. Additionally, the hardware facility addresses the <b>memory</b> <b>buffer</b> with physical <b>memory</b> address, which allows the trace to be written to the user-mode inaccessible <b>memory</b> <b>buffer</b> without a processor mode switching to the kernel mode.|$|R
5|$|Each {{background}} processor {{consisted of}} a computation section, a control section and local memory. The computation section performed 64-bit scalar, floating point and vector arithmetic. The control section provided instruction <b>buffers,</b> <b>memory</b> management functions, and a real-time clock. 16 kwords (128 kbytes) of high-speed local memory was incorporated into each background processor for use as temporary scratch memory.|$|R
50|$|Xeon E7-48xx v3 and E7-88xx v3 series {{contain a}} quad-channel {{integrated}} memory controller (IMC), supporting both DDR3 and DDR4 LRDIMM or RDIMM memory modules {{through the use}} of Jordan Creek (DDR3) or Jordan Creek 2 (DDR4) <b>memory</b> <b>buffer</b> chips. Both versions of the <b>memory</b> <b>buffer</b> chip connect to the processor using version 2.0 of the Intel Scalable Memory Interconnect (SMI) interface, while supporting lockstep memory layouts for improved reliability. Up to four <b>memory</b> <b>buffer</b> chips can be connected to a processor, with up to six DIMM slots supported per each <b>memory</b> <b>buffer</b> chip.|$|R
50|$|USB 3.0 SuperSpeed {{oscilloscopes}} from Pico Tech {{offers up}} to 500 MHz bandwidth (1.25Gsample/s) on four channels, and 2 GS of <b>buffer</b> <b>memory</b> shared between the channels. Pico Tech has been variously credited {{for developing the}} world's first USB 3.0 PC-based oscilloscope.|$|E
5000|$|... // {{allocate}} the <b>buffer</b> <b>memory</b> objects cl_mem memobjs = { clCreateBuffer(context, CL_MEM_READ_ONLY | CL_MEM_COPY_HOST_PTR, sizeof(float) * 2 * NUM_ENTRIES, NULL, NULL), clCreateBuffer(context, CL_MEM_READ_WRITE, sizeof(float) * 2 * NUM_ENTRIES, NULL, NULL) }; // cl_mem memobjs0 = // FIXED, SEE ABOVE // cl_mem memobjs1 = // FIXED, SEE ABOVE ...|$|E
5000|$|Versions {{using an}} {{electrical}} HS channel require an additional active component, {{in the form}} of a [...] "central repeater", with multi-tap collector and distributor lines (which use directional couplers to connect to the LRIs) and a <b>buffer</b> <b>memory,</b> to allow for small differences in data rates.|$|E
40|$|This paper {{describes}} a new algorithm and hardware {{design for the}} generation of two dimensional images from volume data using the ray casting technique. The algorithm {{is part of an}} image generation system that is broken down into three subsystems. The first subsystem stores the input data in a <b>buffered</b> <b>memory</b> using a rearrangement of the original address value. The second subsystem reads data points from the <b>buffered</b> <b>memory</b> and shifts the data to computational elements in order to complete the viewing calculations for the image synthesis process. The final stage takes the results of the viewing calculations combined with the original input data to complete the surface rendering and pixel compositing to create the final image. This paper focusses on the second subsystem which consists of two, two dimensional arrays of processing elements. The first array performs a limited angle, single dimension rotation by shifting the data. The second array performs a two dimensional ray casting opera [...] ...|$|R
50|$|Fully Buffered DIMM (FB-DIMM) modules {{are used}} in some systems with large maximum memory capacities. In normal registered/{{buffered}} memory only the control lines are buffered, whereas in fully <b>buffered</b> <b>memory</b> the data lines are buffered as well with all transfers performed in a serial fashion; the additional logic present on each FB-DIMM module transforms serial input into parallel signals required to drive memory chips.|$|R
40|$|This work {{models and}} evaluates a new cache {{structure}} for scalable multithreaded computer systems. Multithreaded architectures which support the speculative execution of multiple concurrent threads of execution require a special speculative <b>memory</b> <b>buffer</b> {{to detect and}} potentially correct dependences at runtime. The main question being addressed {{in this study is}} whether this speculative <b>memory</b> <b>buffer</b> should be merged with a nonspeculative cache, or kept separate. As a related question, we also evaluate whether the traditional cache structure should be private to each processing element, or whether the cache should be shared among all processing elements. Our results and costfor -performance analysis show that, on average, the novel hybrid level- 1 data cache (which merges a distributed level- 1 data cache with the speculative <b>memory</b> <b>buffer)</b> has a 13 percent slowdown as compared to an ideal shared level- 1 cache with separate speculative <b>memory</b> <b>buffers.</b> The distributed level 1 cache with separate speculative <b>memory</b> <b>buffer</b> showed, on average, a 4 percent speedup compared to an ideal shared level- 1 cache with separate speculative <b>memory</b> <b>buffers...</b>|$|R
50|$|Vivante {{produces}} mobile GPUs {{which have}} tightly coupled frame <b>buffer</b> <b>memory</b> (similar to the Xbox 360 GPU described above). Although {{this can be}} used to render parts of the screen, the large size of the rendered regions means that they are not usually described as using a tile-based architecture.|$|E
5000|$|With the {{introduction}} of multitasking operating systems on PC hardware, such as OS/2, Windows NT or various flavours of UNIX, the short time available to serve character-by-character interrupt requests became a problem, therefore the IBM PS/2 serial ports introduced the 16550(A) UARTs that had a built-in 16 byte FIFO or <b>buffer</b> <b>memory</b> to collect incoming characters.|$|E
50|$|In this method, {{a picture}} {{is stored in}} a line or frame buffer with n1 speed (data rate) and is read with n2 speed, several picture {{processing}} techniques are applicable when the picture is stored in <b>buffer</b> <b>memory</b> including kinds of interpolation from simple to smart high order comparisons, motion detection and … to improve the picture quality and prevent the conversion artifacts.|$|E
5000|$|... "In the Four-Phase System IV/70 {{the memory}} and control {{requirements}} {{of up to}} 32 keyboard display terminals are combined with the mainframe memory and logic of the Central Processing Unit. As a result, data is displayed directly from refresh areas of the Four-Phase Systems parallel-accessed LSI memory, eliminating the cost of separate <b>buffer</b> <b>memories</b> in every terminal. Using this technique, exceptionally high video throughput results, enabling new information to be displayed {{at a rate of}} 395,000 characters per second." ...|$|R
40|$|We {{describe}} Nikola, a first-order {{language of}} array computations embedded in Haskell that compiles to GPUs via CUDA {{using a new}} set of type-directed techniques to support re-usable computations. Nikola automatically handles a range of low-level details for Haskell programmers, such as marshaling data to/from the GPU, size inference for <b>buffers,</b> <b>memory</b> management, and automatic loop parallelization. Additionally, Nikola supports both compiletime and run-time code generation, making it possible for programmers to choose when and where to specialize embedded programs...|$|R
50|$|Registered (also called <b>buffered)</b> <b>memory</b> modules have a {{register}} between the DRAM modules and the system's memory controller. They place less electrical {{load on the}} memory controller and allow single systems to remain stable with more memory modules {{than they would have}} otherwise. When compared with registered memory, conventional memory is usually referred to as unbuffered memory or unregistered memory. When manufactured as a dual in-line memory module (DIMM), {{a register}}ed memory module is called an RDIMM, while unregistered memory is called UDIMM.|$|R
5000|$|In {{the case}} of FCS, when a file was deleted, the {{individual}} file would be [...] "removed from the file list volume" [...] and remaining data would be moved to fill sequential empty space, using the 4 KB portion of display video RAM as a transfer <b>buffer</b> <b>memory.</b> In modern-day terms, files would be automatically defragmented to prevent cross-linked files.|$|E
50|$|The VGA text buffer {{is located}} at {{physical}} memory address 0xB8000. Since this is usually used by 16-bit x86 processes operating in real-mode, {{it is the first}} half of memory segment 0xB800. The text buffer data can be read and written, and bitwise operations can be applied. A part of text <b>buffer</b> <b>memory</b> above the scope of the current mode is accessible, but is not shown.|$|E
50|$|The printer {{had some}} {{graphical}} capabilities, {{as you could}} design your own character shapes, or even turn on or off individual pixels.However, the <b>buffer</b> <b>memory</b> could not hold sufficient information to print a whole line in graphic mode, and you could notalter line spacing, so {{it was impossible to}} print continuous graphics.The printer nevertheless provided some printing utilities that were able to graph a function on a band of paper.|$|E
30|$|The memory {{foot-print}} {{required by}} our implementation is {{significantly lower than}} the one imposed by a direct implementation. A straightforward implementation would require a large <b>memory</b> <b>buffer</b> to store the complete cost volume in order to process it pixel-by-pixel and avoid computing (the same) color weights across different slices. In the proposed implementation, two <b>memory</b> <b>buffers</b> with relatively low sizes are required: a <b>memory</b> <b>buffer</b> which is equal to the processing window size to store current color weights, and a buffer to store the cost values for the current pixel along the 'd' dimension. In case of multi-thread (parallelized) implementation, these <b>memory</b> <b>buffers</b> are multiplied by the number of processing threads. More information about platform-specific optimization of the proposed algorithm is given in [20].|$|R
30|$|Mapper {{function}} iterates over input {{sequence and}} prepares intermediate 〈key, value〉 pairs. Intermediate results are <b>buffered</b> in <b>memory</b> mapper worker and periodically written to distributed file system.|$|R
40|$|A {{seismic signal}} {{processor}} {{was developed and}} tested for use with the NOAA-GOES satellite data collection system. Performance tests on recorded, as well as real time, short period signals indicate that the event recognition technique used is nearly perfect in its rejection of cultural signals and that data can be acquired in many swarm situations {{with the use of}} solid state <b>buffer</b> <b>memories.</b> Detailed circuit diagrams are provided. The design of a complete field data collection platform is discussed and the employment of data collection platforms in seismic network is reviewed...|$|R
