0|47|Public
40|$|<b>Barrelfish</b> {{operating}} system is an experimental instance of multikernel structure which exhibits good {{features such as}} hardware heterogeneity, scalability, dynamicity, etc. <b>Barrelfish</b> is in progress and lacks applications. Therefore, {{there is a need}} to investigate the efficiency of applications running in <b>Barrelfish</b> and one of candidates is a shared-memory application. To conduct an empirical study, Cilk is chosen inasmuch as its runtime library is designed for shared-memory architectures and it has been known to expose good performance. This thesis focuses on making Cilk run on top of <b>Barrelfish</b> in order to reach two goals: portability which is described to be supported by <b>Barrelfish,</b> and good speed afterwards. The porting involves compiling Cilk runtime source code by replacing its pthread subroutines with set of APIs in <b>Barrelfish</b> and then changing the way Cilk scheduler spawns worker thread on multiple cores. However, the main point of the porting is to make different cores access to the same virtual address space. Luckily, <b>Barrelfish</b> provides a notion of domain which specifies the number of cores in an application so that these cores can share the same memory space. This thesis also has carried out benchmarks on some Cilk programs and found that Cilk does not perform as well as it is expected. In addition measurements on parallel workers shows that Cilk on <b>Barrelfish</b> takes more cycles to perform computation. Although Cilk still maintains work-first principle, it cannot achieve the time bound. The spanning domain cost is proportional to the number of cores, but it will matter if applications take small time to complete...|$|R
5000|$|Hyperoglyphe japonica (Döderlein (de), 1884) (Pacific <b>barrelfish)</b> ...|$|R
40|$|Obtaining {{detailed}} information about the internal events occurring in an operating system {{is a prerequisite for}} understanding performance, overhead, and many subtle timing- related bugs and race conditions. <b>Barrelfish</b> is a research operating system that is developed by ETH Zurich in collaboration with Microsoft Research. It has a simple tracing mechanism which works together with a visualization tool. The current tracing infrastructure for <b>Barrelfish</b> is not very sophisticated and unable to handle traces longer than a few thousand processor cycles. In this lab, we extend the tracing functionality provided in <b>Barrelfish</b> an...|$|R
40|$|This {{document}} {{discusses the}} state of capabilities in the <b>Barrelfish</b> operating system. Chapter 2 lists the currently known issues with capability management and 3 discusses the type system. Chapter 4 discusses {{the current state of}} the implementation in <b>Barrelfish,</b> chapter 5 discusses different approaches for maintaining a multicore mapping database of capabilities, chapter 6 discusses the requirements from a correc...|$|R
40|$|Effective {{coordination}} and synchronization between processes remains {{a challenge that}} becomes even more important {{with the rise of}} multi-core hardware. This thesis introduces Octopus, a coordination service for the <b>Barrelfish</b> operating system. Octopus addresses the problem of coordination be-tween concurrent processes or activities in <b>Barrelfish.</b> The Octopus de-sign is influenced by ideas from distributed computing. We show that these ideas are transferrable to operating systems. We used a declar-ative, logic programming engine to implement parts of the Octopus service and evaluate the benefits and drawbacks of this approach. In a case study, we used Octopus to write a service that is responsible for device management and bootstrapping the OS as well as a replace-ment for the <b>Barrelfish</b> name server. Our experience with Octopus has shown that it simplifies programming services that require complex co...|$|R
40|$|This {{technical}} note describes {{a set of}} design proposals (and prototype implementation) of multi-hop message routing in <b>Barrelfish</b> – how to send messages between cores which {{do not have a}} direct con-nection between them. This arises in, for example, Ethernet communication with a fully-distributed <b>Barrelfish</b> instance, or between multiple cores spread out over a PCIe bus (as is the case with Xeon Phi or Intel SCC). All inter-core communication in <b>Barrelfish</b> is performed using explicit messages, which are carried over ”Interconnect Drivers ” (ICDs), specialized messaging subsystems that carry data between cores. At present, all communication happens over direct point-to-point ICD links. However, there are multiple motivations for extending this. In this note, we motivate the introduction of a routing layer in <b>Barrelfish.</b> 1. 1 Partial connectivity Most current multicore machines are fully connected via shared memory. This means that any core in the system can communicate with any other core in the system by using shared memory. Most applications are also designed accordingly. However, this assumption is not necessarily true on modern hardware, as the following two examples illustrate: • On the Intel Single Chip Cloud Computer (SCC), the set of memory a core can access is determine...|$|R
40|$|This {{distributed}} systems lab project is about extending <b>Barrelfish</b> networking architecture. Before this project, {{the system could}} only support a single application for network interaction but now it can support several. To make this happen, extensive changes in the e 1000 NIC driver had to be introduced. A previous lab project named bfdmux had to be integrated within <b>Barrelfish</b> which included a simple virtual machine for demultiplexing incoming packets to different users and doing sanity checks on outgoing packets. Finally, a networking daemon is now necessary for client management, namely port allocation and security checks...|$|R
40|$|Commodity {{computer}} systems contain {{more and more}} specialized hardware tailored to perform certain tasks with optimal efficiency and power consumption. Due to its relatively simple RISC (Reduced Instruction Set Computer) based instruction set, which allows for cheap and highly optimised hardware with low power consumption, ARM based chips have become increasingly popular. This thesis describes the port of <b>Barrelfish,</b> a research operating system developed at ETH Zurich, to a multi-core ARMv 7 -a architecture simulated by Gem 5. <b>Barrelfish’s</b> multikernel architecture inherently supports heterogeneous processor systems and with Gem 5 we target a very interesting hardware simulator. It allows us to simulate {{a wide range of}} system configurations, from simple single-core one-cycle-per-instruction CPU system without caches, to a possibly heterogeneous, multi-core, pipelined, out-of-order CPU system with arbitrarily deep levels of caches. We managed to bring up <b>Barrelfish</b> on Gem 5 supporting up to four cores interacting with each other. The evaluation of our port shows, at least qualitatively...|$|R
40|$|<b>Barrelfish</b> is a {{research}} operating system with {{the focus on the}} scalability of manycore architectures and the increasing numbers of heterogeneous hardware. Instead of heavily relying on the cache coherency protocol which has been proved to be an inherent bottleneck on manycore systems, <b>Barrelfish</b> employs the thought of distributed systems and uses the message-passing approach to implement inter-core communication. The TilePro architecture is a manycore system with up to 64 cores and several mesh networks. Because of its special hardware design, TilePro {{is considered to be a}} ideal vehicle to run <b>Barrelfish</b> on, in order to make full use of the advantages from its manycore and network structure. The porting of <b>Barrelfish</b> on TilePro architecture involves some general set-ups of image booting, virtual memory system, context switch, interrupts and system calls, inter-dispatcher communication and so on. At the beginning, the whole system fully starts up on the first logic core, and later the monitor process on the first core will be responsible for booting up others in order, according to the pre-configuration of memory space on the initial core. There are two sorts of communication provided originally in <b>Barrelfish</b> under the protocol of user remote procedure call (URPC). The local message passing (LMP), which happens when two dispatchers communicate with each other on the same core, is implemented by invoking system calls, passing all the values through reserved registers. The user-level message passing (UMP), which is designed for inter-core communication, depends on a shared memory approach. The inter-core communication begins as the second core is starting. The project also investigates how to utilize TilePro mesh network structure to fulfil the inter-core communication so that the characteristic of the architecture would be exploited thoroughly. TilePro offers several mesh networks with different properties and behaviours. In this case, we mainly use user dynamic network (UDN) instead of UMP to carry out remote core-to-core communication, although still based on the existing protocol of URPC. The result shows that <b>Barrelfish</b> can completely boots up on two cores at least and some user applications could be executed either on the first core or on the second properly, while the core-to-core communication is working on TilePro UDN network...|$|R
40|$|Direct {{memory access}} (DMA) is {{commonly}} used to perform data movement between peripheral devices and main memory independently of the processor. This thesis describes {{how to use a}} system-wide DMA engine, such as the one found in the OMAP system-on-chip platform, to perform memoryto-memory transfers. A driver for this DMA engine is implemented for the <b>Barrelfish</b> operating system, a research operating system developed at ETH Zurich. The driver relies on <b>Barrelfish’s</b> asynchronous message passing system for inter-process communication, as well as the capability system <b>Barrelfish</b> uses for memory management. The capability system allows user space applications to refer to physical memory regions in a secure and sound way, while the asynchronous remote procedure call interface of the driver allows applications to perform computations in parallel with the memory transfer which was offloaded to the device. As part of the evaluation, the raw performance of the hardware device is measured, as well as the overhead introduced by the software driver managing the device. The DMA engine is used in...|$|R
40|$|Personal {{computing}} hardware {{is becoming}} ever more complex with more cores being added. It is moving {{from being a}} multi-core to a many-core system. In {{the next ten years}} we are expected to see hundreds of cores on one single chip. It is also very likely we will see more specialized hardware in coexistence with general purpose processing units. The cache-coherent shared-memory operating systems of today do not scale well on the hardware of tomorrow. As the number of cores grows, so does the complexity of the interconnects. The hardware cache-coherence protocols shared-memory operating systems of today rely upon subsequently become increasingly expensive with a greater overhead. As a result, it is entirely possible that operating system of tomorrow will have to handle non-coherent memory. The expected increase in hardware diversity and issues such as cache coherency on hundred core systems poses new challenges for operating system designers. <b>Barrelfish</b> is a research operating system with the purpose of exploring operating-system design of the future. It is a multi-kernel operating system for multi-core systems and utilizes message passing as a way of communication between kernels. <b>Barrelfish</b> assumes no shared-memory, however it does not explicitly forbid shared-memory. The purpose of this thesis is to performance evaluate <b>Barrelfish</b> using Simics with a modeled approximation of an existing cache structure from a modern processor. A Wool ported version of the Barcelona OpenMP Task suite was used for the purpose of work load simulation, and a comparison between Linux and <b>Barrelfish</b> has been made...|$|R
40|$|A major {{obstacle}} when introducing a new operating system is device sup-port. We analyze {{the possibility of}} using a virtualized Linux to provide driver support for PCI devices, by extending the <b>Barrelfish</b> virtual machine VMKit. As {{it turns out to be}} impossible to create a generic PCI passthrough without any hardware support (IOMMU), we focus our work on one spe-cific network card. For allowing DMA to work correctly, we translate the physical addresses in software. To access the device from <b>Barrelfish</b> we pro-vide a virtual network adapter and use the Linux Ethernet bridging to pass packets. Our measurements show an order of magnitude smaller throughput than a native driver solution, but still there’s room for improvement left...|$|R
40|$|The future manycore {{architectures}} present serious {{challenges to}} operating system designers. The traditional operating system designs {{can no longer}} manage the capabilities {{and power of the}} diverse heterogeneous cores with complex memory hierarchies, interconnects resembling networks, and distributed I/O configurations. The <b>Barrelfish</b> multikernel operating system addresses these issues by treating hardware as a distributed system. Co-operation in such an environment is achieved by message passing. We borrow similar design ideas in this thesis and present a distributed USB hot plugging infrastructure for a multikernel <b>Barrelfish</b> operating system. We have divided the USB system into three primary modules with different responsibilities: Host controller driver, USB manager and client drivers. This modular design provides necessary isolation and flexibility required in manycore systems. It also provides freedom to schedule and, if required, migrate any module independently among the cores depending upon the system workload and the application requirements. These modules communicate by explicit message passing but a few frequently updated and performance critical data structures are shared using shared memory mechanism. In this thesis, we try to design, implement and evaluate this system on top of message services and abstractions provided by the <b>Barrelfish</b> operating system...|$|R
40|$|All inter-core {{communication}} in <b>Barrelfish</b> {{is performed using}} explicit messages, which are carried over ”Interconnect Drivers ” (ICDs), specialized messaging subsystems that carry data between cores. At present, all communication happens over direct point-to-point ICD links. However, there are multiple motivations for extending this. In this chapter, we motivate {{the introduction of a}} routing layer in <b>Barrelfish.</b> 1. 1 Partial connectivity Most current multicore machines are fully connected via shared memory. This means that any core in the system can communicate with any other core in the system by using shared memory. Most applications are also designed accordingly. However, this assumption is not necessarily true on modern hardware, as the following two examples illustrate: • On the Intel Single Chip Cloud Computer (SCC), the set of memory a core can access is determined by the setup of its Look Up Tables (LUTs). It is possible that these tables are set-up in such a manner that two or more cores {{do not have access to}} the same region of memory. In such cases to communication these cores will have to route via another set of cores if such a path exists. • If <b>Barrelfish</b> is operated on a cluster of machines, there is only an Ethernet-based ICD link between the core(s) where the network stack is running. In order to allow every core to communicate with every othe...|$|R
50|$|The {{partners}} {{released the}} first {{snapshot of the}} OS on September 15, 2009 with a second being released in March, 2011. Excluding some third-party libraries, which are covered by various BSD-like open source licenses, <b>Barrelfish</b> is released under the MIT license. Snapshots are regularly released, the last one dating to December 23, 2016.|$|R
40|$|Trying {{to attack}} the problem of {{resource}} contention, created by multiple parallel applications running simultaneously, we propose a space-sharing, two-level, adaptive scheduler for the <b>Barrelfish</b> operating system. The first level is system-wide, existing inside the OS, and has knowledge of the available resources, while the second level {{is aware of the}} parallelism in the application. Feedback on efficiency from the second-level to the first-level, allows the latter to adaptively modify the allotment of cores (domain) thus intelligently avoiding time-sharing. In order to avoid excess inter-core communication, the first-level scheduler is designed as a distributed service, taking advantage of the message-passing nature of <b>Barrelfish.</b> The processor topology is partitioned so that each instance of the scheduler handles an appropriately sized subset of cores. Malleability is achieved by suspending worker-threads. Two different methodologies are introduced and explained, each ideal for different situations. QC 20120202 Barrelfis...|$|R
40|$|Abstract—Traditional OS {{architectures}} {{based on}} a single, shared-memory kernel face significant challenges from hardware trends, in particular the increasing cost of system-wide cachecoherence as core counts increase, {{and the emergence of}} heterogeneous architectures – both on a single die, and also between CPUs, co-processors like GPUs, and programmable peripherals within a platform. The multikernel is an alternative OS model that employs message passing instead of data sharing and enables architectureagnostic inter-core communication, including across non-coherent shared memory and PCIe peripheral buses. This allows a single OS instance to manage the complete collection of heterogeneous, non-cache-coherent processors as a single, unified platform. We report on our experience running the <b>Barrelfish</b> research multikernel OS on the Intel Single-Chip Cloud Computer (SCC). We describe the minimal changes required to bring the OS up on the SCC, and present early performance results from an SCC system running standalone, and also a single <b>Barrelfish</b> instance running across a heterogeneous machine consisting of an SCC and its host PC. I...|$|R
40|$|This lab project {{introduces}} an AHCI {{driver and}} associated ATA primitives to <b>Barrelfish</b> 1. In-terfacing disks is implemented {{in a library}} that communicates with a management service. To enable integration of multiple controllers offering access to ATA/ATAPI-based devices, Floun-der modifications including a backend for AHCI are proposed. This project also provides a basic analysis of the driver’s performance characteristics. To demonstrate usage, a simple test...|$|R
50|$|<b>Barrelfish</b> is an {{experimental}} computer operating system built by ETH Zurich {{with the assistance}} of Microsoft Research in Cambridge. It is {{an experimental}} operating system designed from the ground up for scalability for computers built with multi-core processors with the goal of reducing the compounding decrease in benefit as more CPUs are used in a computer via putting low level hardware information in a database, removing the necessity for driver software.|$|R
40|$|A {{multiprocessor}} system with uniform memory access {{is difficult to}} scale due to the increasing contention on the memory bus and {{the complexity of the}} connections between CPUs and memory modules. Non-uniform memory access (NUMA) offers a solution for these problems by introducing so called nodes. Each node consists of a set of processors and local memory. Even though every processor can access memory on all nodes, the access delay differs for local and remote memory. Applications spanning over multiple cores might suffer from a high access delay for ill-placed memory. In this thesis, we introduce an extension for the <b>Barrelfish</b> operating system capable of detecting local and remote memory access and migrating memory between nodes. To achieve automatic NUMA optimization, we implement a migration policy which analyzes the access pattern and tries to find an optimal memory placement. Furthermore, we present a benchmark for measuring the impact of NUMA optimization on memory access performance. Acknowledgements First and foremost, I would like to thank Prof. Timothy Roscoe and Kornilios Kourtis for providing me with the opportunity to explore <b>Barrelfish</b> and contribute to it. This thesi...|$|R
25|$|The terrace {{consists}} of long and well-defined rocky ridges made of limestone {{that provide a}} habitat for many types of corals, sponges, and fish. Fish species observed there include wreckfish, <b>barrelfish,</b> and bright red alphonsinos. Recently observed intertebrate species have included Lophelia pertusa coral, stylasterine hydrocoral (Stylasteridae), bamboo coral (Isididae), and various sponges and octocorals. Motile invertebrates such as crabs and urchins have also been observed there, including Asteroporpa sp. ophiuroids, Stylocidaris sp. urchins, Mollusca, Actiniaria, and Decapoda crustaceans (Chaceon fenneri and Galatheidae).|$|R
40|$|April 2011 –July 2011 This lab project {{introduces}} an AHCI {{driver and}} associated ATA primitives to <b>Barrelfish</b> 1. Interfacing disks is implemented {{in a library}} that communicates with a management service. To enable integration of multiple controllers offering access to ATA/ATAPIbased devices, Flounder modifications including a backend for AHCI are proposed. This project also provides a basic analysis of the driver’s performance characteristics. To demonstrate usage, a simple testcase, a FAT filesystem implementation and a simple block device filesystem are introduced...|$|R
50|$|The terrace {{consists}} of long and well-defined rocky ridges made of limestone {{that provide a}} habitat for many types of corals, sponges, and fish. Fish species observed there include wreckfish, <b>barrelfish,</b> and bright red alphonsinos. Recently observed intertebrate species have included Lophelia pertusa coral, stylasterine hydrocoral (Stylasteridae), bamboo coral (Isididae), and various sponges and octocorals. Motile invertebrates such as crabs and urchins have also been observed there, including Asteroporpa sp. ophiuroids, Stylocidaris sp. urchins, Mollusca, Actiniaria, and Decapoda crustaceans (Chaceon fenneri and Galatheidae).|$|R
25|$|Medusa fishes are {{a family}} Centrolophidae of 31 species of perciform fishes. They {{are found in}} {{temperate}} and tropical waters throughout the world, usually feeding on fish, crustaceans and small squid near rough sea floors on continental shelf and slope. Examples are <b>barrelfish,</b> southern driftfish, imperial blackfish, the Japanese and pelagic butterfish, the New Zealand and Tasmanian ruffe, and the common, silver and white warehou. The young of some species associate with jellyfish, which provides them with protection from predators and opportunities to scavenge {{the remains of the}} jellyfish's meals. The young of other species associate with large masses of floating kelp.|$|R
40|$|We present Palirria, a {{self-adapting}} work-stealing scheduling {{method for}} nested fork/join parallelism {{that can be}} used to estimate the number of utilizable workers and self-adapt accordingly. The estimation mechanism is optimized for accuracy, minimizing the requested resources without degrading performance. We implemented Palirria for both the Linux and <b>Barrelfish</b> operating systems and evaluated it on two platforms: a 48 -core NUMA multiprocessor and a simulated 32 -core system. Compared to state-of-the-art, we observed higher accuracy in estimating resource requirements. This leads to improved resource utilization and performance on par or better to executing with fixed resource allotments. QC 20140520 </p...|$|R
40|$|Modern {{computers}} increasingly resemble networks, with {{processor and}} memory layouts becoming less symmetrical. Traditional operating systems were {{built on the}} abstraction of a single program running on identical cores with identical views of memory. A multikernel {{on the other hand}} does not depend on such assumptions, making it suitable to run on heterogeneous architectures. In this thesis, we apply the multikernel approach to the OMAP 4460 SoC. We ported the <b>Barrelfish</b> operating system to the Cortex-M 3 microcontroller and ran it together with the existing Cortex-A 9 port. We present the challenges with porting a general purpose operating system to a microcontrolle...|$|R
5000|$|Medusa fishes are {{a family}} Centrolophidae of 31 species of perciform fishes. They {{are found in}} {{temperate}} and tropical waters throughout the world, usually feeding on fish, crustaceans and small squid near rough sea floors on continental shelf and slope. Examples are <b>barrelfish,</b> southern driftfish, imperial blackfish, the Japanese and pelagic butterfish, the New Zealand and Tasmanian ruffe, and the common, silver and white warehou. The young of some species associate with jellyfish, which provides them with protection from predators and opportunities to scavenge {{the remains of the}} jellyfish's meals. The young of other species associate with large masses of floating kelp.|$|R
40|$|Processors have {{historically}} attained performance improvements primarily by increasing frequency {{and the number}} of transistors. As the transistor density increases, keeping the power density constant gets harder. As a result, future processors {{will not be able to}} power all transistors simultaneously without exceeding the power budget. This phenomenon is coined Dark Silicon, referring to the part of the silicon that must be left unpowered. The issue with dark silicon can be mitigated by building heterogeneous computing systems. Such systems consist of several specialised components, each highly efficient in performing a specific task and workload. The SHMAC project was initiated by NTNU to investigate the challenges in designing heterogeneous computing systems. The output of the project is a heterogenous processor called SHMAC, which has an architecture consisting of a grid of computing tiles. One of the available computing tile is an ARMv 3 compliant CPU core. The current software for SHMAC is primarily using this tile as the target CPU. This thesis presents the first functional debugger for SHMAC. The debugger is based on the GNU Debugger (GDB), a popular open-source debugger maintained by the Free Software Foundation. Future software development on SHMAC will greatly benefit from having a proper tool for debugging. Another contribution is the integration of the debugger with <b>Barrelfish,</b> the first functional operating system for SHMAC. The integration facilitates kernel debugging and debugging of user programs running on <b>Barrelfish.</b> </p...|$|R
5000|$|... seL4 takes a novel {{approach}} to kernel resource management, exporting the management of kernel resources to user level and subjects them to the same capability-based access control as user resources. This model, which was also adopted by <b>Barrelfish,</b> simplifies reasoning about isolation properties, and was an enabler for later proofs that seL4 enforces the core security properties of integrity and confidentiality. The NICTA team also proved correctness of the translation from C to executable machine code, taking the compiler out of the trusted computing base of seL4. This implies that the high-level security proofs hold for the kernel executable. seL4 is also the first published protected-mode OS kernel with a complete and sound worst-case execution-time (WCET) analysis, a prerequisite for its use in hard real-time systems.|$|R
40|$|This paper tackles {{the problem}} of {{providing}} familiar OS abstractions for I/O (such as pipes, network sockets, and a shared file system) to applications on heterogeneous cores including accelerators, co-processors, and offload en-gines. We aim to isolate the implementation of these facil-ities from {{the details of a}} platform’s memory architecture, which is likely to include a combination of cache-coherent shared memory, non-cache-coherent shared memory, and non-shared memory, all in the same system. We propose coherence-oblivious sharing (Cosh), a new OS abstraction that provides inter-process sharing with clear semantics on such diverse hardware. We have im-plemented a prototype of Cosh for the <b>Barrelfish</b> multi-kernel. We describe how to build common OS functional-ity using Cosh, and evaluate its performance on a hetero-geneous system consisting of commodity cache-coherent CPUs and prototype Intel many-core co-processors. ...|$|R
40|$|Investigations and fishery on {{deep water}} fish {{at the eastern}} area of the Sargasso Sea on the Corner Rising seamounts (34 – 37 °N, 47 – 53 °W) in NAFO Subarea 6 have been {{conducted}} by the Soviet Union/Russia since 1976. The total catch taken during the period amount to more than 19 000 tons. The most important species of this fishery was Alfonsino (Beryx splendens). Besides Alfonsino, black scabbard fish (Aphanopus carbo), wreckfish (Polyprion americanus), <b>barrelfish</b> (Hyperoglyphe perciforma), cardinal fish (Epigonus telescopus) and f l int-perch (Hoplostethus mediterraneus) were also of commercial importance on the Corner Rising. Biological observations on the main species, including spawning and feeding habits, distribution and formation of deepwater aggregation, and hydrographic conditions are described. Noting the limited stock sizes observed during this long-term study, an international management of the fisheries is advised...|$|R
40|$|As {{personal}} computing devices become increasingly parallel multiprocessors, {{the requirements for}} operating system schedulers change considerably. Future generalpurpose machines will need to handle a dynamic, bursty, and interactive mix of parallel programs sharing a heterogeneous multicore machine. We argue that a key challenge for such machines is rethinking scheduling as an end-to-end problem integrating components from the hardware and kernel up to the programming language runtimes and applications themselves. We present several design principles for future OS schedulers, and discuss the implications of each for OS and runtime interfaces and structure. We illustrate the implementation challenges that result by describing the concrete choices we have made in the <b>Barrelfish</b> multikernel. This allows us to present one coherent scheduling design for an entire multicore machine, {{while at the same}} time drawing conclusions we think are applicable to the design of any general-purpose multicore OS. ...|$|R
40|$|Databases and {{operating}} systems both operate {{over the same}} hardware but they have differing views of how the resources should be managed. As a result databases forgo the system services and implement their own scheduling and memory management which have been refined over several decades. Co-design {{is an area of}} research to address this by improving the collaboration between both systems. The idea is to integrate application knowledge in the operating system’s decisions, and for the database to receive notifications and adapt to changes in system state. This thesis presents work in this area which builds upon two research systems. One is <b>Barrelfish</b> OS, a realisation of the multikernel model which treats the machine as a distributed system. The other is SharedDB, an in-memory relational database designed around sharing of computation which delivers predictable performance on large and complex workloads. Our experimental result...|$|R
40|$|Task-centric {{programming}} models offer {{a versatile}} method for exposing parallelism. Such programs are popularly deployed using work-stealing scheduling runtimes. Work-stealers have traditionally employed randomness dependent techniques, considered optimal for several execution configurations. We have identified certain inefficiencies and leeway for improvement on emerging parallel architectures and workloads of fluctuating parallelism. Our deterministic victim selection (DVS) for work-stealing schedulers {{was designed to}} provide controllable and predictable uniform distribution of tasks without degrading performance; stealing is restricted between specific pairs of workers. We experimentally show that DVS offers improved scalability and performance for irregular workloads. We demonstrate DVS on Linux and <b>Barrelfish</b> operating systems, using an 48 core Opteron system and a simulated ideal platform respectively. On real hardware, we observed better scaling and 13 % average performance gains, up to 55 % for specific irregular workloads. QC 20140403 </p...|$|R
40|$|The {{architecture}} of computer systems is radically changing: core counts are increasing, systems {{are becoming more}} heterogeneous and the memory system is becoming less uniform. One of the proposed implication of this for operating systems design {{is the use of}} a message-passing primitive instead of shared-memory for communication. Message passing happens generally over direct point-to-point channels between processor cores which can directly exchange data. However, this may not be possible in machines with partial connectivity where not all cores can directly exchange data. Furthermore, it may be undesirable in cases where communication is expensive in latency or bandwidth. In this thesis, we demonstrate a routing infrastructure for the <b>Barrelfish</b> operation system that provides multi-hop messaging between cores. This allows communication between all cores in machines with partial connectivity and optimizes resource utilization by multiplexing multi-hop channels over existing communication channels. We further present the appropriat...|$|R
40|$|Popcorn Linux: {{enabling}} efficient inter-core {{communication in}} a Linux-based multikernel operating system Benjamin H. Shelton (ABSTRACT) As manufacturers introduce new machines with more cores, more NUMA-like architectures, and more tightly integrated heterogeneous processors, the traditional abstraction of a mono-lithic OS {{running on a}} SMP system is encountering new challenges. One proposed path forward is the multikernel operating system. Previous efforts have shown promising results both in scalability and in support for heterogeneity. However, one effort’s source code is not freely available (FOS), and the other effort is not self-hosting and does not support a majority of existing applications (<b>Barrelfish).</b> In this thesis, we present Popcorn, a Linux-based multikernel operating system. While Popcorn was a group effort, the boot layer code and the memory partitioning code are the authors work, and we present them in detail here. To our knowledge, we {{are the first to}} support multiple instances of the Linux kernel on a 64 -bit x 86 machine and to support mor...|$|R
