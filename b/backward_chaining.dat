318|50|Public
25|$|It wasn't {{long before}} the frame {{communities}} and the rule-based researchers {{realized that there was}} synergy between their approaches. Frames were good for representing the real world, described as classes, subclasses, slots (data values) with various constraints on possible values. Rules were good for representing and utilizing complex logic such as the process to make a medical diagnosis. Integrated systems were developed that combined Frames and Rules. One of the most powerful and well known was the 1983 Knowledge Engineering Environment (KEE) from Intellicorp. KEE had a complete rule engine with forward and <b>backward</b> <b>chaining.</b> It also had a complete frame based knowledge base with triggers, slots (data values), inheritance, and message passing. Although message passing originated in the object-oriented community rather than AI it was quickly embraced by AI researchers as well in environments such as KEE and in the operating systems for Lisp machines from Symbolics, Xerox, and Texas Instruments.|$|E
2500|$|Although it {{was based}} on the proof methods of logic, Planner, {{developed}} at MIT, was the first language to emerge within this proceduralist paradigm. [...] Planner featured pattern-directed invocation of procedural plans from goals (i.e. goal-reduction or <b>backward</b> <b>chaining)</b> and from assertions (i.e. forward chaining). [...] The most influential implementation of Planner was the subset of Planner, called Micro-Planner, implemented by Gerry Sussman, Eugene Charniak and Terry Winograd. It was used to implement Winograd's natural-language understanding program SHRDLU, which was a landmark at that time. To cope with the very limited memory systems at the time, Planner used a backtracking control structure so that only one possible computation path had to be stored at a time. Planner gave rise to the programming languages QA-4, Popler, Conniver, QLISP, and the concurrent language Ether.|$|E
2500|$|Task {{analysis}} {{is a process}} in which a task is analyzed into its component parts so that those parts can be taught through the use of chaining: forward chaining, <b>backward</b> <b>chaining</b> and total task presentation. Task analysis has been used in organizational behavior management, a behavior analytic approach to changing the behaviors of members of an organization (e.g., factories, offices, or hospitals). Behavioral scripts often emerge from a task analysis. Bergan conducted a task analysis of the behavioral consultation relationship and Thomas Kratochwill developed a training program based on teaching Bergan's skills. A similar approach was used for the development of microskills training for counselors. Ivey would later call this [...] "behaviorist" [...] phase a very productive one and the skills-based approach came to dominate counselor training during 1970–90. Task analysis was also used in determining the skills needed to access a career. In education, Englemann (1968) used task analysis as part of the methods to design the Direct Instruction curriculum.|$|E
40|$|Auction mechanisms	have	attracted	a	great	deal	of	interest	and	have	been	used	in	diverse	e-marketplaces. In	particular,	 combinatorial	auctions	have	the	potential	to	play	an	important role in	electronic	transactions. Therefore,	 diverse	combinatorial	auction	market	types	have	been	proposed	to	satisfy	market	needs. These	combinatorial	auction	types	have	diverse market characteristics,	 which	require	an	effective	market	design	approach. This	study	proposes	a	comprehensive	and	systematic	market	design	methodology	for	combinatorial auctions based	on	three	phases:	 market	architecture	design,	 auction	rule	design,	 and	winner	determination	design. A	market	architecture	design	is	for	designing	market	architecture types by	<b>Backward</b>	<b>Chain</b>	Reasoning. Auction	rules	design	is	to	design	transaction	rules	for	auctions. The	specific	auction	process	type	is	identified	by	the	<b>Backward</b>	<b>Chain</b>	Reasoning process. Winner	determination	design	is	about	determining	the	decision	model	for	selecting	optimal	bids	and	auctioneers. Optimization	models	are	identified	by	Forward	Chain Reasoning. Also,	 we	propose	an	agent	based	combinatorial	auction	market	design	system	using	<b>Backward</b>	and	Forward	<b>Chain</b>	Reasoning. Then	we	illustrate	a	design	process	for	the general n-bilateral	combinatorial	auction	market. This	study	serves	as	a	guideline	for	practical	implementation	of	combinatorial	auction	markets	design...|$|R
40|$|Auction {{mechanisms}} {{have attracted}} {{a great deal}} of interest and have been used in diverse e-marketplaces. In particular, combinatorial auctions have the potential {{to play an important role}} in electronic transactions. Therefore, diverse combinatorial auction market types have been proposed to satisfy market needs. These combinatorial auction types have diverse market characteristics, which require an effective market design approach. This study proposes a comprehensive and systematic market design methodology for combinatorial auctions based on three phases: market architecture design, auction rule design, and winner determination design. A market architecture design is for designing market architecture types by <b>Backward</b> <b>Chain</b> Reasoning. Auction rules design is to design transaction rules for auctions. The specific auction process type is identified by the <b>Backward</b> <b>Chain</b> Reasoning process. Winner determination design is about determining the decision model for selecting optimal bids and auctioneers. Optimization models are identified by Forward Chain Reasoning. Also, we propose an agent based combinatorial auction market design system using <b>Backward</b> and Forward <b>Chain</b> Reasoning. Then we illustrate a design process for the general n-bilateral combinatorial auction market. This study serves as a guideline for practical implementation of combinatorial auction markets design. Combinatorial Auction, Market Design Methodology, Market Architecture Design, Auction Rule Design, Winner Determination Design, Agent-Based System...|$|R
40|$|This study {{established}} {{a framework for}} an integrated forward and <b>backward</b> design <b>chain</b> analysis toward cross-functional product design. A cross-functional viewpoint emphasizing downstream knowledge and lesson learned was introduced for proactive product design management. The study proposed several new approaches for better cross-functional design endeavors including three stages of Concurrent Attributes Review Mechanism (CARM); modeling, simulation, and visualization mechanism; Extended Failure Mode and Effect Analysis (EFMEA); Attributes Function Deployment (AFD), and Feedback Tracking and Analysis System (FeTAS). The contributions include: (1) Proposing a novel <b>backward</b> design <b>chain</b> analysis mechanism; (2) Establishing a forward design chain approach that integrated with the backward design analysis. The integrated forward and <b>backward</b> design <b>chain</b> activities then support a proactive design concept; (3) Introduction of CARM, EFMEA, AFD...|$|R
50|$|A {{fourth class}} of rules engine {{might be called}} a {{deterministic}} engine. These rules engines may forgo both forward chaining and <b>backward</b> <b>chaining,</b> and instead utilize domain-specific language approaches to better describe policy. This approach is often easier to implement and maintain, and provides performance advantages over forward or <b>backward</b> <b>chaining</b> systems.|$|E
50|$|<b>Backward</b> <b>chaining</b> is {{implemented}} in logic programming by SLD resolution. Both rules {{are based on}} the modus ponens inference rule. It is one of the two most commonly used methods of reasoning with inference rules and logical implications - the other is forward chaining. <b>Backward</b> <b>chaining</b> systems usually employ a depth-first search strategy, e.g. Prolog.|$|E
50|$|Flex {{supports}} both forwards and <b>backward</b> <b>chaining,</b> {{and they}} can be interleaved.|$|E
5000|$|The [...] {{instruction}} saves registers 14, 15, and 0 thru 12 in a 72-byte area {{provided by}} the caller called a save area pointed to by register 13. The called routine provides its own save area for use by subroutines it calls; the address of this area is normally kept in register 13 throughout the routine. The instructions following [...] update forward and <b>backward</b> <b>chains</b> linking this save area to the caller's save area.|$|R
40|$|The {{research}} conducted {{has dealt with}} rule-based expert systems. The algorithms {{that may lead to}} effective parallelization of them have beerr investigated. Both the forward and <b>backward</b> <b>chained</b> control paradigms have been investigated {{in the course of this}} work. The best computer architecture for the developed and investigated algorithms has been researched. In the Intelligent Systems Lab at the University of South Florida, two experimental vehicles have been developed to facilitate this research. They are Backpac, a parallel <b>backward</b> <b>chained</b> rule-based reasoning system and Datapac, a parallel forward chained rule-based reasoning system. Both systems have been written in Multilisp [26], a version of Lisp which contains the parallel construct, future. Applying the future function to a function cause the function to become a task parallel to the spawning task. Backpac ha-s-also been ported to MUL-T [32], Common Lisp [59], and C. These systems originally run under a simulator developed at MCC [38]. Additionally, Backpac and Datapac have been run on several disparate parallel pro-cessors. The machines are an Encore Multimax with 10 processors (and one with 8 processors), the Concert Multiprocessor with 6 d processors, and a 32 processor BBN...|$|R
40|$|Abstract—In {{heterogeneous}} sensor networks (HSNs), {{which use}} existing key predistribution schemes, network security will significantly decline with time. In this paper, a continuous secure scheme is proposed based on two-dimensional <b>backward</b> key <b>chains.</b> In the scheme, powerful sensors {{do not need}} to be equipped with tamper-resistant hardware. Analysis and simulations indicate that the proposed scheme can significantly improve the performance of existing schemes in resilience against node capture attacks throughout the lifecycle of static HSNs. Index Terms—heterogeneous sensor network, two-dimensional <b>backward</b> key <b>chain,</b> pairwise key. I...|$|R
5000|$|... <b>backward</b> <b>chaining</b> search, {{possibly}} {{enhanced by}} the use of state constraints (see STRIPS, graphplan) ...|$|E
50|$|Programming {{languages}} such as Prolog, Knowledge Machine and ECLiPSe support <b>backward</b> <b>chaining</b> {{within their}} inference engines.|$|E
5000|$|Cyc {{inference}} engine, {{a forward}} and <b>backward</b> <b>chaining</b> inference engine with numerous specialized modules for high-order logic. (http://research.cyc.com/ ResearchCyc) (http://opencyc.org/ OpenCyc) ...|$|E
40|$|This paper {{describes}} {{the design and}} implementation of <b>backward</b> <b>chained</b> clustered RDFS reasoning in 4 store. The system presented, called “ 4 s-reasoner”, adds no overhead to the import phase and yet performs reasonably well at the query phase. We also demonstrate that our solution scales over clusters of commodity servers providing an optimal solution that balances infrastructure cost and performance over tested data sets with up to 500 M triples. In addition we have shared our implementation under GNU license and a first release is available {{to be used by}} the community...|$|R
40|$|The {{research}} conducted {{has dealt with}} rule-based expert systems. The algorithms {{that may lead to}} effective parallelization of them were investigated. Both the forward and <b>backward</b> <b>chained</b> control paradigms were investigated {{in the course of this}} work. The best computer architecture for the developed and investigated algorithms has been researched. Two experimental vehicles were developed to facilitate this research. They are Backpac, a parallel <b>backward</b> <b>chained</b> rule-based reasoning system and Datapac, a parallel forward chained rule-based reasoning system. Both systems have been written in Multilisp, a version of Lisp which contains the parallel construct, future. Applying the future function to a function causes the function to become a task parallel to the spawning task. Additionally, Backpac and Datapac have been run on several disparate parallel processors. The machines are an Encore Multimax with 10 processors, the Concert Multiprocessor with 64 processors, and a 32 processor BBN GP 1000. Both the Concert and the GP 1000 are switch-based machines. The Multimax has all its processors hung off a common bus. All are shared memory machines, but have different schemes for sharing the memory and different locales for the shared memory. The main results of the investigations come from experiments on the 10 processor Encore and the Concert with partitions of 32 or less processors. Additionally, experiments have been run with a stripped down version of EMYCIN...|$|R
40|$|This paper {{discussed}} {{the development of}} an expert system to diagnose pests and diseases on fruit plants. Rule base method was used to store the knowledge from experts and literatures. Control technique using <b>backward</b> <b>chain</b> and started from the symptoms to get conclusions about the pests and diseases that occur. Development of the system has been performed using software Corvid Exsys developed by Exsys company. Results showed that the development of this expert system can be used to assist users in identifying the type of pests and diseases on fruit plants. Further development and possibility of using internet for this system are proposed...|$|R
5000|$|In {{order to}} teach a task {{utilizing}} a <b>backward</b> <b>chaining</b> procedure, begin by breaking down the entire task into individual steps.|$|E
50|$|<b>Backward</b> <b>chaining</b> is a {{bit less}} {{straight}} forward. In <b>backward</b> <b>chaining</b> the system looks at possible conclusions and works backward {{to see if they}} might be true. So if the system was trying to determine if Mortal(Socrates) is true it would find R1 and query the knowledge base to see if Man(Socrates) is true. One of the early innovations of expert systems shells was to integrate inference engines with a user interface. This could be especially powerful with <b>backward</b> <b>chaining.</b> If the system needs to know a particular fact but doesn't it can simply generate an input screen and ask the user if the information is known. So in this example, it could use R1 to ask the user if Socrates was a Man and then use that new information accordingly.|$|E
50|$|KEE also {{includes}} a frame-based rule system. Rules themselves are frames in the KEE knowledge base. Both forward and <b>backward</b> <b>chaining</b> inference is available.|$|E
40|$|Point-of-sale (POS) systems {{increasingly}} support more retail processes {{than just}} the basic cash functionality. But {{to what extent do}} they support chain digitisation, i. e., interorganisational processes as the exchange of order and sales information? We develop a two-dimensional maturity model for categorising POS systems by their level of <b>backward</b> and forward <b>chain</b> digitisation support. Both dimensions have the same maturity scale, cumulating from internal isolated, internal integrated, external linked to external integrated. We operationalise and apply this model to the Dutch POS system market by assessing 86 different POS solutions of 79 POS vendors. It appears that about a third of all POS systems support <b>backward</b> <b>chain</b> digitisation to the external integrated level, and forward chain digitisation to the external linked level. In some branches, chain digitisation enabling initiatives are successfully deployed, e. g., in the fashion and furniture branches where EDI initiatives are established by industry boards. (aut. ref. ...|$|R
40|$|We {{clarify the}} meaning of diagonalizability of quantum Markov states. Then, we prove that each non {{homogeneous}} quantum Markov state is diagonalizable. Namely, for each Markov state ϕ on the spin algebra A:=⊗̅_̅j̅∈̅ ̅Z̅M̅_̅d̅_̅j̅^C^* there exists a suitable maximal Abelian subalgebra D⊂ A, a Umegaki conditional expectation E:A D and a Markov measure μ on spec(D) such that ϕ=ϕ_μ∘ E, the Markov state ϕ_μ, being the state on D arising from the measure μ. An analogous result is true for non homogeneous quantum processes based on the forward or the <b>backward</b> <b>chain.</b> Besides, we determine the type of the von Neumann factors generated by GNS representation associated with translation invariant or periodic quantum Markov states. Comment: 22 page...|$|R
40|$|Abstract. We {{clarify the}} meaning of diagonalizability of quantum Markov states. Then, we prove that each non {{homogeneous}} quantum Markov state is diagonalizable. Namely, for each Markov state ϕ on the spin algebra M: = ⊗ Mdj(C) C∗ there exists a suitable maximal Abelian subalgebra D ⊂ M, a Umegaki conditional expectation E: M ↦ → D and a Markov measure µ on spec(D) such that ϕ = ϕµ ◦E, the Markov state ϕµ, being the state on D arising from the measure µ. An analogous result is true for non homogeneous quantum processes based on the forward or the <b>backward</b> <b>chain.</b> Besides, we determine the type of the von Neumann factors generated by GNS representation associated with translation invariant or periodic quantum Markov states...|$|R
5000|$|Rete II can be {{characterized}} by two areas of improvement; specific optimizations relating to the general performance of the Rete network (including the use of hashed memories {{in order to increase}} performance with larger sets of data), and the inclusion of a <b>backward</b> <b>chaining</b> algorithm tailored to run on top of the Rete network. <b>Backward</b> <b>chaining</b> alone can account for the most extreme changes in benchmarks relating to Rete vs. Rete II. Rete II is implemented in the commercial product Advisor from FICO, formerly called Fair Isaac ...|$|E
5000|$|The PRR RFP envisaged {{covering}} both {{forward and}} <b>backward</b> <b>chaining</b> rule engines. However, {{the lack of}} vendor support for / interest in <b>backward</b> <b>chaining</b> caused this to be revise to forward chaining and [...] "sequential" [...] semantics. The latter is simply the scripting mode provided by many BPM tools, where rules are listed and executed sequentially as if programmed. This provides PRR with better compatibility with typical BPM scripting engines (and acknowledges {{the fact that most}} BREs today support a [...] "sequential" [...] mode of operation, improving performance in some circumstances).|$|E
50|$|<b>Backward</b> <b>chaining</b> {{starts with}} a list of goals (or a hypothesis) and works {{backwards}} from the consequent to the antecedent {{to see if there is}} data available that will support any of these consequents. An inference engine using <b>backward</b> <b>chaining</b> would search the inference rules until it finds one which has a consequent (Then clause) that matches a desired goal. If the antecedent (If clause) of that rule is not known to be true, then it is added to the list of goals (in order for one's goal to be confirmed one must also provide data that confirms this new rule).|$|E
40|$|Abstract. The problem {{considered}} is how {{to provide}} virtual animals, living in an online virtual world, with internal personality and emotion structures that will lead them to display behaviors perceived as naturalistic and emotionally compelling by humans controlling avatars that interact with the virtual animals. A novel approach is proposed, in which both spontaneous and goal-driven animal behaviors are governed {{by a set of}} probabilistic logic implications, which are forward and <b>backward</b> <b>chained</b> together, both to directly guide action selection, and to adjust the values of internal emotion indicators. The approach has been prototyped in an preliminary version of a system that controls virtual animals in Second Life, and is expected to be included in a commercial virtual-animals product later in 2008. ...|$|R
40|$|We {{consider}} {{the construction of}} perfect samplers for posterior distributions associated with mixtures of exponential families and conjugate priors, starting with a perfect slice sampler {{in the spirit of}} Mira and co-workers. The methods rely on a marginalization akin to Rao-Blackwellization and illustrate the duality principle of Diebolt and Robert. A first approximation embeds the finite support distribution on the latent variables within a continuous support distribution that is easier to simulate by slice sampling, but we later demonstrate that the approximation can be very poor. We conclude by showing that an alternative perfect sampler based on a single <b>backward</b> <b>chain</b> can be constructed. This alternative can handle much larger sample sizes than the slice sampler first proposed. Copyright 2002 Royal Statistical Society. ...|$|R
40|$|There {{are many}} {{applications}} {{which may be}} done by an expert system in real time, if the system is capable of real-time response. The LISP and PROLOG-based expert systems have typically been too slow for real-time response. This {{has led to an}} effort to use other languages, the development of fast pattern matching techniques and other methods of improving the speed of expert systems. Another approach to developing faster expert systems is {{to make use of the}} emerging parallel processing computer technology. A further use for parallelism is to allow reasonable response time for large knowledge bases. The size of knowledge bases may become as large as 20, 000 chunks of knowledge (and more) in the near future in medical and space applications. This paper describes the use of parallel processing in the EMYCIN <b>backward</b> <b>chained</b> rule-based model...|$|R
50|$|Because {{the list}} of goals determines which rules are {{selected}} and used, this method is called goal-driven, in contrast to data-driven forward-chaining inference. The <b>backward</b> <b>chaining</b> approach is often employed by expert systems.|$|E
50|$|Drools is a {{business}} rule management system (BRMS) with a forward and <b>backward</b> <b>chaining</b> inference based rules engine, more correctly known as a production rule system, using an enhanced implementation of the Rete algorithm.|$|E
50|$|Because {{the data}} determines which rules are {{selected}} and used, {{this method is}} called data-driven, in contrast to goal-driven <b>backward</b> <b>chaining</b> inference. The forward chaining approach is often employed by expert systems, such as CLIPS.|$|E
40|$|A {{part of a}} {{complete}} expert system for powder technology is presented. This {{part of the system}} deals with the powder selection according to predetermineded or required material properties,and specific characteristics. Then, determinig the most common powder production(i. e processing) method, which satisfies the specified powder requirements for a specific application. For this purpose a detailed functional protype expert system is developed using a rule-based knowledge representation model. The expert system is designed to acquire knowledge from the user give recommendations. The inference engine, VP-Expert, is used as the development tool. The forward and <b>backward</b> <b>chain</b> techniques are utilized, thus the reverse process is also possible. Therefore, the system will determine or assign some primary powder characterstics and production method to satisfy or achieve the required product and vice versa. The developed expert system is flexible, easy to be implemented, modified, and extended. The system displayed excellent performance and typical illustrative examples are shown...|$|R
50|$|In {{the first}} case, {{go back to}} the {{originally}} chosen connection and follow its <b>chain</b> <b>backward,</b> drawing additional direction arrows, until each link in the chain is assigned a direction, always head-to-tail.|$|R
50|$|In a Demand-driven chain, a {{customer}} activates the flow by ordering from the retailer, who reorders from the wholesaler, who reorders from the manufacturer, who reorders raw materials from suppliers. Orders flow <b>backward,</b> up the <b>chain,</b> in this structure.|$|R
