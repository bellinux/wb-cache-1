313|15|Public
2500|$|The phrases {{interactive}} consistency {{or source}} congruency {{have been used}} to refer to Byzantine fault tolerance, particularly among the members of some early implementation teams. [...] It is also referred to as error avalanche, <b>Byzantine</b> <b>agreement</b> problem, Byzantine generals problem and Byzantine failure.|$|E
5000|$|In 2007, {{a quantum}} {{protocol}} for <b>Byzantine</b> <b>Agreement</b> was demonstrated experimentally [...] using a four-photon polarization-entangled state. This {{shows that the}} quantum implementation of classical <b>Byzantine</b> <b>Agreement</b> protocols is indeed feasible.|$|E
5000|$|Using <b>Byzantine</b> <b>Agreement,</b> {{and upon}} receipt of a “last gasp” message, the DTM initiates the {{determination}} {{as to the}} presence or absence of an attack/intrusion; ...|$|E
40|$|<b>Byzantine</b> <b>Agreements</b> {{were first}} {{formally}} proposed by Lamport [8], {{for use in}} finding faulty processors in distrubuted computer networks. In this article we will use the process of finding faults to uncover traitors in secure communications networks. Maintaining reliability in trusted networks is an important application of <b>Byzantine</b> <b>Agreements.</b> Thus by introducing the fundamentals of the Byzantine Generals problem and its generalized Agreement protocol we will establish a game theoretic solution to the cryptographic problem of secure communications networks...|$|R
3000|$|... 2) {{messages}} to be exchanged for n replicas. Some implementations [35] try {{to address this}} inefficiency by optimistically processing requests and falling back to individual <b>Byzantine</b> <b>agreements</b> only when <b>Byzantine</b> behavior is detected. In practice, this leads to very complex implementations whose correctness is hard to verify and that have weak progress guarantees [16].|$|R
40|$|For a {{complete}} network of n processors within which communication lines are private, we show {{how to achieve}} concurrently many <b>Byzantine</b> <b>Agreements</b> within constant expected time both on synchronous and asynchronous networks. As an immediate consequence, this provides {{a solution to the}} Interactive Consistency problem. Our algorithms tolerate up to (n 1) / 3 faulty processors in both the synchronous and asynchronous cases and are therefore resilient-optimal...|$|R
50|$|In this section, {{we provide}} a brief {{overview}} of the FOSA system and its major components. However, in this manuscript we will not cover the reliability and adaptability elements of the architecture, and the use of <b>Byzantine</b> <b>Agreement,</b> see 4, to build resiliency into the system.|$|E
5000|$|Attack Detection/ Prevention {{occurs at}} two levels. At the local level, SHM {{represents}} the traditional IDS/IPS system. However, {{decisions that affect}} {{the health of the}} entire system, or decisions concerning a distributed attack, are made by correlating information among all security devices in the system using a <b>Byzantine</b> <b>Agreement</b> Protocols or BAP.|$|E
5000|$|The <b>Byzantine</b> <b>Agreement</b> {{protocol}} is {{a protocol}} in distributed computing.It takes {{its name from}} a problem formulated by Lamport, Shostak and Pease in 1982, which itself is a reference to a historical problem. The Byzantine army was divided into divisions with each division being led by a General with the following properties: ...|$|E
40|$|The article {{considers}} trust {{management in}} P 2 P games of turns without trusted, centralized resources and without using reputation. We improve a fair protocol for random drawing developed for P 2 P Scrabble [23]. We also modify the public state management to use <b>Byzantine</b> <b>agreements.</b> The {{complexity of the}} proposed mechanisms is analyzed and a new mechanism for faster reshuffling and drawing during the game stage is proposed. 1...|$|R
40|$|International audienceIn {{decentralized}} P 2 P networks, many security mechanisms still rely on {{a central}} authority. This centralization creates a {{single point of failure}} and does not comply with the P 2 P principles. We previously proposed a distributed PKI for P 2 P networks which allows to push security mechanisms to the edges of the network but relies on unaffordable maintenance operations using <b>byzantine</b> <b>agreements.</b> In this paper, we address this shortcoming and propose efficient maintenance operations without any agreements. Our improvements allow a real deployment of this P 2 P PKI...|$|R
40|$|Ally is a {{framework}} for building distributed services in a federated architecture. In a federation, nodes may occupy multiple, independent administrative domains, with complex trust relationships, connected by an asynchronous, wide-area network. We present a library that implements <b>Byzantine</b> fault-tolerant <b>agreement,</b> a critical building-block service in robust distributed systems, targeted at the federation model; threshold cryptography improves the basic agreement protocol with proactive, verifiable security and improved resilience to continuous attack. ...|$|R
50|$|None of {{the three}} models can handle more complex failures, such as {{machines}} that are taken over by a virus, or a network that sometimes modifies the messages transmitted. The so-called <b>Byzantine</b> <b>agreement</b> model goes beyond the data replication schemes discussed here by also solving such issues, but does so at a price: Byzantine replication protocols typically require larger numbers of servers, and can be much slower.|$|E
50|$|Byzantine fault {{tolerant}} protocols are algorithms that are robust to arbitrary types of failures in distributed algorithms. With the advent and {{popularity of the}} Internet, {{there is a need}} to develop algorithms that do not require any centralized control that have some guarantee of always working correctly. The <b>Byzantine</b> <b>agreement</b> protocol is an essential part of this task. In this article the quantum version of the Byzantine protocol, which works in constant time is described.|$|E
5000|$|In {{fault-tolerant}} computer systems, and {{in particular}} distributed computing systems, Byzantine fault tolerance (BFT) is the characteristic {{of a system that}} tolerates the class of failures known as the Byzantine Generals' Problem, which is a generalized version of the Two Generals' Problem - for which there is an unsolvability proof. The phrases interactive consistency or source congruency have been used to refer to Byzantine fault tolerance, particularly among the members of some early implementation teams. [...] It is also referred to as error avalanche, <b>Byzantine</b> <b>agreement</b> problem, Byzantine generals problem and Byzantine failure.|$|E
40|$|This short paper {{presents}} {{a necessary condition}} for <b>Byzantine</b> k-set <b>agreement</b> in (synchronous or asynchronous) message-passing systems and asynchronous shared memory systems where the processes communicate through atomic single-writer multi-reader registers. It gives a proof, which is particularly simple, that k-set agreement cannot be solved t-resiliently in an n-process system when n ≤ 2 t + t/k. This bound is tight for the case k= 1 (Byzantine consensus) in synchronous message-passing systems...|$|R
40|$|This paper {{presents}} PICO, {{a generic}} infrastructure for secure group communication in mobile ad-hoc networks (MANETs). PICO provides an intrusion-tolerant group management service, allowing clients to join or leave a logical group and enabling group members to communicate securely using a dynamically generated group encryption key. Since MANETs {{are characterized by}} relatively high message loss and frequent network partitions, PICO is built around a new <b>Byzantine</b> fault-tolerant <b>agreement</b> protocol designed to cope with these conditions. The agreement protocol leverages weak (commutative) semantics to allow multiple partitions to continue operating in parallel without sacrificing correctness, and it uses threshold cryptography to provide efficient reconciliation and coordination {{without the need for}} reliable communication links...|$|R
40|$|Abstract—This paper {{presents}} PICO, a distributed protocol {{that manages}} group membership and keying in mobile adhoc networks (MANETs). PICO tolerates {{a limited number}} of Byzantine nodes and an additional limited number of crashed nodes. It allows clients to join or leave a dynamically changing group and provides group members with a dynamically updated group encryption key. Since MANETs are characterized by relatively high message loss and frequent network partitions, PICO is built around a new <b>Byzantine</b> fault-tolerant <b>agreement</b> protocol designed to cope with these conditions. The agreement protocol leverages weak (commutative) semantics to allow multiple partitions to continue operating in parallel without sacrificing correctness; it also copes well with unreilable communication links because it uses cumulative messages instead of needing the retransmission of prior lost messages. I...|$|R
5000|$|At {{the end of}} {{this phase}} players agree on which secrets were {{properly}} shared, the secrets are then opened and each player [...] is assigned the value This requires private information channels so we replace the random secrets by the superposition [...] In which the state is encoded using a quantum verifiable secret sharing protocol (QVSS). We cannot distribute the state [...] since the bad players can collapse the state. To prevent bad players from doing so we encode the state using the Quantum verifiable secret sharing (QVSS) and send each player their share of the secret. Here again the verification requires <b>Byzantine</b> <b>Agreement,</b> but replacing the agreement by the grade-cast protocol is enough.|$|E
50|$|The Brooks-Iyengar hybrid {{algorithm}} for {{distributed control}} {{in the presence of}} noisy data combines <b>Byzantine</b> <b>agreement</b> with sensor fusion. It bridges the gap between sensor fusion and Byzantine fault tolerance. This seminal algorithm unified these disparate fields for the first time. Essentially, it combines Dolev’s algorithm for approximate agreement with Mahaney and Schneider’s fast convergence algorithm (FCA). The algorithm assumes N processing elements (PEs), t of which are faulty and can behave maliciously. It takes as input either real values with inherent inaccuracy or noise (which can be unknown), or a real value with apriori defined uncertainty, or an interval. The output of the algorithm is a real value with an explicitly specified accuracy. The algorithm runs in O(NlogN) where N is the number of PEs: see Big O notation. It is possible to modify this algorithm to correspond to Crusader’s Convergence Algorithm (CCA), however, the bandwidth requirement will also increase. The algorithm has applications in distributed control, software reliability, High-performance computing, etc.|$|E
40|$|It has {{recently}} been shown that executions of authenticated <b>Byzantine</b> <b>Agreement</b> protocols {{in which more than}} a third of the parties are faulty, cannot be composed concurrently, in parallel, or even sequentially (where the latter is true for deterministic protocols). This result puts into question any usage of authenticated <b>Byzantine</b> <b>agreement</b> in a setting where many executions take place. In particular, this is true for the whole body of work of secure multiparty protocols in the case that 1 = 3 or more of the parties are faulty. Such protocols strongly rely on the extensive use of a broadcast channel, which is in turn realized using authenticated <b>Byzantine</b> <b>Agreement.</b> Essentially, this use of <b>Byzantine</b> <b>Agreement</b> cannot be eliminated, since the standard definitions of secure multiparty computation actually imply <b>Byzantine</b> <b>agreement...</b>|$|E
40|$|In this paper, we {{show that}} the {{protocol}} complex of a Byzantine synchronous system can remain (k - 1) -connected for up to t/k rounds, where t is {{the maximum number of}} Byzantine processes, and t > k > 1. This topological property implies that t/k + 1 rounds are necessary to solve k-set <b>agreement</b> in <b>Byzantine</b> synchronous systems, compared to t/k + 1 rounds in synchronous crash-failure systems. We also show that our connectivity bound is tight as we indicate solutions to <b>Byzantine</b> k-set <b>agreement</b> in exactly t/k + 1 synchronous rounds, at least when n is suitably large compared to t. In conclusion, we see how Byzantine failures can potentially require one extra round to solve k-set agreement, and, for n suitably large compared to t, at most that...|$|R
50|$|In 1158 {{he leaves}} Hungary {{and returns to}} Serbia. When Manuel I had removed his brother Uroš II in 1161, Beloš came to rule briefly in 1162, then gave the throne to his younger brother Desa. He returns to Croatia, once again serving as Ban of Croatia. After the death of Géza II in 1162, Byzantines wanted to instate {{a member of the}} dynasty, Stephen IV, who had lived in Constantinople. Beloš ousts Stephen IV after he briefly rules, taking him as prisoner. He {{releases}} Stephen IV to the <b>Byzantines</b> after an <b>agreement.</b>|$|R
2500|$|At the Battle of Pelagonia (1259), {{the forces}} of the Byzantine emperor Michael VIII Palaiologos (r. 1259–1282) had killed or {{captured}} most of the Latin nobles of the Principality of Achaea, including the Prince William II of Villehardouin (r. 1246–1278). In exchange for his freedom, William agreed to hand over a number of fortresses in the southwestern part of the Morea peninsula. He also swore an oath of allegiance to Michael, becoming his vassal and being honoured by becoming godfather to one of Michael's sons and receiving the title and post of megas domestikos. In early 1262, William was released, and the forts of Monemvasia and Mystras, with the districts of Mani and Kinsterna, were handed over to the <b>Byzantines.</b> The <b>agreement</b> was bound to be of short duration, however: the establishment of a small province in the Morea was for Palaiologos but the first step towards reclaiming all of the peninsula, and William likewise was involved in the Latin efforts to counter the emperor and regain Constantinople. Consequently, soon after his return to the Morea, William settled his differences with the Venetians over Negroponte, and negotiated with them and the Pope for joint action against Palaiologos. In July, Pope Urban IV nullified William's oaths to the emperor, and appealed to the Western princes for aid against the [...] "schismatic" [...] Byzantines.|$|R
40|$|This paper gives a {{scalable}} {{protocol for}} solving the <b>Byzantine</b> <b>agreement</b> problem. The protocol is scalable {{in the sense}} that for <b>Byzantine</b> <b>agreement</b> over n processors, each processor sends and receives only O(log n) messages in expectation. To {{the best of our knowledge}} this is the first result for the <b>Byzantine</b> <b>agreement</b> problem where each processor sends and receives o(n) messages. The protocol uses randomness and is correct with high probability. 1 It can tolerate any fraction of faulty processors which is strictly less than 1 / 6. Our result partially answers the following question posed by Kenneth Birman: “How scalable are the traditional solutions to problems such as Consensus or <b>Byzantine</b> <b>Agreement?</b> ” [5]. ...|$|E
40|$|<b>Byzantine</b> <b>agreement</b> means {{achieving}} reliable {{broadcast on}} a point-to-point network of n processors, of which up to t may be maliciously faulty. A well-known result by Pease, Shostak, and Lamport says that perfect <b>Byzantine</b> <b>agreement</b> is only possible if t < n/ 3. In contrast, so-called authenticated protocols achieve <b>Byzantine</b> <b>agreement</b> for any t based on computational assumptions, typically {{the existence of}} a digital signature scheme, an assumption equivalent to the existence of one-way functions. The "folklore" belief based on these two results is that computational assumptions are necessary to achieve <b>Byzantine</b> <b>agreement</b> for t ³ n/ 3. We present a protocol that refutes this folklore belief, i. e., it achieves <b>Byzantine</b> <b>agreement</b> for any t in an information-theoretic setting. It does not, however, contradict the precise impossibility result: More than one difference exists between the model in that proof and the model of the existing authenticated protocols, and we only remove the com [...] ...|$|E
40|$|In {{this paper}} we study {{when and how}} B <b>Byzantine</b> <b>agreement</b> {{protocol}} can he used in general-purpose database management systems. We present {{an overview of the}} failure model used for <b>Byzantine</b> <b>agreement,</b> and of the protocol itself. We then present correctness criteria for database processing in this failure environment and discuss strategies for satisfying them. In doing this, we present new failure models for input/output nodes and study ways to distribute input transactions to processing nodes under these models. Finally, we investigate applications of <b>Byzantine</b> <b>agreement</b> protocols in the more common failure environment where processors are assumed to halt after a failure...|$|E
40|$|This thesis gathers and {{analyzes}} Origen of Alexandria's citations of Romans, 2 Corinthians and Galatians {{in order}} {{to gain a better understanding}} of the nature of the New Testament text in the second and third centuries. Throughout the transmission process of Origen’s writings, it is possible that the wording of his citations has undergone alteration that relates to changes in the New Testament transmission. Origen’s citations are analyzed to determine whether his citations, as they are found today, first transmit the text quoted by the author, and, second, are likely to be a reflection of his biblical manuscripts. If Origen’s authorial citations can be demonstrated to be from his biblical exemplars, it is only then that his citational text can be compared with New Testament manuscripts for the purposes of establishing textual affinity. If Origen’s citations cannot be used to establish his biblical text, then his use as a witness to specific text-forms should be reconsidered. However, his citations still reveal the transmission history of his writings, specifically how they have undergone alteration in light of the historical and theological environments of his editors. The thesis concludes that Origen, despite often corresponding to the Initial text and <b>Byzantine</b> text <b>agreements,</b> cited freely with little extant manuscript support. This suggests that his authorial citations have been accommodated to a text form similar to that of the Initial text and then the Byzantine text through subsequent transmission...|$|R
40|$|Distributed Consensus is a {{classical}} problem in distributed computing. It requires the correct processors in a distributed system {{to agree on}} a common value despite the failure of other processors. This problem is closely related to other problems, such as <b>Byzantine</b> Generals, Approximate <b>Agreement,</b> and k-Set Agreement. This paper examines a variant of Distributed Consensus that considers agreement on a value that is more than a single bit and requires that the agreed upon value be one of the correct processors' input values. It shows that, for this problem to be solved in a system with arbitrary failures, it is necessary that more processors remain correct than for solutions to Distributed Consensus and for cases where agreement is only a single bit. Specifically, the number of processors that must be correct {{is a function of the}} size of the domain of values used. Two existing consensus algorithms are modified to solve this stronger variant...|$|R
40|$|The common {{approach}} to detecting anomaly-based intrusion is by replicating the computation {{and running a}} <b>Byzantine</b> <b>agreement</b> protocol among all replicas. However, <b>Byzantine</b> <b>agreement</b> incurs high communication overhead and also {{requires the use of}} more than 2 t replicas (in fact, more than 3 t replicas in asynchronous systems) in order to overcome t such failures. However, for many applications, and in particular scientific computation, it is possible to achieve the same goal with much lower average communication and replication overheads. This paper presents a new approach for detecting an intrusion by combining checkpoint/restart with replication. The main benefit of the approach is that we replicate the execution into only t + 1 replicas, and invoke a <b>Byzantine</b> <b>agreement</b> only if we suspect an anomalous behavior that could be observed using checkpointing techniques. If a failure occurs, it is detected using any <b>Byzantine</b> <b>agreement</b> protocol that can agree on a recent valid system’s state. Such a <b>Byzantine</b> <b>agreement</b> protocol also identifies the compromised nodes and eliminates them, so the computation can proceed with only t + 1 replicas until the next failure occurs. 1...|$|E
40|$|We resolve two long-standing open {{problems}} in distributed computation by describing polylogarithmic protocols for <b>Byzantine</b> <b>agreement</b> and leader {{election in the}} asynchronous full information model with a nonadaptive malicious adversary. All past protocols for asynchronous <b>Byzantine</b> <b>Agreement</b> had been exponential, − ɛ) · n faulty processors, for any positive constant ɛ. They are Monte Carlo, succeeding with probability 1 − o(1) for <b>Byzantine</b> <b>agreement,</b> and constant probability for leader election. A key technical contribution of our paper is a new approach for emulating Feige’s lightest bin protocol, even with adversarial message scheduling. and no protocol for asynchronous leader election had been known. Our protocols tolerate up to (1 3...|$|E
40|$|In this report, {{building}} on the deterministic multi-valued one-to-many <b>Byzantine</b> <b>agreement</b> (broadcast) algorithm in our recent technical report [2], we introduce a deterministic multi-valued all-to-all <b>Byzantine</b> <b>agreement</b> algorithm (consensus), with linear complexity per bit agreed upon. The discussion in this note is not self-contained, and relies heavily on the material in [2] - please refer to [2] for the necessary background...|$|E
40|$|A {{fundamental}} problem of distributed computing {{is that of}} simulating a secure broadcast channel, within the setting of a point-to-point network. This problem is known as <b>Byzantine</b> <b>Agreement</b> (or Generals) and {{has been the focus}} of much research. Lamport et al. showed that in order to achieve <b>Byzantine</b> <b>Agreement</b> in the standard model, more than 2 / 3 of the participating parties must be honest. They further showed that by augmenting the network with a public-key infrastructure for digital signatures, it is possible to obtain protocols that are secure for any number of corrupted parties. The problem in this augmented model is called “authenticated Byzantine Agreement”. In this paper we consider the question of concurrent, parallel and sequential composition of authenticated <b>Byzantine</b> <b>Agreement</b> protocols. We present surprising impossibility results showing that: 1. If an authenticated <b>Byzantine</b> <b>Agreement</b> protocol remains secure under parallel or concurrent composition (even for just two executions), then more than 2 / 3 of the participating parties must be honest...|$|E
40|$|AbstractWe {{describe}} {{several new}} algorithms for <b>Byzantine</b> <b>agreement.</b> The {{first of these}} is a simplification of the original exponential-time <b>Byzantine</b> <b>agreement</b> algorithm due to Pease, Shostak, and Lamport, and is of comparable complexity to their algorithm. However, its proof is very intuitively appealing. A technique of shifting between algorithms for solving the <b>Byzantine</b> <b>agreement</b> problem is then studied. We present two families of algorithms obtained by applying a shift operator to our first algorithm. These families obtain the same rounds to message length trade-off as do Coan's families but do not require the exponential local computation time (and space) of his algorithms. We also describe a modification of an O(n) -resilient algorithm for <b>Byzantine</b> <b>agreement</b> of Dolev, Reischuk, and Strong. Finally, we obtain a hybrid algorithm that dominates all our others, by beginning execution of an algorithm in one family, first shifting into an algorithm of the second family, and finally shifting into an execution of the adaptation of the Dolev, Reischuk, and Strong algorithm...|$|E
40|$|<b>Byzantine</b> <b>agreement</b> is a {{fundamental}} issue in fault-tolerant and secure distributed computing. Protocols solving <b>Byzantine</b> <b>agreement</b> guarantee that a sender can transmit a value {{to a group of}} receivers consistently, even if some of the nodes, including the sender, are arbitrarily faulty. In the past, protocols for <b>Byzantine</b> <b>agreement</b> were generally either authenticated or non-authenticated. Non-authenticated protocols make no use of signatures, while in authenticated protocols, all messages have to be signed. Authenticated protocols can tolerate more faults and are more message-efficient than non-authenticated protocols, but they have the disadvantage of timeconsuming signature generation. In this paper, we introduce techniques {{to reduce the amount of}} signatures by combining mechanisms from authenticated and nonauthenticated protocols...|$|E
40|$|Abstract. In a <b>Byzantine</b> <b>agreement</b> protocol, a {{synchronous}} network of n interconnected processes of which t may be faulty, starts {{with an initial}} binary value associated with each process; after exchanging messages, all correct processes must agree {{on one of the}} initial values of the non-faulty processes. If the network consists of only unicast channels (i. e. a 2 -uniform hypergraph), then <b>Byzantine</b> <b>agreement</b> is possible if and only if n ≥ 3 t + 1 (Pease et. al. [11]). However, Fitzi and Maurer ([7]) show that if, in addition to all unicast channels, there exists local broadcast among every three processes in the network (i. e. a complete (2, 3) -uniform hypergraph), n ≥ 2 t + 1 is necessary and sufficient for <b>Byzantine</b> <b>agreement.</b> In this paper, we show that optimum tolerance of n ≥ 2 t + 1 can be achieved even if a substantial fraction of the local broadcast channels are not available. Specifically, we model the network as a (2, 3) -uniform hypergraph H =(P, E), where P denotes the set of n processes and E is a set of 2 -tuples and/or 3 -tuples of processes (edges or 3 -hyperedges), wherein each 3 -hyperedge represents a local broadcast among the three processes; we obtain a characterization of the hypergraphs on which <b>Byzantine</b> <b>agreement</b> is possible. Using this characterization, we show that for n = 2 t + 1, � 2 3 t 3 + Θ(t 2) � 3 -hyperedges are necessary and sufficient to enable <b>Byzantine</b> <b>agreement.</b> This settles an open problem raised by Fitzi and Maurer in [7]. An efficient protocol is also given whenever <b>Byzantine</b> <b>agreement</b> is possible. ...|$|E
