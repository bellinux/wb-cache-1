862|286|Public
5|$|Integer sorting {{algorithms}} {{are usually}} {{designed to work}} in either the pointer machine or random access machine models of computing. The main {{difference between these two}} models is in how memory may be addressed. The random access machine allows any value that is stored in a register to be used as the address of memory read and write operations, with unit cost per operation. This ability allows certain complex operations on data to be implemented quickly using table lookups. In contrast, in the pointer machine model, read and write operations use addresses stored in pointers, and it is not allowed to perform arithmetic operations on these pointers. In both models, data values may be added, and bitwise <b>Boolean</b> <b>operations</b> and binary shift operations may typically also be performed on them, in unit time per operation. Different integer sorting algorithms make different assumptions, however, about whether integer multiplication is also allowed as a unit-time operation. Other more specialized models of computation such as the parallel random access machine have also been considered.|$|E
25|$|The n-ary <b>Boolean</b> <b>operations</b> {{themselves}} {{constitute a}} power set algebra 2W, namely when W {{is taken to}} be the set of 2n valuations of the n inputs. In terms of the naming system of operations n'f'i where i in binary is a column of a truth table, the columns can be combined with <b>Boolean</b> <b>operations</b> of any arity to produce other columns present in the table. That is, we can apply any Boolean operation of arity m to m <b>Boolean</b> <b>operations</b> of arity n to yield a Boolean operation of arity n, for any m and n.|$|E
25|$|The {{original}} application for <b>Boolean</b> <b>operations</b> was mathematical logic, where it combines the truth values, true or false, of individual formulas.|$|E
40|$|Abstract. <b>Boolean</b> <b>operation</b> {{is the key}} {{technology}} for modeling the bone scaffold. This paper proposes a <b>Boolean</b> <b>operation</b> algorithm based on triangle mesh model. It firstly voxelizes the mesh models based on project vector and octree, and classifies the vertices into inside, outside and surface type according to the position relationship between the vertex and the other mesh model’s voxel. Then the triangles can be easily classified based on the vertices class. Finally the Boolean model can be composed by the corresponding triangles of the <b>Boolean</b> <b>operation.</b> In order to obtain the intersection features well, it detects the intersection lines and gets the intersection polygons further, and then triangulates the polygon using the ear clipping method. This <b>Boolean</b> <b>operation</b> algorithm {{has been applied to}} the bone scaffold modeling and got good performance...|$|R
2500|$|A Boolean {{homomorphism}} is {{a function}} h: A→B between Boolean algebras A, B such that for every <b>Boolean</b> <b>operation</b> m'f'i, ...|$|R
25|$|That is, a Boolean algebra {{is a set}} and {{a family}} of {{operations}} thereon interpreting the <b>Boolean</b> <b>operation</b> symbols and satisfying the same laws as the Boolean prototype.|$|R
25|$|Given two operands, {{each with}} two {{possible}} values, there are 22 = 4 possible combinations of inputs. Because each output can have two possible values, {{there are a}} total of 24 = 16 possible binary <b>Boolean</b> <b>operations.</b>|$|E
25|$|Propositional {{calculus}} restricts {{attention to}} abstract propositions, those built up from propositional variables using <b>Boolean</b> <b>operations.</b> Instantiation {{is still possible}} within propositional calculus, but only by instantiating propositional variables by abstract propositions, such as instantiating Q by Q→P in P→(Q→P) to yield the instance P→((Q→P)→P).|$|E
25|$|Naive {{set theory}} interprets <b>Boolean</b> <b>operations</b> as acting on subsets {{of a given}} set X. As we saw earlier this {{behavior}} exactly parallels the coordinate-wise combinations of bit vectors, with the union of two sets corresponding to the disjunction of two bit vectors and so on.|$|E
5000|$|SAND CDBMS traces {{its roots}} to {{developments}} by Nucleus International Corporation research and eventual patent issued to, among others, Edward L. Glaser on “Bit string compressor with <b>boolean</b> <b>operation</b> processing capability.” ...|$|R
40|$|The {{boundaries}} of conic polygons consist of conic segments or second degree curves. The conic polygon has two degenerate or special cases: the linear polygon and the circular-arc polygon. The natural problem [...] - <b>boolean</b> <b>operation</b> on linear polygons, {{has been well}} studied. Surprisingly, (almost) no article focuses {{on the problem of}} <b>boolean</b> <b>operation</b> on circular-arc polygons, which actually can also find many applications, implying {{that if there is a}} targeted solution for <b>boolean</b> <b>operation</b> on circular-arc polygons, which should be favourable for potential users. In this article, we devise a concise data structure, and then develop a targeted algorithm called R E 2 L. Our method is surprisingly simple, easy-to-implement but without loss of efficiency. Given two circular-arc polygons with m and n edges respectively, we prove that the proposed method runs in O(m+n+(l+k) l) time, using O(m+n+l+k) space, where k is the number of intersections, and l is the number of related edges. The experimental results show our proposed algorithm is significantly faster than the ones that are by directly appealing to the existing algorithms. Comment: 12 page...|$|R
40|$|In {{order to}} improve the speed and {{performance}} of <b>Boolean</b> <b>operation,</b> we propose a Cube-based algorithm for the rapid <b>Boolean</b> <b>operation.</b> And this algorithm creates Cubes for all triangles of the feature entities, takes intersecting detection rapidly by the sufficiency principle of feature interaction, defines the {{inside and outside of}} triangles by the values of Cube ’s vertexes instead of the normal lines used in traditional methods and builds a new entity by classified spaces of Cubes. This algorithm can increase the speed and performance of computing and avoid the errors about holes in the new entity. Through the experiments on computer, it has been validated that this new algorithm is more adaptable and practicable...|$|R
25|$|The set {0,1} and its <b>Boolean</b> <b>operations</b> as treated above can be {{understood}} as the special case of bit vectors of length one, which by the identification of bit vectors with subsets can also {{be understood}} as the two subsets of a one-element set. We call this the prototypical Boolean algebra, justified by the following observation.|$|E
25|$|It has {{applications}} in logic, interpreting 0 as false, 1 as true, ∧ as and, ∨ as or, and ¬ as not. Expressions involving {{variables and the}} <b>Boolean</b> <b>operations</b> represent statement forms, and two such expressions can {{be shown to be}} equal using the above axioms if and only if the corresponding statement forms are logically equivalent.|$|E
25|$|<b>Boolean</b> <b>operations</b> {{are used}} in digital logic to combine the bits carried on {{individual}} wires, thereby interpreting them over {0,1}. When a vector of n identical binary gates are used to combine two bit vectors each of n bits, the individual bit operations can be understood collectively as a single operation on values from a Boolean algebra with 2n elements.|$|E
40|$|We {{present a}} {{real-time}} interactive modeling system for users to create sculpture {{in a virtual}} world. We find several practical issues of virtual sculpting and propose solutions to address them in this paper. Our previous work, Cubical Marching Squares (CMS), provides a rel-atively accurate method to generate surface from vol-ume data. Also, another previous work provides a vol-umetric data structure which preserves information of sharp features after <b>boolean</b> <b>operation</b> is applied. By combining the data structure for <b>boolean</b> <b>operation</b> and CMS to display the data, {{it is possible to}} create sculp-ture in a natural way in a virtual world. However, an artist friendly system for sculpting requires contin-uous operation to mimic the real world sculpting ex-periences. Also, the system must provide an intuitive way for artists to operate, and so these requirements raise four issues to be addressed. First, a motion graver is created to overcome the zigzag artifacts as shown in Figure 1, which is caused by discretely sampled sculpting movements. Second, to perform continuous <b>boolean</b> <b>operation</b> at interactive rate is another second issue. Third, a force feedback device is used to provide touchable hints during operations. Finally, some basic Computer Numerical Control (CNC) like operations are provided for more precise control over the sculpting op-eration. 1...|$|R
40|$|Abstract—The {{boundaries}} of conic polygons consist of conic segments or second degree curves. The conic polygon has two degenerate or special cases: the linear polygon and the circular-arc polygon. The natural problem — <b>boolean</b> <b>operation</b> on linear polygons, {{has been well}} studied. Surprisingly, (almost) no article focuses {{on the problem of}} <b>boolean</b> <b>operation</b> on circular-arc polygons, which actually can also find many applications, implying {{that if there is a}} targeted solution for <b>boolean</b> <b>operation</b> on circular-arc polygons, which should be favourable for potential users. In this article, we devise a concise data structure, and then develop a targeted algorithm called RE 2 L. Our method is surprisingly simple, easy-to-implement but without loss of efficiency. Given two circular-arc polygons with m and n edges respectively, we prove that the proposed method runs in O(m + n + (l + k) log l) time, using O(m + n + l + k) space, where k is the number of intersections, and l is the number of related edges. The experimental results show our proposed algorithm is significantly faster than the ones that are by directly appealing to the existing algorithms. Index Terms—Boolean operation, circular-arc polygons, related edges, sequence lists, appendix points F...|$|R
40|$|In the orthognathic surgery, dental splints are {{important}} and necessary to help the surgeon reposition the maxilla or mandible. However, the traditional methods of manual design of dental splints are difficult and time-consuming. The research on computer-aided design software for dental splints is rarely reported. Our purpose {{is to develop a}} novel special software named EasySplint to design the dental splints conveniently and efficiently. The design can be divided into two steps, which are the generation of initial splint base and the <b>Boolean</b> <b>operation</b> between it and the maxilla-mandibular model. The initial splint base is formed by ruled surfaces reconstructed using the manually picked points. Then, a method to accomplish <b>Boolean</b> <b>operation</b> based on the distance filed of two meshes is proposed. The interference elimination can be conducted on the basis of marching cubes algorithm and <b>Boolean</b> <b>operation.</b> The accuracy of the dental splint can be guaranteed since the original mesh is utilized to form the result surface. Using EasySplint, the dental splints can be designed in about 10 minutes and saved as a stereo lithography (STL) file for 3 D printing in clinical applications. Three phantom experiments were conducted and the efficiency of our method was demonstrated. Comment: 10 pages, 10 figures, 1 table, 18 reference...|$|R
25|$|Both {{of these}} bases allow Boolean algebras {{to be defined}} via {{a subset of the}} equational {{properties}} of the <b>Boolean</b> <b>operations.</b> For the lattice basis, it suffices to define a Boolean algebra as a distributive lattice satisfying x∧¬x = 0 and x∨¬x = 1, called a complemented distributive lattice. The ring basis turns a Boolean algebra into a Boolean ring, namely a ring satisfying x2 = x.|$|E
25|$|The 256-element free Boolean algebra {{on three}} {{generators}} is deployed in computer displays based on raster graphics, which use bit blit to manipulate whole regions consisting of pixels, relying on <b>Boolean</b> <b>operations</b> to specify how the source region should {{be combined with}} the destination, typically {{with the help of}} a third region called the mask. Modern video cards offer all 223=256 ternary operations for this purpose, with the choice of operation being a one-byte (8-bit) parameter. The constants SRC = 0xaa or 10101010, DST = 0xcc or 11001100, and MSK = 0xf0 or 11110000 allow <b>Boolean</b> <b>operations</b> such as (SRC^DST) (meaning XOR the source and destination and then AND the result with the mask) to be written directly as a constant denoting a byte calculated at compile time, 0x60 in the (SRC^DST) example, 0x66 if just SRC^DST, etc. At run time the video card interprets the byte as the raster operation indicated by the original expression in a uniform way that requires remarkably little hardware and which takes time completely independent of the complexity of the expression.|$|E
25|$|The finitary {{operations}} on {0,1} may be exhibited as truth tables, thinking of 0 and 1 as the truth values false and true. They can be {{laid out in}} a uniform and application-independent way that allows us to name, or at least number, them individually. These names provide a convenient shorthand for the <b>Boolean</b> <b>operations.</b> The names of the n-ary operations are binary numbers of 2n bits. There being 22n such operations, one cannot ask for a more succinct nomenclature. Note that each finitary operation can be called a switching function.|$|E
40|$|This work {{describes}} a decomposition scheme for polyhedra called Layer-based decomposition. This decomposition can be computed in a efficient way {{for any kind}} of polyhedron, and has interesting applications in several geometric problems, like <b>Boolean</b> <b>operation</b> computation, point-in-polyhedron inclusion test, 3 D location and rayscene intersection computation...|$|R
5000|$|This {{distinguished}} agent represents ambiguous {{choice and}} can be used to simulate any other agent with arbitrary number of principal ports. For instance, it allows to define a [...] <b>boolean</b> <b>operation</b> that returns true if any of its arguments is true, independently of the computation taking place in the other arguments.|$|R
25|$|Digital {{logic is}} the {{application}} of the Boolean algebra of 0 and 1 to electronic hardware consisting of logic gates connected to form a circuit diagram. Each gate implements a <b>Boolean</b> <b>operation,</b> and is depicted schematically by a shape indicating the operation. The shapes associated with the gates for conjunction (AND-gates), disjunction (OR-gates), and complement (inverters) are as follows.|$|R
25|$|As a minor detail {{important}} {{more for}} its form than its content, {{the operations of}} an algebra are traditionally organized as a list. Although we are here indexing the operations of a Boolean algebra by the finitary operations on {0,1}, the truth-table presentation above serendipitously orders the operations first by arity and second by {{the layout of the}} tables for each arity. This permits organizing the set of all <b>Boolean</b> <b>operations</b> in the traditional list format. The list order for the operations of a given arity is determined by the following two rules.|$|E
25|$|A law of Boolean algebra is an {{identity}} such as x∨(y∨z) = (x∨y)∨z between two Boolean terms, where a Boolean term {{is defined as}} an expression built up from variables and the constants 0 and 1 using the operations ∧, ∨, and ¬. The concept can be extended to terms involving other <b>Boolean</b> <b>operations</b> such as ⊕, →, and ≡, but such extensions are unnecessary for the purposes to which the laws are put. Such purposes include {{the definition of a}} Boolean algebra as any model of the Boolean laws, and as a means for deriving new laws from old as in the derivation of x∨(y∧z) = x∨(z∧y) from y∧z = z∧y as treated in the section on axiomatization.|$|E
25|$|Windows Search {{queries are}} {{specified}} in Advanced Query Syntax (AQS) which supports not only simple text searches but provides advanced property-based query operations as well. AQS defines certain keywords {{which can be}} used to refine the search query, such as specifying <b>boolean</b> <b>operations</b> on searched terms (AND, OR, NOT) as well as to specify further filters based on file metadata or file type. It {{can also be used to}} limit results from specific information stores like regular files, offline files cache, or email stores. File type specific operators are available as well. WDS also supports wildcard prefix matching searches. It also includes several SQL-like operators like GROUP BY. AQS is locale dependent and uses different keywords in international versions of Windows 7.|$|E
40|$|This paper {{describes}} {{an approach to}} the representation of polygons by real functions and its application to sweeping. We combine an algorithm employing a monotone function of a <b>boolean</b> <b>operation,</b> with R-functions. Application of this method results in a continuous function F(x,y) with zero value at polygon edges. We discuss and illustrate different sweeping techniques {{with the use of}} functionally defined generators. 1. INTRODUCTION Recently the representation of geometric objects by real continuous functions of several variables (so-called implicit representation or F-rep) has attracted {{a great deal of attention}} in many technical applications and animation. The exact conversion from the boundary representation to a real function is an open problem. This paper deals with such conversion of a two-dimensional polygon. We discuss an algorithm for a simple polygon bounded by straight line segments. We combine an algorithm employing a monotone function of a <b>boolean</b> <b>operation,</b> with R-functi [...] ...|$|R
50|$|Bitwise <b>Boolean</b> (16-bit) <b>operations</b> (AND, OR, NOT), with {{additional}} operators XOR, EQV, IMP.|$|R
40|$|We outline an {{algorithm}} {{and implementation}} {{of a system that}} computes Boolean combinations of sculptured solids. We represent the surface of the solids in terms of trimmed and untrimmed spline surfaces and a connectivity graph. Based on algorithms for trapezoidation of polygons, partitioning of polygons, surface intersection and ray-shooting, we compute the boundaries of the resulting solids after the <b>Boolean</b> <b>operation.</b> ...|$|R
25|$|Example 7. Ultimately {{periodic}} sequences, sequences {{that become}} periodic {{after an initial}} finite bout of lawlessness. They constitute a proper extension of Example 5 (meaning that Example 5 is a proper subalgebra of Example 7) and also of Example 4, since constant sequences are periodic with period one. Sequences may vary as to when they settle down, but any finite set of sequences will all eventually settle down no later than their slowest-to-settle member, whence ultimately periodic sequences are closed under all <b>Boolean</b> <b>operations</b> and so form a Boolean algebra. This example has the same atoms and coatoms as Example 4, whence it is not atomless and therefore not isomorphic to Example 5/6. However it contains an infinite atomless subalgebra, namely Example 5, and so is not isomorphic to Example 4, every subalgebra of which must be a Boolean algebra of finite sets and their complements and therefore atomic. This example is isomorphic to the direct product of Examples 4 and 5, furnishing another description of it.|$|E
25|$|Solid {{modeling}} {{systems for}} {{computer aided design}} {{offer a variety of}} methods for building objects from other objects, combination by <b>Boolean</b> <b>operations</b> being one of them. In this method the space in which objects exist is understood as a set S of voxels (the three-dimensional analogue of pixels in two-dimensional graphics) and shapes are defined as subsets of S, allowing objects to be combined as sets via union, intersection, etc. One obvious use is in building a complex shape from simple shapes simply as the union of the latter. Another use is in sculpting understood as removal of material: any grinding, milling, routing, or drilling operation that can be performed with physical machinery on physical materials can be simulated on the computer with the Boolean operation x∧¬y or x−y, which in set theory is set difference, remove the elements of y from those of x. Thus given two shapes one to be machined and the other the material to be removed, the result of machining the former to remove the latter is described simply as their set difference.|$|E
500|$|Instead {{of using}} an integer {{priority}} queue in a sorting algorithm, {{it is possible}} to go the other direction, and use integer sorting algorithms as subroutines within an integer priority queue data structure. [...] used this idea to show that, if {{it is possible to}} perform integer sorting in time [...] per key, then the same time bound applies to the time per insertion or deletion operation in a priority queue data structure. Thorup's reduction is complicated and assumes the availability of either fast multiplication operations or table lookups, but he also provides an alternative priority queue using only addition and <b>Boolean</b> <b>operations</b> with time [...] per operation, at most multiplying the time by an iterated logarithm.|$|E
50|$|Listed {{are some}} of the {{possible}} sub-expressions that can be created for various logic gates. In an operation expression, C acts as an output; in a CNF sub-expression, C acts as a new Boolean variable. For each operation, the CNF sub-expression is true if and only if C adheres to the contract of the <b>Boolean</b> <b>operation</b> for all possible input values.|$|R
40|$|In this paper, {{we propose}} {{a method to}} hide {{invisible}} patterns in color error diffused halftone images. The hidden pattern is embedded in different color components. The hidden patterns would be revealed when the watermarked color halftone images are under <b>Boolean</b> <b>operation</b> or overlaid. Simulation {{results show that the}} watermarked color halftone images have good visual quality and the hidden pattern is visible clearly...|$|R
40|$|This paper {{proposes a}} {{mathematical}} programming framework for combining SVMs with possibly different kernels. Compared to single SVMs, {{the advantage of}} this approach is twofold: it creates SVMs with local domains of expertise leading to local enlargements of the margin, and it allows the use of simple linear kernels combined with a fixed <b>boolean</b> <b>operation</b> that is particularly well suited for building dedicated hardware...|$|R
